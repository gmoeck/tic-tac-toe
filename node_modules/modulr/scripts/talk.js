var __DEV__ = false;
var __PERF__ = true;
// modulr.sync.js (c) 2010 Tobie Langel
(function(exports) {
  var modulr = {},
      _factories = {},
      _modules = {},
      PREFIX = '__module__', // Poor man's hasOwnProperty
      RELATIVE_IDENTIFIER_PATTERN = /^\.\.?\//;

  if (__PERF__) {
    var _perf = modulr.perf = {
      start: Date.now(),
      modules: {}
    },
    _pos = 1;
  }

  function makeRequire(id, main) {
    // Find the requirer's dirname from it's id.
    var path = id.substring(0, id.lastIndexOf('/') + 1);

    function require(identifier) {
      if (__PERF__) { var t0 = Date.now(); }
      var id = resolveIdentifier(identifier, path),
          key = PREFIX + id,
          mod = _modules[key];

      if (__PERF__) {
        var _p = _perf.modules[id];
        _p.count++;
      }
      // Check if this module's factory has already been called.
      if (!mod) {
        if (__PERF__) {
          _p.left = _pos++;
          _p.start = t0;
        }
        var fn = _factories[key];
        delete _factories[key]; // no longer needed.

        if (!fn) { throw 'Can\'t find module "' + identifier + '".'; }

        // lazy eval
        if (typeof fn === 'string') {
          if (__PERF__) { _p.evalStart = Date.now(); }
          fn = new Function('require', 'exports', 'module', fn);
          if (__PERF__) { _p.evalEnd = Date.now(); }
        }

        _modules[key] = mod = { id: id, exports: {} };
        // Create an instance of `require` per module. Each instance has a
        // reference to the path it was called from to be able to properly
        // resolve relative identifiers.
        // `main` isn't defined until we actually require the program's
        // entry point.
        var r = makeRequire(id, main || mod);
        fn(r, mod.exports, mod);
        if (__PERF__) {
          _p.right = _pos++;
          _p.end = Date.now();
        }
      }
      return mod.exports;
    }

    require.main = main;
    return require;
  }

  function resolveIdentifier(identifier, dir) {
    var parts, part, path;
    
    if (!RELATIVE_IDENTIFIER_PATTERN.test(identifier)) {
      return identifier;
    }

    parts = (dir + identifier).split('/');

    path = [];
    for (var i = 0, length = parts.length; i < length; i++) {
      part = parts[i];
      switch (part) {
        case '':
        case '.':
          continue;
        case '..':
          if (path.length) {
            path.pop();
          } else {
            throw new RangeError('Out of bounds identifier: ' + identifier);
          }
          break;
        default:
          path.push(part);
      }
    }
    return path.join('/');
  }
  
  function define(id, factory) {
    _perf.modules[id] = { count: 0 };
    _factories[PREFIX + id] = factory;
  }
  
  exports.define = define;
  exports.require = makeRequire('');
  exports.modulr = modulr;
})(this);

if (__PERF__) { modulr.perf.defineStart = Date.now(); }


// module: ufi/client
// file:   ../../ufi/client/index.js
define("ufi/client", function(require, exports, module) {
module.exports = require("ufi/client/index");});

// module: view/thread_row
// file:   view/thread_row/index.js
define("view/thread_row", function(require, exports, module) {
module.exports = require("view/thread_row/index");});

// module: views/timestamp
// file:   ../../views/timestamp/index.js
define("views/timestamp", function(require, exports, module) {
module.exports = require("views/timestamp/index");});

// module: incall/dtmf_keypad
// file:   ../../incall/lib/dtmf_keypad/index.js
define("incall/dtmf_keypad", function(require, exports, module) {
module.exports = require("incall/dtmf_keypad/index");});

// module: views/feedback/bar
// file:   ../../views/feedback/bar/index.js
define("views/feedback/bar", function(require, exports, module) {
module.exports = require("views/feedback/bar/index");});

// module: views/framed_image
// file:   ../../views/framed_image/index.js
define("views/framed_image", function(require, exports, module) {
module.exports = require("views/framed_image/index");});

// module: view/thread_actions
// file:   view/thread_actions/index.js
define("view/thread_actions", function(require, exports, module) {
module.exports = require("view/thread_actions/index");});

// module: views/feedback/flyout
// file:   ../../views/feedback/flyout/index.js
define("views/feedback/flyout", function(require, exports, module) {
module.exports = require("views/feedback/flyout/index");});

// module: views/profile_picture
// file:   ../../views/profile_picture/index.js
define("views/profile_picture", function(require, exports, module) {
module.exports = require("views/profile_picture/index");});

// module: views/menu_search_list
// file:   ../../views/menu_search_list/index.js
define("views/menu_search_list", function(require, exports, module) {
module.exports = require("views/menu_search_list/index");});

// module: bolt_touch/views/image
// file:   ../../../frameworks/bolt_touch/lib/views/image/index.js
define("bolt_touch/views/image", function(require, exports, module) {
module.exports = require("bolt_touch/views/image/index");});

// module: bolt_touch/views/scrim
// file:   ../../../frameworks/bolt_touch/lib/views/scrim/index.js
define("bolt_touch/views/scrim", function(require, exports, module) {
module.exports = require("bolt_touch/views/scrim/index");});

// module: bolt_touch/views/button
// file:   ../../../frameworks/bolt_touch/lib/views/button/index.js
define("bolt_touch/views/button", function(require, exports, module) {
module.exports = require("bolt_touch/views/button/index");});

// module: shared/data2/store/schema
// file:   ../../shared/js/data2/store/schema/index.js
define("shared/data2/store/schema", function(require, exports, module) {
module.exports = require("shared/data2/store/schema/index");});

// module: bolt_touch/views/carousel
// file:   ../../../frameworks/bolt_touch/lib/views/carousel/index.js
define("bolt_touch/views/carousel", function(require, exports, module) {
module.exports = require("bolt_touch/views/carousel/index");});

// module: bolt_touch/views/scrubber
// file:   ../../../frameworks/bolt_touch/lib/views/scrubber/index.js
define("bolt_touch/views/scrubber", function(require, exports, module) {
module.exports = require("bolt_touch/views/scrubber/index");});

// module: bolt_touch/views/data_list
// file:   ../../../frameworks/bolt_touch/lib/views/data_list/index.js
define("bolt_touch/views/data_list", function(require, exports, module) {
module.exports = require("bolt_touch/views/data_list/index");});

// module: bolt_touch/views/textinput
// file:   ../../../frameworks/bolt_touch/lib/views/textinput/index.js
define("bolt_touch/views/textinput", function(require, exports, module) {
module.exports = require("bolt_touch/views/textinput/index");});

// module: third-party/libphonenumber
// file:   ../../third-party/libphonenumber/index.js
define("third-party/libphonenumber", function(require, exports, module) {
module.exports = require("third-party/libphonenumber/index");});

// module: photos/app/lib/view/loader
// file:   ../../photos/app/lib/view/loader/index.js
define("photos/app/lib/view/loader", function(require, exports, module) {
module.exports = require("photos/app/lib/view/loader/index");});

// module: shared/shadowbroker/broker
// file:   ../../shared/js/shadowbroker/broker/index.js
define("shared/shadowbroker/broker", function(require, exports, module) {
module.exports = require("shared/shadowbroker/broker/index");});

// module: views/deprecated/table_view
// file:   ../../views/deprecated/table_view/index.js
define("views/deprecated/table_view", function(require, exports, module) {
module.exports = require("views/deprecated/table_view/index");});

// module: bolt_touch/views/button_new
// file:   ../../../frameworks/bolt_touch/lib/views/button_new/index.js
define("bolt_touch/views/button_new", function(require, exports, module) {
module.exports = require("bolt_touch/views/button_new/index");});

// module: photos/app/lib/view/toolbar
// file:   ../../photos/app/lib/view/toolbar/index.js
define("photos/app/lib/view/toolbar", function(require, exports, module) {
module.exports = require("photos/app/lib/view/toolbar/index");});

// module: bolt_touch/views/table_view
// file:   ../../../frameworks/bolt_touch/lib/views/table_view/index.js
define("bolt_touch/views/table_view", function(require, exports, module) {
module.exports = require("bolt_touch/views/table_view/index");});

// module: views/feedback/ufi/like_row
// file:   ../../views/feedback/ufi/like_row/index.js
define("views/feedback/ufi/like_row", function(require, exports, module) {
module.exports = require("views/feedback/ufi/like_row/index");});

// module: bolt_touch/views/pageheader
// file:   ../../../frameworks/bolt_touch/lib/views/pageheader/index.js
define("bolt_touch/views/pageheader", function(require, exports, module) {
module.exports = require("bolt_touch/views/pageheader/index");});

// module: views/feedback/ufi/composer
// file:   ../../views/feedback/ufi/composer/index.js
define("views/feedback/ufi/composer", function(require, exports, module) {
module.exports = require("views/feedback/ufi/composer/index");});

// module: shared/data2/local/migration
// file:   ../../shared/js/data2/local/migration/index.js
define("shared/data2/local/migration", function(require, exports, module) {
module.exports = require("shared/data2/local/migration/index");});

// module: photos/app/lib/view/checkbox
// file:   ../../photos/app/lib/view/checkbox/index.js
define("photos/app/lib/view/checkbox", function(require, exports, module) {
module.exports = require("photos/app/lib/view/checkbox/index");});

// module: bolt_touch/views/scene_stack
// file:   ../../../frameworks/bolt_touch/lib/views/scene_stack/index.js
define("bolt_touch/views/scene_stack", function(require, exports, module) {
module.exports = require("bolt_touch/views/scene_stack/index");});

// module: bolt_touch/views/button_base
// file:   ../../../frameworks/bolt_touch/lib/views/button_base/index.js
define("bolt_touch/views/button_base", function(require, exports, module) {
module.exports = require("bolt_touch/views/button_base/index");});

// module: camera2/app/lib/view/preview
// file:   ../../camera2/app/lib/view/preview/index.js
define("camera2/app/lib/view/preview", function(require, exports, module) {
module.exports = require("camera2/app/lib/view/preview/index");});

// module: photos/app/lib/view/thumbnail
// file:   ../../photos/app/lib/view/thumbnail/index.js
define("photos/app/lib/view/thumbnail", function(require, exports, module) {
module.exports = require("photos/app/lib/view/thumbnail/index");});

// module: bolt_touch/views/action_sheet
// file:   ../../../frameworks/bolt_touch/lib/views/action_sheet/index.js
define("bolt_touch/views/action_sheet", function(require, exports, module) {
module.exports = require("bolt_touch/views/action_sheet/index");});

// module: bolt_touch/views/scroll_view_j
// file:   ../../../frameworks/bolt_touch/lib/views/scroll_view_j/index.js
define("bolt_touch/views/scroll_view_j", function(require, exports, module) {
module.exports = require("bolt_touch/views/scroll_view_j/index");});

// module: photos/app/lib/view/photo_grid
// file:   ../../photos/app/lib/view/photo_grid/index.js
define("photos/app/lib/view/photo_grid", function(require, exports, module) {
module.exports = require("photos/app/lib/view/photo_grid/index");});

// module: views/feedback/ufi/comment_row
// file:   ../../views/feedback/ufi/comment_row/index.js
define("views/feedback/ufi/comment_row", function(require, exports, module) {
module.exports = require("views/feedback/ufi/comment_row/index");});

// module: photos/app/lib/view/photo_view
// file:   ../../photos/app/lib/view/photo_view/index.js
define("photos/app/lib/view/photo_view", function(require, exports, module) {
module.exports = require("photos/app/lib/view/photo_view/index");});

// module: photos/app/lib/view/photo_tags
// file:   ../../photos/app/lib/view/photo_tags/index.js
define("photos/app/lib/view/photo_tags", function(require, exports, module) {
module.exports = require("photos/app/lib/view/photo_tags/index");});

// module: views/contact_menu_search_list
// file:   ../../views/contact_menu_search_list/index.js
define("views/contact_menu_search_list", function(require, exports, module) {
module.exports = require("views/contact_menu_search_list/index");});

// module: photos/app/lib/view/album_scene
// file:   ../../photos/app/lib/view/album_scene/index.js
define("photos/app/lib/view/album_scene", function(require, exports, module) {
module.exports = require("photos/app/lib/view/album_scene/index");});

// module: views/feedback/ufi/comment_list
// file:   ../../views/feedback/ufi/comment_list/index.js
define("views/feedback/ufi/comment_list", function(require, exports, module) {
module.exports = require("views/feedback/ufi/comment_list/index");});

// module: photos/app/lib/view/photo_viewer
// file:   ../../photos/app/lib/view/photo_viewer/index.js
define("photos/app/lib/view/photo_viewer", function(require, exports, module) {
module.exports = require("photos/app/lib/view/photo_viewer/index");});

// module: bolt_touch/views/background_image
// file:   ../../../frameworks/bolt_touch/lib/views/background_image/index.js
define("bolt_touch/views/background_image", function(require, exports, module) {
module.exports = require("bolt_touch/views/background_image/index");});

// module: views/feedback/buttons/like_button
// file:   ../../views/feedback/buttons/like_button/index.js
define("views/feedback/buttons/like_button", function(require, exports, module) {
module.exports = require("views/feedback/buttons/like_button/index");});

// module: photos/app/lib/view/photo_carousel
// file:   ../../photos/app/lib/view/photo_carousel/index.js
define("photos/app/lib/view/photo_carousel", function(require, exports, module) {
module.exports = require("photos/app/lib/view/photo_carousel/index");});

// module: views/units/component/fb_object_link
// file:   ../../views/units/component/fb_object_link/index.js
define("views/units/component/fb_object_link", function(require, exports, module) {
module.exports = require("views/units/component/fb_object_link/index");});

// module: photos/app/lib/view/expandable_photo
// file:   ../../photos/app/lib/view/expandable_photo/index.js
define("photos/app/lib/view/expandable_photo", function(require, exports, module) {
module.exports = require("photos/app/lib/view/expandable_photo/index");});

// module: photos/app/lib/view/video_list_scene
// file:   ../../photos/app/lib/view/video_list_scene/index.js
define("photos/app/lib/view/video_list_scene", function(require, exports, module) {
module.exports = require("photos/app/lib/view/video_list_scene/index");});

// module: photos/app/lib/view/album_list_scene
// file:   ../../photos/app/lib/view/album_list_scene/index.js
define("photos/app/lib/view/album_list_scene", function(require, exports, module) {
module.exports = require("photos/app/lib/view/album_list_scene/index");});

// module: photos/app/lib/view/grid_photo_viewer
// file:   ../../photos/app/lib/view/grid_photo_viewer/index.js
define("photos/app/lib/view/grid_photo_viewer", function(require, exports, module) {
module.exports = require("photos/app/lib/view/grid_photo_viewer/index");});

// module: views/feedback/buttons/comment_button
// file:   ../../views/feedback/buttons/comment_button/index.js
define("views/feedback/buttons/comment_button", function(require, exports, module) {
module.exports = require("views/feedback/buttons/comment_button/index");});

// module: photos/app/lib/view/video_player_scene
// file:   ../../photos/app/lib/view/video_player_scene/index.js
define("photos/app/lib/view/video_player_scene", function(require, exports, module) {
module.exports = require("photos/app/lib/view/video_player_scene/index");});

// module: view/messages_scene/messages_scene_menu
// file:   view/messages_scene/messages_scene_menu/index.js
define("view/messages_scene/messages_scene_menu", function(require, exports, module) {
module.exports = require("view/messages_scene/messages_scene_menu/index");});

// module: photos/app/lib/view/unpublished_album_scene
// file:   ../../photos/app/lib/view/unpublished_album_scene/index.js
define("photos/app/lib/view/unpublished_album_scene", function(require, exports, module) {
module.exports = require("photos/app/lib/view/unpublished_album_scene/index");});

// module: views/picker/camera_picker/viewfinder_scene
// file:   ../../views/picker/camera_picker/viewfinder_scene/index.js
define("views/picker/camera_picker/viewfinder_scene", function(require, exports, module) {
module.exports = require("views/picker/camera_picker/viewfinder_scene/index");});

// module: views/picker/camera_picker/photo_review_scene
// file:   ../../views/picker/camera_picker/photo_review_scene/index.js
define("views/picker/camera_picker/photo_review_scene", function(require, exports, module) {
module.exports = require("views/picker/camera_picker/photo_review_scene/index");});

// module: contacts/contact_filters_section/ui/contact_filters_scene
// file:   contacts/contact_filters_section/ui/contact_filters_scene/index.js
define("contacts/contact_filters_section/ui/contact_filters_scene", function(require, exports, module) {
module.exports = require("contacts/contact_filters_section/ui/contact_filters_scene/index");});

// module: mock/clipboardmanager_api
// file:   ../../mock/js/clipboardmanager_api.js
define("mock/clipboardmanager_api", function(require, exports, module) {
var text = null;

exports.getText = function() {
  return text;
};

exports.setText = function(val) {
  text = val;
};
});

// module: mock/alarm_api
// file:   ../../mock/js/alarm_api.js
define("mock/alarm_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

module.exports = {
  setAlarm: function() {
    return;
  }
};
});

// module: bolt_touch/views/scroll_view
// file:   ../../../frameworks/bolt_touch/lib/views/scroll_view.js
define("bolt_touch/views/scroll_view", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

exports.ScrollView = require('bolt_touch/views/scroll_view_j').ScrollView;
});

// module: mock/sensor_api
// file:   ../../mock/js/sensor_api.js
define("mock/sensor_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

module.exports = {
  registerListener: function(sensorType, samplingFrequency) {
    return;
  }
};
});

// module: talk/client/model/message/message_types
// file:   ../client/model/message/message_types.js
define("talk/client/model/message/message_types", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

exports.MESSAGE_TYPES = {
  NORMAL: 0,
  SUBSCRIBE: 1,
  UNSUBSCRIBE: 2,
  VIDEO_CALL: 3,
  THREAD_IMAGE: 4,
  THREAD_NAME: 5
};
});

// module: shared/data2/store/constants
// file:   ../../shared/js/data2/store/constants.js
define("shared/data2/store/constants", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

exports.STATE = {
  NORMAL: 0,
  POSSIBLE_GAP: 1,
  GAP: 2,
  LOCAL: 4,
  LOCAL_CHANGES: 8,
  LAST: 16
};

exports.SEQUENCE_STATE = {
  NORMAL: 0,
  EMPTY: 1
};
});

// module: views/profile_picture/index
// file:   ../../views/profile_picture/index.js
define("views/profile_picture/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core              = require('bolt/core');
var FramedImage = require('views/framed_image').FramedImage;

var ProfilePicture = exports.ProfilePicture = core.createClass({

  name: 'ProfilePicture',

  extend: FramedImage
});
});

// module: third-party/libphonenumber/index
// file:   ../../third-party/libphonenumber/index.js
define("third-party/libphonenumber/index", "exports.AsYouTypeFormatter =\n  require('./compiled_formatter').i18n.phonenumbers.AsYouTypeFormatter;\nexports.PhoneNumberUtil =\n  require('./compiled_formatter').i18n.phonenumbers.PhoneNumberUtil;\nexports.PhoneNumberFormat =\n  require('./compiled_formatter').i18n.phonenumbers.PhoneNumberFormat;\n\n//@ sourceURL=../../third-party/libphonenumber/index.js\n");

// module: bolt/event
// file:   ../../../frameworks/bolt/lib/event.js
define("bolt/event", function(require, exports, module) {
var Event = exports.Event = function() {};

Event.prototype = {
  name: "Event",

  targetView: null,
  type: "",

  defaultPrevented: false,
  preventDefault: function() {
    this.defaultPrevented = true;
  },

  propagationStopped: false,
  stopPropagation: function() {
    this.propagationStopped = true;
  }
};
});

// module: mock/audio_record_api
// file:   ../../mock/js/audio_record_api.js
define("mock/audio_record_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;

module.exports = {
  setupRecorder: function() {},
  startRecording: function() {},
  stopRecording: function() {
    EventManager.broadcastEvent("audiorecord.RECORD_COMPLETE", {"path": ""});
  }
};
});

// module: contacts/stubs/facebook_contacts
// file:   contacts/stubs/facebook_contacts.js
define("contacts/stubs/facebook_contacts", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var data = [
  {
    name: "Greg Moeck",
    id: '123456789'
  },
  {
    name: 'Greg Peck',
    id: '987654321'
  }
];

var stubServer = {
  fetchContacts: function(searchTerm, callback) {
    callback(data);
  }
};

exports.server = stubServer;
exports.data = data;
});

// module: mock/special_dialog_api
// file:   ../../mock/js/special_dialog_api.js
define("mock/special_dialog_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var util = require('bolt/util');

module.exports = {
  SPECIAL_DIALOG_ID: 'specialDialogId',

  _getId: function() {
    return util.generateUUID();
  },

  dismiss: function(id, result, formData) {
    console.log('SpecialDialogAPI.dismiss()', id, result, formData);
  }
};
});

// module: photos/app/lib/view/loader/index
// file:   ../../photos/app/lib/view/loader/index.js
define("photos/app/lib/view/loader/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var View = require('bolt_touch/view').View;

var Loader = exports.Loader = core.createClass({
  name: 'Loader',

  extend: View,

  declare: function() {
    return {
      content: 'Loading...'
    };
  }
});
});

// module: view/loading/loading
// file:   view/loading/loading.js
define("view/loading/loading", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt/view').View;

var Loading = core.createClass({
  extend: View,
  name: 'Loading',

  declare: function() {
    return {
      className: 'talkLoading',
      content: 'Loading...'
    };
  }
});


exports.Loading = Loading;
});

// module: mock/glitter_api
// file:   ../../mock/js/glitter_api.js
define("mock/glitter_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

// simshim overrides this API with a custom one, beware
// DO NOT require shared/event_manager in here.

module.exports = {
  sendSystemMessage: function(msg, jsonData) {
    if (!window.buffyGlitter) {
      return;
    }

    buffyGlitter.sendSystemMessage(msg, jsonData, 'angel');
  }
};
});

// module: mock/orientation_api
// file:   ../../mock/js/orientation_api.js
define("mock/orientation_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

module.exports = {
  PORTRAIT: 1, // ActivityInfo.SCREEN_ORIENTATION_PORTRAIT
  LANDSCAPE: 0, //ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
  UNSPECIFIED: -1, //ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED
  SENSOR: 10, //ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR
  setOrientation: function(arg) {}
};
});

// module: shared/model/profile/profile
// file:   ../../shared/js/model/profile/profile.js
define("shared/model/profile/profile", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core              = require('bolt/core');
var Model             = require('bolt/model').Model;

/**
 * Represents a profile with limited information, when we only need name, id,
 * type, and possibly a profile picture.
 */
exports.Profile = core.createClass({
  name: 'Profile',
  extend: Model
});
});

// module: contacts/shared/ui/contacts_portfolio_table_model
// file:   contacts/shared/ui/contacts_portfolio_table_model.js
define("contacts/shared/ui/contacts_portfolio_table_model", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var ContactsTableModel = require('./contacts_table_model').ContactsTableModel;

var ContactsPortfolioTableModel = function(portfolio) {
  var tableModel = new ContactsTableModel();
  portfolio.addEventListener(tableModel);
  return tableModel;
};

exports.ContactsPortfolioTableModel = ContactsPortfolioTableModel;
});

// module: bolt_touch/views/touchable_view
// file:   ../../../frameworks/bolt_touch/lib/views/touchable_view.js
define("bolt_touch/views/touchable_view", function(require, exports, module) {
var core = require('bolt/core');
var View = require('bolt/view').View;
var Touchable = require('../mixins/touchable').Touchable;

/**
 * @classdesc TouchableView is a basic view that has the Touchable mixin. It
 * should not be extended.
 */
var TouchableView = core.createClass({

  name: 'TouchableView',

  extend: View,

  mixins: [Touchable]
});

exports.TouchableView = TouchableView;
});

// module: bolt_touch/views/actionable_view
// file:   ../../../frameworks/bolt_touch/lib/views/actionable_view.js
define("bolt_touch/views/actionable_view", function(require, exports, module) {
var core = require('bolt/core');
var View = require('bolt/view').View;
var Actionable = require('../mixins/actionable').Actionable;

/**
 * @classdesc ActionableView is a basic view that has the Actionable mixin. It
 * should not be extended.
 */
var ActionableView = core.createClass({

  name: 'ActionableView',

  extend: View,

  mixins: [Actionable]
});

exports.ActionableView = ActionableView;
});

// module: shared/data2/model/friend_list/friend_list
// file:   ../../shared/js/data2/model/friend_list/friend_list.js
define("shared/data2/model/friend_list/friend_list", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var Model = require('bolt/model').Model;

/**
 * FriendList is the data model for a friend list.
 * {
 *   owner: '1234',
 *   flid: '999',
 *   name: 'People I actually like',
 *   type: 'user_created'
 * }
 */
var FriendList = exports.FriendList = core.createClass({
  name: 'FriendList',
  extend: Model
});
});

// module: contacts/contacts_local_mapper
// file:   contacts/contacts_local_mapper.js
define("contacts/contacts_local_mapper", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var contactsSchema = require('./contact').contactsSchema;
var LocalMapper = require('shared/data2/local/local_mapper').LocalMapper;

var ContactsLocalMapper = core.createClass({
  extend: LocalMapper,

  properties: {
    tableName: 'contacts',
    schema: contactsSchema
  }
});

exports.ContactsLocalMapper = ContactsLocalMapper;
});

// module: talk/app/contacts/contacts_local_mapper
// file:   contacts/contacts_local_mapper.js
define("talk/app/contacts/contacts_local_mapper", function(require, exports, module) {
module.exports = require("contacts/contacts_local_mapper");});

// module: bolt_touch/util/easing
// file:   ../../../frameworks/bolt_touch/lib/util/easing.js
define("bolt_touch/util/easing", function(require, exports, module) {
/**
 * Provides easing functions for animations, e.g. for ScrollView.
 * Easing functions map [0,1]->[0,1] where the input is time elapsed and the
 * output is animation progress.  A mathematical function that provides a
 * smooth curve should be used.  For more information on easing functions, see
 * http://www.w3.org/TR/css3-transitions/#transition-timing-function_tag.
 */

exports.linear = function(t) {
  return t;
};
});

// module: mock/touch_api
// file:   ../../mock/js/touch_api.js
define("mock/touch_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

module.exports = {

  LEFT_TOUCH_COMPENSATION: 0,
  RIGHT_TOUCH_COMPENSATION: 1,
  TOP_TOUCH_COMPENSATION: 2,
  BOTTOM_TOUCH_COMPENSATION: 3,

  setTouchCompensation: function(index, value) {
    window.localStorage['touch_compensation_' + index] = value;
  },

  getTouchCompensation: function(index, value) {
    return window.localStorage['touch_compensation_' + index];
  }
};
});

// module: contacts/all_contacts_section/in_memory_search_command
// file:   contacts/all_contacts_section/in_memory_search_command.js
define("contacts/all_contacts_section/in_memory_search_command", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var InMemorySearchCommand = function() {
};

InMemorySearchCommand.prototype = {
  searchingFor: function(searchTerm) {
    if (searchTerm.length >= 1) {
      this._searchModel.filterByName(searchTerm);
    } else {
      this._searchModel.clearFilter();
    }
  },

  setModel: function(model) {
    this._searchModel = model;
  }
};

exports.InMemorySearchCommand = InMemorySearchCommand;
});

// module: views/picker/album_picker/picker_model
// file:   ../../views/picker/album_picker/picker_model.js
define("views/picker/album_picker/picker_model", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core       = require('bolt/core');
var util       = require('bolt/util');
var Model      = require('bolt/model').Model;
var Collection = require('bolt/collection').Collection;

var SelectedPhotoCollection = exports.SelectedPhotoCollection =
  core.createClass({

  extend: Collection,

  name: 'SelectedPhotoCollection',

  comparator:function(photo) {
    return -1 * photo.get('pickPosition');
  }
});

});

// module: contacts/find_facebook_contact_section/facebook_contact_searcher/ajax_facebook_contacts_server
// file:   contacts/find_facebook_contact_section/facebook_contact_searcher/ajax_facebook_contacts_server.js
define("contacts/find_facebook_contact_section/facebook_contact_searcher/ajax_facebook_contacts_server", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var apixhr = require('shared/api_xhr');

var AjaxFacebookContactsServer = function() {
};


AjaxFacebookContactsServer.prototype = {
  fetchContacts: function(searchTerm, callback) {
    apixhr.graph('GET', 'search', {
      q: searchTerm,
      type: 'user'
    }).then(function(response) {
      callback(response.data);
    }, this);
  }
};

exports.AjaxFacebookContactsServer = AjaxFacebookContactsServer;
});

// module: shared/util/assert
// file:   ../../shared/js/util/assert.js
define("shared/util/assert", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var util = require('bolt/util');

/**
  @param {Boolean|Function} statement The statement to test
  @param {String} message If the statement is false, this is thrown
*/
var assert = function(statement, message) {
  var isFalse = typeof statement === 'boolean' && !statement;
  var returnsFalse = util.isFunction(statement) && !statement();
  if (isFalse || returnsFalse) {
    throw message;
  }
};

exports.assert = assert;
});

// module: bolt_touch/util/event_manager
// file:   ../../../frameworks/bolt_touch/lib/util/event_manager.js
define("bolt_touch/util/event_manager", function(require, exports, module) {
// Event Manager Provides a global singleton for invoking and listening to
// high-level system events.
//
// In general it is better to invoke and listen for events at a more granular;
// however, at times it is more practical to provide a global Event bus that
// any object can hook into. This object should be used for that purpose.
//
// Please do not abuse it.

var util   = require('bolt/util'),
    Events = require('bolt/mixins/events').Events;

exports.EventManager = util.extend({}, Events);
});

// module: contacts/stubs/group_contacts
// file:   contacts/stubs/group_contacts.js
define("contacts/stubs/group_contacts", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var data = [
  {
    first_name: "Ashwin",
    last_name: "Bhat",
    middle_name: "",
    pic_square: "http://something.com/some_pic.jpg",
    uid: '1234'
  },
  {
    first_name: "Akash",
    last_name: "Gupta",
    middle_name: "lala",
    pic_square: "http://something.com/other_pic.jpg",
    uid: '4321'
  }
];

var stubServer = {
  fetchContacts: function(gid, callback) {
    callback(data);
  }
};
exports.server = stubServer;
exports.data = data;
});

// module: mock/vibration_api
// file:   ../../mock/js/vibration_api.js
define("mock/vibration_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

// TODO just adding skeleton methods here for now, but we could probably
// rig this up to rapidly change the absolute positioning of the body or
// phone element in the simulator to simulate vibration
module.exports = {
  VIBRATION_WIBBLY: "wibbly",
  VIBRATION_SHAKE_YOUR_HAND: "shakey",

  vibrate: function(millisecondsOrPattern) {
  },

  vibrateCustom: function(jsonEncodedLongs) {
  },

  cancel: function() {
  },

  hasVibrator: function() {
    return false;
  }
};
});

// module: photos/app/lib/view/toolbar/index
// file:   ../../photos/app/lib/view/toolbar/index.js
define("photos/app/lib/view/toolbar/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var View = require('bolt_touch/view').View;

var Toolbar = exports.Toolbar = core.createClass({
  name: 'Toolbar',
  extend: View,

  properties: {
    type: ''
  },

  declare: function(options) {
    var klass = '';
    if (options.type) {
      klass = options.type;
    }

    return {
      boxOrientation: 'horizontal',
      additionalClasses: klass
    };
  }
});

Toolbar.TYPE = {
  HEADER: 'header',
  FOOTER: 'footer'
};
});

// module: mock/spelling_api
// file:   ../../mock/js/spelling_api.js
define("mock/spelling_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var EventManager = require('shared/event_manager').EventManager;


module.exports = {
  CORRECTION_AVAILABLE: "CorrectionAvailable",

  correctWord: function(word) {
    console.log("Mock got request to correct word " + word);
    var b = 1;
    for (var a = 0; a < 10000; a++) {
      b = a / 2 * 3;
    }
    EventManager.broadcastEvent(this.CORRECTION_AVAILABLE, {"word": word,
      "corrections": {"10": "third", "20": "second", "30": "first"}});
  },

  reportHistogram: function(histogram) {
  }
};
});

// module: views/timestamp/index
// file:   ../../views/timestamp/index.js
define("views/timestamp/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var View              = require('bolt_touch/view').View;
var core              = require('bolt/core');
var sharedUtil        = require('shared/util');

var Timestamp = exports.Timestamp = core.createClass({

  name: 'Timestamp',

  extend: View,

  properties: {
    relative: true
  },

  setDateTime: function(date) {
    if (this.getRelative()) {
      this.setContent(sharedUtil.relativeTimestamp(new Date(date)));
    } else {
      this.setContent(sharedUtil.shortTimestamp(new Date(date)));
    }
  }
});
});

// module: shared/data2/model/story/story_store_versions
// file:   ../../shared/js/data2/model/story/story_store_versions.js
define("shared/data2/model/story/story_store_versions", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

function getLatestSpec() {
  return require('./story_store_spec-1_1').createTableSpec();
}

var _migrations;
function getMigrations() {
  var SpecMigration =
    require('shared/data2/local/migration/spec_migration').SpecMigration;
  if (!_migrations) {
    _migrations = [
      new SpecMigration({
        version: '1.1',
        spec: require('./story_store_spec-1_1').createTableSpec()
      })
    ];
  }
  return _migrations;
}

exports.getLatestSpec = getLatestSpec;
exports.getMigrations = getMigrations;
});

// module: mock/dogfood_api
// file:   ../../mock/js/dogfood_api.js
define("mock/dogfood_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var noop = function() {};

module.exports = {
  isAtTrustedLocation: function() {
    return true;
  },
  getTrustedLocations:   function() {
    return '{}';
  },
  getIsSlowPokeEnabled: function() {
    if (this.slowpoke !== false) {
      this.slowpoke = true;
    }
    return this.slowpoke;
  },
  toggleIsSlowPokeEnabled: function() {
    this.slowpoke = !this.slowpoke;
    return true; // toggle succeeded
  },
  addTrustedLocation:    noop,
  isTakingRisks:         noop,
  removeTrustedLocation: noop
};
});

// module: shared/data2/store/schema/type/boolean
// file:   ../../shared/js/data2/store/schema/type/boolean.js
define("shared/data2/store/schema/type/boolean", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var TypeBase = require('./base').TypeBase;

/**
 * @classdesc TypeBoolean is for boolean types. Does some minor work to make it
 * nicely compatible with the local database.
 */
var TypeBoolean = core.createClass({

  name: 'TypeBoolean',

  extend: TypeBase,

  localType: 'BOOLEAN',

  transformModelToLocal: function(bool) {
    return bool ? 1 : 0;
  },

  transformLocalToModel: function(num) {
    return num === 1 ? true : false;
  }
});

exports.TypeBoolean = TypeBoolean;
});

// module: talk/client/model/thread/client_thread
// file:   ../client/model/thread/client_thread.js
define("talk/client/model/thread/client_thread", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core  = require('bolt/core');
var Model = require('bolt/model').Model;

var CommonThreadAPI = require('./common_thread_api').CommonThreadAPI;


var ClientThread = exports.ClientThread = core.createClass({
  extend: Model,

  name: 'ClientThread',

  mixins: [CommonThreadAPI],

  _participantProfiles: null,

  setParticipantProfiles: function(profiles) {
    this._participantProfiles = profiles;
    return this;
  },

  getParticipantProfiles: function() {
    return this._participantProfiles || [];
  }
});
});

// module: system/util/logging
// file:   ../../system/lib/util/logging.js
define("system/util/logging", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var config = require('../config');

// TODO: we can add log levels and various other hooks here to make debugging
//       easier without junking up logcat under normal circumstances.
var log = exports.log = function() {
  if (config.getDebugMode()) {
    console.log.apply(console, arguments);
  }
};

var debug = exports.debug = function() {
  if (config.getDebugMode()) {
    console.log.apply(console, arguments);
  }
};

var logError = exports.logError = function() {
  console.error.apply(console, arguments);
};
});

// module: talk/app/contacts/util/announcer
// file:   contacts/util/announcer.js
define("talk/app/contacts/util/announcer", function(require, exports, module) {
module.exports = require("contacts/util/announcer");});

// module: contacts/util/announcer
// file:   contacts/util/announcer.js
define("contacts/util/announcer", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*globals undefined:false */

var Announcer = function() {
  this._eventListeners = [];
};

Announcer.prototype = {
  addListener: function(listener) {
    this._eventListeners.push(listener);
  },

  announce: function() {
    var args = Array.prototype.slice.call(arguments);
    var messageName = args.shift();
    this._eventListeners.forEach(function(listener) {
      if (listener[messageName] !== undefined) {
        listener[messageName].apply(listener, args);
      }
    });
  }
};

exports.Announcer = Announcer;
});

// module: contacts/edit_contact_section/ui/edit_contact_scene
// file:   contacts/edit_contact_section/ui/edit_contact_scene.js
define("contacts/edit_contact_section/ui/edit_contact_scene", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var ContactFormScene = require('../../shared/ui/contact_form_scene').ContactFormScene;
var ContactSnapshotBuilder = require('../../contact').ContactSnapshotBuilder;

var EditContactScene = function(options) {
  options.header = 'Edit Contact';
  options.id = 'editContactScene';
  options.saveEvent = 'updateContact';
  options.cancelEvent = 'cancelEdit';
  options.builderType = ContactSnapshotBuilder;
  options.allowsDelete = true;

  return new ContactFormScene(options);
};

exports.EditContactScene = EditContactScene;
});

// module: contacts/edit_contact_section/contact_updater
// file:   contacts/edit_contact_section/contact_updater.js
define("contacts/edit_contact_section/contact_updater", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var Announcer = require('../util/announcer').Announcer;

var ContactUpdater = function(collector) {
  this._collector = collector;
  this._announcer = new Announcer();
};

ContactUpdater.prototype = {
  addEventListener: function(listener) {
    this._announcer.addListener(listener);
  },

  updateContact: function(information) {
    var contact = this._collector.contactWithId(information.id);
    contact.update(information);
    this._announcer.announce('contactSuccessfullyUpdated');
  }
};

exports.ContactUpdater = ContactUpdater;
});

// module: photos/app/lib/client/broker
// file:   ../../photos/app/lib/client/broker.js
define("photos/app/lib/client/broker", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*global SharedWorker:false*/

var _instance = null;

function createBroker() {
  var Broker = require('shared/shadowbroker/broker').Broker;
  var Client = require('shared/shadowbroker/system/client').Client;
  var worker = new SharedWorker('/apps/photos/worker.js');
  var broker = new Broker(worker.port);
  broker.setName('photos'); // logging
  var systemClient = new Client(broker);
  systemClient.init();

  return broker;
}

exports.getInstance = function() {
  if (!_instance) {
    _instance = createBroker();
  }
  return _instance;
};
});

// module: contacts/shared/new_contact_creator
// file:   contacts/shared/new_contact_creator.js
define("contacts/shared/new_contact_creator", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var Announcer = require('../util/announcer').Announcer;

var NewContactCreator = function(contactsList) {
  this.contactsList = contactsList;
  this._announcer = new Announcer();
};

NewContactCreator.prototype = {
  createContact: function(newContactInformation) {
    var contact = this.contactsList.createContact(newContactInformation);
    this._announcer.announce('contactSuccessfullyCreated', contact);
  },

  addEventListener: function(listener) {
    this._announcer.addListener(listener);
  }
};

exports.NewContactCreator = NewContactCreator;
});

// module: contacts/edit_contact_section/contact_remover
// file:   contacts/edit_contact_section/contact_remover.js
define("contacts/edit_contact_section/contact_remover", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var Announcer = require('../util/announcer').Announcer;

var ContactRemover = function(collector) {
  this._collector = collector;
  this._announcer = new Announcer();
};

ContactRemover.prototype = {
  deleteContact: function(removeContactInformation) {
    var contact = this._collector.contactWithId(removeContactInformation.id);
    contact.destroy();
    this._announcer.announce('contactSuccessfullyDeleted');
  },

  addEventListener: function(listener) {
    this._announcer.addListener(listener);
  }
};

exports.ContactRemover = ContactRemover;
});

// module: shared/data2/model/group/group_member
// file:   ../../shared/js/data2/model/group/group_member.js
define("shared/data2/model/group/group_member", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var Model = require('bolt/model').Model;

/**
 * GroupMember is the data model for a connection between a user and a group. It
 * expects a data clock like:
 * {
 *  uid: '6565',
 *  group: {
 *    gid: '123',
 *    name: 'Group Name'
 *  }
 * }
 */
var GroupMember = exports.GroupMember = core.createClass({
  name: 'GroupMember',
  extend: Model,

  construct: function(options) {
    Model.call(this, options);
    var group = this.get('group');
    if (group && group.gid) {
      this.set('gid', group.gid);
    }
  }
});
});

// module: camera2/app/lib/controller/constants
// file:   ../../camera2/app/lib/controller/constants.js
define("camera2/app/lib/controller/constants", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

// Camera basics
exports.LOG_START         = 'camera:start';
exports.LOG_ERROR         = 'camera:error';
exports.LOG_PREVIEW_START = 'camera:previewStart';

// Snapshot
exports.LOG_TAKE_PHOTO    = 'camera:takePhoto';

// Video
exports.LOG_START_VIDEO   = 'camera:startVideo';
exports.LOG_START_RECORD  = 'camera:startRecord';
exports.LOG_END_RECORD    = 'camera:endRecord';

// Album interaction
exports.LOG_GO_TO_ALBUM   = 'camera:goToAlbum';
exports.LOG_FROM_ALBUM    = 'camera:fromAlbum';

// Face Recognition
exports.LOG_FACE_RECOG    = 'camera:faceRecog';
});

// module: contacts/find_facebook_contact_section/facebook_contact_searcher/contacts_list_searcher
// file:   contacts/find_facebook_contact_section/facebook_contact_searcher/contacts_list_searcher.js
define("contacts/find_facebook_contact_section/facebook_contact_searcher/contacts_list_searcher", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var ContactsListSearcher = function(contactsList, collector) {
  this.contactsList = contactsList;
  this.collector = collector;
};

ContactsListSearcher.prototype = {
  searchingFor: function(searchTerm) {
    if (searchTerm.length >= 1) {
      var collector = this.collector;
      this.contactsList.withName(searchTerm, function(contacts) {
        collector.empty();
        contacts.forEach(function(contact) {
          collector.add(contact);
        });
      });
    } else {
      this.collector.empty();
    }
  }
};

exports.ContactsListSearcher = ContactsListSearcher;
});

// module: shared/util/bind_once
// file:   ../../shared/js/util/bind_once.js
define("shared/util/bind_once", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var util = require('bolt/util');

var huid = 1;
/**
* Special version of bind. Guarantied to provide the same result
* for the same fn and context pair provided. Cannot bind arguments
*
* Useful for event handlers:
*   x.on('click', bindOnce(handler, this));
*   // will unbind bound function here
*   x.removeListener('click', fun.bindOnce(handler, this));
*/
exports.bindOnce = function(fn, context) {
  fn.huid = fn.huid || huid++;
  var bindingName = '__bind_' + fn.huid;
  context[bindingName] = context[bindingName] || util.bind(fn, context);
  return context[bindingName];
};
});

// module: shared/util/user
// file:   ../../shared/js/util/user.js
define("shared/util/user", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

/**
 * Checks if the given ID is in the range of valid Facebook user IDs.
 * NB: This is based on the PHP function fbid_in_uid_range(), so it should
 * be kept in sync with that function.
 *
 * @param   uid   The ID to check.
 * @returns bool  True if the ID is in the valid range.
 */
exports.isFacebookUserID = function(id) {
  return id < 2200000000 ||
    (id >= 100000000000000 &&  // 100T is first 64-bit UID
     id <= 100099999989999) || // 100T + 3,333,333*30,000 - 1)
    (id >= 89000000000000 &&   // DBTYPE_TEST2: see flib/core/fbid/hash.php
     id <= 89999999999999);
};
});

// module: ufi/client/broker
// file:   ../../ufi/client/broker.js
define("ufi/client/broker", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var _instance = null;
var global = this;

function createBroker() {
  var Broker = require('shared/shadowbroker/broker').Broker;
  var Client = require('shared/shadowbroker/system/client').Client;

  var worker = new window.SharedWorker('/apps/dash/ufi_worker.js');
  var broker = new Broker(worker.port);
  broker.setName('ufi'); // logging
  if (!global.DEBUG_WORKER_CONTEXT) {
    var systemClient = new Client(broker);
    systemClient.init();
  }

  return broker;
}

exports.getInstance = function() {
  if (!_instance) {
    _instance = createBroker();
  }
  return _instance;
};
});

// module: shared/data2/model/like/model
// file:   ../../shared/js/data2/model/like/model.js
define("shared/data2/model/like/model", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var Model = require('bolt/model').Model;

/**
 * @class LikeModel
 * @classdesc A LikeModel representes a single like on a Likeable
 * model. It contains the ID of its target model and the user who
 * liked the target model. It can also contain the type of the target
 * model and whether or not the person who liked the model is a friend
 * of the user.
 */
var LikeModel = core.createClass({

  name: 'LikeModel',

  extend: Model,

  storeModel: function() {
    require('./store').getInstance().store([this]);
  }
});

exports.LikeModel = LikeModel;
});

// module: shared/data2/model/comment/model
// file:   ../../shared/js/data2/model/comment/model.js
define("shared/data2/model/comment/model", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var Model = require('bolt/model').Model;
var Likeable = require('../mixin/likeable').Likeable;
var Profile = require('../../../model/profile/profile').Profile;

var CommentModel = core.createClass({

  name: 'CommentModel',

  extend: Model,

  mixins: [Likeable],

  storeModel: function() {
    require('./store').getInstance().store([this]);
  },

  getActor: function() {
    if (!this._actor) {
      var actor = this.get('actor');
      this._actor = actor && new Profile(actor);
    }
    return this._actor;
  }
});

exports.CommentModel = CommentModel;
});

// module: shared/data2/local/migration/migration
// file:   ../../shared/js/data2/local/migration/migration.js
define("shared/data2/local/migration/migration", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');

var Migration = core.createClass({
  name: 'Migration',

  properties: {
    version: ''
  },

  construct: function(options) {
    if (options.version) {
      this.setVersion(options.version);
    }
    if (options.up) {
      this.up = options.up;
    }
    if (options.reset) {
      this.reset = options.reset;
    }
  },

  up: function(transaction) {
    throw new Error('Migration must specify up transform.');
  },

  reset: function(transaction) {
    throw new Error('Migration must specify reset transform.');
  }
});

exports.Migration = Migration;
});

// module: shared/data2/store/schema/type/integer
// file:   ../../shared/js/data2/store/schema/type/integer.js
define("shared/data2/store/schema/type/integer", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var TypeBase = require('./base').TypeBase;

function intify(value) {
  if (!value) {
    return 0;
  }
  return +value;
}
/**
 * @classdesc TypeInteger casts values to an integer when writing to the
 * database.
 *
 *    int: new TypeInteger({})
 */
var TypeInteger = core.createClass({

  name: 'TypeInteger',

  extend: TypeBase,

  localType: 'INTEGER',

  transformModelToLocal: intify,
  transformLocalToModel: intify,
  transformModelToRemote: intify,
  transformRemoteToModel: intify
});

exports.TypeInteger = TypeInteger;
});

// module: contacts/display_contact_section/external_services
// file:   contacts/display_contact_section/external_services.js
define("contacts/display_contact_section/external_services", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var sharedUtil = require('shared/util');

var ProfileServices = {
  viewProfile: function(contactSnapshot) {
    sharedUtil.openProfile(contactSnapshot.facebookId);
  }
};

var TalkServices = {
  callNumber: function(number) {
    sharedUtil.makeCall(number);
  },

  messageContact: function(contactSnapshot) {
    var url = sharedUtil.getMessageContactUrl(contactSnapshot.facebookId);

    if (window.FBAPI && FBAPI.use('glitter')) {
      window.openUrl(url);
    } else {
      window.location = url;
    }
  }
};

exports.ProfileServices = ProfileServices;
exports.TalkServices = TalkServices;
});

// module: contacts/create_new_contact_section/ui/create_new_contact_scene
// file:   contacts/create_new_contact_section/ui/create_new_contact_scene.js
define("contacts/create_new_contact_section/ui/create_new_contact_scene", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*global undefined: true */

var ContactFormScene = require('../../shared/ui/contact_form_scene').ContactFormScene;
var ContactSnapshotBuilder = require('../../contact').ContactSnapshotBuilder;

var CreateNewContactScene = function(options) {
  options = options === undefined ? {} : options;
  options.header = 'New Contact';
  options.id = 'createNewContactScene';
  options.cancelEvent = 'cancelCreateContact';
  options.builderType = ContactSnapshotBuilder;
  options.saveEvent = 'createContact';

  return new ContactFormScene(options);
};

exports.CreateNewContactScene = CreateNewContactScene;
});

// module: mock/uploadmanager_api
// file:   ../../mock/js/uploadmanager_api.js
define("mock/uploadmanager_api", function(require, exports, module) {
var util = require('bolt/util');
exports.UPLOAD_PROGRESS = 'upload.PROGRESS';
exports.UPLOAD_COMPLETE = 'upload.COMPLETE';
exports.UPLOAD_ERROR = 'upload.ERROR';
exports.UPLOAD_STARTED = 'upload.STARTED';

util.extend(exports, {
  cancelAllUploads: function(){},

  uploadImage: function(){},

  uploadVideo: function(){},

  uploadPhotoData: function(){
    return true;
  },

  getUploadQueue: function(){
    return '[]';
  },

  changePhotoUpload: function(){
    return true;
  },

  changeVideoUpload: function(){
    return true;
  },

  cancelUpload: function(){
    return true;
  },

  importMessage: function(){},

  sendMessage: function(){},
});
});

// module: shared/data2/store/schema/type/base
// file:   ../../shared/js/data2/store/schema/type/base.js
define("shared/data2/store/schema/type/base", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');

function returnArg(object) {
  return object;
}

/**
 * @classdesc TypeBase is the class to extend when creating different property
 *  types. Types are useful as a way of reusing code for schema property
 *  config.
 */
var TypeBase = core.createClass({

  name: 'TypeBase',

  construct: function(options, name) {
    util.extend(this, options);
  },

  transformModelToLocal: returnArg,
  transformLocalToModel: returnArg,
  transformModelToRemote: returnArg,
  transformRemoteToModel: returnArg
});


exports.TypeBase = TypeBase;
});

// module: view/message_composer_scene/recipient_token
// file:   view/message_composer_scene/recipient_token.js
define("view/message_composer_scene/recipient_token", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var CollectionView = require('bolt/collection_view').CollectionView;
var Actionable = require('bolt_touch/mixins/actionable').Actionable;

var RecipientToken = core.createClass({
  name: 'RecipientToken',
  extend: View,

  mixins: [Actionable],

  properties: {
    selected: false
  },

  setSelected: function(state) {
    var oldState = this.getSelected();
    if (state !== oldState) {
      this.set('selected', state);
      this.toggleClass('selected', state);
    }
    return this;
  }
});

exports.RecipientToken = RecipientToken;
});

// module: shared/data2/with_annotation
// file:   ../../shared/js/data2/with_annotation.js
define("shared/data2/with_annotation", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*global __DEV__:false*/

if (__DEV__) {
  exports.WithAnnotation = {
    _annotation: null,

    annotate: function(text) {
      this._annotation = text;
      return this;
    },

    getAndClearAnnotation: function(defaultText) {
      var extraText = this.getDeclaredClass() + '#' + defaultText;
      var result =
        this._annotation ? (this._annotation + ' -> ' + extraText) : extraText;
      this._annotation = null;
      return result;
    }
  };
} else {
  exports.WithAnnotation = {
    annotate: function() {
      return this;
    },

    getAndClearAnnotation: function() {
      return '';
    }
  };
}
});

// module: shared/shadowbroker/broker/controller_factory
// file:   ../../shared/js/shadowbroker/broker/controller_factory.js
define("shared/shadowbroker/broker/controller_factory", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core = require('bolt/core');

var ControllerFactory = core.createClass({

  _classes: null,
  _cache: null,

  construct: function() {
    this._classes = {};
    this._cache  = {};
  },

  registerController: function(type, klass) {
    if (typeof type == 'string') {
      this._classes[type] = klass;
    } else {
      this._classes[type.type] = type;
    }
  },

  getController: function(type) {
    if (!this._cache[type]) {
      var Klass = this._classes[type];
      this._cache[type] = typeof Klass === 'function' ? new Klass() : Klass;
    }
    return this._cache[type];
  }
});


exports.ControllerFactory = ControllerFactory;
});

// module: contacts/values/remove_contact_information
// file:   contacts/values/remove_contact_information.js
define("contacts/values/remove_contact_information", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var RemoveContactInformation = function(attributes) {
  this.id = attributes.id;
};

RemoveContactInformation.prototype = {
  equals: function(removeContactInformation) {
    return this.id === removeContactInformation.id;
  }
};

var RemoveContactInformationBuilder = function() {
  this._attributes = {};
};

RemoveContactInformationBuilder.prototype = {
  withId: function(id) {
    this._attributes.id = id;
    return this;
  },
  build: function() {
    return new RemoveContactInformation(this._attributes);
  }
};

exports.RemoveContactInformation = RemoveContactInformation;
exports.RemoveContactInformationBuilder = RemoveContactInformationBuilder;
});

// module: bolt_touch/view
// file:   ../../../frameworks/bolt_touch/lib/view.js
define("bolt_touch/view", function(require, exports, module) {
require('bolt/compat/view');

var core = require('bolt/core');
var BoltView = require('bolt/view').View;

/**
 * The base view for Bolt Touch.
 */
var View = core.createClass({
  // Don't override View in bolt/core.ClassRegistry.View as long as that is
  // still around
  name: 'TouchView',

  extend: BoltView

});

exports.View = View;

//is view running in a touchable device
var hasTouch = View.hasTouch = 'ontouchstart' in window;

// map of touch events or mouse equivalents for testing in browser or device
View.touchEvents = {
  TOUCHSTART: hasTouch ? 'touchstart' : 'mousedown',
  TOUCHEND: hasTouch ? 'touchend' : 'mouseup',
  TOUCHMOVE: hasTouch ? 'touchmove' : 'mousemove',
  TOUCHCANCEL: hasTouch ? 'touchend' : 'mouseup'
};
});

// module: views/feedback/buttons/comment_button/index
// file:   ../../views/feedback/buttons/comment_button/index.js
define("views/feedback/buttons/comment_button/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var Actionable = require('bolt_touch/mixins/actionable').Actionable;

/**
 * @class CommentButton
 * @classdesc A comment button with a pressed state.
 */
var CommentButton = core.createClass({

  name: 'CommentButton',

  extend: View,

  mixins: [Actionable],

  properties: {
    /**
     * @property overlay {boolean} If true, the view will be stylized to stand
     * out better over an image. If false, it will look better over white.
     */
    overlay: false
  },

  setOverlay: function(overlay) {
    this.set('overlay', overlay);
    this.setMode('overlay', overlay);
  }
});

exports.CommentButton = CommentButton;
});

// module: photos/app/lib/model/photo/photo_local_mapper
// file:   ../../photos/app/lib/model/photo/photo_local_mapper.js
define("photos/app/lib/model/photo/photo_local_mapper", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');

var LocalMapper = require('shared/data2/local/local_mapper').LocalMapper;

var PhotoLocalMapper = core.createClass({
  name: 'PhotoLocalMapper',
  extend: LocalMapper,

  properties: {
    tableName: 'photo'
  },

  createIndexes: function(tx) {
    tx.executeSql('CREATE UNIQUE INDEX IF NOT EXISTS ' +
      'idx_photo__id ON ' + this.getTableName() +
      '(id)');
    tx.executeSql('CREATE INDEX IF NOT EXISTS ' +
      'idx_photo__position ON ' + this.getTableName() +
      '(position ASC)');
    tx.executeSql('CREATE INDEX IF NOT EXISTS ' +
      'idx_photo__album_id ON ' + this.getTableName() +
      '(album_id)');
  }
});

exports.PhotoLocalMapper = PhotoLocalMapper;
});

// module: mock/keyboard_api
// file:   ../../mock/js/keyboard_api.js
define("mock/keyboard_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;

module.exports = {

  PREF_VALUE_AVAILABLE: "keyboard.PREF_VALUE_AVAILABLE",

  settings: {
    auto_cap: true,
    quick_fixes: true,
    show_suggestions: true,
    recorrection_enabled: true,
    auto_complete: true,
    vibrate_on: false,
    sound_on: false,
    popup_on: true
  },

  requestBooleanSetting: function(name) {
    var value = (this.settings[name] !== undefined) ?
        this.settings[name] : false;
    EventManager.broadcastEvent(this.PREF_VALUE_AVAILABLE, {
      name: name,
      value: value
    });
  },

  setBooleanSetting: function(name, value) {
    this.settings[name] = value;
    this.requestBooleanSetting(name);
  }
};
});

// module: photos/app/lib/controller/constants
// file:   ../../photos/app/lib/controller/constants.js
define("photos/app/lib/controller/constants", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

exports.LOG_START            = 'photos:start';
exports.LOG_LOAD_IMAGES      = 'photos:loadImages';
exports.LOG_ALBUM_DETAILS    = 'photos:albumDetails';
exports.LOG_SCROLL_ALBUM_LIST = 'photos:scrollFPS:albumList';
exports.LOG_LOAD_PHOTO       = 'photos:loadPhoto';
exports.VIDEO_ID_IDENTIFIER  = "#fbid=";
exports.UNPUBLISHED_ALBUM_NAME = 'Camera Roll';
exports.UNPUBLISHED_ALBUM_ID = '-1';
exports.VIDEO_ALBUM_ID       = '-2';
exports.MEDIA_TYPE = {
  PHOTO: 'photo',
  VIDEO: 'video'
};

exports.PHOTO_STATE = {
  LOCAL          : 1,
  UPLOADING      : 2,
  POSTING        : 4,
  POST_SUCCEEDED : 8,
  POST_FAILED    : 16,
  SYNCED         : 32
};

exports.DB_VERSION = '1.4';
exports.DB_KEY     = 'photos_storage_version';
});

// module: views/composer/js/photo_thumbnail_view
// file:   ../../views/composer/js/photo_thumbnail_view.js
define("views/composer/js/photo_thumbnail_view", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core              = require('bolt/core');
var View              = require('bolt_touch/view').View;

var PhotoThumbnailView = exports.PhotoThumbnailView = core.createClass({
  name: 'PhotoThumbnailView',

  extend: View,

  statics: {
    THUMBNAIL_DIM : 50
  },

  properties: {
    id: null,
    thumbnail: null
  },

  declare: function(options) {
    return {
      childViews: [{
        tagName: 'img',
        ref: 'thumb',
        additionalClasses: 'composer-thumbnail'
      }]
    };
  },

  ready: function() {
    var node = this.findRef('thumb').getNode();
    node.src = this.getThumbnail();
    // Put the id on the node so that id can be retrieved
    // in the event callback
    node.id = this.getId();
  }
});
});

// module: shared/model/profile/page
// file:   ../../shared/js/model/profile/page.js
define("shared/model/profile/page", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core              = require('bolt/core');
var Profile           = require('shared/model/profile/profile').Profile;

exports.PageProfile = core.createClass({

  name: 'PageProfile',

  extend: Profile,

  /**
   * If this page has a location associated with it, return its location.
   * @return {Object} Latitude and longitude in an object of the form
   *  {latitude: 35.1234, longitude: -122.1234}
   */
  getLatLong: function() {
    if (typeof this._latLong === 'undefined') {
      this._latLong = null;
      if (this.get('latitude') && this.get('longitude')) {
        this._latLong = {
          latitude: this.get('latitude'),
          longitude: this.get('longitude')
        };
      }
    }
    return this._latLong;
  }

});
});

// module: views/units/component/fb_object_link/index
// file:   ../../views/units/component/fb_object_link/index.js
define("views/units/component/fb_object_link/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var Actionable = require('bolt_touch/mixins/actionable').Actionable;

/**
 * @classdesc A link to any Facebook object.
 * id: the id of the object
 * type: the type of the object (e.g. user, page, etc)
 */
var FBObjectLink = exports.FBObjectLink = core.createClass({
  name: 'FBObjectLink',
  extend: View,

  mixins: [Actionable],

  properties: {
    id: null,
    type: null
  },

  declare: function(options) {
    return {
      tagName: 'a'
    };
  },

  doAction: function() {
    this.invoke(
      'action',
      {
        type: 'fbObjectClick',
        fbObjectType: this.getType(),
        id: this.getId()
      }
    );
  }
});

exports.FBObjectLink = FBObjectLink;
});

// module: contacts/display_contact_section/ui/phone_numbers/phone_numbers_section
// file:   contacts/display_contact_section/ui/phone_numbers/phone_numbers_section.js
define("contacts/display_contact_section/ui/phone_numbers/phone_numbers_section", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;

var PhoneNumberView = require('./phone_number_view').PhoneNumberView;

var PhoneNumbersSection = core.createClass({
  extend: View,

  declare: function(options) {
    return {
      tagName: 'ul',
      className: 'phone-numbers-section'
    };
  },

  setPhoneNumbers: function(numbers) {
    for (var i = 0; i < numbers.length; i++) {
      var view = new PhoneNumberView({
        action: 'phoneClick',
        owner: this
      });
      view.setPhoneNumber(numbers[i]);
      this.appendChild(view);
    }
  },

  phoneClick: function(view) {
    this.invoke('phoneClicked', {
      number: view.getNumber()
    });
  }
});

exports.PhoneNumbersSection = PhoneNumbersSection;
});

// module: shared/screen_constants
// file:   ../../shared/js/screen_constants.js
define("shared/screen_constants", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

exports.PHONE_DIMENSION = (function() {
  var infoAPI = window.FBAPI ? FBAPI.use("info") : null;
  var isNewDevice;
  if (infoAPI) {
    isNewDevice = (/blue|enterprise/i).test(infoAPI.getModelNumber());
  } else {
    isNewDevice = true;
  }

  return {
    height: isNewDevice ? 960: 800,
    width: isNewDevice ? 540: 480
  };
}());

exports.BAR_HEIGHT = 60;
exports.FULL_KEYBOARD_HEIGHT = 422;
exports.TAB_BAR_HEIGHT = 91;
exports.CONTENT_MARGIN = 78;
exports.BROWSER_BAR_HEIGHT = 71;
exports.SCREEN_WIDTH = exports.PHONE_DIMENSION.width;
exports.SCREEN_HEIGHT = exports.PHONE_DIMENSION.height;
exports.CONTENT_HEIGHT = exports.SCREEN_HEIGHT - exports.CONTENT_MARGIN;
exports.KEYBOARD_ACTIVE_CONTENT_HEIGHT = exports.CONTENT_HEIGHT - exports.FULL_KEYBOARD_HEIGHT;
});

// module: talk/app/contacts/simple_contact_fetcher
// file:   contacts/simple_contact_fetcher.js
define("talk/app/contacts/simple_contact_fetcher", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var Deferred = require('shared/deferred').Deferred;
var LocalContactsList = require('./local_contacts_list').LocalContactsList;

var contactsList;
var allContacts;

/**
 * A simple API for fetching an array of contacts.  This only loads local
 * contacts, and does not fetch contacts remotely.  A Deferred is returned.
 */
exports.fetchContacts = function() {
  var deferred = new Deferred();

  if (!allContacts) {
    if (!contactsList) {
      contactsList = new LocalContactsList();
    }
    contactsList.allContacts().addCallback(function(contacts) {
      // Cache the local contacts
      allContacts = contacts;
      deferred.succeed(contacts);
    });
  } else {
    deferred.succeed(allContacts);
  }

  return deferred;
};
});

// module: mock/hand_sensor_api
// file:   ../../mock/js/hand_sensor_api.js
define("mock/hand_sensor_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

module.exports = {
  _isPowerOn: true,

  readRegisters: function() {
    // API should return a stringified JSON array of integers.
    // Values are made up since I don't know what they're supposed to be.
    return '[258,2109,3592,5820,1895]';
  },

  readChannels: function() {
    // API should return a stringified JSON array of integers.
    // Values are made up since I don't know what they're supposed to be.
    return '[258,2109,3592,5820,1895]';
  },

  setMode: function(mode) {
  },

  isPowerOnEnabled: function() {
    return this._isPowerOn;
  },

  setIsPowerOnEnabled: function(enable) {
    this._isPowerOn = enable;
    return true;
  },

  togglePowerOn: function() {
    this.setIsPowerOnEnabled(!this.isPowerOnEnabled());
    return true;
  }
};
});

// module: views/composer/js/screen_shield
// file:   ../../views/composer/js/screen_shield.js
define("views/composer/js/screen_shield", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var View = require('bolt_touch/view').View;

var ScreenShield = exports.ScreenShield = core.createClass({
  name: 'ScreenShield',

  extend: View,

  declare: function() {
    return {
      additionalClasses: 'shield'
    };
  },

  ready: function() {
    this.getNode().ontouchmove = this._cancel;
  },

  show: function(top, height) {
    this.getNode().style.top = top + 'px';
    this.getNode().style.height = height + 'px';
    View.prototype.show.apply(this);
  },

  hide: function() {
    this.getNode().style.top = 0 + 'px';
    this.getNode().style.height = 0 + 'px';

    View.prototype.hide.apply(this);
  },

  _cancel: function(e) {
    e.preventDefault();
    e.stopPropagation();
  }
});
});

// module: bolt_touch/views/textinput/index
// file:   ../../../frameworks/bolt_touch/lib/views/textinput/index.js
define("bolt_touch/views/textinput/index", function(require, exports, module) {
var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var dom  = require('bolt/dom');


var TextInput = core.createClass({
  name: 'TextInput',

  extend: View,

  properties: {
    tagName: 'input'
  },

  delegateProperties: {
    node: ['size', 'type', 'value', 'select', 'placeholder', 'maxlen', 'disabled']
  },

  declare: function() {
    return {
      tagName: 'input',
      type: 'text'
    };
  },

  focus: function() {
    this.getNode().focus();
  },

  setReadonly: function(isReadonly) {
    var node = this.getNode();
    if (isReadonly) {
      node.setAttribute('readonly', 'readonly');
    } else {
      node.removeAttribute('readonly');
    }
  },

  getReadonly: function() {
    return this.getNode().getAttribute('readonly') == 'readonly';
  }
});


exports.TextInput = TextInput;
});

// module: shared/shadowbroker/shadow/base/shadow
// file:   ../../shared/js/shadowbroker/shadow/base/shadow.js
define("shared/shadowbroker/shadow/base/shadow", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

/**
 * Shadow is a live-updated object returned from the SharedWorker.
 * Shadow should not be used directly, instead subclass it. See
 * 'shadow/collection/collection_shadow' for an example.
 */
var Shadow = {
  _channel: null,

  /**
   * Called right after creation by the broker
   */
  setChannel: function(channel) {
    this._channel = channel;
    this._channel.setActor(this);
    this.initFromData(channel.getInitialData());
    channel.clearInitialData();
    return this;
  },

  initFromData: function(data) {},

  /**
   * Called every time a new message comes from the worker
   */
  reactToMessage: function(message) {},

  destroy: function() {
    if (this._channel) {
      this._channel.close();
    }
  },

  getChannel: function() {
    return this._channel;
  }
};

exports.Shadow = Shadow;
});

// module: photos/app/lib/view/checkbox/index
// file:   ../../photos/app/lib/view/checkbox/index.js
define("photos/app/lib/view/checkbox/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core       = require('bolt/core');
var View       = require('bolt_touch/view').View;
var Actionable = require('bolt_touch/mixins/actionable').Actionable;

/**
 * Checkbox button with a "selected" property that you can get or set.
 * "selectionChanged" event is fired whenever this property changes. Clicking
 * the checkbox toggles the "selected" property.
 */
var Checkbox = exports.Checkbox = core.createClass({
  name: 'Checkbox',

  extend: View,

  events: ['selectionChanged'],

  mixins: [Actionable],

  properties: {
    selected: false
  },

  setSelected: function (selected) {
    this.set('selected', selected);
    this.setMode('selected', selected);
    this.invoke('selectionChanged', {
      selected: selected
    });
  },

  doAction: function() {
    this.setSelected(!this.get('selected'));
  }
});
});

// module: mock/location_manager_api
// file:   ../../mock/js/location_manager_api.js
define("mock/location_manager_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

module.exports = {
  providers: {},
  geofences: {},
  geofenceId: 0,

  isProviderEnabled: function(provider) {
    return !!this.providers[provider];
  },

  setProviderEnabled: function(provider, enabled) {
    this.providers[provider] = enabled;
    return true;
  },

  updateLocation: function(provider, time, latitude, longitude, accuracy) {
  },

  clearLastKnownLocation: function(provider) {
  },

  addGeofenceCircular: function(latitude, longitude, radius, outside) {
    var geofence = {
      latitude: latitude,
      longitude: longitude,
      radius: radius,
      outside: outside
    };

    this.geofences[this.geofenceId] = geofence;
    return this.geofenceId++;
  },

  removeGeofence: function(geofenceAlert) {
    delete this.geofences[geofenceAlert];
  },

  clearGeofences: function() {
    this.geofences = {};
  }
};
});

// module: contacts/display_contact_section/ui/phone_numbers/phone_number_view
// file:   contacts/display_contact_section/ui/phone_numbers/phone_number_view.js
define("contacts/display_contact_section/ui/phone_numbers/phone_number_view", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var Actionable = require('bolt_touch/mixins/actionable').Actionable;

var PhoneNumberView = core.createClass({
  extend: View,

  mixins: [Actionable],

  declare: function(options) {
    return {
      tagName: 'li',
      className: 'phone-number',
      childViews: [
        {
          tagName: 'span',
          className: 'type',
          ref: 'type'
        },
        {
          tagName: 'span',
          className: 'number',
          ref: 'number'
        }
      ]
    };
  },

  setPhoneNumber: function(number) {
    this.findRef('type').setContent(number.type);
    this.findRef('number').setContent(number.number);
    this._number = number;
  },

  getNumber: function() {
    return this._number.number;
  }
});

exports.PhoneNumberView = PhoneNumberView;
});

// module: view/delimiter_message_row/delimiter_message_row
// file:   view/delimiter_message_row/delimiter_message_row.js
define("view/delimiter_message_row/delimiter_message_row", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var dateUtil          = require('shared/date_util');

var DelimiterMessageRow = exports.DelimiterMessageRow = core.createClass({

  name: 'DelimiterMessageRow',

  extend: View,

  properties: {
    model: null
  },

  declare: function(options) {
    return {
      boxOrientation: 'horizontal',
      childViews: [
        {
          className: 'bt-delimiter-bg',
          childViews: [
            {
              tagName: 'span',
              className: 'bt-delimiter-message-row--text',
              ref: 'text',
              owner: this
            }
          ]
        }
      ]
    };
  },

  setModel: function(model) {
    this.set('model', model);

    this.findRef('text').setContent(
      dateUtil.delimiterTimestamp(new Date(model.get('delimiter') * 1)));
  }
});
});

// module: system/components/keyboard/keyboard_constants
// file:   ../../system/lib/components/keyboard/keyboard_constants.js
define("system/components/keyboard/keyboard_constants", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var variants = {
  NORMAL:   'normal',
  EMAIL:    'email',
  URL:      'url',
  TEXTAREA: 'textarea',
  SEARCH:   'search',
  NUMBER:   'number'
};

exports.KBD = {
  variants: variants,

  // These variants will have things like auto-caps, autocorrect, etc
  textVariants: [
    variants.NORMAL, variants.TEXTAREA
  ],

  keys: {
    ALPHA_BOARD:       1,
    NUMERIC_BOARD:     2,
    SYMBOL_BOARD:      3,
    DELETE:            8,
    RETURN:           10,
    DONE:             13,
    SHIFT:            16,
    SPACE:            32,
    a:                97,
    z:               122,
    A:                65,
    Z:                90,
    UPPER_LOWER_DIFF: 32,
    PERIOD:           46
  },

  isValidVariant: function(variant) {
    for (var i in variants) {
      if (variants[i] === variant) {
        return true;
      }
    }
    return false;
  }
};
});

// module: view/message_composer_scene/picker_input
// file:   view/message_composer_scene/picker_input.js
define("view/message_composer_scene/picker_input", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var View = require('bolt_touch/view').View;

var PickerInput = core.createClass({
  name: 'PickerInput',
  extend: View,

  getValue: function() {
    return this.getNode().value;
  },

  setValue: function(value) {
    this.getNode().value = value;
    this._autogrow();
    return this;
  },

  declare: function() {
    return {
      tagName: 'input',
      type: 'text'
    };
  },

  input: function(e) {
    this._autogrow();
  },

  _autogrow: function() {
    // For now, guess the width based on the number of characters.
    // TODO (achien): revisit this.  The estimate isn't always accurate.
    // Should we use a shadow?
    var chars = this.getNode().value.length;
    var width = Math.min(300, (chars * 16 + 20)) + 'px';
    this.setWidth(width);
  }
});

exports.PickerInput = PickerInput;
});

// module: shared/config
// file:   ../../shared/js/config.js
define("shared/config", function(require, exports, module) {
exports.api_key = "34c9f486c4580bed299e976587a2b829";
exports.api_secret = "956407f56a3602881514029e66848765";

//Determines if the current context belongs to a worker.
//By convention, we'll check for the existence of the window variable, and
//window.mock if the window variable exists. This is because some libraries
//(e.g. bolt) assume the window variable exists and the worker context can mock
//this variable.
var isWorker = exports.isWorker = function () {
  //for future versions of webkit, self.toString() might contain worker. When
  //such version is updated, change the check to the worker context to something
  //like this: return -1 !== self.toString().toLowerCase().indexOf('worker');
  return (typeof window === 'undefined' || window.isWorker);
};

exports.keyEvents = {
  KEYCODE_DPAD_CENTER: 23,
  KEYCODE_VOLUME_UP: 24,
  KEYCODE_VOLUME_DOWN: 25,
  KEYCODE_ANSWER_PLAY_PAUSE: 79,
  KEYCODE_NEXT: 87,
  KEYCODE_PREVIOUS: 88
};
});

// module: contacts/client/store_client
// file:   contacts/client/store_client.js
define("contacts/client/store_client", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core = require('bolt/core');
var ManagedCollectionShadow =
  require('shared/shadowbroker/shadow/managed_collection/managed_collection_shadow')
    .ManagedCollectionShadow;

var Contact = require('../contact').Contact;
var ContactsPortfolio = require('../contacts_portfolio').ContactsPortfolio;


var ContactsStoreClient = core.createClass({

  name: 'ContactsStoreClient',

  _broker: null,

  construct: function(broker) {
    this._broker = broker;
  },

  fetchCollection: function(filter, limit) {
    limit = limit || 99999;
    return this._broker.callMethod('store', 'fetchCollection', filter, limit)
                       .then(this._fetchCollectionComplete, this);
  },

  _fetchCollectionComplete: function(channel) {
    var portfolio = new ContactsPortfolio();
    portfolio.setChannel(channel);
    return portfolio;
  }
});

exports.ContactsStoreClient = ContactsStoreClient;
});

// module: contacts/browse_contacts_section/facebook_contacts_browser
// file:   contacts/browse_contacts_section/facebook_contacts_browser.js
define("contacts/browse_contacts_section/facebook_contacts_browser", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');

var ContactBuilder = require('../contact').ContactBuilder;

var FacebookContactsBrowser = core.createClass({
  name: 'FacebookContactsBrowser',

  construct: function(contactsList, collector) {
    this.contactsList = contactsList;
    this.collector = collector;
    this._gotContacts = util.bind(this._gotContacts, this);
  },

  browseByGroup: function(gid) {
    this.collector.empty();
    //TODO: use paging so we can start getting data faster
    this.contactsList.withGid(gid, this._gotContacts);
  },

  browseByList: function(flid) {
    this.collector.empty();
    this.contactsList.withFlid(flid, this._gotContacts);
  },

  _gotContacts: function(contacts) {
    for (var i = 0; i < contacts.length; i++) {
      this.collector.add(contacts[i]);
    }
  }
});

exports.FacebookContactsBrowser = FacebookContactsBrowser;
});

// module: photos/app/lib/model/video/video
// file:   ../../photos/app/lib/model/video/video.js
define("photos/app/lib/model/video/video", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core        = require('bolt/core');
var util        = require('bolt/util');
var Model       = require('bolt/model').Model;
var Likeable    = require('shared/data2/model/mixin/likeable').Likeable;
var Commentable = require('shared/data2/model/mixin/commentable').Commentable;
var videoStore;

var Video = exports.Video = core.createClass({
  name: 'Video',

  extend: Model,

  mixins: [Likeable, Commentable],

  construct: function(options) {
    Model.call(this, options);
    videoStore = require('./video_store').getInstance();
  },

  storeModel: function() {
    return this.save();
  },

  getFeedbackIdType: function() {
    return Commentable.FEEDBACK_ID_OBJECT_TYPE;
  },

  save: function() {
    return videoStore.store([this]);
  },

  getDisplayName: function() {
    return this.get('name') ? this.get('name') :
      (new Date(this.get('created_time') * 1000)).toDateString();
  }
});
});

// module: view/message_composer_scene/forwards_view
// file:   view/message_composer_scene/forwards_view.js
define("view/message_composer_scene/forwards_view", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;


var ForwardsView = exports.ForwardsView = core.createClass({
  name: 'ForwardsView',

  extend: View,

  properties: {
    messages: []
  },

  declare: function(options) {
    return {
      boxOrientation: 'vertical',
      childViews: [
        {
          ref: 'title',
          className: 'bt-message-composer-forwards-title',
          content: 'No Messages Forwarding.'
        }
      ]
    };
  },

  setMessages: function(messages) {
    this.set('messages', messages);
    switch (messages.length) {
      case 0:
        this.refs.title.setContent('No Messages Forwarding.');
        break;
      case 1:
        this.refs.title.setContent('Forwarding 1 Message');
        break;
      default:
        this.refs.title.setContent(
          'Forwarding ' + messages.length + ' Messages');
        break;
    }
  }
});
});

// module: mock/perflogging_api
// file:   ../../mock/js/perflogging_api.js
define("mock/perflogging_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.


module.exports = {
  _started: false,

  hasStarted: function() {
    return this._started;
  },

  start: function() {
    this._started = true;
  },

  stop: function() {
    this._started = false;
  },

  getPerfData: function(webviewId, time) {
    return '[{"tabId":"dash","id":"dashScrollFPS","time":1332367947799,"fps":16},{"id":"PerfTimer","time":1332367946453,"totalTime":26,"info":{"callstack":[{"wallTime":70,"time":26,"name":"void WebCore::FrameView::layout(bool)"}]}},{"id":"PerfTimer","time":1332367946253,"totalTime":0,"info":{"callstack":[{"wallTime":66,"time":0,"name":"void facebook::stopmotion::MessageHub::readMessages(std::list<facebook::stopmotion::Message*>&, const timespec*)"}]}},{"id":"PerfTimer","time":1332367946016,"totalTime":0,"info":{"callstack":[{"wallTime":1398,"time":0,"name":"void facebook::stopmotion::MessageHub::readMessages(std::list<facebook::stopmotion::Message*>&, const timespec*)"}]}}]';
  }
};
});

// module: contacts/contact_filters_section/stub_filters_data_source
// file:   contacts/contact_filters_section/stub_filters_data_source.js
define("contacts/contact_filters_section/stub_filters_data_source", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var Model = require('bolt/model').Model;
var Collection = require('bolt/collection').Collection;

var GroupMember =
  require('shared/data2/model/group/group_member').GroupMember;
var FriendList =
  require('shared/data2/model/friend_list/friend_list').FriendList;

function sortByBookmarkOrder(model) {
  return model.get('bookmark_order');
}

var data = [{
  gid: '1234',
  group: {
    name: 'Test Group'
  },
  bookmark_order: 1
}];

var groupCollection = new Collection({
  modelType: GroupMember
});
groupCollection.comparator = sortByBookmarkOrder;
for (var i = 0; i < data.length; i++) {
  groupCollection.add(new GroupMember(data[i]));
}

var stubFiltersDataSource = {
  getGroupCollection: function() {
    return groupCollection;
  },

  getListCollection: function() {
    return new Collection();
  }
};

exports.stubFiltersDataSource = stubFiltersDataSource;
exports.groupCollection = groupCollection;
});

// module: bolt_touch/views/scrim/index
// file:   ../../../frameworks/bolt_touch/lib/views/scrim/index.js
define("bolt_touch/views/scrim/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var View = require('bolt_touch/view').View;
var core = require('bolt/core');
var Actionable = require('../../mixins/actionable').Actionable;
var util = require('bolt/util');

// A Scrim is a background element that covers the entire window.
// It is intended to work with modal dialogs so that when it is tapped,
// the application can execute an action to hide the modal dialog.
exports.Scrim = core.createClass({
  name: 'Scrim',

  extend: View,

  mixins: [Actionable],

  construct: function(options) {
    this.hide = util.bind(this.hide, this);
    this.destroy = util.bind(this.destroy, this);
    View.call(this, options);
  },

  ready: function() {
    this.addAction(this.hide);
  },

  hide: function() {
    if (this.hidden) {
      return;
    }
    this.hidden = true;
    this.setStyle({opacity: 0});
    setTimeout(this.destroy, 300);
  },

  onDocumentInsertion: function() {
    var _this = this;

    setTimeout(function() {
      _this.setStyle({opacity: 0.5});
    }, 50);
  }
});
});

// module: contacts/find_facebook_contact_section/facebook_contact_searcher/facebook_profiles_contacts_list
// file:   contacts/find_facebook_contact_section/facebook_contact_searcher/facebook_profiles_contacts_list.js
define("contacts/find_facebook_contact_section/facebook_contact_searcher/facebook_profiles_contacts_list", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

//The following are not actually global, but local, defined underneath
//for readability

/*global buildContactFromData: true */
/*global profileUrlForFBId: true */

var ContactBuilder = require('../../contact').ContactBuilder;
var FacebookProfilesContactsList = function(server) {
  this.server = server;
};

FacebookProfilesContactsList.prototype = {
  withName: function(searchTerm, callback) {
    this.server.fetchContacts(searchTerm, function(contactsData) {
      callback(contactsData.map(buildContactFromData));
    });
  },

  withPhoneNumber: function(phoneNumber, callback) {
    callback([]);
  }
};

var buildContactFromData = function(contactData) {
  return new ContactBuilder()
             .withName(contactData.name)
             .withProfileUrl(profileUrlForFBId(contactData.id))
             .build();
};

var profileUrlForFBId = function(id) {
  return 'http://graph.facebook.com/' + id + '/picture?type=square';
};

exports.FacebookProfilesContactsList = FacebookProfilesContactsList;
});

// module: contacts/find_facebook_contact_section/facebook_contact_searcher
// file:   contacts/find_facebook_contact_section/facebook_contact_searcher.js
define("contacts/find_facebook_contact_section/facebook_contact_searcher", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var FacebookProfilesContactsList =
  require('./facebook_contact_searcher/facebook_profiles_contacts_list').FacebookProfilesContactsList;
var ContactsListSearcher =
  require('./facebook_contact_searcher/contacts_list_searcher').ContactsListSearcher;
var AjaxFacebookContactsServer =
  require('./facebook_contact_searcher/ajax_facebook_contacts_server').AjaxFacebookContactsServer;

var FacebookContactSearcher = function(portfolio) {
  //I'd rather do the configuration of the application inside index, but I don't
  //want to clutter that space with contact specific stuff since the rest of
  //talk doesn't follow this pattern
  var server;
  if (window.__ACCEPTANCE_TEST__) {
    server = require('../stubs/facebook_contacts').server;
  } else {
    server = new AjaxFacebookContactsServer();
  }
  var contactsList =  new FacebookProfilesContactsList(server);
  var searcher = new ContactsListSearcher(contactsList, portfolio);
  return searcher;
};

exports.FacebookContactSearcher = FacebookContactSearcher;
});

// module: contacts/shared/ui/search_box
// file:   contacts/shared/ui/search_box.js
define("contacts/shared/ui/search_box", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var TextInput = require('bolt_touch/views/textinput').TextInput;

var SearchBox = core.createClass({
  extend: View,

  construct: function() {
    View.apply(this, arguments);

    this._announcer = arguments[0].announcer;
  },

  declare: function(options) {
    return {
      className: 'search-box',
      childViews: [
        {
          view: TextInput,
          id: options.textFieldId,
          ref: 'searchBox',
          placeholder: 'Search...',
          onkeyup: 'searchChanged',
          value: options.initialValue
        }
      ]
    };
  },

  searchChanged: function(event) {
    var searchValue = this.getValue();
    this._announcer.announce('searchingFor', searchValue);
  },

  getValue: function() {
    return this.findRef('searchBox').getNode().value;
  },

  clear: function() {
    this.findRef('searchBox').getNode().value = '';
    this._announcer.announce('searchingFor', '');
  }
});

exports.SearchBox = SearchBox;
});

// module: views/feedback/buttons/like_button/index
// file:   ../../views/feedback/buttons/like_button/index.js
define("views/feedback/buttons/like_button/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var Actionable = require('bolt_touch/mixins/actionable').Actionable;

/**
 * @class LikeButton
 * @classdesc A togglable like button. Requires binding to a model's likes.
 */
var LikeButton = core.createClass({

  name: 'LikeButton',

  extend: View,

  mixins: [Actionable],

  properties: {
    /**
     * @property likes {Object} Object containing a user_likes property, at the
     * very least. user_likes is a boolean indicating whether or not the user
     * likes the model at hand.
     */
    likes: null,
    /**
     * @property overlay {boolean} If true, the view will be stylized to stand
     * out better over an image. If false, it will look better over white.
     */
    overlay: false
  },

  setLikes: function(likes) {
    this.set('likes', likes);
    this.setMode('liked', likes.user_likes);
  },

  setOverlay: function(overlay) {
    this.set('overlay', overlay);
    this.setMode('overlay', overlay);
  }
});

exports.LikeButton = LikeButton;
});

// module: views/contacts_table/contacts_cell
// file:   ../../views/contacts_table/contacts_cell.js
define("views/contacts_table/contacts_cell", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core                   = require('bolt/core');
var TableViewCell          = require("views/deprecated/table_view").TableViewCell;
var ProfilePicture = require('views/profile_picture').ProfilePicture;

var ContactCell = exports.ContactsCell = core.createClass({
  name: 'ContactCell',
  extend: TableViewCell,

  delegateProperties: {
    profilePicture: [{alias: 'profilePictureSrc', name: 'src'}]
  },

  declare: function(options) {
    return {
      additionalClass: 'contacts-row',
      boxOrientation: 'horizontal',
      childViews: [
        {view: 'ProfilePicture', ref: 'profilePicture'},
        {
          additionalClasses: 'bt-name',
          childViews: [
            {
              tagName: 'span',
              ref: 'name'
            },
          ]
        }
      ]
    };
  },

  setName: function(name) {
    this.refs.name.setContent(name);
  },

  setModel: function(contact) {
    this.setBinding(contact, [
      {property: 'name'},
      {modelProperty: 'pic_big', viewProperty: 'profilePictureSrc'}
    ]);
  }
});
});

// module: mock/voicemail_api
// file:   ../../mock/js/voicemail_api.js
define("mock/voicemail_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

module.exports = {
  getDHParameters: function() {
    // actually OK values (seriously)
    var vvmDHParams = {
      parameter:"935713ecbea3cfcf8b53e9a9217615dacc394bd4b206117c2baa3f196189"+
        "32efe69ed3be41aa2cff9573469f9f0de87b68cf875e337bd1bf63e848feb2c9c69b",
      generator:5,
      publicKey:"30819E305706092A864886F70D010301304A024100935713ECBEA3CFCF8B"+
        "53E9A9217615DACC394BD4B206117C2BAA3F19618932EFE69ED3BE41AA2CFF957346"+
        "9F9F0DE87B68CF875E337BD1BF63E848FEB2C9C69B02010502020180034300024038"+
        "9148B601E04D38543614D15A9F51F8FA8FAAC9796923C5DD80FC74B8B0AF084C963A"+
        "1DC50D23DF845BC1A477144C985728610BE498C708B4723DB58681F8E7"
    };
    return JSON.stringify(vvmDHParams);
  },

  encryptPin: function() {
    // one possible value
    return "q7luRNYXDrHd1PUPtwSLmw==";
  },

  saveAttachment: function() {
    return "/data/data/com.facebook.buffy/vvm/whatever.amr";
  },

  httpRequest: function() {
    // we could try to mimic this via XHR but what would be the point?
    return false;
  }
};
});

// module: bolt_touch/mixins/actionable
// file:   ../../../frameworks/bolt_touch/lib/mixins/actionable.js
define("bolt_touch/mixins/actionable", function(require, exports, module) {
var View = require('bolt_touch/view').View;
var util = require('bolt/util');
var dom = require('bolt/dom');
var Touchable = require('./touchable').Touchable;

exports.Actionable = util.extend({}, Touchable, {

  mixinReady: function() {
    Touchable.mixinReady.call(this);
  },

  hasFinishedTouching: function(wasTouched, evt) {
    if (wasTouched) {
      evt.stopPropagation();
      this.doAction(evt);
    }
  },

  doAction: function(evt) {
    var actions = this._actions;
    var action;

    if (!actions) {
      return;
    }

    for (var i = 0; i < actions.length; i++) {
      action = actions[i];
      if (typeof action == 'string') {
        var context = null;
        var owner = this.getOwner();
        if (owner[action]) {
          context = owner;
        } else {
          context = this;
        }
        context[action](this, evt);
      } else if (action) {
        action(this, evt);
      }
    }
  },

  addAction: function(action) {
    this._actions = this._actions || [];
    this._actions.push(action);
  },

  setAction: function(action) {
    this._actions = [action];
  }

});
});

// module: shared/data2/local/spec
// file:   ../../shared/js/data2/local/spec.js
define("shared/data2/local/spec", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');

var TableSpec = core.createClass({
  name: 'TableSpec',

  properties: {
    tableName: '',
    dataColumnName: 'data',
    schema: null,
    indexes: []
  },

  construct: function(options) {
    for (var o in options) {
      var setter = this[util.setter(o)];
      if (util.isFunction(setter)) {
        setter.call(this, options[o]);
      }
    }
  },

  getColumns: function() {
    var result = [];
    var schema = this.getSchema();
    var propertyNames = schema.getPropertyNames();

    for (var i = 0, length = propertyNames.length; i < length; i++) {
      var name = propertyNames[i];
      var info = schema.getPropertyInfo(name);
      if (info.searchable) {
        var column = {
          name: info.local
        };
        if (info.localType) {
          column.type = info.localType;
        }
        result.push(column);
      }
    }

    result.push({
      name: this.getDataColumnName(),
      type: 'TEXT'
    });
    return result;
  }
});

exports.TableSpec = TableSpec;
});

// module: views/dialer/emergency_entry_display
// file:   ../../views/dialer/emergency_entry_display.js
define("views/dialer/emergency_entry_display", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core            = require('bolt/core');
var EntryDisplay    = require('views/dialer/entry_display').EntryDisplay;

var EmergencyEntryDisplay = exports.EmergencyEntryDisplay = core.createClass({
  name: 'EmergencyEntryDisplay',
  extend: EntryDisplay,

  statics: {
    EMERGENCY_MESSAGE_DURATION: 2000
  },

  declare: function(options) {
    options.emergency = true;
    options.addClasses = 'bt-emergency-entry-display';
    options.addChildren =
      [{
        ref: 'airplaneModeMessage',
        additionalClasses: 'bt-emergency-message',
        content: 'Disabling Airplane Mode...',
        style: {display: 'none'}
      }];
    return EntryDisplay.prototype.declare.call(this, options);
  },

  showAirplaneModeMessage: function() {
    var dialString = this.dialString;
    var airplaneModeMessage = this.refs.airplaneModeMessage;
    dialString.hide();
    airplaneModeMessage.show();
    var showNumber = function() {
      dialString.show();
      airplaneModeMessage.hide();
    };
    setTimeout(showNumber, this.klass.EMERGENCY_MESSAGE_DURATION);
  }
});
});

// module: photos/app/lib/client/album_client
// file:   ../../photos/app/lib/client/album_client.js
define("photos/app/lib/client/album_client", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core = require('bolt/core');
var ManagedCollectionShadow =
  require('shared/shadowbroker/shadow/managed_collection/managed_collection_shadow')
    .ManagedCollectionShadow;
var Album = require('../model/album/album').Album;

var AlbumCollectionShadow = core.createClass({
  extend: ManagedCollectionShadow,
  name: 'AlbumCollectionShadow',

  statics: {
    modelType: Album
  }
});


var AlbumClient = core.createClass({

  _broker: null,

  construct: function(broker) {
    this._broker = broker;
  },

  fetchAlbumCollection: function() {
    return this._broker
      .callMethod('album', 'fetchAlbumCollection')
      .then(this._fetchAlbumCollectionComplete, this);
  },

  _fetchAlbumCollectionComplete: function(channel) {
    var shadowCollection = new AlbumCollectionShadow();
    shadowCollection.setChannel(channel);
    return shadowCollection;
  }
});



var _instance = null;
exports.getInstance = function() {
  if (!_instance) {
    _instance = new AlbumClient(require('./broker').getInstance());
  }
  return _instance;
};

exports.AlbumClient = AlbumClient;
});

// module: shared/data2/model/mixin/commentable
// file:   ../../shared/js/data2/model/mixin/commentable.js
define("shared/data2/model/mixin/commentable", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var sharedUtil = require('shared/util');

/**
 * This is a mixin for models that can be commented on (such as videos, posts,
 * etc);
 *
 * To be able to use this mixin a model must have a property 'comments' that is
 * an object with the following properties:
 *
 *  count - How many comments there are on the object.
 *  can_comment - True if the user can comment on the object.
 *
 * The model must also either have a method called getId that returns the fbid
 * or a propery named  property 'id' that is the fbid of the model.
 */
exports.Commentable = {

  /**
   * These constants are used in getFeedbackIdType.
   */
  FEEDBACK_ID_POST_TYPE: 'post_id',

  FEEDBACK_ID_OBJECT_TYPE: 'object_id',

  /**
   * @return the fbid of the model
   */
  getFeedbackId: function() {
    return this.get('id');
  },

  /**
   *  Returns either this.FEEDBACK_ID_POST_TYPE or
   *  this.FEEDBACK_ID_OBJECT_TYPE depending on which field in the FQL
   *  table contains the ID for the model.
   */
  getFeedbackIdType: function() {
    sharedUtil.abstractMethod('Commentable.getFeedbackIdType');
  }
};
});

// module: contacts/browse_contacts_section/ajax_group_contacts_server
// file:   contacts/browse_contacts_section/ajax_group_contacts_server.js
define("contacts/browse_contacts_section/ajax_group_contacts_server", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var apixhr = require('shared/api_xhr');

/**
 * Fetches users who are members of a group.
 */
var AjaxGroupContactsServer = core.createClass({
  name: 'AjaxGroupContactsServer',

  fetchContacts: function(gid, callback) {
    var queries = {
      "member_uids": "SELECT uid FROM group_member WHERE gid = " + gid,
      "user_information": "SELECT " + commandSeperatedColumns() +
                            " FROM user WHERE uid in " +
                            "(SELECT uid FROM #member_uids)"
    };

    apixhr.multifql(queries)
          .then(function(response) {
            if (response.error_msg) {
              console.error('Error getting users:', response.error_msg);
              return;
            }
            var userInformation = response[1].fql_result_set;
            callback(userInformation);
          }, this);
  }

});

var commandSeperatedColumns = function() {
  var columns = [
    'first_name', 'middle_name', 'last_name', 'pic_square', 'uid'
  ];

  return columns.join(',');
};

exports.AjaxGroupContactsServer = AjaxGroupContactsServer;
});

// module: shared/data2/model/like/remote_mapper
// file:   ../../shared/js/data2/model/like/remote_mapper.js
define("shared/data2/model/like/remote_mapper", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');

var Deferred = require('shared/deferred').Deferred;

var MultiFQLRemoteMapper =
  require('../../remote/multi_fql_remote_mapper').MultiFQLRemoteMapper;

/**
 * @class LikeRemoteMapper
 * @classdesc A LikeRemoteMapper is a type of MultiFQLRemoteMapper that adds
 * an is_friend field to the fetched model based on whether we queried for likes
 * from friends or not.
 */
var LikeRemoteMapper = core.createClass({

  name: 'LikeRemoteMapper',

  extend: MultiFQLRemoteMapper,

  // This function wraps the MultiFQLRemoteMapper's download function and
  // adds the is_friend field appropriately.
  download: function(filter, limit, _orderingWhere) {
    return MultiFQLRemoteMapper.prototype.download.apply(this, arguments)
      .then(function(models, hasMore) {
        var is_friend = !!filter.getProperties().user;
        for (var i = 0; i < models.length; i++) {
          models[i].set('is_friend', is_friend);
        }
        return (new Deferred()).succeed(models, hasMore);
      });
  }

});

exports.LikeRemoteMapper = LikeRemoteMapper;
});

// module: bolt_touch/views/button_new/index
// file:   ../../../frameworks/bolt_touch/lib/views/button_new/index.js
define("bolt_touch/views/button_new/index", function(require, exports, module) {
var core = require('bolt/core');
var ButtonBase = require('bolt_touch/views/button_base').ButtonBase;

exports.ButtonNew = core.createClass({

  name: 'ButtonNew',

  extend: ButtonBase,

  properties: {
    iconSrc: null,
    iconOnly: false,
    label: ''
  },

  declare: function(options) {
    return {
      tagName: 'button',
      type: 'button',
        childViews: [
        {
          className: 'bt-label',
          ref: 'label'
        }
      ]
    };
  },

  // The size of the icon should be 24px X 24px
  setIconSrc: function(iconSrc) {
    this.set('iconSrc', iconSrc);
    this.toggleClass('has-icon', iconSrc);
    this.refs.label.setStyle({
      backgroundImage: 'url(' + iconSrc +')'
    });
  },

  setIconOnly: function(iconOnly) {
    this.set('iconOnly', iconOnly);
    this.conditionClass('iconOnly', iconOnly);
    var label = this.getLabel();
    if (label) {
      if (iconOnly) {
        this.refs.label.setContent('');
      } else  {
        this.refs.label.setContent(label);
      }
    }
  },

  setLabel: function(label) {
    this.set('label', label);
    if (!this.getIconOnly()) {
      this.refs.label.setContent(label);
    }
  }
});
});

// module: talk/client/broker
// file:   ../client/broker.js
define("talk/client/broker", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*global SharedWorker:false*/

var global = this;

function createBroker() {
  var Broker = require('shared/shadowbroker/broker').Broker;
  var worker;
  if (global.DEBUG_WORKER_CONTEXT) {
    var SharedWorker =
      require('shared/shadowbroker/mock/shared_worker').SharedWorker;
    worker = new SharedWorker(global.DEBUG_WORKER_CONTEXT);
  } else {
    if (global.__ACCEPTANCE_TEST__) {
      worker = new global.SharedWorker('/apps/talk/worker.js?test=true');
    } else {
      worker = new global.SharedWorker('/apps/talk/worker.js');
    }
  }
  var broker = new Broker(worker.port);
  broker.setName('talk'); // logging

  return broker;
}


var _instance = null;
var _system = null;
exports.getInstance = function() {
  if (!_instance) {
    _instance = createBroker();
  }
  return _instance;
};

exports.initSystemClient = function() {
  if (!_system) {
    // do not override console/FBAPI/EventManager when in the worker
    if (!global.DEBUG_WORKER_CONTEXT) {
      var Client = require('shared/shadowbroker/system/client').Client;
      _system = new Client(exports.getInstance());
      _system.init();
    }
  }
};
});

// module: contacts/browse_contacts_section/ajax_friend_list_contacts_server
// file:   contacts/browse_contacts_section/ajax_friend_list_contacts_server.js
define("contacts/browse_contacts_section/ajax_friend_list_contacts_server", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var apixhr = require('shared/api_xhr');

/**
 * Fetches users who are members of a list */
var AjaxFriendListContactsServer = core.createClass({
  name: 'AjaxFriendListContactsServer',

  fetchContacts: function(flid, callback) {
    var queries = {
      "member_uids": "SELECT uid FROM friendlist_member WHERE flid = " + flid,
      "user_information": "SELECT " + commandSeperatedColumns() +
                            " FROM user WHERE uid in " +
                            "(SELECT uid FROM #member_uids)"
    };

    apixhr.multifql(queries)
          .then(function(response) {
            if (response.error_msg) {
              console.error('Error getting users:', response.error_msg);
              return;
            }
            var userInformation = response[1].fql_result_set;
            callback(userInformation);
          }, this);
  }

});

var commandSeperatedColumns = function() {
  var columns = [
    'first_name', 'middle_name', 'last_name', 'pic_square', 'uid'
  ];

  return columns.join(',');
};

exports.AjaxFriendListContactsServer = AjaxFriendListContactsServer;
});

// module: photos/app/lib/client/photo_client
// file:   ../../photos/app/lib/client/photo_client.js
define("photos/app/lib/client/photo_client", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core = require('bolt/core');
var ManagedCollectionShadow =
  require('shared/shadowbroker/shadow/managed_collection/managed_collection_shadow')
    .ManagedCollectionShadow;
var Photo = require('../model/photo/photo').Photo;

var PhotoCollectionShadow = core.createClass({
  extend: ManagedCollectionShadow,
  name: 'PhotoCollectionShadow',

  statics: {
    modelType: Photo
  }
});


var PhotoClient = core.createClass({

  _broker: null,

  construct: function(broker) {
    this._broker = broker;
  },

  fetchPhotosByAlbumId: function(albumId, updatedTime, limit) {
    return this._broker
      .callMethod('photo', 'fetchPhotosByAlbumId', albumId, updatedTime, limit)
      .then(this._fetchPhotosByAlbumIdComplete, this);
  },

  _fetchPhotosByAlbumIdComplete: function(channel) {
    var shadowCollection = new PhotoCollectionShadow();
    shadowCollection.setChannel(channel);
    return shadowCollection;
  }
});



var _instance = null;
exports.getInstance = function() {
  if (!_instance) {
    _instance = new PhotoClient(require('./broker').getInstance());
  }
  return _instance;
};

exports.PhotoClient = PhotoClient;
});

// module: shared/data2/store/schema/type/timestamp
// file:   ../../shared/js/data2/store/schema/type/timestamp.js
define("shared/data2/store/schema/type/timestamp", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var ModelBase = require('bolt/model').Model;
var TypeBase = require('./base').TypeBase;

/**
 * @classdesc TypeTimestamp converts timestamps from a resolution of seconds to
 * milliseconds. This is necessary because the API often returns second
 * resolution time, but milliseconds are easier to use when working with
 * Javascript's Date Object.
 *
 * Store timestamps as strings. Convert to/from integer on read/write.
 */
var TypeTimestamp = core.createClass({

  name: 'TypeTimestamp',

  extend: TypeBase,

  localType: 'BIGINT',

  construct: function(options) {
    TypeBase.call(this, options);

    // only convert if explictly said to
    if (!options.x1000) {
      this.transformRemoteToModel = this.transformLocalToModel;
      this.transformModelToRemote = this.transformModelToLocal;
    }
  },

  transformModelToLocal: function(time) {
    return time * 1;
  },

  transformLocalToModel: function(value) {
    return value * 1;
  },

  transformRemoteToModel: function(time) {
    return time * 1000;
  },

  transformModelToRemote: function(time) {
    return time / 1000;
  }
});
exports.TypeTimestamp = TypeTimestamp;
});

// module: view/admin_message_row/admin_message_row
// file:   view/admin_message_row/admin_message_row.js
define("view/admin_message_row/admin_message_row", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var MESSAGE_TYPES =
  require('talk/client/model/message/message_types').MESSAGE_TYPES;

var TYPES_MAP = {};
TYPES_MAP[MESSAGE_TYPES.SUBSCRIBE]   = 'subscribe';
TYPES_MAP[MESSAGE_TYPES.UNSUBSCRIBE] = 'unsubscribe';
TYPES_MAP[MESSAGE_TYPES.VIDEO_CALL]   = 'video-call';
TYPES_MAP[MESSAGE_TYPES.THREAD_IMAGE] = 'thread-image';
TYPES_MAP[MESSAGE_TYPES.THREAD_NAME]  = 'thread-name';

var AdminMessageRow = exports.AdminMessageRow = core.createClass({

  name: 'AdminMessageRow',

  extend: View,

  properties: {
    model: null
  },

  declare: function(options) {
    return {
      className: 'bt-admin-message-row',
      childViews: [
        {className: 'bt-admin-message-row--icon', ref: 'icon', owner: this},
        {className: 'bt-admin-message-row--text', ref: 'text', owner: this}
      ]
    };
  },

  setModel: function(model) {
    this.set('model', model);

    this.findRef('text').setContent(model.get('body'));
    this.findRef('icon').setClassName(
      'bt-admin-message-row--icon ' +
      'bt-admin-message-row--icon_type_' + TYPES_MAP[model.get('type')]
      );
  }
});
});

// module: bolt_touch/views/image/index
// file:   ../../../frameworks/bolt_touch/lib/views/image/index.js
define("bolt_touch/views/image/index", function(require, exports, module) {
var View = require('bolt_touch/view').View;
var imageQueue = require('bolt_touch/util/image_queue');

/**
 * @class Image
 * @classdesc An Image widget that supports delayed queued loading.
 */
exports.Image = require('bolt/core').createClass({

  name: 'Image',

  extend: View,

  properties: {
    /**
     * @property {boolean} queued If set to true, this Image view delays the
     * loading ofits src parameter by using the global ImageQueue.
     */
    queued: true
  },

  declare: function() {
    return {
      tagName: 'img'
    };
  },

  setSrc: function(url) {
    if (this.getQueued() && url) {
      this.set('src', url);
      this.setStyle({visibility: 'hidden'});
      imageQueue.add(url, this.handleQueueCallback, this);
      this.enqueued = true;
    } else {
      this.setStyle({visibility: 'inherit'});
      this.setAttributes({src: url});
    }
  },

  handleQueueCallback: function(url, width, height) {
    if (url === this.get('src')) {
      this.setStyle({visibility: 'inherit'});
      this.setAttributes({src: url});
    }
  },

  destroy: function() {
    if (this.enqueued) {
      imageQueue.remove(this.get('src'), this.handleQueueCallback, this);
    }
    View.prototype.destroy.call(this);
  }
});
});

// module: photos/app/lib/view/album_scene/index
// file:   ../../photos/app/lib/view/album_scene/index.js
define("photos/app/lib/view/album_scene/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core            = require('bolt/core');
var util            = require('bolt/util');
var Scene           = require('bolt_touch/views/scene').Scene;
var GridPhotoViewer = require('../grid_photo_viewer').GridPhotoViewer;
var photoClient     = require('../../client/photo_client').getInstance();

exports.AlbumScene = core.createClass({
  name: 'AlbumScene',

  extend: Scene,

  properties: {
    album: null
  },

  declare: function() {
    return {
      boxOrientation: 'vertical',
      childViews: [
        {
          view: GridPhotoViewer,
          ref: 'gridPhotoViewer',
          flex: 1,
          header: true,
          showTags: false
        }
      ]
    };
  },

  ready: function() {
    // Wire up events
    this.refs.gridPhotoViewer.addListener('back', this.pop, this);

    // Set the title
    this.refs.gridPhotoViewer.setTitle(this.get('album').get('name'));

    // Fetch the photos in the album
    photoClient.fetchPhotosByAlbumId(this.get('album').get('id'), null, 200)
      .addCallback(function(photos) {
        this.refs.gridPhotoViewer.setPhotos(photos);
        this.refs.gridPhotoViewer.load();
        photos.download(200);
      }, this);
  }
});
});

// module: bolt_touch/views/button_base/index
// file:   ../../../frameworks/bolt_touch/lib/views/button_base/index.js
define("bolt_touch/views/button_base/index", function(require, exports, module) {
var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var Actionable = require('../../mixins/actionable').Actionable;

var USE_DEFAULT = 'default';
var USE_CONFIRM = 'confirm';
var USE_INSET = 'inset';
var USE_SPECIAL = 'special';
var USE_NEGATIVE = 'negative';

exports.ButtonBase = core.createClass({

  name: 'ButtonBase',

  extend: View,

  mixins: [Actionable],

  statics: {
    USE_DEFAULT: USE_DEFAULT,
    USE_CONFIRM: USE_CONFIRM,
    USE_INSET: USE_INSET,
    USE_SPECIAL: USE_SPECIAL,
    USE_NEGATIVE: USE_NEGATIVE
  },

  properties: {
    // One of the constants that start with USE_ in statics.
    use: USE_DEFAULT,
    disabled: false
  },

  declare: function(options) {
    return {
      tagName: 'button',
      type: 'button'
    };
  },

  ready: function() {
    this.setMode('use', this.getUse());
  },

  setUse: function(use) {
    switch (use) {
      case USE_DEFAULT:
      case USE_CONFIRM:
      case USE_INSET:
      case USE_SPECIAL:
      case USE_NEGATIVE:
        this.set('use', use);
        break;
      default:
        throw 'Invalid use property for Button: ' + use;
    }
  },

  setDisabled: function(disabled) {
    this.set('disabled', disabled);
    this.getNode().disabled = !!disabled;
  }
});
});

// module: views/picker/camera_picker/photo_review_scene/index
// file:   ../../views/picker/camera_picker/photo_review_scene/index.js
define("views/picker/camera_picker/photo_review_scene/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core  = require('bolt/core');
var util  = require('bolt/util');
var Scene = require('bolt_touch/views/scene').Scene;

var CameraToolbar = require('photos/app/lib/view/toolbar').Toolbar;

exports.PhotoReviewScene = core.createClass({
  name: 'PhotoReviewScene',
  extend: Scene,

  properties: {
    photo: null
  },

  declare: function(options) {
    this.callback = options.callback;

    return {
      boxOrientation: 'vertical',

      childViews: [
        {
          ref: 'photoPreview',
          className: 'photo-preview',
          flex: 1
        },
        {
          view: CameraToolbar,

          childViews: [
            {
              content: 'Retake',
              additionalClasses: 'button left',
              onclick: 'pop'
            },
            { flex: 1 },
            {
              content: 'Attach',
              additionalClasses: 'button right',
              onclick: 'attach'
            }
          ]
        }
      ]
    };
  },

  ready: function() {
    this.photoPreview = this.findRef('photoPreview');
    this.photoPreview.setStyle('backgroundImage', 'url(' + this.getPhoto().picture + ')');
  },

  attach: function() {
    this.callback([this.getPhoto()]);
  }
});
});

// module: mock/media_storage_api
// file:   ../../mock/js/media_storage_api.js
define("mock/media_storage_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;

module.exports = {
  _timeout: 1000,
  _stored: {},

  isStored: function(key) {
    var _this = this;

    return _this._stored[key];
  },

  getStoredURL: function(key) {
    if (this._stored[key]) {
      return '';
    } else {
      return null;
    }
  },

  storeURL: function(key, url, wifi, cookie, priority) {
    var _this = this;

    _this._stored[key] = true;
    setTimeout(
      function() {
        EventManager.broadcastEvent('storage.STARTED', {'key': key});
        EventManager.broadcastEvent(
          'storage.COMPLETE',
          {'key': key, 'metadata': ''}
        );
      },
      _this._timeout);
  },

  storeURLMulti: function(keys, urls, wifis, cookies, priorities) {
    var _this = this;

    var length = keys.length;
    for (var i = 0; i < length; i++) {
      this.storeURL(keys[i], urls[i], wifis[i], cookies[i], priorities[i]);
    }
  },

  removeStored: function(key) {
    var _this = this;

    _this._stored[key] = false;
  },

  removeStoredMulti: function(keys) {
    var _this = this;

    for (key in keys) {
      _this._stored[key] = false;
    }
  },

  removeStoredByFilepath: function(path) {
    return true;
  }
};
});

// module: photos/app/lib/view/thumbnail/index
// file:   ../../photos/app/lib/view/thumbnail/index.js
define("photos/app/lib/view/thumbnail/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core       = require('bolt/core');
var View       = require('bolt_touch/view').View;
var ImageQueue = require('bolt_touch/util/image_queue');
var Actionable = require('bolt_touch/mixins/actionable').Actionable;

var Thumbnail = exports.Thumbnail = core.createClass({
  name: 'Thumbnail',

  extend: View,

  mixins: [Actionable],

  properties: {
    model: null
  },

  doAction: function() {
    this.invoke('thumbnailTouched', {
      view: this,
      photo: this.get('model')
    });
  },

  setModel: function(model) {
    this.set('model', model);

    this.setStyle({
      backgroundImage: null
    });

    if (model) {
      ImageQueue.add(
        model.get('thumbnail_url'),
        this.onImageLoad,
        this
      );
    }
  },

  onImageLoad: function(src, width, height) {
    if (this.get('model') && src == this.get('model').get('thumbnail_url')) {
      this.setStyle({
        backgroundImage: 'url(' + src + ')'
      });

      if (this.getModel().get('cacheState') !== 'full') {
        this.getModel().set('cacheState', 'thumbnail');
      }
    }
  },

  getPhotoRect: function() {
    return this.getRect();
  },

  showPhoto: function() {
    this.removeClass('hidden');
  },

  hidePhoto: function() {
    this.addClass('hidden');
  }
});
});

// module: bolt/compat/event
// file:   ../../../frameworks/bolt/lib/compat/event.js
define("bolt/compat/event", function(require, exports, module) {

var defineProperty = require('../util').defineProperty;

var EVENT_KEYS = {
  type: true,
  data: true,
  isBoltEvent: true,
  defaultPrevented: true,
  preventDefault: true,
  propagationStopped: true,
  stopPropagation: true,
  getTargetView: true,
  getRawEvent: true,
  isDefaultPrevented: true,
  isPropagationStopped: true
};

var descriptor = {
  configurable: true,
  enumerable: true
};

function makeGetter(key) {
  return function() {
    console.error('You\'re attempting to get ' + key + ' from an event ' +
      'object. Please get this from the event.data property instead');

    return this.data[key];
  };
}

function makeSetter(key) {
  return function(value) {
    console.error('You\'re attempting to set ' + key + ' on an event ' +
      'object. Please set this on the event.data property instead');

    return this.data[key] = value;
  };
}

var EventShim = function(type, data) {
  this.type = type;
  this.data = data;

  this.propagationStopped = false;
  this.stopPropagation = function() {
    this.propagationStopped = true;
  }

  if (typeof data === 'object') {
    var key;
    for (key in data) {
      if (EVENT_KEYS[key]) { continue; }

      descriptor.get = makeGetter(key);
      descriptor.set = makeSetter(key);
      defineProperty(this, key, descriptor);
      descriptor.get = null;
    }
  }
};

exports.EventShim = EventShim;
});

// module: talk/client/model/thread/thread_contacts_util
// file:   ../client/model/thread/thread_contacts_util.js
define("talk/client/model/thread/thread_contacts_util", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var sharedUtil   = require('shared/util');

exports.getThreadPhoneNumbers = function(thread) {

  var i, j;

  var contacts = require('./contacts');
  var Collection = require('bolt/collection').Collection;
  var participants =
    thread.getRelevantParticipants().map(contacts.buildInfoIdent);
  var relatedUsers = new Collection();

  return contacts.fetchContacts(participants, relatedUsers).then(function() {
    var allPhonesTemp = [];
    for (i = 0; i < relatedUsers.length; i++) {
      var phones = relatedUsers.at(i).get('phoneNumbers');
      for (j = 0; j < phones.length; j++) {
        allPhonesTemp.push({
          'name' : relatedUsers.at(i).getName(),
          'phone' : phones[j].number
        });
      }
    }

    var allPhones = [];
    var flag = 0;
    for (i = 0; i < allPhonesTemp.length; i++) {
      // thread participant number may be dialable string, which isn't always
      // a valid phone number
      allPhonesTemp[i].phone =
        sharedUtil.getCanonicalPhoneNumber(allPhonesTemp[i].phone);
      flag = 1;
      for (j = 0; j < allPhones.length; j++) {
        if (allPhones[j].phone === allPhonesTemp[i].phone) {
          flag = 0;
          break;
        }
      }
      if (flag == 1) {
        allPhones.push(allPhonesTemp[i]);
      }
    }
    return allPhones;
  });
};
});

// module: talk/client/send_message_client
// file:   ../client/send_message_client.js
define("talk/client/send_message_client", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core = require('bolt/core');
var util = require('bolt/util');

var SendMessageClient = core.createClass({

  name: 'SendMessageClient',

  _broker: null,

  construct: function(broker) {
    this._broker = broker;
  },

  shouldSplitGroup: function(idents) {
    return this._broker
      .callMethod(
        'send_message',
        'shouldSplitGroup',
        idents);
  },

  sendToThread: function(thread, messageData) {
    return this._broker
      .callMethod(
        'send_message',
        'sendToThread',
        thread.getId(),
        messageData);
  },

  resolveThread: function(recipientsIdents, messageData) {
    return this._broker
      .callMethod(
        'send_message',
        'resolveThread',
        recipientsIdents,
        messageData)
      .then(this._resolveThreadComplete, this);
  },

  deleteMessages: function(ids) {
    return this._broker.callMethod('send_message', 'deleteMessages', ids);
  },

  _resolveThreadComplete: function(thread) {
    var ClientThread = require('./model/thread/client_thread').ClientThread;
    return thread && new ClientThread(thread);
  }
});



var _instance = null;
exports.getInstance = function() {
  if (!_instance) {
    _instance = new SendMessageClient(require('./broker').getInstance());
  }
  return _instance;
};

exports.SendMessageClient = SendMessageClient;
});

// module: view/status_bar/status_bar
// file:   view/status_bar/status_bar.js
define("view/status_bar/status_bar", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var View = require('bolt_touch/view').View;

var StatusBar = core.createClass({
  name: 'StatusBar',
  extend: View,

  declare: function() {
    return { className: 'talkStatusBar', style: 'display: none' };
  },

  setVisible: function(state) {
    state = !!state;
    if (this.getVisible() != state) {
      this.toggleClass('talkStatusBar_visible', state);
    }
    return this;
  },

  getVisible: function() {
    return this.hasClass('talkStatusBar_visible');
  },

  addMessage: function(text) {
    var message = new View({
      content: text,
      className: 'talkStatusBar-message'
    });
    this.appendChild(message);
    setTimeout(util.bind(this.setVisible, this, true), 1);
    setTimeout(util.bind(this.removeMessage, this, message), 30000);
    return message;
  },

  removeMessage: function(message) {
    if (this.getChildViews().length == 1) {
      this.setVisible(false);
    }
    message
      .addClass('talkStatusBar-message_hiding')
      .addListener('webkitTransitionEnd', function() {
        this.removeChild(message);
      }, this);
  }

});


exports.StatusBar = StatusBar;

var _instance = null;
exports.getInstance = function() {
  if (!_instance) {
    _instance = new StatusBar();
    _instance.placeIn(document.body);
  }
  return _instance;
};
});

// module: shared/data/key_value_mixin
// file:   ../../shared/js/data/key_value_mixin.js
define("shared/data/key_value_mixin", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var util           = require('bolt/util');
var SqlTransaction = require('shared/data/sql_transaction').SqlTransaction;
var KeyValueStore  = require('shared/data/key_value_store').KeyValueStore;

/**
 * This is a mixin for classes that inherit from StoreBase. It provides
 * default functionality to store things using KeyValueStore. This mixin will
 * automatically add this store's storesName to the 'source' column in
 * KeyValueStore, and clearStore in StoreBase will call this.clearKeyValuePairs,
 * which clears all the pairs that have been stored by this store.
 */
exports.KeyValueMixin = {
  // if we mix into a store we should init KeyValueStore for any transaction
  createTransaction: function() {
    var deferred = KeyValueStore.init().then(this.init, this);
    return new SqlTransaction(deferred);
  },

  clearKeyValuePairs: function(tx) {
    return KeyValueStore.deleteItemsWithTransaction(
      tx, {source: this.getName()});
  },

  updateOrCreateKeyValue: function(key, value) {
    params = {
      key: key,
      value: value,
      source: this.getName()
    };
    return KeyValueStore.updateOrCreateItem(params);
  },

  getKeyValue: function(key) {
    return KeyValueStore.getItem({key: key}).then(this._parseKeyValue);
  },

  _parseKeyValue: function(obj) {
    if (obj) {
      return obj.value;
    } else {
      return null;
    }
  }
};
});

// module: shared/data2/local/init
// file:   ../../shared/js/data2/local/init.js
define("shared/data2/local/init", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*global openDatabase */

var versioned_db = require('./versioned_db');

// default database properties
var NAME = 'firefly';
var DESCRIPTION = 'Main Firefly database';
var ESTIMATED_SIZE = 20 * 1024 * 1024;

if (this.__ACCEPTANCE_TEST__) {
  NAME = 'firefly_mock';
  DESCRIPTION = 'Firefly acceptance test database';
}

/**
 * Initializes the native database.  Ensures that the version and schema are
 * correct.
 *
 * Can pass in a reset option to reset the database before initializing.  It's
 * important to run the reset here because doing 2 changeVersion operations at
 * the same time causes problems, as a failed changeVersion screws up the
 * Database object so we can't read from it.
 */
function initDatabase(nativeDb) {
  if (nativeDb.version === '') {
    nativeDb.changeVersion('', '1.0', function(t) {
      versioned_db.init(t);
    }, function(err) {
      console.error('error initializing database: ' + err.message);
    });
  }
  return new versioned_db.VersionedDatabase(nativeDb);
}

var database;
/**
 * Gets the default database instance.  The instance will be initialized using
 * initDatabase.
 */
function getDatabase() {
  if (!database) {
    var nativeDb = openDatabase(NAME, '', DESCRIPTION, ESTIMATED_SIZE);
    database = initDatabase(nativeDb);
  }
  return database;
}

exports.initDatabase = initDatabase;
exports.getDatabase = getDatabase;
});

// module: view/messages_scene/messages_scene_menu/index
// file:   view/messages_scene/messages_scene_menu/index.js
define("view/messages_scene/messages_scene_menu/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core   = require('bolt/core');
var util = require('bolt/util');
var View = require('bolt_touch/view').View;
var ActionableView = require('bolt_touch/views/actionable_view').ActionableView;

var baseClass = 'bt-messages-scene-menu--';

/* @classdesc
 * MessagesSceneMenu is the view for the menu that slides up in MessagesSceene.
 * It includes 3 tabs and actions: info, call, and timeline
*/
exports.MessagesSceneMenu = core.createClass({
  name: 'MessagesSceneMenu',
  extend: View,

  properties: {
  },

  declare: function(options) {
    return {
      childViews: [
        {
          view: ActionableView,
          className: baseClass + 'info',
          action: '_onInfo',
          content: "Info"
        },
        {
          view: ActionableView,
          className: baseClass + 'call',
          action: '_onCall',
          content: "Call"
        },
        {
          view: ActionableView,
          owner: this,
          className: baseClass + 'timeline',
          action: '_onTimeline',
          content: "Timeline"
        }
      ]
    };
  },

  /* Toggle the position of the menu. Slide up or slide back down */
  toggle: function() {
    this.toggleClass("show");
  },

  _onInfo: function() {
    this.invoke('selectinfo');
  },

  _onCall: function() {
    this.invoke('selectcall');
  },

  _onTimeline: function() {
    this.invoke('selecttimeline');
  }

});
});

// module: talk/client/thread_changes_client
// file:   ../client/thread_changes_client.js
define("talk/client/thread_changes_client", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core = require('bolt/core');
var util = require('bolt/util');

var ThreadChangesClient = core.createClass({

  name: 'ThreadChangesClient',

  _broker: null,

  construct: function(broker) {
    this._broker = broker;
  },

  markAsRead: function(threadId, state) {
    return this._broker
      .callMethod('thread_changes', 'markAsRead', threadId, state);
  },

  markAsSpam: function(threadId, state) {
    return this._broker
      .callMethod('thread_changes', 'markAsSpam', threadId, state);
  },

  markAsArchived: function(threadId, state) {
    return this._broker
      .callMethod('thread_changes', 'markAsArchived', threadId, state);
  },

  addParticipants: function(threadId, recipients) {
    return this._broker
      .callMethod('thread_changes', 'addParticipants', threadId, recipients);
  },

  leave: function(threadId) {
    return this._broker.callMethod('thread_changes', 'leave', threadId);
  },

  uploadChanges: function(threadId) {
    return this._broker.callMethod('thread_changes', 'uploadChanges', threadId);
  },

  uploadAllChanges: function() {
    return this._broker.callMethod('thread_changes', 'uploadAllChanges');
  }
});



var _instance = null;
exports.getInstance = function() {
  if (!_instance) {
    _instance = new ThreadChangesClient(require('./broker').getInstance());
  }
  return _instance;
};

exports.ThreadChangesClient = ThreadChangesClient;
});

// module: contacts/browse_contacts_section/facebook_users_contacts_list
// file:   contacts/browse_contacts_section/facebook_users_contacts_list.js
define("contacts/browse_contacts_section/facebook_users_contacts_list", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

//The following are not actually global, but local, defined underneath
//for readability

/*global buildContactFromData: true */

var core = require('bolt/core');
var ContactBuilder = require('../contact').ContactBuilder;

var FacebookUsersContactsList = core.createClass({
  name: 'FacebookUsersContactsList',

  construct: function(groupServer, friendListServer) {
    this.groupServer = groupServer;
    this.friendListServer = friendListServer;
  },

  withGid: function(gid, callback) {
    this.groupServer.fetchContacts(gid, function(contactsData) {
      callback(contactsData.map(buildContactFromData));
    });
  },

  withFlid: function(flid, callback) {
    this.friendListServer.fetchContacts(flid, function(contactsData) {
      callback(contactsData.map(buildContactFromData));
    });
  }
});

var buildContactFromData = function(contactData) {
  if (contactData.name) {
    return new ContactBuilder()
              .withName(contactData.name)
              .withProfileUrl(contactData.pic_square)
              .withFacebookId(contactData.uid)
              .build();
  }
  return new ContactBuilder()
             .withFirstName(contactData.first_name)
             .withLastName(contactData.last_name)
             .withProfileUrl(contactData.pic_square)
             .withFacebookId(contactData.uid)
             .build();
};

exports.FacebookUsersContactsList = FacebookUsersContactsList;
});

// module: bolt_touch/views/background_image/index
// file:   ../../../frameworks/bolt_touch/lib/views/background_image/index.js
define("bolt_touch/views/background_image/index", function(require, exports, module) {
var View = require('bolt_touch/view').View;
var imageQueue = require('bolt_touch/util/image_queue');

/**
 * @class BackgroundImage
 * @classdesc BackgroundImage has all the utility of Image but also provides the
 * style options a div with a backgroundImage.
 */
exports.BackgroundImage = require('bolt/core').createClass({

  name: 'BackgroundImage',

  extend: View,

  properties: {
    /**
     * @property {string} src - the location of the image file
     */
    src: null,
    /**
     * @property {boolean} queued If set to true, this Image view delays the
     * loading ofits src parameter by using the global ImageQueue.
     */
    queued: true,

    imageHeight: 0,

    imageWidth: 0
  },

  setSrc: function(url) {
    this.set('src', url);
    if (this.getQueued() && url) {
      this.setStyle({backgroundImage: null});
      imageQueue.add(url, this.handleQueueCallback, this);
      this._enqueued = true;
    } else {
      this.setStyle({backgroundImage: 'url(' + url + ')'});
    }
  },

  handleQueueCallback: function(url, width, height) {
    this._enqueued = false;
    if (url === this.getSrc()) {
      this.setStyle({backgroundImage: 'url(' + url + ')'});
      this.setImageWidth(width);
      this.setImageHeight(height);

      this.invoke('load', url);
    }
  },

  destroy: function() {
    if (this._enqueued) {
      imageQueue.remove(this.getSrc(), this.handleQueueCallback, this);
    }
    View.prototype.destroy.call(this);
  }
});

});

// module: photos/app/lib/view/video_player_scene/index
// file:   ../../photos/app/lib/view/video_player_scene/index.js
define("photos/app/lib/view/video_player_scene/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core  = require('bolt/core');
var util  = require('bolt/util');
var Scene = require('bolt_touch/views/scene').Scene;

exports.VideoPlayerScene = core.createClass({
  name: 'VideoPlayerScene',
  extend: Scene,

  properties: {
    video: null
  },

  declare: function(options) {
    return {
      boxOrientation: 'vertical',
      flex: 1,

      childViews: [
        {
          boxOrientation: 'horizontal',
          additionalClasses: 'bt-bar',
          childViews: [
            {
              additionalClasses: 'bt-bar-button bt-down-button left',
              onclick: 'pop'
            },
            {
              ref: 'title',
              additionalClasses: 'bt-bar-title',
              flex: 1
            },
            {
              additionalClasses: 'bt-bar-button right' // empty
            }
          ]
        },
        {
          // TODO: make generic video player
          ref: 'video',
          flex: 1,
          tagName: 'video',
          className: 'video'
        }
      ]
    };
  },

  ready: function() {
    this.video = this.findRef('video');
    this.videoNode = this.video.getNode();
    this.videoNode.width = 540;
    this.videoNode.height = 540;
    this.videoNode.controls = 'controls';
    this.videoNode.autoplay = 'autoplay';
    this.videoNode.src = this.getVideo().get('source');

    this.findRef('title').setContent(this.getVideo().getDisplayName());
  }
});
});

// module: mock/info_api
// file:   ../../mock/js/info_api.js
define("mock/info_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

module.exports = {
  RESTART_REASON_BOOT_BASE: 0x77665500,
  RESTART_REASON_BOOTLOADER: 0x77665500,
  RESTART_REASON_REBOOT: 0x77665501,
  RESTART_REASON_RECOVERY: 0x77665502,
  RESTART_REASON_HTCBL: 0x77665503,
  RESTART_REASON_OFFMODE: 0x77665504,
  RESTART_REASON_RAMDUMP: 0x776655AA,
  RESTART_REASON_HARDWARE: 0x776655A0,
  RESTART_REASON_POWEROFF: 0x776655BB,
  RESTART_REASON_ERASE_FLASH: 0x776655EF,

  autoupdate: true,

  getModelNumber: function() {
    return "Enterprise";
  },

  getBuildNumber: function() {
    return "blue-eng 2.3.4 fbdevel-slayer_evt-eng 47 fbdevel test-keys GEP0920";
  },

  getBuildType: function() {
    return "eng";
  },

  getBuildVersion: function() {
    return "2.3.4";
  },

  getUptime: function() {
    return 2452138;
  },

  getWebviewUptime: function() {
    return 36939;
  },

  getDeviceId: function() {
    return "004999010640000";
  },

  getBuffyMemStats: function() {
    return "\"{availSysMem:77148160,totalProcessMem:334136}\"";
  },

  getRebootReason: function() {
    return 0x77665500;
  },

  getBuildTime: function() {
    return 1333095136000;
  },

  isInRecoveryMode: function() {
    return false;
  },

  getSerialNumber: function() {
    return 'HT1232311';
  },

  getAssetsVersion: function() {
    return "2.3.44524";
  },

  getAutoUpdate: function() {
    return this.autoupdate;
  },

  toggleAutoUpdate: function() {
    this.autoupdate = !this.autoupdate;
    return true;
  }
};
});

// module: contacts/create_new_contact_section
// file:   contacts/create_new_contact_section.js
define("contacts/create_new_contact_section", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var NewContactCreator = require('./shared/new_contact_creator').NewContactCreator;
var CreateNewContactScene =
  require('./create_new_contact_section/ui/create_new_contact_scene').CreateNewContactScene;
var Announcer = require('./util/announcer').Announcer;

/*
 * CreateNewContact is the section of the application that is responsible for
 * the creating of new contacts. The following events come out of the create
 * new contact section:
 *
 * cancel: no parameters
 * contactSuccessfullyCreated: contact that was created
 */

var CreateNewContactSection = function(contactCreator) {
  this._contactCreator = contactCreator;

  var announcer = this._announcer = new Announcer();
  this._externalEventsProxy = {
    cancelCreateContact: function() {
      announcer.announce('cancel');
    },

    contactSuccessfullyCreated: function(contact) {
      announcer.announce('contactSuccessfullyCreated', contact);
    }
  };
  this._contactCreator.addEventListener(this._externalEventsProxy);
};

CreateNewContactSection.prototype = {
  getScene: function(snapshot) {
    this._scene = new CreateNewContactScene({contactInformation: snapshot});
    this._scene.addEventListener(this._contactCreator);
    this._scene.addEventListener(this._externalEventsProxy);
    this._scene.setContact(snapshot);
    return this._scene;
  },

  addListener: function(listener) {
    this._announcer.addListener(listener);
  }
};

exports.CreateNewContactSection = CreateNewContactSection;
});

// module: ufi/model/like_collection_shadow
// file:   ../../ufi/model/like_collection_shadow.js
define("ufi/model/like_collection_shadow", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var ManagedCollectionShadow =
  require('shared/shadowbroker/shadow/managed_collection/managed_collection_shadow')
    .ManagedCollectionShadow;
var LikeModel = require('shared/data2/model/like/model').LikeModel;

/**
 * @classdesc LikeCollectionShadow is the shadow collection for likes
 * on a story or other object. It communicates with LikeCollectionUpdater
 * to apply functions to LikeCollection and receives and reflects the updates
 * for LikeCollection.
 */
var LikeCollectionShadow = core.createClass({
  extend: ManagedCollectionShadow,

  name: 'LikeCollectionShadow',

  statics: {
    modelType: LikeModel
  },

  properties: {
    /**
     * @property {Model} target the target of these likes
     */
    target: null
  },

  download: function(limit) {
    return ManagedCollectionShadow.prototype.download.apply(this, arguments)
      .addCallback(this._afterDownload, this);
  },

  // Because the like data that we fetch may contain more up to date
  // information on the number of likes, we have this callback to
  // update the model with the new like count.
  _afterDownload: function() {
    var target = this.getTarget();
    var targetLikes = target.get('likes');
    var length = this.length;
    if (length > targetLikes.count) {
      target.set('likes', {
        can_like: targetLikes.can_like,
        count: length
      });
      target.storeModel();
    }
  }
});

exports.LikeCollectionShadow = LikeCollectionShadow;
});

// module: contacts/client/domain_client
// file:   contacts/client/domain_client.js
define("contacts/client/domain_client", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var Announcer = require('../util/announcer').Announcer;

/* The shared worker contacts domain proxies all commands to a contacts domain
 * that is inside of a shared worker. It also announces all events that come
 * from that contacts domain object */

var ContactsDomainClient = function(broker) {
  this._broker = broker;
  this._announcer = new Announcer();
  broker.registerController('contactsDomain', this);
};

ContactsDomainClient.prototype = {
  createContact: function(snapshot) {
    this._sendMessage('createContact', snapshot);
  },

  updateContact: function(snapshot) {
    this._sendMessage('updateContact', snapshot);
  },

  deleteContact: function(snapshot) {
    this._sendMessage('deleteContact', snapshot);
  },

  _sendMessage: function(message, data) {
    this._broker.sendMessage('contactsDomain', message, data);
  },

  addEventListener: function(listener) {
    this._announcer.addListener(listener);
  },

  /* This section should get rid of using the announcer once we change the
     listeners */
  contactSuccessfullyDeletedReceived: function(snapshot) {
    this._announcer.announce('contactSuccessfullyDeleted', snapshot);
  },

  contactSuccessfullyCreatedReceived: function(snapshot) {
    this._announcer.announce('contactSuccessfullyCreated', snapshot);
  },

  contactSuccessfullyUpdatedReceived: function(snapshot) {
    this._announcer.announce('contactSuccessfullyUpdated', snapshot);
  }
};

exports.ContactsDomainClient = ContactsDomainClient;
});

// module: mock/power_api
// file:   ../../mock/js/power_api.js
define("mock/power_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;

module.exports = {
  _batteryLevel: 50,
  _batteryStatus: 0,
  _batterySource: 0, // Running on battery power

  BATTERY_LEVEL_UNKNOWN: -1,

  BATTERY_STATUS_UNKNOWN: 1,
  BATTERY_STATUS_CHARGING: 2,
  BATTERY_STATUS_DISCHARGING: 3,
  BATTERY_STATUS_NOT_CHARGING: 4,
  BATTERY_STATUS_FULL: 5,

  getBatteryLevel: function() {
    return this._batteryLevel;
  },

  // Exists only in mock
  _setBatteryLevel: function(level) {
    this._batteryLevel = level;
    this._fireStateChangeEvent();
  },

  getBatteryStatus: function() {
    return this._batteryStatus;
  },

  // Exists only in mock
  _setBatteryStatus: function(status) {
    // status should be one of BatteryManager.BATTERY_STATUS_*
    this._batteryStatus = status;
    this._fireStateChangeEvent();
  },

  getPowerSource: function() {
    return this._batterySource;
  },

  // Exists only in mock
  _setPowerSource: function(source) {
    // status should be one of BatteryManager.BATTERY_PLUGGED_*
    // or 0 for battery power
    this._batterySource = source;
    this._fireStateChangeEvent();
  },

  powerOff: function() {
    location.reload();
  },

  reboot: function() {
    location.reload();
  },

  // Exists only in mock
  _fireStateChangeEvent: function() {
    EventManager.broadcastEvent('battery.STATE_CHANGED', {
      percent: this.getBatteryLevel(),
      status: this.getBatteryStatus(),
      source: this.getPowerSource()
    });
  }
};
});

// module: shared/model/mailbox
// file:   ../../shared/js/model/mailbox.js
define("shared/model/mailbox", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*global _getFilterFunction:false*/

exports.Mailbox = {
  INBOX: 'inbox',
  OTHER: 'other',
  ARCHIVED_INBOX: 'archived_inbox',
  ARCHIVED_OTHER: 'archived_other',
  SPAM: 'spam',

  MAILBOXES: {
    inbox: {
      title: 'Messages',
      visible: true,
      folder: 'inbox',
      archived: false,
      filter: _getFilterFunction('inbox', false),
      key: 'inbox'
    },
    other: {
      title: 'Other',
      visible: true,
      folder: 'other',
      archived: false,
      filter: _getFilterFunction('other', false),
      key: 'other'
    },
    archived_inbox: {
      title: 'Archived Messages',
      visible: true,
      folder: 'inbox',
      archived: true,
      filter: _getFilterFunction('inbox', true),
      key: 'archived_inbox'
    },
    archived_other: {
      title: 'Archived Other',
      visible: true,
      folder: 'other',
      archived: true,
      filter: _getFilterFunction('other', true),
      key: 'archived_other'
    },
    // TODO (toddkrabach): what happens to the threads when they are marked as
    // spam on the server?  for now, just change the folder so it doesn't show
    // up anymore
    spam: {
      title: 'Spam',
      visible: false,
      folder: 'spam',
      archived: false,
      filter: function() {
        return false;
      },
      key: 'spam'
    }
  }
};

function _getFilterFunction(folder, archived) {
  return function(model) {
    return (
      model.get('folder') === folder &&
      model.get('archived') === archived
    );
  };
}
});

// module: bolt_touch/util/eventually
// file:   ../../../frameworks/bolt_touch/lib/util/eventually.js
define("bolt_touch/util/eventually", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var id = 1;
var bound = {};
var queue = [];
var MARKER = '_uid';

function identify(callback, context) {
  callback[MARKER] = callback[MARKER] || id++;
  var key = [callback[MARKER]];
  if (context) {
    context[MARKER] = context[MARKER] || id++;
    key.push(context[MARKER]);
  }
  return key.join('_');
}

function runCallbacks() {
  var currentQueue = queue;
  queue = [];
  bound = {};
  currentQueue.forEach(function(pair) {
    pair[0].call(pair[1]);
  });
}

/**
 * Runs callback after current 'execution chunk' is finished. Callback will
 * run only once regardless the number of eventually() calls during the
 * 'execution chunk'
 *
 * 'execution chunk' = consitent uninterupted execution of js by browser,
 * usualy browser event handler or script load.
 *
 * Consider this example:
 *
 *   var CustomLayout = core.createClass({
 *     appendChild: function() {
 *       ...
 *       eventually(this.relayout, this);
 *     },
 *
 *     relayout: function() {
 *       ... some heavy dom lifting
 *     }
 *   });
 *
 *   var layout = new CustomLayout();
 *   for (var i = 0; i < 100; i++) {
 *     layout.appendChild(new View());
 *   }
 *
 * eventually() guaranties that relayout will be called only once after all
 * appendChild() in calls are done.
 */
exports.eventually = function(callback, context) {
  var key = identify(callback, context);
  if (bound[key]) {
    return;
  }
  bound[key] = true;

  if (!queue.length) {
    setTimeout(runCallbacks, 1);
  }
  queue.push([callback, context]);
};
});

// module: shared/data2/store/memory_cache
// file:   ../../shared/js/data2/store/memory_cache.js
define("shared/data2/store/memory_cache", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');

/**
 * MemoryCache tracks activley used models with simple reference counting.
 * It guaranties that at any place in time there's only one instance of a model
 * with a given id exists => reduced memory, easier change management
 *
 * @example
 *    function getModelFromDB(id, callback) {
 *      if (memoryCache.getCached(id)) {
 *        // model is allready in use, return used instance
 *        callback(memoryCache.getCached(id));
 *      } else {
 *        // web sql stuff here
 *          callback(fetchedModel);
 *        //
 *      }
 *    }
 *
 *    getModelFromDB(1, function(model) {
 *      memoryCache.hold(model);
 *      setTimeout(function() {
 *        ... do stuff with model
 *        // if I'm the only user, model will be destroyed here
 *        memoryCache.release(model);
 *      })
 *    });
 */
exports.MemoryCache = core.createClass({
  name: 'MemoryCache',

  construct: function() {
    this._counts = {};
    this._models = {};
  },

  get: function(id) {
    return this._models[id];
  },

  hold: function(model) {
    var id = model.getId();
    if (this._counts[id]) {
      this._counts[id]++;
    } else {
      this._counts[id] = 1;
      this._models[id] = model;
    }
  },

  release: function(model) {
    var id = model.getId();
    this._counts[id]--;
    if (0 === this._counts[id]) {
      if (this._models[id].destroy) {
        this._models[id].destroy();
      }
      delete this._models[id];
      delete this._counts[id];
    }
  }
});
});

// module: views/picker/camera_picker/camera_picker_controller
// file:   ../../views/picker/camera_picker/camera_picker_controller.js
define("views/picker/camera_picker/camera_picker_controller", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core  = require('bolt/core');
var util  = require('bolt/util');
var Model = require('bolt/model').Model;

var EventManager     = require('shared/event_manager').EventManager;
var Photo            = require('photos/app/lib/model/photo/photo').Photo;
var photoStore       = require('photos/app/lib/model/photo/photo_store').getInstance();
var PickerController = require('../common/picker_controller').PickerController;
var ViewfinderScene  = require('./viewfinder_scene').ViewfinderScene;
var uploadAPI        = FBAPI.use('uploadmanager');

// CameraPickerController launches the camera, handles the camera
// result and pass that back to the app that has launched the
// picker.
exports.CameraPickerController = core.createClass({
  name: 'CameraPickerController',
  extend: PickerController,

  construct: function(options) {
    options.startScene = ViewfinderScene;
    PickerController.prototype.construct.call(this, options);
  },

  _onPickerDone: function(photos) {
    if (!photos) {
      this.callback(null);
      return;
    }

    var photoIds = [];
    util.forEach(photos, function(photo) {
      var photoId = Photo.addPhoto(
        photo.picture_path, photo.picture, photo.thumb_path, photo.thumb);
      photoIds.push(photoId);
    });

    photoStore.fetchPhotosByIds(photoIds)
      .addCallback(function(photos) {
        this.callback(photos.toArray());
      }, this)
      .addErrback(function() {
        console.log('failed to fetch photos by ids', photoIds);
        this.callback(null);
      });
  }
});
});

// module: talk/client/message_client
// file:   ../client/message_client.js
define("talk/client/message_client", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core = require('bolt/core');
var ManagedCollectionShadow =
  require('shared/shadowbroker/shadow/managed_collection/managed_collection_shadow')
    .ManagedCollectionShadow;
var ClientMessage =
  require('talk/client/model/message/client_message').ClientMessage;

var MessageCollectionShadow = core.createClass({
  extend: ManagedCollectionShadow,
  name: 'MessageCollectionShadow',

  statics: {
    modelType: ClientMessage
  }
});


var MessageClient = core.createClass({

  name: 'MessageClient',

  _broker: null,

  construct: function(broker) {
    this._broker = broker;
  },

  fetchLastMessages: function(threadId, limit) {
    return this._broker
      .callMethod('message', 'fetchLastMessages', threadId, limit)
      .then(this._fetchLastMessagesComplete, this);
  },

  refreshThreadHead: function(threadId, limit) {
    return this._broker
      .callMethod('message', 'refreshThreadHead', threadId, limit);
  },

  remove: function(ids) {
    return this._broker.callMethod('message', 'remove', ids);
  },

  update: function(messageId, data) {
    return this._broker.callMethod('message', 'update', messageId, data);
  },

  _fetchLastMessagesComplete: function(channel) {
    var shadowCollection = new MessageCollectionShadow();
    shadowCollection.setChannel(channel);
    return shadowCollection;
  }
});



var _instance = null;
exports.getInstance = function() {
  if (!_instance) {
    _instance = new MessageClient(require('./broker').getInstance());
  }
  return _instance;
};

exports.MessageClient = MessageClient;
});

// module: views/multiavatar
// file:   ../../views/multiavatar.js
define("views/multiavatar", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var View          = require('bolt_touch/view').View;
var core          = require('bolt/core');
var imageQueue    = require('bolt_touch/util/image_queue');

var MultiAvatar = exports.MultiAvatar = core.createClass({
  name: 'MultiAvatar',

  extend: View,

  declare: function() {
    return {
      additionalClasses: 'bt-avatar-wrapper',
      childViews: [
        {additionalClasses: 'bt-avatar', ref: 'avatar1', owner: this},
        {additionalClasses: 'bt-avatar', ref: 'avatar2', owner: this}
      ]
    };
  },

  ready: function() {
  },

  getAvatarRefs: function() {
    var avatars = [this.findRef('avatar1'), this.findRef('avatar2')];

    return (this.getAvatarRefs = function() {
      return avatars;
    })();
  },

  setParticipants: function(participants) {
    var avatars = this.getAvatarRefs();
    for (var i = 0; i < 2; i++) {
      var p = participants[i];
      var avatar = avatars[i];
      if (p) {
        var url = p.avatarUrl;
        avatar.url = url;
        avatar.getNode().style.backgroundImage = '';
        imageQueue.add(url, function(url) {
          if (url !== this.url) return;
          this.getNode().style.backgroundImage = 'url(' + url + ')';
        }, avatar);
        avatar.show();
      } else {
        avatar.hide();
      }
    }
  },

  setImageWithDataURI: function(dataURI) {
    var avatars = this.getAvatarRefs();
    avatars[0].setStyle('backgroundImage', 'url(' + dataURI + ')');
    avatars[0].show();
    for (var i = 1; i < avatars.length; i++) {
      avatars[i].hide();
    }
  }
});
});

// module: views/contacts_table/contacts_table
// file:   ../../views/contacts_table/contacts_table.js
define("views/contacts_table/contacts_table", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core                   = require('bolt/core');
var View                   = require('bolt_touch/view').View;
var SearchContactsTable =
  require('views/contacts_table/search_contacts_table').SearchContactsTable;
var ScrollContactsTable =
  require('views/contacts_table/scroll_contacts_table').ScrollContactsTable;

var ContactsTable = exports.ContactsTable = core.createClass({
  name: 'ContactsTable',
  extend: View,

  properties: {
    filter: null
  },

  declare: function(options) {
    return {
      childViews: [
        {
          view: 'ScrollContactsTable',
          ref: 'scrollTable'
        },
        {
          view: 'SearchContactsTable',
          ref: 'searchTable'
        }
      ]
    };
  },

  ready: function() {
    if (!this.getFilter()) {
      // Make sure views are appropriately visible/hidden
      this.resetFilter();
    }
  },

  setFilterFunction: function(filter) {
    this.refs.searchTable.setFilterFunction(filter);
    this.refs.scrollTable.setFilterFunction(filter);
  },

  setFilter: function(filter) {
    this.set('filter', filter);

    if (filter) {
      this.refs.searchTable.setFilter(filter);
      this.refs.searchTable.show();
      this.refs.scrollTable.hide();
    } else {
      this.refs.searchTable.resetFilter();
      this.refs.searchTable.hide();
      this.refs.scrollTable.show();
    }
  },

  resetFilter: function() {
    this.setFilter(null);
  },

  onContactSelect: function(contact) {
    var owner = this.getOwner();
    if (owner && owner.onContactSelect) {
      owner.onContactSelect(contact);
    }
  }
});
});

// module: view/message_composer_scene/picker_row
// file:   view/message_composer_scene/picker_row.js
define("view/message_composer_scene/picker_row", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var Actionable = require('bolt_touch/mixins/actionable').Actionable;

exports.PickerRow = core.createClass({
  name: 'PickerRow',
  extend: View,

  mixins: [Actionable],

  properties: {
    contact: null
  },

  declare: function() {
    return {
      className: 'bt-recipient-picker-choice',
      childViews: [
        {
          ref: 'content',
          className: 'content',
          childViews: [
            {
              ref: 'text',
              childViews: [
                { ref: 'name',  className: 'name' },
                { ref: 'extra', className: 'extra' }
              ]
            }
          ]
        }
      ]
    };
  },

  setHighlighted: function(state) {
    this.toggleClass('highlighted', state);
  },

  setContact: function(contact) {
    this.set('contact', contact);
    var contentView = this.findRef('content');
    var textView = this.findRef('text');
    var nameView = this.findRef('name');
    var extraView = this.findRef('extra');

    // set pic
    var pic = contact.getProfileUrl() || 'empty_profile.gif';
    contentView.setStyle('background', 'url(' + pic + ') no-repeat 0px 0px');

    // set name
    nameView.setContent(contact.getFirstName() + ' ' + contact.getLastName());

    // set extra matching information, if it exists
    if (contact._matchingValue) {
      textView.setClassName('hasextra');
      extraView.show();
      extraView.setContent(contact._matchingValue);
    } else {
      textView.setClassName('noextra');
      extraView.hide();
    }
  }
});
});

// module: audience_picker/audience_constants
// file:   ../../audience_picker/js/audience_constants.js
define("audience_picker/audience_constants", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

// Constants for audience picker

var PUBLIC_ID = exports.PUBLIC_ID = '-1';
var FRIENDS_ID = exports.FRIENDS_ID = '-2';
var SELF_ID = exports.SELF_ID = '-3';
var FB_ONLY = exports.FB_ONLY = '-4';

exports.getAudienceIcon = function(privacyId) {
  var icon = null;
  switch (privacyId) {
    case PUBLIC_ID:
      icon = 'audience_world';
      break;
    case FRIENDS_ID:
      icon = 'audience_friends';
      break;
    case SELF_ID:
      icon = 'audience_only_me';
      break;
    default:
      icon = 'audience_groups';
      break;
  }
  return icon;
};

var getAudienceObject = exports.getAudienceObject = function(privacyId) {
  var obj = null;

  switch (privacyId) {
    case PUBLIC_ID:
      obj = {value : 'EVERYONE'};
      break;
    case FRIENDS_ID:
      obj = {value : 'ALL_FRIENDS'};
      break;
    case SELF_ID:
      obj = {value: 'CUSTOM', friends: 'SELF'};
      break;

    // An internal permssion to make sure that photos are
    // not visible outside FB.
    //
    // TODO: Remove after dogfodding
    case FB_ONLY:
      obj = {value: 'CUSTOM', networks: '50431648'};
      break;
    default:
      break;
  }
  return obj;
};

// Override photo post visibility.
// TODO: Remove after camera calibration!!!
exports.getPhotoAudienceObject = function(privacyId) {
  switch (privacyId) {
    case PUBLIC_ID:
      privacyId = FB_ONLY;
      break;
    case FRIENDS_ID:
      privacyId = FB_ONLY;
      break;
    default:
      // It is a post to group or to "self".
      // Do not restrict permission in this case.
      break;
  }

  return getAudienceObject(privacyId);
};
});

// module: view/photo_button/photo_button
// file:   view/photo_button/photo_button.js
define("view/photo_button/photo_button", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

// Photo button that lets the user select a single photo

var core              = require('bolt/core');
var util              = require('bolt/util');
var View              = require('bolt_touch/view').View;

var PhotoButton = exports.PhotoButton = core.createClass({

  name: 'PhotoButton',

  extend: View,

  properties: {
    selectedPhoto: null
  },

  setSelectedPhoto: function(selectedPhoto) {
    this.set('selectedPhoto', selectedPhoto);

    if (selectedPhoto) {
      this.icon.setStyle({
        'background-image': 'url(' + selectedPhoto.get('picture') + ')',
        'background-size': 'contain'
      });
    } else {
      this.icon.setStyle({
        'background-image': '',
        'background-size': ''
      });
    }
  },

  declare: function(options) {
    return {
      childViews: [
        {
          className: 'bt-photo-button-icon',
          ref: 'icon'
        }
      ]
    };
  },

  ready: function() {
    this.icon = this.findRef('icon');
    this.addListener('click', this.onClick, this);
  },

  onClick: function() {
    var photoPicker =
      require('views/picker/photo_picker/photo_picker').photoPicker;
    if (!this.getSelectedPhoto()) {
      photoPicker.show(util.bind(this.photoCallback, this));
    } else {
      this.setSelectedPhoto();
    }
  },

  getIconNode: function() {
    return this.findRef('icon').getNode();
  },

  photoCallback: function(photos) {
    if (photos) {
      this.setSelectedPhoto(util.isArray(photos) ? photos[0] : photos);
    }
    this.invoke(
      'photos',
      {photos: photos}
    );
  },

  clear: function() {
    this.setSelectedPhoto();
  }
});
});

// module: shared/simpin/pin_util
// file:   ../../shared/js/simpin/pin_util.js
define("shared/simpin/pin_util", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;
var Deferred = require('shared/deferred').Deferred;
var dialogUtil = require('shared/dialogs');

/**
 * Utility function that verifies that the SIM card is unlocked.  If the SIM is
 * currently locked, the user is shown a dialog and, if possible, is given
 * an opportunity to unlock the SIM.
 *
 * @param verb
 *   a string of the form 'make calls', used as part of sentences like
 *   "Please unlock the SIM to make calls."
 * @param ignorePinLock (optional)
 *   when true, the SIM is considered unlocked even when a PIN is required
 * @return Deferred
 *   succeeds when the SIM is unlocked, fails when user cancels the action
 */
function verifySimUnlocked(verb, ignorePinLock) {
  var phoneApi = FBAPI.use('phone');
  var state = phoneApi.getSimState();
  var def = new Deferred();

  if (state === phoneApi.SIM_STATE_BLOCKED ||
      state === phoneApi.SIM_STATE_IMEI_LOCKED ||
      state === phoneApi.SIM_STATE_NETWORK_LOCKED ||
      state === phoneApi.SIM_STATE_PUK_REQUIRED ||
      state === phoneApi.SIM_STATE_ABSENT ||
      (!ignorePinLock && state === phoneApi.SIM_STATE_PIN_REQUIRED)) {
    var id;
    EventManager.listen('dialog.RESULT_RECEIVED', function(data) {
      if (data.id === id) {
        id = null;
        if (data.result) {
          def.succeed();
        } else {
          def.fail();
        }
      }
    });
    id = dialogUtil.showSpecialDialog(dialogUtil.TYPE_SIM_LOCKED, {
      verb: verb,
      ignorePinLock: ignorePinLock
    });
  } else {
    def.succeed();
  }
  return def;
}

exports.verifySimUnlocked = verifySimUnlocked;
});

// module: contacts/edit_contact_section
// file:   contacts/edit_contact_section.js
define("contacts/edit_contact_section", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EditContactScene = require('./edit_contact_section/ui/edit_contact_scene').EditContactScene;
var Announcer = require('./util/announcer').Announcer;
var ContactUpdater = require('./edit_contact_section/contact_updater').ContactUpdater;
var ContactRemover = require('./edit_contact_section/contact_remover').ContactRemover;

/*
 * EditContactSection is the section of the application that allows editing of
 * contacts. The following events come out of the edit contact section:
 *
 * contactSuccessfullyDeleted: no parameters
 * cancel: no parameters
 * contactSuccessfullyUpdated: no parameters
 */

var EditContactSection = function(contactUpdater) {
  var announcer = this._announcer = new Announcer();
  this._externalEventsProxy = {
    contactSuccessfullyUpdated: function() {
      announcer.announce('contactSuccessfullyUpdated');
    },

    cancelEdit: function() {
      announcer.announce('cancel');
    },

    contactSuccessfullyDeleted: function() {
      announcer.announce('contactSuccessfullyDeleted');
    }
  };
  this._contactUpdater = contactUpdater;
  this._contactUpdater.addEventListener(this._externalEventsProxy);
};

EditContactSection.prototype = {
  getScene: function(snapshot) {
    var editContactScene = new EditContactScene({
      contactInformation: snapshot
    });
    editContactScene.addEventListener(this._contactUpdater);
    editContactScene.addEventListener(this._externalEventsProxy);
    editContactScene.setContact(snapshot);
    return editContactScene;
  },

  addListener: function(listener) {
    this._announcer.addListener(listener);
  }
};

exports.EditContactSection = EditContactSection;
});

// module: bolt_touch/mixins/table-view-item
// file:   ../../../frameworks/bolt_touch/lib/mixins/table-view-item.js
define("bolt_touch/mixins/table-view-item", function(require, exports, module) {
/**
 * TableViewItem should be mixed into components that are put into TableView. Area
 * should also be mixed into these types of components if they are full-width.
 */
exports.TableViewItem = {

  // The resize event should invoked by a TableViewItem View that's in a
  // TableViewItemAreaList if the View has changed height and the table should be
  // repositioned.
  events: ['resize'],

  properties: {
    highlighted: false,
    selectable: false,
    selected: false,
    reuseIdentifier: 'cell'
  },

  /**
   * Marks whether or not this view should be highlighted. Highlighting marks
   * either a selection or gives feedback to the user that they are touching
   * something that is selectable. Highlighting is done by toggling the
   * bt-active class on the view.
   *
   * @param {boolean} value true to set highlighted, false to unset highlighted.
   */
  setHighlighted: function(value) {
    this.set('highlighted', value);
    if (this.getSelectable()) {
      if (value) {
        this.addClass('bt-active');
      } else {
        this.removeClass('bt-active');
      }
    }
  },

  /**
   * Marks whether or not this view is selected. Selected views are highlighted.
   *
   * @param {boolean} value true to set selected, false to unset selected.
   */
  setSelected: function(value) {
    // cells can be highlighted while they are not selected - synchronize the
    // state when selection changes
    if (this.getSelected() !== value) {
      this.set('selected', value);
      this.setHighlighted(value);
    }
  },

  /**
   * Called when a cell is enqueued. Use this to remove event listeners or to
   * clean up the contents of a cell and return it to a blank state.
   */
  cleanForReuse: function() {}
};
});

// module: views/picker/common/picker_controller
// file:   ../../views/picker/common/picker_controller.js
define("views/picker/common/picker_controller", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core                 = require('bolt/core');
var util                 = require('bolt/util');
var PickerAlbumListScene   =
  require('views/picker/album_picker/picker_album_list_scene');

// The root class of picker controller.
// It abstracts the commonalities among pickers.
// 1) A picker (except for camera) needs a scene stack to push itself onto.
// 2) A picker needs a callback function to pass its results.
exports.PickerController = core.createClass({
  name: 'PickerController',

  construct: function(options) {
    if (options) {
      this.startScene = options.startScene;
      this.sceneStack = options.sceneStack;
      this.callback = options.callback;
    }
  },

  // By default, do not need to set up any events.
  setupEvents: function() {
  },

  // By default, do not need to clean up any events
  cleanUpEvents: function() {
  },

  // The default behavior is to push a picker scene
  // onto the scenestack. However, specific picker
  // controllers could override this method and have
  // different behaviors.
  startPicker: function() {
    this.setupEvents();

    if (this.startScene) {
      this.sceneStack.push({
        view: this.startScene,
        callback: util.bind(this._onPickerDone, this)
      }, {
        transition: 'slide'
      });
    }
  },

  // The default behavior is to trigger the callback.
  // This method could be overridden to provide some
  // additional post processing.
  _onPickerDone: function(result) {
    this.cleanUpEvents();

    if (this.callback) {
      this.callback(result);
    }
  },

  setSceneStack: function(sceneStack) {
    this.sceneStack = sceneStack;
  },

  setCallback: function(callback) {
    this.callback = callback;
  }
});

});

// module: shared/session
// file:   ../../shared/js/session.js
define("shared/session", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;
var AuthManager = require('shared/auth_manager').AuthManager;
var config = require('shared/config');
var global = this;
// for now this will just manage a singleton storage of the fb session
var _session = null;

if (!config.isWorker()) {
  _session = AuthManager.createSessionObject();
  if (!_session) {
    EventManager.addListener('login.FINISHED', function(event) {
      _session = event.data;
      // What the hell even is this crap. Login and authentication code needs a
      // serious cleanup. This is necessary or else first time logging in will
      // break for at least dash.
      if (AuthManager.getAuth() === null) {
        AuthManager.setAuth({
          accessToken: _session.access_token,
          sessionKey: _session.session_key,
          sessionSecret: _session.session_secret,
          userId: _session.uid,
          name: _session.name,
          expires: _session.expires
        });
      }
      EventManager.removeListener('login.FINISHED', arguments.callee);
    });
  }
}

exports.hasConnectSession = function () {
  return !!_session;
};

exports.getAccessToken = function () {
  return (_session ? _session.access_token : null);
};

exports.getUid = function () {
  if (global.__ACCEPTANCE_TEST__) {
    return 1;
  } else {
    return (_session ? _session.uid : null);
  }
};

exports.getName = function () {
  return (_session ? _session.name : null);
};

exports.getPicture = function() {
  return (_session ?
    'http://graph.facebook.com/' + _session.uid + '/picture?type=large' :
    null);
};

exports._getSession = function() {
  return _session;
};

exports._setSession = function(session) {
  _session = session;
};
});

// module: shared/data2/model/story/story_remote_mapper
// file:   ../../shared/js/data2/model/story/story_remote_mapper.js
define("shared/data2/model/story/story_remote_mapper", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var MultiFQLRemoteMapper =
  require('../../remote/multi_fql_remote_mapper').MultiFQLRemoteMapper;
var Deferred = require('shared/deferred').Deferred;

/**
 *  @classdesc StoryRemoteMapper aggregates sub-stories
 * (stories with a parent_post_id) into the respective
 * parent stories.
 */

exports.StoryRemoteMapper = core.createClass({

  name: 'StoryRemoteMapper',

  extend: MultiFQLRemoteMapper,

  properties: {
    migrationsOverride: {
      recent_activity: true
    },
    seq_property: 'view_time_position',
    tableName: 'stream'
  },

  download: function(filter, limit, _orderingWhere) {
    return MultiFQLRemoteMapper.prototype.download
      .call(this, filter, limit, _orderingWhere)
      .then(function(models, flag) {
        var modelsMap = {};
        util.forEach(models, function(model) {
          model.set('children_posts', []);
          modelsMap[model.get('id')] = model;
        });

        util.forEach(models, function(model) {
          var parent_post_id = model.get('parent_post_id');
          if (!!parent_post_id && !!modelsMap[parent_post_id]) {
            modelsMap[parent_post_id]
              .get('children_posts').push(model._properties);
          }
        });

        // Filter out all children posts and all aggregated posts that only have
        // one child post.
        // TODO: Fix any stories with aggregated posts with only one child post.
        var agg_models = util.filter(models, function(model) {
          return !model.get('parent_post_id') &&
            (model.get('children_posts').length !== 1);
        });

        return (new Deferred()).succeed(agg_models, agg_models.length > 0);
      }, this);
  }
});
});

// module: contacts/display_contact_section
// file:   contacts/display_contact_section.js
define("contacts/display_contact_section", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var ProfileServices = require('./display_contact_section/external_services').ProfileServices;
var TalkServices = require('./display_contact_section/external_services').TalkServices;
var Announcer = require('./util/announcer').Announcer;
var DisplayContactScene =
  require('./display_contact_section/ui/display_contact_scene').DisplayContactScene;

/*
 * DisplayContactSection is the section of the application that displays the
 * information for a single contact. The following events come out of the
 * display contact section:
 *
 * back: no prameters
 * edit: snapshot of contact that is to be edited
 */
var DisplayContactSection = core.createClass({
  name: 'DisplayContactSection',

  construct: function(options) {
    this._announcer = new Announcer();
  },

  getScene: function(snapshot) {
    var scene = new DisplayContactScene({
      onbackFromDisplayContact: 'backFromDisplayContact',
      oneditContact: 'editContact',
      oncallNumber: 'callNumber',
      onmessageContact: 'messageContact',
      onviewProfile: 'viewProfile',
      owner: this
    });
    scene.setContact(snapshot || this._lastSnapshot);
    this._lastSnapshot = snapshot;
    return scene;
  },

  backFromDisplayContact: function() {
    this._announcer.announce('back');
  },

  editContact: function(evt) {
    this._announcer.announce('edit', evt.data.snapshot);
  },

  callNumber: function(evt) {
    TalkServices.callNumber(evt.data.number);
  },

  messageContact: function(evt) {
    TalkServices.messageContact(evt.data.snapshot);
  },

  viewProfile: function(evt) {
    ProfileServices.viewProfile(evt.data.snapshot);
  },

  addListener: function(listener) {
    this._announcer.addListener(listener);
  }
});

exports.DisplayContactSection = DisplayContactSection;
});

// module: bolt_touch/views/pageheader/index
// file:   ../../../frameworks/bolt_touch/lib/views/pageheader/index.js
define("bolt_touch/views/pageheader/index", function(require, exports, module) {
var core = require('bolt/core');
var util = require('bolt/util');

var View = require('bolt_touch/view').View;

var PageHeader = core.createClass({

  name: 'PageHeader',

  extend: View,

  delegateProperties: {
    label: [{alias: 'label', name: 'content'}]
  },

  declare: function() {
    return {
      additionalClasses: 'bolt-page-header bt-bar'
    };
  },

  createDom: function(options) {
    var node = View.prototype.createDom.call(this, options);
    var buttonBar = this.build({
      boxOrientation: 'horizontal',
      childViews: [
        {
          ref: 'left',
          additionalClasses: 'bolt-page-header-left',
          flex: 1
        },
        {
          flex: 8
        },
        {
          ref: 'right',
          additionalClasses: 'bolt-page-header-right',
          flex: 1
        }
      ]
    });
    buttonBar.setBoxOrientation('horizontal');
    this.appendChild(buttonBar);
    this.appendChild(this.build({
      ref: 'label',
      additionalClasses: 'bolt-page-header-label'
    }));
    return node;
  },

  /**
   * Adds a view to either the left or the right
   *
   * @param {Object} view The view definition, usually a Button
   * @param {String} position Either 'left' or 'right'
   */
  addView: function(view, position) {
    this.refs[position || 'right'].setChildViews([view]);
  },

  getView: function(position) {
    return this.refs[position || 'right'].getChildViews()[0];
  },

  setChildViews: function(views) {
    var container = 'left';

    this.refs.left.setChildViews([]);
    this.refs.right.setChildViews([]);

    for (var i = 0; i < views.length && i < 2; i++) {
      if (views[i].headerAlign) {
        container = views[i].headerAlign;
        delete views[i].headerAlign;
      }
      this.addView(views[i], container);

      container = 'right';
    }
  }
});


exports.PageHeader = PageHeader;
});

// module: shared/data2/local/migration/sql_helper
// file:   ../../shared/js/data2/local/migration/sql_helper.js
define("shared/data2/local/migration/sql_helper", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

function _getColumnSql(column) {
  var sql = column.name;
  if (column.type) {
    sql += " " + column.type;
  }
  return sql;
}

function createTable(spec) {
  var name = spec.getTableName();
  var columns = spec.getColumns();
  var columnsSql = columns.map(_getColumnSql);
  return "CREATE TABLE " + name + " (" + columnsSql.join(", ") + ")";
}

function dropTable(spec) {
  return "DROP TABLE IF EXISTS " + spec.getTableName();
}

function _getIndexName(spec, index) {
  var columnNames = index.columns.map(function(col) {
    if (typeof col == 'string') {
      return col;
    } else {
      return col.name;
    }
  });
  return "idx_" + spec.getTableName() + "__" + columnNames.join("_");
}

function createIndexes(spec) {
  var indexes = spec.getIndexes();
  return indexes.map(function(index) {
    var columns = index.columns;
    var columnsSql = new Array(columns.length);
    for (var i = 0; i < columns.length; i++) {
      var col = columns[i];
      if (typeof col == 'string') {
        columnsSql[i] = col;
      } else {
        columnsSql[i] = col.name;
        if (col.hasOwnProperty('collate')) {
          columnsSql[i] += " COLLATE " + col.collate;
        }
        if (col.hasOwnProperty('sort')) {
          columnsSql[i] += " " + col.sort;
        }
      }
    }
    var sql = index.unique ? "CREATE UNIQUE INDEX " : "CREATE INDEX ";
    sql += _getIndexName(spec, index) + " ON " + spec.getTableName();
    sql += " (" + columnsSql.join(", ") + ")";
    return sql;
  });
}

function dropIndexes(spec) {
  var indexes = spec.getIndexes();
  return indexes.map(function(index) {
    return "DROP INDEX IF EXISTS " + _getIndexName(spec, index);
  });
}

exports.createTable = createTable;
exports.dropTable = dropTable;
exports.createIndexes = createIndexes;
exports.dropIndexes = dropIndexes;
});

// module: audience_picker/audience_cell
// file:   ../../audience_picker/js/audience_cell.js
define("audience_picker/audience_cell", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var TableViewCell          = require("views/deprecated/table_view").TableViewCell;
var core                   = require('bolt/core');
var AudienceConstants      = require('./audience_constants');

var AudienceCell = exports.AudienceCell = core.createClass({
  name: 'audience-cell',
  extend: TableViewCell,

  declare: function() {
    return {
      boxOrientation: 'horizontal',
      childViews: [
        {
          additionalClasses: 'audience_picker_icon',
          ref: 'icon',
          flex: 1
        },
        {
          ref: 'name',
          flex: 20
        },
        {
          ref: 'toggle',
          flex: 1
        }
      ]
    };
  },

  ready: function() {
    this._icon = this.findRef('icon');
    this._name = this.findRef('name');
    this._toggle = this.findRef('toggle');
    this._selected = false;
    this._currentIconClass = null;
  },

  setAudience: function(audience, selected) {
    if (this._currentIconClass) {
      this._icon.removeClass(this._currentIconClass);
    }
    switch (audience.get('id')) {
      case AudienceConstants.PUBLIC_ID:
        this._currentIconClass = 'audience_world';
        break;
      case AudienceConstants.FRIENDS_ID:
        this._currentIconClass = 'audience_friends';
        break;
      case AudienceConstants.SELF_ID:
        this._currentIconClass = 'audience_only_me';
        break;
      default:
        this._currentIconClass = 'audience_groups';
        break;
    }

    this._icon.addClass(this._currentIconClass);
    this._name.setContent(audience.get('name') || audience.get('group').name);
    this._selected = selected;
    this._refreshToggle();
  },

  _refreshToggle: function() {
    if (this._selected) {
      this._toggle.addClass('audience_picker_selected');
    } else {
      this._toggle.removeClass('audience_picker_selected');
    }

  }
});
});

// module: index
// file:   index.js
define("index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

require('bolt/event_dispatcher').defaultEventDispatcher.setEnabled(true);

console.info('talk:loaded');
var isTestEnviornment = function() {
  return window.location.toString().indexOf('test=true') !== -1;
};

window.__PERF_LOGGING__ = false;

var STANDALONE = !window.FBAPI;

require('shared/init').ready(function() {
  console.info('talk:init');
  if (STANDALONE) {
    require('mock/init').init();
  }

  function run() {
    var AppController = require('controller/app_controller').AppController;
    (new AppController());

    // notify the system that the application has rendered
    var EventManager = require('shared/event_manager').EventManager;
    setTimeout(function() {
      // There's a slight delay after AppController is initialized before the
      // screen is actually rendered. This timeout mitigates the flash of
      // white.
      EventManager.notifyCore('applicationDidLoad');
    }, 100);
  }

  if (!isTestEnviornment()) {
    require('shared/bootstrap').bootstrap(function() {
      console.info('talk:bootstrap');
      if (STANDALONE) {
        require('talk/client/broker').initSystemClient();
      }

      var WindowManager = require('shared/window_manager').WindowManager;
      WindowManager.setResizeMode(WindowManager.AUTO_RESIZE_TO_VIEWPORT);

      run();

      var uptime = FBAPI.use('info').getWebviewUptime();
      require('shared/logger').logger.logTimeDirect(
        'talk:start', 'latency', uptime);
      require('shared/event_manager').EventManager
        .broadcastEvent('talk:start', {uptime: uptime});
      console.info('talk:start');
    });
  } else {
    //I'd rather do the configuration of the application here, but I don't
    //want to clutter this space with contact specific stuff since the rest of
    //talk doesn't follow this pattern
    window.__ACCEPTANCE_TEST__ = true;
    run();
  }
});

});

// module: shared/geo/coords
// file:   ../../shared/js/geo/coords.js
define("shared/geo/coords", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');

var Coords = core.createClass({
  name: 'Coords',

  construct: function() {
    if (arguments.length == 1) {
      this.latitude = Number(arguments[0]['latitude']);
      this.longitude = Number(arguments[0]['longitude']);
    }
    if (arguments.length == 2) {
      this.latitude = Number(arguments[0]);
      this.longitude = Number(arguments[1]);
    }
  },

  distanceTo: function(c2) {
    return this.haversineDist(this.latitude, this.longitude,
      c2.latitude, c2.longitude);
  },

  toMSFTLocation: function() {
    return new Microsoft.Maps.Location(this.latitude, this.longitude);
  },

  statics: {
    // @returns distance in km between two lat-lon pairs
    haversineDist: function(lat1, lon1, lat2, lon2) {
      var R = 6371; // Earth radius in km
      var dLat = (lat2-lat1) * Math.PI / 180;
      var dLon = (lon2-lon1) * Math.PI / 180;
      var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    },

    centroid: function(coords) {
      var latitude = 0;
      var longitude = 0;
      for (var i = 0; i < coords.length; i++) {
        latitude += coords[i].latitude;
        longitude += coords[i].longitude;
      }
      return new Coords(latitude/coords.length,
                                    longitude/coords.length);
    },

    currentLocation: function() {
      var loc = FBAPI.use("location").getLastKnownPosition();
      // stub out location until we have network location provider figured out
      if (loc == 'null')
        return new Coords({latitude: 37.441883, longitude: -122.143019})
      else
        return new Coords(JSON.parse(loc).coords);
    }
  }
});

exports.Coords = Coords;
});

// module: contacts/contact_filters_section
// file:   contacts/contact_filters_section.js
define("contacts/contact_filters_section", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var ContactFiltersScene =
  require('./contact_filters_section/ui/contact_filters_scene')
  .ContactFiltersScene;
var Announcer = require('./util/announcer').Announcer;

/**
 * Section for displaying a list of contact "filters", which can be groups,
 * lists, or other filterings of people.
 */
var ContactFiltersSection = core.createClass({
  name: 'ContactFiltersSection',

  construct: function(options) {
    this._announcer = new Announcer();
  },

  getScene: function() {
    return new ContactFiltersScene({
      oncancel: 'cancel',
      onallContactsSelected: 'allContactsSelected',
      ongroupFilterSelected: 'groupFilterSelected',
      onlistFilterSelected: 'listFilterSelected',
      groupCollection: this.getDataSource().getGroupCollection(),
      listCollection: this.getDataSource().getListCollection(),
      owner: this
    });
  },

  getDataSource: function() {
    var dataSource = this.get('dataSource');
    if (!dataSource) {
      if (window.__ACCEPTANCE_TEST__) {
        dataSource =
          require('./contact_filters_section/stub_filters_data_source')
          .stubFiltersDataSource;
      } else {
        dataSource =
          require('./contact_filters_section/filters_data_source')
          .getInstance();
      }
      this.set('dataSource', dataSource);
    }
    return dataSource;
  },

  cancel: function(evt) {
    this._announcer.announce('cancel');
  },

  allContactsSelected: function(evt) {
    this._announcer.announce('allContactsSelected');
  },

  groupFilterSelected: function(evt) {
    this._announcer.announce('groupFilterSelected', evt.data);
  },

  listFilterSelected: function(evt) {
    this._announcer.announce('listFilterSelected', evt.data);
  },

  addListener: function(listener) {
    this._announcer.addListener(listener);
  }

});

exports.ContactFiltersSection = ContactFiltersSection;
});

// module: mock/face_recognition_api
// file:   ../../mock/js/face_recognition_api.js
define("mock/face_recognition_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;
var PHONE_DIMENSION = require('shared/screen_constants').PHONE_DIMENSION;

module.exports = {
  _timeout: 1000,
  _faceWidth: 15,
  _faceHeight: 15,

  FACE_RECOGNIZED: 'facerecognition.RECOGNIZED',

  subscribeToLiveFaceRecognition: function(facesPerSecond) {
    console.info('Function not implemented');
  },

  addFaceRecognitionToCamera: function(facesPerSecond) {
    setTimeout(
      function() {
        // Pretend to recognize faces after some timeout.
        EventManager.broadcastEvent(this.FACE_RECOGNIZED,
            this.recognizeImage(Math.floor(Math.random() * 100), ''));
      },
      this._timeout);
  },

  unsubscribeToLiveFaceRecognition: function() {
    // noop
  },

  recognizeImage: function(id, filepath) {
    var recPos = this._getRandomFacePosition();
    var detPos = this._getRandomFacePosition();

    // Return one recognized face, and one we're not sure about
    return {
      internalId: id,
      faces: [
        {
          topLeftX: recPos.x,
          topLeftY: recPos.y,
          width: this._faceWidth,
          height: this._faceHeight,
          guesses: [
            {
              confidence: 0.9,
              userId: 4
            },
            {
              confidence: 0.4,
              userId: 504182228
            }
          ]
        },
        {
          topLeftX: detPos.x,
          topLeftY: detPos.y,
          width: this._faceWidth,
          height: this._faceHeight,
          guesses: [
            {
              confidence: 0.35,
              userId: 3700464
            },
            {
              confidence: 0.22,
              userId: 10009554
            }
          ]
        }
      ]
    };
  },

  _getRandomFacePosition: function() {
    var x = Math.random() * (PHONE_DIMENSION.width - this._faceWidth);
    var y = Math.random() * (PHONE_DIMENSION.height - this._faceHeight);

    return {x: x, y: y};
  }
};
});

// module: bolt_touch/views/button/index
// file:   ../../../frameworks/bolt_touch/lib/views/button/index.js
define("bolt_touch/views/button/index", function(require, exports, module) {
var util = require('bolt/util');
var View = require('bolt_touch/view').View;
var Actionable = require('../../mixins/actionable').Actionable;

var Button = require('bolt/core').createClass({

  name: 'Button',

  extend: View,

  properties: {
    value: ''
  },

  mixins: [Actionable],

  declare: function(options) {
    // TODO: wbailey we should come up with a general solution for this the
    // problem is that passing in view properties lets you break the
    // internals of a control in some cases. In this case passing in your own
    // additionalClasses was overriding the additionalClasses that Button
    // needs to render properly.
    var defaultButtonClasses = 'uiButton uiButtonNoText';
    if (options.additionalClasses) {
      options.additionalClasses += ' ' + defaultButtonClasses;
    }
    return {
      tagName: 'label',
      additionalClasses: defaultButtonClasses,
      childViews: [
        {
          ref: 'button',
          tagName: 'input',
          type: 'button',
          className: 'uiButtonInput bt-button-input'
        }
      ]
    };
  },

  setLarge: function(state) {
    this.large = state;
    this.toggleClass('uiButtonLarge', state);
  },

  getLarge: function(state) {
    return this.large;
  },

  setValue: function(value) {
    this.refs.button.getNode().value = value;
  },

  getValue: function() {
    return this.refs.button.getNode().value;
  },

  setUse: function(use) {
    this.toggleClass(useClassName(this.use), false);
    this.use = use;
    this.toggleClass(useClassName(this.use), true);
    return this;
  },

  getUse: function() {
    return this.use;
  },

  setDisabled: function(disabled) {
    this.set('disabled', disabled);
    this.toggleClass('uiButtonDisabled', disabled);
  },

  setDown: function(down) {
    if (down) {
      this.addClass('bt-button-down');
    } else {
      this.removeClass('bt-button-down');
    }
  }
});

function useClassName(use) {
  if (use === 'special') {
    return 'uiButtonSpecial';
  } else {
    return 'uiButtonConfirm';
  }
}

exports.Button = Button;
});

// module: shared/data2/local/versioned_db
// file:   ../../shared/js/data2/local/versioned_db.js
define("shared/data2/local/versioned_db", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var Database = require('./db').Database;

var INIT_VERSION_SQL =
  "CREATE TABLE __version__ (identifier TEXT PRIMARY KEY, version TEXT)";
var GET_VERSION_SQL =
  "SELECT version FROM __version__ WHERE identifier=?";
var SET_VERSION_SQL =
  "INSERT OR REPLACE INTO __version__ (identifier, version) VALUES (?, ?)";
var DELETE_VERSION_SQL =
  "DELETE FROM __version__ WHERE identifier=?";

function extractVersion(resultSet) {
  var rows = resultSet.rows;
  if (rows.length === 0) {
    return null;
  } else {
    return rows.item(0).version;
  }
}

var VersionedDatabase = core.createClass({
  name: 'VersionedDatabase',
  extend: Database,

  construct: function(nativeDatabase) {
    Database.call(this, nativeDatabase);
  },

  getVersion: function(identifier, /*optional*/ transaction) {
    if (!transaction) {
      transaction = this.transaction();
    }
    return transaction.executeSql(GET_VERSION_SQL, [identifier])
      .then(extractVersion);
  },

  changeVersion: function(identifier, desiredVersion, migrationFunc) {
    var transaction = this.transaction();
    this.getVersion(identifier, transaction)
    .then(function(currentVersion) {
      if (currentVersion !== desiredVersion) {
        transaction.executeSql(SET_VERSION_SQL, [identifier, desiredVersion]);
        migrationFunc(transaction, currentVersion, desiredVersion);
      }
    });
    return transaction;
  },

  clearVersion: function(identifier, cleanupFunc) {
    var versions = this.versions;
    var transaction = this.transaction();
    this.getVersion(identifier, transaction)
    .then(function(currentVersion) {
      if (currentVersion !== null) {
        transaction.executeSql(DELETE_VERSION_SQL, [identifier]);
        cleanupFunc(transaction, currentVersion);
      }
    });
    return transaction;
  }
});

exports.VersionedDatabase = VersionedDatabase;

exports.init = function(nativeTransaction) {
  nativeTransaction.executeSql(INIT_VERSION_SQL);
};
});

// module: bolt_touch/views/data_list/rendering_strategy/base
// file:   ../../../frameworks/bolt_touch/lib/views/data_list/rendering_strategy/base.js
define("bolt_touch/views/data_list/rendering_strategy/base", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core = require('bolt/core');

/**
 * @class BaseRenderingStrategy
 * @classdesc API definition for the RenderingStrategy
 *
 * RenderingStrategy expects to be constructed and used when and only when
 * DataList:
 *   is measurable (in DOM and display != none) and
 *   has data (data.length != 0)
 *
 * @abstract
 */
var BaseRenderingStrategy = core.createClass({

  name: 'BaseRenderingStrategy',

  _data: null,
  _viewManager: null,
  _paneView: null,
  _isReverse: false,

  _isInited: false,

  construct: function(options) {
    if (options) {
      for (var key in options) {
        this.set(key, options[key]);
      }
    }
  },

  /**
   * Happens once before first update.
   *
   * @param {ViewManager} viewManager
   * @param {View} paneView  target view to render rows in
   * @param {Bool} isReverse
   */
  init: function(viewManager, paneView, isReverse) {
    this._viewManager = viewManager;
    this._paneView = paneView;
    this._isReverse = isReverse;
  },

  /**
   * Happens when new data arrives into DataList
   * 
   * @param {Array|Collection} data
   */ 
  setData: function(data) {
    this._data = data;
    this.clear();
  },

  /**
   * Clear internal state. Happens when data changes.
   * @abstract
   */ 
  clear: function() {},

  destroy: function() {},

  /**
   * Happens when vieport dimensions change or data is updated
   * 
   * @param {Array} events
   * @param {Object} range { from: 0, to: 1000 }
   * @param {Number} width
   * @return {Bool} true if height changed
   */
  update: function(events, range, width) {
    return false;
  },

  /**
   * @return {Number} current estimation of height
   */
  getHeight: function() {
    return 0;
  },

  /**
   * Change higlighted state of a row at "index" to "state"
   * @param {Number} index
   * @param {Bool} state
   */
  setHighlighted: function(index, state) {},

  /**
   * Convert DOM event to a view index
   */
  getIndexForEvent: function(event) {
    return 0;
  }
});


exports.BaseRenderingStrategy = BaseRenderingStrategy;
});

// module: talk/client/thread_client
// file:   ../client/thread_client.js
define("talk/client/thread_client", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core = require('bolt/core');
var ManagedCollectionShadow =
  require('shared/shadowbroker/shadow/managed_collection/managed_collection_shadow')
    .ManagedCollectionShadow;
var ClientThread = require('./model/thread/client_thread').ClientThread;

var ThreadCollectionShadow = core.createClass({
  extend: ManagedCollectionShadow,
  name: 'ThreadCollectionShadow',

  statics: {
    modelType: ClientThread
  }
});


var ThreadClient = core.createClass({

  name: 'ThreadClient',

  _broker: null,

  construct: function(broker) {
    this._broker = broker;
  },

  fetchLastThreads: function(mailboxName, limit) {
    return this._broker
      .callMethod('thread', 'fetchLastThreads', mailboxName, limit)
      .then(this._fetchCollectionComplete, this);
  },

  fetchCollection: function(filter, order, limit) {
    return this._broker
      .callMethod('thread', 'fetchCollection', filter, order, limit)
      .then(this._fetchCollectionComplete, this);
  },

  fetchThreadByIdents: function(idents) {
    return this._broker
      .callMethod('thread', 'fetchThreadByIdents', idents)
      .then(this._fetchThreadSnapshot, this);
  },

  refreshMailboxHead: function(mailboxName, limit) {
    return this._broker
      .callMethod('thread', 'refreshMailboxHead', mailboxName, limit);
  },

  fetchThreadSnapshot: function(id) {
    return this._broker.callMethod('thread', 'fetchThreadSnapshot', id)
      .then(this._fetchThreadSnapshot, this);
  },

  remove: function(ids) {
    return this._broker.callMethod('thread', 'remove', ids);
  },

  _fetchCollectionComplete: function(channel) {
    var shadowCollection = new ThreadCollectionShadow();
    shadowCollection.setChannel(channel);
    return shadowCollection;
  },

  _fetchThreadSnapshot: function(data) {
    return data && new ClientThread(data);
  }
});



var _instance = null;
exports.getInstance = function() {
  if (!_instance) {
    _instance = new ThreadClient(require('./broker').getInstance());
  }
  return _instance;
};

exports.ThreadClient = ThreadClient;
});

// module: bolt/compat/view
// file:   ../../../frameworks/bolt/lib/compat/view.js
define("bolt/compat/view", function(require, exports, module) {
/**
 * Copyright (c) 2011-2012, Facebook, Inc.
 * All rights reserved.
 *
 * @option preserve-header
 *
 * @deprecated Move to project specific folder
 */

var view = require('../view');
var View = view.View;
var TagView = require('../tag_view').TagView;
var util = require('../util');

function deprecated(what, replacement) {
  var msg = what + ' is deprecated.';
  if (replacement) {
    msg += '\nUse ' + replacement + ' instead.';
  }
  var stack;
  try { throw new Error(); } catch(e) { stack = e.stack; }
  stack = '\n' + (stack || '').replace(/.*\n.*\n/, '');
  msg += ' Stack: ' + stack;
  console.warn(msg);
}

TagView.prototype.setBoxOrientation = function(orientation) {
  this.set('boxOrientation', orientation);
  return this.setStyle({
    'display': '-webkit-box',
    'webkitBoxOrient': orientation
  });
};

TagView.prototype.setFlex = function(flex) {
  this.set('flex', flex);
  return this.setStyle({'-webkit-box-flex': flex});
};


View.prototype.listen = View.prototype.addListener;
View.prototype.stopListening = View.prototype.removeListener;

View.prototype.getBoxOrientation = function() {
  return this.get('boxOrientation');
};

/**
 * WEBKIT SPECIFIC
 * sets flexbox orientation onto the view
 * @param {String} orientation - vertical/horizontal
 *                 the flexbox orientation to use
 */
View.prototype.setBoxOrientation = function(orientation) {
  this.set('boxOrientation', orientation);
  return this.setStyle({
    'display': '-webkit-box',
    'webkitBoxOrient': orientation
  });
};

View.prototype.getFlex = function() {
  return this.get('flex');
};

/**
 * WEBKIT SPECIFIC
 * set the box flex for a box child view
 */
View.prototype.setFlex = function(flex) {
  this.set('flex', flex);
  return this.setStyle({'-webkit-box-flex': flex});
};

var setup = View.prototype.setup;
View.prototype.setup = function() {
  if (!this.klass.cssClass) {
    var classes = util.map(this.klass.inheritanceChain, function(k) {
      return 'bt-' + util.hyphenate(k.klassName);
    }).reverse();
    this.klass.cssClass = classes.join(' ');
  }
  return setup.apply(this, arguments);
};
});

// module: shared/data2/store/filter
// file:   ../../shared/js/data2/store/filter.js
define("shared/data2/store/filter", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var Model = require('bolt/model').Model;

/**
 * Filter for both SQL and collections.
 *
 * @example
 *
 *   store
 *    .fetchCollection(new Filter({ thread_id: 2 }, 'modified desc'))
 *    .addCallback(function(collection) {
 *      // do stuff with collection
 *    })
 */
exports.Filter = core.createClass({
  name: 'Filter',

  properties: {
    key: null,
    comparator: null,
    matcher: null,
    SQLWhere: null,
    SQLArgs: null,
    SQLOrder: null,
    FQLQuery: null,
    FQLOrder: null,
    sortKey: null
  },

  construct: function(filter, order) {
    this._filter = filter;
    order = (order || '').split(' ');
    this._order = [order[0], order[1] || 'ASC'];
  },

  getProperties: function() {
    return this._filter;
  },

  getComparator: function() {
    if (this.get('comparator')) {
      return this.get('comparator');
    }
    var isAsc = this.isAsc();
    var property = this._order[0];

    return isAsc ?
      function(a) {
        return a.get(property);
      } :
      function(a) {
        return a.get(property) * -1;
      };
  },

  getSortKey: function() {
    if (this.get('sortKey')) {
      return this.get('sortKey');
    }
    var property = this._order[0];
    return property;
  },

  isAsc: function() {
    return this._order[1].toLowerCase() !== 'desc';
  },

  getMatcher: function() {
    var filter = this._filter;
    var keys = Object.keys(filter);
    return this.get('matcher') || function(object) {
      for (var i = keys.length - 1; i >= 0; i--) {
        var key = keys[i];
        var expected = filter[key];
        var value = object instanceof Model ? object.get(key) : object[key];

        if (util.isArray(expected)) {
          if (!util.contains(expected, value)) {
            return false;
          }
        } else if (!expected.subquery) {
          if (value != expected) {
            return false;
          }
        }
      }
      return true;
    };
  },

  getOrder: function() {
    return this._order[0] && this._order;
  }
});
});

// module: shared/bootstrap
// file:   ../../shared/js/bootstrap.js
define("shared/bootstrap", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var AuthManager  = require('shared/auth_manager').AuthManager;
var api_key      = require('shared/config').api_key;
var EventManager = require('shared/event_manager').EventManager;
var logger       = require('shared/logger').logger;

exports.bootstrap = function(callback, errback) {
  var session = AuthManager.createSessionObject();

  if (session) {
    callback && callback();

    logger && logger.log && logger.log({
      type: 'fb.bootstrap',
      url: window.location.href
    });
  } else {
    if (errback) {
      // The caller has told us that it can handle errors like being not logged
      // in
      errback();
    }

    logger && logger.log && logger.log({
      error: 'null AuthManager.createSessionObject()',
      type: 'fb.bootstrap',
      url: window.location.href
    });

    EventManager.addListener('login.FINISHED', function(event) {
      // The reason we setting localstorage here is that
      // after the system webkit webview stores the access
      // token into localstorage. The boostrap script in
      // core webview can not read the localstorage correctly.
      // This may be caused by the fact that the core webview
      // has a cached version of auth object which is null.
      // Therefore, set the auth object here again to
      // refresh the localstorage in core webviews and the app
      // could load auth object from localstorage successfully
      // afterwards.
      var session = event.data;
      if (AuthManager.getAuth() === null) {
        AuthManager.setAuth({
          accessToken: session.access_token,
          sessionKey: session.session_key,
          sessionSecret: session.session_secret,
          userId: session.uid,
          name: session.name,
          expires: session.expires
        });
      }

      logger && logger.log && logger.log({
        session: JSON.stringify(session),
        getSession: JSON.stringify(session),
        type: 'fb.bootstrap - fail',
        url: window.location.href
      });

      callback && callback();
      EventManager.removeListener('login.FINISHED', arguments.callee);
    });
  }
};
});

// module: contacts/find_facebook_contact_section
// file:   contacts/find_facebook_contact_section.js
define("contacts/find_facebook_contact_section", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var ContactsPortfolio =
  require('./contacts_portfolio').ContactsPortfolio;
var FindContactScene =
  require('./find_facebook_contact_section/ui/find_contact_scene').FindContactScene;
var Announcer = require('./util/announcer').Announcer;
var NewContactCreator = require('./shared/new_contact_creator').NewContactCreator;
var FacebookContactSearcher =
  require('./find_facebook_contact_section/facebook_contact_searcher').FacebookContactSearcher;

/*
 * FindFacebookContactSection is the section of the application allows the user
 * to find an existing facebook contact to add instead of creating a completely
 * new local contact.
 *
 * cancel: no parameters
 * addContact: contact information for local contact to add
 * contactSuccessfullyCreated: contact created from fb contact
 */


var FindFacebookContactSection = function(contactsList) {
  this._portfolio = new ContactsPortfolio();
  this._searcher = new FacebookContactSearcher(this._portfolio);
  var announcer = this._announcer = new Announcer();
  var contactCreator = new NewContactCreator(contactsList);
  this._externalEventsProxy = {
    cancelFind: function() {
      announcer.announce('cancel');
    },

    createNewContact: function(information) {
      announcer.announce('addContact', information);
    },

    contactSuccessfullyCreated: function(contact) {
      announcer.announce('contactSuccessfullyCreated', contact);
    }
  };
  this._eventsTranslator = {
    contactSelected: function(contactSnapshot) {
      contactCreator.createContact(contactSnapshot);
    }
  };
  contactCreator.addEventListener(this._externalEventsProxy);
};

FindFacebookContactSection.prototype = {
  getScene: function() {
    this._scene = new FindContactScene({
      initialSearchValue: '',
      portfolio: this._portfolio
    });
    this._scene.addEventListener(this._searcher);
    this._scene.addEventListener(this._externalEventsProxy);
    this._scene.addEventListener(this._eventsTranslator);
    return this._scene;
  },

  addListener: function(listener) {
    this._announcer.addListener(listener);
  }
}

exports.FindFacebookContactSection = FindFacebookContactSection;
});

// module: bolt/token_list
// file:   ../../../frameworks/bolt/lib/token_list.js
define("bolt/token_list", function(require, exports, module) {
/**
 * Copyright (c) 2011-2012, Facebook, Inc.
 * All rights reserved.
 *
 * @option preserve-header
 *
 */

function noop() {};

function Token(list, type, listener, context, args) {
  this.list = list;
  this.type = type;
  this.listener = listener;
  this.context = context;
  this.args = args;
};

Token.prototype.remove = function() {
  this.list.removeListener(this.type, this.listener, this.context);
};


function TokenList() {}

TokenList.prototype.addToken = function(token) {
  this._listeners || (this._listeners = {});
  this._listeners[token.type] || (this._listeners[token.type] = []);
  this._listeners[token.type].push(token);
  return token;
};

TokenList.prototype.addListener = function(type, listener, context, args) {
  return this.addToken(new Token(this, type, listener, context, args));
};

TokenList.prototype.isEmpty = function() {
  if (!this._listeners) {
    return true;
  }
  for (var type in this._listeners) {
    if (this._listeners.hasOwnProperty(type)) {
      return false;
    }
  }
  return true;
};



TokenList.prototype.removeListener = function(type, listener, contextOrNull) {
  if (!this._listeners) { return; }
  if (!type) {
    delete this._listeners;
  } else if (!listener) {
    delete this._listeners[type];
  } else {
    if (!this._listeners || !this._listeners[type]) { return; }
    var list = this._listeners[type];
    for (var i = 0, l = list.length; i < l; i++) {
      var token = list[i];
      if (listener === token.listener && contextOrNull === token.context) {
        list.splice(i--, 1);
        l--;

        // Mark as removed.
        token.isDestroyed = true;
        // Clean up stuff.
        token.list = null;
        token.type = null;
        token.listener = null;
        token.context = null;
        token.args = null;
        token.remove = noop;
      }
    }
    if (!list.length) {
      delete this._listeners[type];
    }
  }
};

TokenList.prototype.getTokensForType = function(type) {
  return this._listeners && this._listeners[type] || [];
};

TokenList.prototype.hasTokensForType = function(type) {
  return this._listeners &&
    this._listeners[type] && this._listeners[type].length;
};

exports.TokenList = TokenList;
});

// module: bolt/builder
// file:   ../../../frameworks/bolt/lib/builder.js
define("bolt/builder", function(require, exports, module) {
/**
 *
 * Copyright (c) 2011-2012, Facebook, Inc.
 * All rights reserved.
 *
 * @option preserve-header
 *
 */

var util          = require('./util');
var core          = require('./core');
var ClassRegistry = core.ClassRegistry;

var Builder = core.createClass({
  name: 'Builder',

  build: function(configuration, owner) {
    if (util.isArray(configuration)) {
      var arr = [];
      for (var i = 0, length = configuration.length; i < length; i++) {
        arr.push(this._buildOne(configuration[i], owner));
      }
      return arr;
    }
    return this._buildOne(configuration, owner);
  },

  _buildOne: function(configuration, owner) {
    /**
     * Then the configuration was already built.
     */
    if (configuration.setup) {
      return configuration;
    }

    /* If you specify a particular view class, that takes precedence, if you
     * specify a tagName and no view class then we build an instance of TagView,
     * with your specified tagName, otherwise we just build the view base class.
     */
    configuration.owner = configuration.owner || owner;
    var viewConstructor = this._resolveViewConstructor(configuration);
    return new viewConstructor(configuration);
  },

  _resolveViewConstructor: function(configuration) {
    var providedView = configuration.view;
    /* By default, if you don't provide a view name, we'll make a tag view, and
     * if you provided a tagName, we'll use that - otherwise default to div.
     */
    if (!providedView) {
      return require('./tag_view').TagView;
    } else {
      /* This is a bit nuanced. We obtain 'View' from the class registry because
       * different stacks may alias 'View' to be a custom view that has
       * additional capabilities (such as layouts etc.). Aliasing in general is
       * discouraged - but in the case of Views, it's so core that it might make
       * sense to allow it.
       */
      return util.isFunction(providedView) ?
        providedView :
        ClassRegistry[providedView];
    }
  }
});

var builder = new Builder();

exports.build = function(configuration, owner) {
  return builder.build(configuration, owner);
};

exports.setBuilder = function(customBuilder) {
  builder = customBuilder;
};

exports.Builder = Builder;
});

// module: contacts/all_contacts_section
// file:   contacts/all_contacts_section.js
define("contacts/all_contacts_section", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var InMemorySearchCommand =
  require('./all_contacts_section/in_memory_search_command').InMemorySearchCommand;
var ContactsListScene =
  require('./all_contacts_section/ui/contacts_list_scene').ContactsListScene;
var Announcer = require('./util/announcer').Announcer;
var ContactsTableModel =
  require('./shared/ui/contacts_table_model').ContactsTableModel;
var ContactsPortfolio = require('./contacts_portfolio').ContactsPortfolio;

/*
 * AllContactsSection is the section of the application that displays all of the
 * contacts. The following events come out of the all contacts section:
 *
 * addContact: requestedName
 * contactSelected: snapshot of the contact
 * filterContacts
 */

var ContactsListSceneWithInMemorySearch = function(tableModel) {
  var inMemorySearchCommand = new InMemorySearchCommand();
  var scene = new ContactsListScene({
    tableModel: tableModel,
    searchManager: inMemorySearchCommand
  });
  scene.addEventListener(inMemorySearchCommand);
  return scene;
};

var AllContactsSection = function(contactsClient) {
  var announcer = this._announcer = new Announcer();
  this._contactsClient = contactsClient;

  this._externalEventsProxy = {
    addContact: function(contactName) {
      announcer.announce('addContact', contactName);
    },

    contactSelected: function(contactSnapshot) {
      announcer.announce('contactSelected', contactSnapshot);
    },

    filterContacts: function() {
      announcer.announce('filterContacts');
    }
  };
};

AllContactsSection.prototype = {
  getScene: function() {
    if (!this._scene) {
      this._contactsClient.fetchCollection({})
                          .then(this._contactsLoaded, this);
      this._tableModel = new ContactsTableModel();
      this._scene = new ContactsListSceneWithInMemorySearch(this._tableModel);
      this._scene.addEventListener(this._externalEventsProxy);
    }
    return this._scene;
  },

  addListener: function(listener) {
    this._announcer.addListener(listener);
  },

  _contactsLoaded: function(collection) {
    collection.addEventListener(this._tableModel);
    this._tableModel.contactsAdded(collection.toArray());
  }
};

exports.AllContactsSection = AllContactsSection;
});

// module: mock/system_update_api
// file:   ../../mock/js/system_update_api.js
define("mock/system_update_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;

// TODO this is a partial implementation created by analyzing
// About Settings. Feel free to continue to flesh the rest of it out.

var QUERY_DELAY = 2500;
var DOWNLOAD_PROGRESS_INCREMENT = 0.6;
var DOWNLOAD_PROGRESS_INTERVAL = 30

module.exports = {

  // Mock only: Set this to false to make it look like there are no updates
  // available.
  _updateAvailable: true,

  lastData: { state: 'idle' },
  updateVersion: '2.0',
  downloadProgress: 0.0,

  _sendUpdateInfo: function(_this, data) {
    _this.lastData = data;
    EventManager.broadcastEvent('systemupdate.STATE_CHANGED', data);
  },

  checkForUpdate: function() {
    var _this = this;
    setTimeout(function() {
      if (!_this._updateAvailable) {
        // no update is available
        _this._sendUpdateInfo(_this, { state: 'onLatest' });
      } else {
        if (_this.downloadHandle) {
          clearInterval(_this.downloadHandle);
          delete _this.downloadHandle;
        }

        // start update
        _this.downloadHandle = setInterval(function() {
          // increment download percentage
          _this.downloadProgress += DOWNLOAD_PROGRESS_INCREMENT;
          _this.downloadProgress = Math.min(_this.downloadProgress, 100);
  
          if (100 - _this.downloadProgress > 0.01) {
            // downloading...
            _this._sendUpdateInfo(_this, {
              state: 'downloading',
              updateVersion: _this.updateVersion,
              completion: Math.round(100 * _this.downloadProgress) / 100
            });
  
          } else {
            // download complete
            clearInterval(_this.downloadHandle);
            _this._sendUpdateInfo(_this, {
              state: 'installed',
              updateVersion: _this.updateVersion
            });
          }
        }, DOWNLOAD_PROGRESS_INTERVAL);
      }
    }, QUERY_DELAY);
  },

  checkForProgress: function() {
    var _this = this;
    setTimeout(function() {
      EventManager.broadcastEvent('systemupdate.STATE_CHANGED', _this.lastData);
    }, QUERY_DELAY);
  },

  postponeReboot: function() {
  },

  getDownloadProgress: function() {
    return this.downloadProgress;
  }
};
});

// module: shared/text_measurer
// file:   ../../shared/js/text_measurer.js
define("shared/text_measurer", function(require, exports, module) {
var core = require('bolt/core');
var builder  = require('bolt/builder');
var util = require('bolt/util');
/**
 * Class to measure the width of a string
 * Takes 2 parameters to measure: font, which includes:
 *          font-family, font-height and font-size
 * and string to measure.
 * Saves the width for every (font, char) pair, so we can
 * measure the width without accessing the DOM tree
 */
var Measurer = core.createClass({
  name: 'Measurer',

  construct: function() {
    this.shadow = builder.build({
      tagName: 'pre',
      style: {
        display: "inline-block",
        position: 'absolute',
        left: '-10000px',
        top: '-10000px',
        visibility: 'hidden',
        maxWidth: '10000px'
      }
    });
    this.styles = {};
    this.placed = false;
    this.PREFIX = ' ';
  },

  measure: function(s, style) {
    // We need one instance per application, but sometimes
    // document.body does not exist when we create this class
    if (!this.placed) {
      this.shadow.placeIn(document.body);
      this.placed = true;
      this.node = this.shadow.getNode();
    }
    var font = this.getFont(style);
    var data = this.styles[font];
    if (!data) {
      data = {};
      this.styles[font] = data;
      // getting the width of PREFIX
      // we will use it to measure the symbol's width later
      this.node.style.font = font;
      this.node.textContent = this.PREFIX;
      data.PREFIX_SIZE = this.node.clientWidth;
    }

    var length = 0;
    for (var i = 0; i < s.length; i++) {
      var symbol = s[i];
      var t = data[ symbol ];
      if (!t) {
        // for more accuracy measureSymbol returns width of (PREFIX + symbol) string
        t = this.measureSymbol(symbol, font) - data.PREFIX_SIZE;
        data[symbol] = t;
      }
      length += t;
    }
    return length;
  },

  getFont: function(style) {
    return style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily;
  },

  /**
   * Measures the width of symbol + some PREFIX
   * "actual" width = measured - width of PREFIX, which was calculated before
   */
  measureSymbol: function(symbol, font) {
    this.node.style.font = font;
    this.node.textContent = this.PREFIX + symbol;
    return this.node.clientWidth;
  }
});

var measurer = exports.Measurer = new Measurer();
});

// module: contacts/contacts_portfolio
// file:   contacts/contacts_portfolio.js
define("contacts/contacts_portfolio", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*global undefined: true */

var Contact = require('./contact').Contact;
var Announcer = require('./util/announcer').Announcer;
var core = require('bolt/core');
var Collection = require('bolt/collection').Collection;
var ManagedCollectionShadow =
  require('shared/shadowbroker/shadow/managed_collection/managed_collection_shadow')
    .ManagedCollectionShadow;


var ContactsPortfolio = core.createClass({
  extend: ManagedCollectionShadow,

  statics: {
    modelType: Contact
  },

  construct: function() {
    ManagedCollectionShadow.apply(this, arguments);
    this._announcer = new Announcer();
    this._batchingChanges = false;
    this._addedModels = [];
    this.addListener('beginUpdate', this._beginUpdate, this);
    this.addListener('endUpdate', this._endUpdate, this);
    this.addListener('modelAdded', this._modelAdded, this);
    this.addListener('modelRemoved', this._modelRemoved, this);
    this.addListener('updated', this._updated, this);
  },

  modelType: Contact,

  addEventListener: function(listener) {
    this._announcer.addListener(listener);
  },

  empty: function() {
    this.clear();
  },

  merge: function(models, quiet, batchUpdateEvents) {
    Collection.prototype.merge.call(this, models, false, true);
  },

  remove: function(model, quiet) {
    var id = model.id;
    var actualModel = this.getById(id);
    Collection.prototype.remove.call(this, actualModel, quiet);
  },

  _modelAdded: function(event) {
    var contact = event.data.model;
    if (this._batchingChanges) {
      this._addedModels.push(contact);
    } else {
      this._announcer.announce('contactAdded', contact);
    }
  },

  _modelRemoved: function(event) {
    var contact = event.data.model;
    event.data.model.destroy();
  },

  _updated: function(event) {
    if (event.action === 'clear') {
      this._announcer.announce('allContactsRemoved');
    }
  },

  _beginUpdate: function(event) {
    this._batchingChanges = true;
    this._addedModels = [];
  },

  _endUpdate: function(event) {
    if (this._addedModels.length > 0) {
      this._announcer.announce('contactsAdded', this._addedModels);
      this._addedModels = [];
    }
    this._batchingChanges = false;
  }
});

exports.ContactsPortfolio = ContactsPortfolio;
});

// module: views/picker/camera_picker/viewfinder_scene/index
// file:   ../../views/picker/camera_picker/viewfinder_scene/index.js
define("views/picker/camera_picker/viewfinder_scene/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core  = require('bolt/core');
var util  = require('bolt/util');
var Scene = require('bolt_touch/views/scene').Scene;

var EventManager     = require('shared/event_manager').EventManager;
var CameraPreview    = require('camera2/app/lib/view/preview').CameraPreview;
var CameraToolbar    = require('photos/app/lib/view/toolbar').Toolbar;
var PhotoReviewScene = require('../photo_review_scene').PhotoReviewScene;

exports.ViewfinderScene = core.createClass({
  name: 'ViewfinderScene',
  extend: Scene,

  declare: function(options) {
    this.callback = options.callback;

    return {
      boxOrientation: 'vertical',

      childViews: [
        {
          view: CameraPreview,
          ref: 'cameraPreview',
          onError: util.bind(this.onError, this),
          onCaptureStart: util.bind(this.onCaptureStart, this),
          onCaptureEnd: util.bind(this.onCaptureEnd, this),
          flex: 1
        },
        {
          view: CameraToolbar,

          childViews: [
            {
              content: 'Cancel',
              additionalClasses: 'button left',
              onclick: 'cancel'
            },
            {
              className: 'shutter-button',
              onclick: 'takePhoto',
              flex: 1
            }
          ]
        }
      ]
    };
  },

  ready: function() {
    this.camPreview = this.findRef('cameraPreview');
  },

  takePhoto: function() {
    this.camPreview.takePhoto();
  },

  // CameraPreview callback
  onError: function(data) {
    console.error('camera on error', data);
  },

  // CameraPreview callback
  onCaptureStart: function() {
    console.log('on capture start');
  },

  // CameraPreview callback
  onCaptureEnd: function(data) {
    console.log('on capture end');

    var photo = JSON.parse(data.details);
    this.onPictureTaken(photo);
  },

  onPictureTaken: function(data) {
    var photo = {
      picture      : 'file://' + data.picture,
      picture_path : data.picture,
      thumb        : 'file://' + data.thumb,
      thumb_path   : data.thumb,
    };

    this.getStack().push({
      view: PhotoReviewScene,
      photo: photo,
      callback: this.callback
    }, { transition: 'slide' });
  },

  cancel: function() {
    this.callback(null);
  }
});
});

// module: views/dialer/entry_display
// file:   ../../views/dialer/entry_display.js
define("views/dialer/entry_display", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core            = require('bolt/core');
var View            = require('bolt_touch/view').View;

var EllipsifiedText =
  require('shared/boltwidget/ellipsified_text').EllipsifiedText;

var AsYouTypeFormatter;

/**
 * This is the entry display to be used by each type of entry display to be
 * added to the DialerScene. The current options are as follows:
 *
 * - fontSize: the font size of the entry dialer; defaults to 60
 * - addClasses: string of classes to add to the entry display
 * - addChildren: array of child objects to add to the entry display
 */
var EntryDisplay = exports.EntryDisplay = core.createClass({
  name: 'EntryDisplay',
  extend: View,

  properties: {
    phoneApi: null
  },

  declare: function(options) {
    var classes = 'bt-dial-string callee';
    if (options.addClasses) {
      classes += ' ' + options.addClasses;
    }

    var fontSize = options.fontSize || 55;
    var resizeLength = options.resizeLength || 13;

    var children = [{
        ref: 'dialString',
        additionalClasses: classes,
        view: EllipsifiedText,
        maxLength: 30,
        fontSize: fontSize,
        elmWidth: 440,
        resizeLength: resizeLength
      }];

    if (options.addChildren) {
      children = children.concat(options.addChildren);
    }

    return {
      childViews: children
    };
  },

  ready: function() {
    this.setPhoneApi(FBAPI.use('phone'));
    this.dialString = this.refs.dialString;
    AsYouTypeFormatter = AsYouTypeFormatter ||
      require('third-party/libphonenumber').AsYouTypeFormatter;
    this.formatter = new AsYouTypeFormatter('US');
  },

  // number is the number to update to, if clear is set to true, then
  // we simply clear the formatter and push all the digits onto the formatter,
  // otherwise we only push the last digit
  updateNumber: function(number, clear) {
    var formattedNum = '';
    if (clear) {
      this.formatter.clear();
      var i;
      for (i = 0; i < number.length; i ++) {
        formattedNum = this.formatter.inputDigit(number.charAt(i));
      }
    } else {
      formattedNum = this.formatter.inputDigit(number.substr(-1));
    }
    this.setNumber(formattedNum);
  },

  setNumber: function(number) {
    this.dialString.setText(number);
  }
});
});

// module: ufi/client/index
// file:   ../../ufi/client/index.js
define("ufi/client/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var ManagedCollectionShadow =
  require('shared/shadowbroker/shadow/managed_collection/managed_collection_shadow')
    .ManagedCollectionShadow;
var session = require('shared/session');
var CommentModel = require('shared/data2/model/comment/model').CommentModel;
var LikeCollectionShadow =
  require('../model/like_collection_shadow').LikeCollectionShadow;

/**
 * @classdesc UfiClient communicates with and exposes the API for the
 * SharedWorker for UFI.
 */
var UfiClient = core.createClass({

  _broker: null,

  construct: function(broker) {
    this._broker = broker;
  },

  fetchCommentCollection: function(target) {
    var targetIdInfo = {
      idType: target.getFeedbackIdType(),
      id: target.getFeedbackId()
    };
    return this._broker
      .callMethod('ufi', 'fetchCommentCollection', targetIdInfo)
      .then(function(channel) {
        var shadowCollection = new ManagedCollectionShadow({modelType: CommentModel});
        shadowCollection.setChannel(channel);
        return shadowCollection;
      }, this);
  },

  postComment: function(message, target) {
    var commentData = {
      text: message,
      time: Date.now(),
      likes: {user_likes: false, count: 0, can_like: true},
      // temporary solution
      actor: {
        name: session.getName(),
        id: session.getUid(),
        pic_big: session.getPicture(),
        type: 'user'
      }
    };
    commentData[target.getFeedbackIdType()] = target.getFeedbackId();
    return this._broker
      .callMethod('ufi', 'postComment', commentData, target.getFeedbackId());
  },

  fetchLikeCollection: function(target, friends) {
    var targetIdInfo = {
      idType: target.getFeedbackIdType(),
      id: target.getFeedbackId()
    };
    return this._broker
      .callMethod('ufi', 'fetchLikeCollection', targetIdInfo, friends)
      .then(function(channel) {
        var shadowCollection = new LikeCollectionShadow();
        shadowCollection.setTarget(target);
        shadowCollection.setChannel(channel);
        return shadowCollection;
      }, this);
  }
});

var _instance = null;
exports.getInstance = function() {
  if (!_instance) {
    _instance = new UfiClient(require('./broker').getInstance());
  }
  return _instance;
};
});

// module: mock/push_api
// file:   ../../mock/js/push_api.js
define("mock/push_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;

module.exports = {
  _state: 'CONNECTED',
  _stateDuration: 1,
  _kickstartInterval: 5 * 1000,
  _keepaliveInterval: 4 * 60 * 1000,
  _networkType: 'mobile',
  _networkSubtype: 'HSPA',
  _networkState: 'CONNECTED',
  _topics: {},
  _sessionId: 1,
  _sequenceId: 1,
  _channelReset: false,
  _messageCount: 1,
  _missedCount: 0,
  _errorCount: 0,

  NOTIFY_STATE: 'push.NOTIFY_STATE',
  NOTIFY_RESET: 'push.NOTIFY_RESET',
  NOTIFY_MESSAGE: 'push.NOTIFY_MESSAGE',
  NOTIFY_CONNECT: 'push.NOTIFY_CONNECT',
  NOTIFY_DISCONNECT: 'push.NOTIFY_DISCONNECT',

  ALL_TOPICS: '*',

  isServiceBoundToApi: function() {
    return true;
  },

  setCredentials: function(username, password) {
  },

  registerTopic: function(topic) {
    // Issue a connect notification in case this is from a new client.
    this._notifyEvent(this.NOTIFY_CONNECT);
    this._topics[topic] = true;
  },

  unregisterTopic: function(topic) {
    delete this._topics[topic];
  },

  notifyMessageTestHook: function(topic) {
    var _this = this;
    setTimeout(function() {
      if (_this._topics[topic] || _this._topics[_this.ALL_TOPICS]) {
        EventManager.broadcastEvent(
          _this.NOTIFY_MESSAGE,
          {
            topic: topic,
            message: 'test'
          }
        );
      }
    }, 0);
  },

  notifyStateTestHook: function(topic) {
    this._notifyEvent(this.NOTIFY_STATE);
  },

  killServiceTestHook: function() {
  },

  _notifyEvent: function(type) {
    var _this = this;
    setTimeout(function() {
      EventManager.broadcastEvent(
        type,
        {
          state: _this._state,
          stateDuration: _this._stateDuration,
          kickstartInterval: _this._kickstartInterval,
          keepaliveInterval: _this._keepaliveInterval,
          networkType: _this._networkType,
          networkSubtype: _this._networkSubtype,
          networkState: _this._networkState,
          topics: Object.keys(_this._topics),
          sessionId: _this._sessionId,
          sequenceId: _this._sequenceId,
          channelReset: _this._channelReset,
          messageCount: _this._messageCount,
          missedCount: _this._missedCount,
          errorCount: _this._errorCount
        });
    }, 0);
  }
};
});

// module: mock/auth_api
// file:   ../../mock/js/auth_api.js
define("mock/auth_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var md5 = require('third-party/md5');

var AuthenticationManager = {
  sUserId: null,
  sAccessToken: null,
  sApiKey: null,
  sSessionKey: null,
  sSessionSecret: null,

  setUserId: function(userId) {
    this.sUserId = userId;
  },

  getUserId: function() {
    return this.sUserId;
  },

  setAccessToken: function(accessToken) {
    this.sAccessToken = accessToken;
  },

  getAccessToken: function() {
    return this.sAccessToken;
  },

  setApiKey: function(apiKey) {
    this.sApiKey = apiKey;
  },

  getApiKey: function() {
    return this.sApiKey;
  },

  setSessionKey: function(sessionKey) {
    this.sSessionKey = sessionKey;
  },

  getSessionKey: function() {
    return this.sSessionKey;
  },

  setSessionSecret: function(sessionSecret) {
    this.sSessionSecret = sessionSecret;
  },

  getSessionSecret: function() {
    return this.sSessionSecret;
  },

  getMSiteAuthenticatedUrl: function(url) {
    var t = Math.floor((new Date()).getTime() / 1000);

    var rawSig = "" +
     "api_key=" + this.getApiKey() +
     "session_key=" + this.getSessionKey() +
     "t=" + t +
     "uid=" + this.getUserId() +
     "url=" + url + AuthenticationManager.getSessionSecret();

    var sig = md5.hex_md5(rawSig).toLowerCase();
    while (sig.length < 32) {
      sig = "0" + sig;
    }

    var newUrl = "https://m.facebook.com/auth.php?" +
     "api_key=" + this.getApiKey() +
     "&session_key=" + this.getSessionKey() +
     "&t=" + t +
     "&uid=" + this.getUserId() +
     "&url=" + window.encodeURIComponent(url) +
     "&sig=" + sig;

    return newUrl;
  }
};

module.exports = {
  isDeviceProvisioned: function() { return true; },
  provisionDevice: function() { return true; },
  setUserId: function(userId) {
    AuthenticationManager.setUserId(userId);
  },
  setAccessToken: function(accessToken) {
    AuthenticationManager.setAccessToken(accessToken);
  },
  setApiKey: function(apiKey) {
    AuthenticationManager.setApiKey(apiKey);
  },
  setSessionKey: function(sessionKey) {
    AuthenticationManager.setSessionKey(sessionKey);
  },
  setSessionSecret: function(sessionSecret) {
    AuthenticationManager.setSessionSecret(sessionSecret);
  },
  getAuthenticatedURL: function(url) {
    return AuthenticationManager.getMSiteAuthenticatedUrl(url);
  }
};
});

// module: photos/app/lib/model/album/album
// file:   ../../photos/app/lib/model/album/album.js
define("photos/app/lib/model/album/album", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core        = require('bolt/core');
var util        = require('bolt/util');
var Model       = require('bolt/model').Model;
var api_xhr     = require('shared/api_xhr');
var Likeable    = require('shared/data2/model/mixin/likeable').Likeable;
var Commentable = require('shared/data2/model/mixin/commentable').Commentable;
var Deferred    = require('shared/deferred').Deferred;
var session     = require('shared/session');
var albumStore;
var Constants   = require('../../controller/constants');

var Album = exports.Album = core.createClass({
  name: 'Album',

  extend: Model,

  mixins: [Likeable, Commentable],

  construct: function(options) {
    Model.call(this, options);
    albumStore = require('./album_store').getInstance();
  },

  storeModel: function() {
    return this.save();
  },

  getFeedbackIdType: function() {
    return Commentable.FEEDBACK_ID_OBJECT_TYPE;
  },

  save: function() {
    return albumStore.store([this]);
  },

  canLikeAndComment: function() {
    return (this.get('id') !== Constants.UNPUBLISHED_ALBUM_ID);
  },

  canDelete: function() {
    return (this.get('id') !== Constants.UNPUBLISHED_ALBUM_ID && this.get('type') !== 'profile');
  },

  getPhotos: function(limit) {
    var photoClient = require('../../client/photo_client').getInstance();
    var updatedTime = Math.round(this.get('last_sync_time') / 1000);
    return photoClient.fetchPhotosByAlbumId(this.get('id'), updatedTime, limit);
  },

  "delete": function() {
    var deferred = new Deferred();

    api_xhr.rest({
      aid: this.get('aid'),
      method: 'photos:deleteAlbum'
    }, /* readOnly */ false)
      .addCallback(function(response) {
        albumStore.remove([this.get('id')]);
        photoStore.deletePhotosByAlbumId(this.get('id'));
        deferred.succeed();
      }, this)
      .addErrback(function(response) {
        deferred.fail(response);
      });

    return deferred;
  },

  getCoverPhotoURL: function() {
    if (this.get('cover_photo') === '0') {
      return 'fbcf:///apps/photos/empty-album.jpg';
    }
    else if (!isNaN(this.get('cover_photo'))) {
      return thumb = "https://graph.facebook.com/" + this.get('cover_photo') +
        "/picture?access_token=" + session.getAccessToken() + "&type=album";
    }
    else {
      return this.get('cover_photo');
    }
  }
});
});

// module: mock/datetime_api
// file:   ../../mock/js/datetime_api.js
define("mock/datetime_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;

module.exports = {
  timeZoneList: JSON.stringify([
    {
      id: 'Pacific/Honolulu',
      name: 'Hawaii',
      offset: '-10'
    },
    {
      id: 'America/Anchorage',
      name: 'Alaska',
      offset: '-9'
    },
    {
      id: 'America/Los_Angeles',
      name: 'Pacific Time',
      offset: '-8'
    },
    {
      id: 'America/Denver',
      name: 'Mountain Time',
      offset: '-7'
    },
    {
      id: 'America/Chicago',
      name: 'Central Time',
      offset: '-6'
    },
    {
      id: 'America/New_York',
      name: 'Eastern Time',
      offset: '-5'
    }
  ]),

  autoTime: true,
  timeZone: 'America/Los_Angeles',
  timeFormat24: true,

  getAutoTime: function() {
    return this.autoTime;
  },

  setAutoTime: function(enable) {
    this.autoTime = !!enable;
    return true;
  },

  toggleAutoTime: function() {
    return this.setAutoTime(!this.getAutoTime());
  },

  setDate: function(day, month, year) {
    // Since we have no way of controlling the reported system time aside from
    // possibly altering the prototype of several Date functions, we just
    // do nothing here.
    console.info('Attempted to set date to ' + month + '/' + day + '/' + year);
    EventManager.broadcastEvent('info.CLOCK_CHANGED');
    return false;
  },

  setTime: function(hour, minute) {
    // Since we have no way of controlling the reported system time aside from
    // possibly altering the prototype of several Date functions, we just
    // do nothing here.
    var minuteDisplay = (minute < 10) ? '0' + minute : minute;
    console.info('Attempted to set time to ' + hour + ':' + minuteDisplay);
    EventManager.broadcastEvent('info.CLOCK_CHANGED');
    return false;
  },

  getTimeZoneList: function() {
    return this.timeZoneList;
  },

  getTimeZone: function() {
    return this.timeZone;
  },

  setTimeZone: function(id) {
    this.timeZone = id;
    EventManager.broadcastEvent('info.CLOCK_CHANGED');
  },

  getIs24HourFormat: function() {
    return this.timeFormat24;
  },

  setIs24HourFormat: function(enable) {
    this.timeFormat24 = !!enable;
    EventManager.broadcastEvent('info.CLOCK_CHANGED');
    return true;
  },

  toggle24HourFormat: function() {
    return this.setIs24HourFormat(!this.getIs24HourFormat());
  }
};
});

// module: view/location_button/location_button
// file:   view/location_button/location_button.js
define("view/location_button/location_button", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*global navigator: false */

// Location button that lets user select his/her location
var core = require('bolt/core');
var View = require('bolt_touch/view').View;

var bindOnce = require('shared/util/bind_once').bindOnce;

var Coords = require('shared/geo/coords').Coords;
var ActionableView = require('bolt_touch/views/actionable_view').ActionableView;

var SEND_LOCATION_KEY = 'talk:send_location';
var storage = window.localStorage || {};


var LocationButton = exports.LocationButton = core.createClass({

  name: 'LocationButton',

  extend: View,

  _requesting: false,
  _watching: false,

  properties: {
    coords: null
  },

  declare: function(options) {
    return {
      childViews: [
        {
          view: ActionableView,
          action: 'toggle',
          className: 'bt-location-button--icon'
        }
      ]
    };
  },

  setSendLocation: function(state) {
    storage[SEND_LOCATION_KEY] = state ? 1 : 0;
    this.toggleClass('bt-location-button_send_yes', !!state);
    if (!!state && !this._requesting) {
      this._requesting = true;
      navigator.geolocation.getCurrentPosition(
        bindOnce(this._onRecievePosition, this),
        bindOnce(this._onRecievePositionError, this));
    }
    if (!!state && !this._watching) {
      this._watching = true;
      navigator.geolocation.watchPosition(
        bindOnce(this._onRecievePosition, this));
    }
    return this;
  },

  getCoords: function() {
    // use FBAPI while geolocation is broken
    if (window.FBAPI) {
      var position = Coords.currentLocation();
      if (position) {
        this.set('coords', {
          latitude: position.latitude,
          longitude: position.longitude,
          accuracy: position.accuracy
        });
      }
    }
    return this.get('coords');
  },

  getSendLocation: function() {
    return storage[SEND_LOCATION_KEY] * 1 > 0;
  },

  ready: function() {
    this.setSendLocation(this.getSendLocation());
  },

  toggle: function() {
    this.setSendLocation(!this.getSendLocation());
  },

  _onRecievePosition: function(position) {
    this._requesting = false;
    this.set('coords', {
      latitude: position.coords.latitude,
      longitude: position.coords.longitude,
      accuracy: position.coords.accuracy
    });
  },

  _onRecievePositionError: function() {
    this._requesting = false;
  }
});
});

// module: third-party/json/cycle
// file:   ../../third-party/json/cycle.js
define("third-party/json/cycle", function(require, exports, module) {
//Douglas Crockford
//douglas@crockford.com
//
//https://github.com/douglascrockford/JSON-js

exports.decycle = function(object) {
  'use strict';

// Make a deep copy of an object or array, assuring that there is at most
// one instance of each object or array in the resulting structure. The
// duplicate references (which might be forming cycles) are replaced with
// an object of the form
//    {$ref: PATH}
// where the PATH is a JSONPath string that locates the first occurance.
// So,
//    var a = [];
//    a[0] = a;
//    return JSON.stringify(JSON.decycle(a));
// produces the string '[{"$ref":"$"}]'.

// JSONPath is used to locate the unique object. $ indicates the top level of
// the object or array. [NUMBER] or [STRING] indicates a child member or
// property.

  var objects = [],   // Keep a reference to each unique object or array
    paths = [];   // Keep the path to each unique object or array

  return (function derez(value, path) {

// The derez recurses through the object, producing the deep copy.

    var i,      // The loop counter
      name,     // Property name
      nu;     // The new object or array

    switch (typeof value) {
    case 'object':

// typeof null === 'object', so get out if this value is not really an object.

      if (!value) {
        return null;
      }

// If the value is an object or array, look to see if we have already
// encountered it. If so, return a $ref/path object. This is a hard way,
// linear search that will get slower as the number of unique objects grows.

      for (i = 0; i < objects.length; i += 1) {
        if (objects[i] === value) {
          return {$ref: paths[i]};
        }
      }

// Otherwise, accumulate the unique value and its path.

      objects.push(value);
      paths.push(path);

// If it is an array, replicate the array.

      if (Object.prototype.toString.apply(value) === '[object Array]') {
        nu = [];
        for (i = 0; i < value.length; i += 1) {
          nu[i] = derez(value[i], path + '[' + i + ']');
        }
      } else {

// If it is an object, replicate the object.

        nu = {};
        for (name in value) {
          if (Object.prototype.hasOwnProperty.call(value, name)) {
            nu[name] = derez(value[name],
              path + '[' + JSON.stringify(name) + ']');
          }
        }
      }
      return nu;
    case 'number':
    case 'string':
    case 'boolean':
      return value;
    }
  }(object, '$'));
};
});

// module: bolt/tag_view
// file:   ../../../frameworks/bolt/lib/tag_view.js
define("bolt/tag_view", function(require, exports, module) {
/**
 * Copyright (c) 2011-2012, Facebook, Inc.
 * All rights reserved.
 *
 * @option preserve-header
 *
 */

var util     = require('./util');
var core     = require('./core');
var dom      = require('./dom');

var Container = require('./mixins/container').Container;

/**
 * A special (final) class that should be private to the builder. Noone should
 * ever need to instantiate an instance of TagView except the builder. View
 * classes in general do not need to delegate html attributes to the container
 * node, because many of them just don't make sense from the perspective of a
 * general container component. However a TagView is a container component that
 * is intended to be treated as a lower level building block in a build paln, or
 * declare() statement, so control over all attributes is important.
 */

var TagView = exports.TagView = core.createClass({

  name: 'TagView',

  mixins: [Container],

  /**
   * Accepts options and tagName. Usually tagName will be in the options, but
   * if you're allocating a TagView, you likely allready found the tagName -
   * pass it in so we don't need to look it up again.
   */
  construct: function(options) {
    options = options || {};
    this.setNode(dom.createElement(options.tagName || 'div'));
    this.setup(options);
  },

  setName: function(name) {
    this._node.name = name;
    return this;
  },
  getName: function() {
    return this._node.name;
  },
  setHref: function(href) {
    this._node.href = href;
    return this;
  },
  getHref: function() {
    return this._node.href;
  },
  setId: function(id) {
    this._node.id = id;
    return this;
  },
  getId: function() {
    return this._node.id;
  },
  setTagName: function(tagName) {
    // Do nothing - just make sure noone tries to set a tag name on a dom node
    // directly - causing an error in IE.
    return this;
  },
  getTagName: function() {
    return this._node.tagName;
  },

  delegateProperties: {
    node: [
      'disabled',
      'id',
      'tabIndex',
      'src',
      'cellpadding',
      'cellspacing',
      'htmlFor',
      'colspan',
      'rowspan',

      // Just in case someone uses additionalClasses on a tag view, expecting
      // it to gracefully append a className. In the case of tag views, there's
      // nothing to gracefully append to so we just set the class.
      { name: 'className', alias: 'additionalClasses'}
    ],
    style: [
      'height',
      'width'
    ]
  }

});

});

// module: bolt_touch/mixins/touchable
// file:   ../../../frameworks/bolt_touch/lib/mixins/touchable.js
define("bolt_touch/mixins/touchable", function(require, exports, module) {
var View = require('../view').View;
var dom = require('bolt/dom');
var util = require('bolt/util');

var touchClassName = 'touched';

function handleTouchStart(event) {
  if (!this.getIsTouchable()) {
    return;
  }
  event = event.touches ? event.touches[0] : event;

  var target = this.getNode();
  this.__touched = {
    x: event.pageX,
    y: event.pageY,
    target: target
  };
  this.__moved = false;

  this.__addTouchable();
}

function handleTouchMove(event) {
  if (!this.getIsTouchable()) {
    return;
  }
  if (this.__touched && !this.__moved) {
    var touch = event = event.touches ? event.touches[0] : event;

    if (hasMovedPastLimit(this.__touched, touch, this.get('touchLimit'))) {
      this.__moved = true;
      this.__removeTouchable();
    }
  }
}

function handleTouchEnd(event) {
  if (!this.getIsTouchable()) {
    return;
  }
  if (this.__touched) {
    var touch = event.changedTouches ? event.changedTouches[0] : event;

    if (this.__moved ||
        hasMovedPastLimit(this.__touched, touch, this.get('touchLimit'))) {
      this.__removeTouchable();
      this.hasFinishedTouching(false, event);
    } else {
      this.hasFinishedTouching(true, event);
      this.__removeTouchable();
    }
  }

  this.__touched = null;
  this.__moved = false;
}

function hasMovedPastLimit(start, end, limit) {
  var xDiff = start.x - end.pageX;
  var yDiff = start.y - end.pageY;
  var dist = Math.sqrt((xDiff * xDiff) + (yDiff * yDiff));

  return dist > limit;
}

function addTouchable() {
  dom.addClass(this.getNode(), touchClassName);
}

function removeTouchable() {
  dom.removeClass(this.getNode(), touchClassName);
}

exports.Touchable = {

  properties: {
    isTouchable: true,
    // maximum distance, in pixels, a user can move before the action
    // is no longer considered a "touch"
    touchLimit: 30
  },

  mixinReady: function() {
    this.addListener(View.touchEvents.TOUCHSTART, handleTouchStart, this);
    this.addListener(View.touchEvents.TOUCHMOVE, handleTouchMove, this);
    this.addListener(View.touchEvents.TOUCHEND, handleTouchEnd, this);

    this.__addTouchable = util.bind(addTouchable, this);
    this.__removeTouchable = util.bind(removeTouchable, this);
  },

  /**
   * Delegate method, calld when the user is done touching the element.
   *
   * @param {Boolean} whether the element has been touched
   * @param {Object} the touchend event
   */
  hasFinishedTouching: function(wasTouched, event) { }
};
});

// module: bolt_touch/views/data_list/view_pool
// file:   ../../../frameworks/bolt_touch/lib/views/data_list/view_pool.js
define("bolt_touch/views/data_list/view_pool", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');


var id = 1;
function identify(view) {
  if (!view.__poolid) {
    view.__poolid = id++;
  }
  return view.__poolid;
}

/**
 * @class ViewPool
 * @classdesc ViewPool is used by ViewManager to track used and available views.
 * See ViewManager for more info.
 */
var ViewPool = core.createClass({
  name: 'DataListViewPool',

  construct: function() {
    this._free = {};
    this._usedType = {};
    this._usedView = {};
  },

  hold: function(view, type, objectId) {
    var id = identify(view);
    this._usedType[id] = type;
    this._usedView[id] = view;
    view.__poolobjectid = objectId;
  },

  release: function(view) {
    var id = identify(view);
    var type = this._usedType[id];
    if (!type) {
      return null;
    }
    if (!this._free[type]) {
      this._free[type] = [];
    }
    this._free[type].push(view);
    this._usedType[id] = null;
    this._usedView[id] = null;
    return type;
  },

  acquire: function(type, objectId) {
    if (this._free[type] && this._free[type].length) {
      var view;

      if (typeof objectId !== 'undefined') {
        // If an object id has been specified, then search for a view
        // that is free, but was previously assigned to that object id
        var arr = this._free[type];
        for (var i = 0, length = arr.length; i < length; i++) {
          if (arr[i].__poolobjectid === objectId) {
            view = arr.splice(i, 1)[0];
            break;
          }
        }
      }
      if (!view) {
        view = this._free[type].pop();
        view.__poolobjectid = objectId;
      }

      var id = identify(view);
      this._usedType[id] = type;
      this._usedView[id] = view;
      return view;
    }
    return null;
  },

  fetch: function(objectId) {
    var targetView = null;
    util.forEach(this._usedView, function(view) {
      if (view && view.__poolobjectid === objectId) {
        targetView = view;
      }
    });
    return targetView;
  },

  destroy: function() {
    var result = [];
    util.forEach(this._free, function(views) {
      result = result.concat(views);
    });
    util.forEach(this._usedView, function(view) {
      if (view) {
        result.push(view);
      }
    });
    result = util.unique(result);

    util.run(result, 'destroy');
    this._free = this._usedType = this._usedView = null;
  }
});


exports.ViewPool = ViewPool;
});

// module: bolt_touch/views/data_list/command_queue
// file:   ../../../frameworks/bolt_touch/lib/views/data_list/command_queue.js
define("bolt_touch/views/data_list/command_queue", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var CircularBuffer = require('./circular_buffer').CircularBuffer;

var INSERT = 1;
var REMOVE = 2;
var RESIZE = 3;
var REDRAW = 4;

/**
 * @class CommandQueue
 * @classdesc A queue of commands for DataList. Available commands are
 * INSERT, REMOVE, REMOVE, and REDRAW. CommandQueue tries to reuse command
 * objects instead of creating new ones to save memory.
 *
 * CommandQueue also merges similar commands into one. So two subsequent REDRAW
 * are merged into one.
 */
var CommandQueue = core.createClass({
  name: 'CommandQueue',

  /**
   * @return {CommandQueue}
   */
  construct: function() {
    this._queue = new CircularBuffer();
    this.length = 0;
  },

  /**
   * Pushes command into the queue
   * @param {Integer} action
   * @param {Integer} index
   * @param {Model}   model
   */
  push: function(action, index, model) {
    var last = this.length > 0 && this._queue.get(this.length - 1);
    if (last && last.index === index) {
      // resizing or redraing
      if (last.action === INSERT && (action === RESIZE || action === REDRAW)) {
        return;
      }

      if ((last.action === RESIZE || last.action === REDRAW) &&
        (action === RESIZE || action === REDRAW)) {
          last.action = (last.action === RESIZE || action === RESIZE) ?
            RESIZE : REDRAW;
          return;
        }

      if (last.action != REMOVE && action === REMOVE) {
        this.shift();
        return;
      }
    }
    this._push(action, index, model);
  },

  _push: function(action, index, model) {
    if (this._queue.length == this.length) {
      this._queue.push({});
    }
    var current = this._queue.get(this.length);
    current.action = action;
    current.index  = index;
    current.model  = model;
    this.length++;
  },

  /**
   * Returns and removes the first command from the queue.
   * Command has the following options:
   * {
   *   action: INSERT, REMOVE, REMOVE or REDRAW,
   *   index: 12,
   *   model: [object Model]
   * }
   *
   * @return {Object}
   */
  shift: function() {
    if (this.length > 0) {
      this.length--;
      return this._queue.shift();
    }
    return 0;
  },

  /**
   * Clears the queue
   */
  clear: function() {
    this.length = 0;
    this._queue.clear();
  }
});
CommandQueue.INSERT = INSERT;
CommandQueue.REMOVE = REMOVE;
CommandQueue.RESIZE = RESIZE;
CommandQueue.REDRAW = REDRAW;


exports.CommandQueue = CommandQueue;});

// module: mock/connectivity_api
// file:   ../../mock/js/connectivity_api.js
define("mock/connectivity_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;

module.exports = {
  _voicemailFeatureConnected: false,

  APN_ALREADY_ACTIVE: 0,
  APN_REQUEST_STARTED: 1,
  APN_TYPE_NOT_AVAILABLE: 2,
  APN_REQUEST_FAILED: 3,

  _getActiveNetworkInfoJson: function() {
    var wifiApi = FBAPI.use('wifi');
    var connectionInfo = JSON.parse(wifiApi.getConnectionInfo());
    return {
      type: (connectionInfo.state === wifiApi.STATE_CONNECTED) ? 'WIFI' : 'MOBILE',
      isConnected: true,
      detailedState: 'CONNECTED',
      id: 'fbguest'
    };
  },

  startUsingVoicemailFeature: function() {
    if (this._voicemailFeatureConnected) {
      return this.APN_ALREADY_ACTIVE;
    }

    var _this = this;
    setTimeout(
      function() {
        _this._voicemailFeatureConnected = true;
        EventManager.broadcastEvent(
          'connectivity.DATA_NETWORK_STATE_CHANGED',
          _this._getActiveNetworkInfoJson());
      },
      2 * 1000);
    return this.APN_REQUEST_STARTED;
  },

  stopUsingVoicemailFeature: function() {
    var _this = this;
    setTimeout(
      function() {
        _this._voicemailFeatureConnected = false;
        EventManager.broadcastEvent(
          'connectivity.DATA_NETWORK_STATE_CHANGED',
          _this._getActiveNetworkInfoJson());
      },
      2 * 1000);
  },

  isVoicemailFeatureAvailable: function() {
    return true;
  },

  isVoicemailFeatureConnected: function() {
    return this._voicemailFeatureConnected;
  },

  getActiveNetworkInfo: function() {
    return JSON.stringify(this._getActiveNetworkInfoJson());
  },

  getPageDownloadUrl: function(useHttps, kilobytes) {
    if ((kilobytes < 0) || (kilobytes > 1024)) {
      return '';
    }
    return (useHttps ? 'https' : 'http') +
      '://www.facebook.com/diagnostics/gen_size.php?q=' +
      kilobytes + 'k';
  },

  runPageDownloadTest: function(useHttps, kilobytes) {
    var startTime = new Date();
    var kilobytesDownloaded = 0;
    var progressTimer = setInterval(
      function() {
        kilobytesDownloaded++;
        EventManager.broadcastEvent(
          'connectivity.PAGE_DOWNLOAD_PROGRESS',
          {
            kilobytesDownloaded: kilobytesDownloaded,
            elapsedTime: new Date() - startTime
          });
        if (kilobytesDownloaded === kilobytes) {
          EventManager.broadcastEvent(
            'connectivity.PAGE_DOWNLOAD_COMPLETE',
            { elapsedTime: new Date() - startTime });
          clearInterval(progressTimer);
        }
      },
      10);
  }
};
});

// module: shared/data/key_value_store
// file:   ../../shared/js/data/key_value_store.js
define("shared/data/key_value_store", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core           = require('bolt/core');
var util           = require('bolt/util');
var Deferred       = require('shared/deferred').Deferred;
var StoreBase      = require('shared/data/store_base').StoreBase;
var SqlBuilder     = require('shared/data/sql_builder').SqlBuilder;
var SqlTransaction = require('shared/data/sql_transaction').SqlTransaction;

var KeyValueStore = core.createClass({
  name: 'KeyValueStore',
  extend: StoreBase,

  getStoreVersion: function() {
    return 1.1;
  },

  // source tells us where the key value pair came from. Its optional, but
  // useful if you want to later delete all your keys (which is the only thing
  // its used for).
  getTableColumns: function() {
    return ['key', 'value', 'source'];
  },

  getTableConstraints: function () {
    return ['PRIMARY KEY (key)'];
  },

  getItemWithTransaction: function(tx, params) {
    var builder = this.createSqlBuilder(params).addAllParamFilters();
    return this.getObjectWithTransaction(tx, builder);
  },

  getItemsWithTransaction: function(tx, params) {
    var builder = this.createSqlBuilder(params).addAllParamFilters();
    return this.getObjectsWithTransaction(tx, builder);
  },

  deleteItemWithTransaction: function(tx, id) {
    if(util.isBlank(id)) {
      return new Deferred().succeed();
    }
    var builder = this.createSqlBuilder({key: id}).addParamFilter('key');
    return this.deleteObjectWithTransaction(
      tx,
      id,
      builder
    );
  },

  /**
   * Deletes items that correspond to params.
   * Example query:
   *    deleteItemsWithTransaction(tx, {source: 'FriendRequestStore'});
   *
   * @param params {Object} The params to filter the selection to (property
   *   mappings).
   * @return {Object} A SqlTransaction deferred object that you can chain on
   */
  deleteItemsWithTransaction: function(tx, params) {
    var builder = this.createSqlBuilder(params).addAllParamFilters();
    return this.deleteObjectsWithTransaction(
      tx,
      builder,
      'key'
    );
  },

  updateOrCreateItemWithTransaction : function (tx, obj) {
    if(util.isBlank(obj) ||
       util.isBlank(obj.key)) {
      return new Deferred().succeed();
    }
    var builder = this.createSqlBuilder(obj).addParamFilter('key');
    return this.updateOrCreateObjectWithTransaction(
      tx, obj.key, builder);
  }

});

StoreBase.defineTransactionWrapperFunctions(KeyValueStore, [
  'getItem',
  'getItems',
  'updateOrCreateItem',
  'deleteItem',
  'deleteItems'
]);

exports.KeyValueStore = new KeyValueStore();
});

// module: bolt/feature_detect
// file:   ../../../frameworks/bolt/lib/feature_detect.js
define("bolt/feature_detect", function(require, exports, module) {
// some code borrowed from Modernizr (www.modernizr.com)

var cssPrefixes = ['Webkit', 'Moz', 'O', 'ms'];

/*
 * Use a element with custom tag for feature detection.
 */
var elem;
function getElem() {
  if (!elem) {
    elem = document.createElement('boltfeaturetester');
  }
  return elem;
}

function getStyleObj() {
  return getElem().style;
}

/**
 * Browser specific CSS properties are prefixed.  For example, the transition
 * CSS property appears as WebkitTransition in Chrome and Safari, MozTransition
 * in Firefox, OTransition in Opera, msTransition on IE, and transition on
 * future browsers when it's a standard.
 *
 * @param  {String} prop property to look for
 * @return {String} prefixed property, or false if not available
 */
function prefixedCSS(prop) {
  // prefixed properties begin with uppercase
  var ucProp = prop.charAt(0).toUpperCase() + prop.substr(1);
  var props = new Array(cssPrefixes.length + 1);
  // first check the raw property
  props[0] = prop;
  // then check all property prefixes
  for (var i = 1; i <= cssPrefixes.length; i++) {
    props[i] = cssPrefixes[i - 1] + ucProp;
  }
  var style = getStyleObj();
  for (var i = 0; i < props.length; i++) {
    if (typeof(style[props[i]]) !== 'undefined') {
      return props[i];
    }
  }
  return false;
}

/**
 * Browser specific events can be detected by checking for prefixed CSS
 * properties.  For compatibility reasons, eventName should be camelcased; it
 * will automatically be lowercased when necessary.
 *
 * TODO: This function is only verified with transition and animation events;
 * make sure it works in all other cases too.
 */
function prefixedEvent(cssProp, eventName) {
  // make first letter uppercase for camelcasing
  var ucEventName = eventName.charAt(0).toUpperCase() + eventName.substr(1);
  var prefixedProp = prefixedCSS(cssProp);
  var prefix = prefixedProp.slice(0, -cssProp.length).toLowerCase();
  switch (prefix) {
    case '':
      // unprefixed event should be supported
      return eventName.toLowerCase();
    case 'webkit':
      // Webkit uses CamelCase
      return 'webkit' + ucEventName;
    case 'moz':
      // Firefox doesn't prefix events
      return eventName.toLowerCase();
    case 'o':
      // Opera uses lowercase in version >=12, CamelCase in <=11?
      // let's just support newest version
      return 'o' + eventName.toLowerCase();
    case 'ms':
      // IE does camelcase weirdly, because it prefixes with MS instead of ms
      return 'MS' + ucEventName;
    default:
      return false;
  }
}

exports.prefixedCSS = prefixedCSS;
exports.prefixedEvent = prefixedEvent;
});

// module: views/composer/js/composer_scene
// file:   ../../views/composer/js/composer_scene.js
define("views/composer/js/composer_scene", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core              = require('bolt/core');
var util              = require('bolt/util');
var Scene             = require('bolt_touch/views/scene').Scene;
var ComposerView      = require('./composer_view').ComposerView;

var ComposerScene = exports.ComposerScene = core.createClass({
  name: 'ComposerScene',

  extend: Scene,

  properties: {
    // The composeType of the contained ComposerView (null, 'photo' or 'place').
    composeType: null
  },

  declare: function(options) {
    return {
      boxOrientation: 'vertical',

      childViews: [
        {
          boxOrientation: 'horizontal',
          additionalClasses: 'bt-bar',
          childViews: [
            {
              ref: 'backButton',
              additionalClasses: 'bt-bar-button bt-back-button left'
            },
            {
              flex: 1,
              content: 'Update Status',
              additionalClasses: 'bt-bar-title',
              ref: 'title'
            },
            {
              ref: 'shareButton',
              content: 'Share',
              additionalClasses: 'bt-bar-button right composer-share-button'
            }
          ]
        },
        {
          view: ComposerView,
          ref: 'composer',
          composerModel: options.composerModel,
          buttons: options.buttons,
          inScene: true,
          composeType: options.composeType
        }
      ]
    };
  },

  // Initial data binding
  ready: function() {
    this._composer = this.findRef('composer');
    this._initModalHandler =
      util.bind(this._composer.initModal, this._composer);
  },

  useHeader: function() {
    return false;
  },

  endTransition: function(dir) {
    if (dir === 'in') {
      this._composer.initPickers();
      // Need to yield so keyboard shows up promptly
      // TODO: A better way of doing this is on keyboard did appear.
      // We need to add this API.
      setTimeout(this._initModalHandler, 50);
    }
  },

  onComposerDidPostStatus: function(postParams) {
    if (this.getOwner().onComposerDidPostStatus) {
      this.getOwner().onComposerDidPostStatus(postParams);
    }
  },

  onComposerDidClose: function() {
    if (this.getOwner() !== this && this.getOwner().onComposerDidClose) {
      this.getOwner().onComposerDidClose();
    }
    this.getStack().pop();
  },

  _postStatus: function() {
    this._composer.postStatus();
  },

  _goBack: function() {
    this._composer.close();
  },

  backButtonClick: function(evt) {
    this._goBack();
  },

  shareButtonClick: function(evt) {
    this._postStatus();
  }
});
});

// module: shared/shadowbroker/mock/shared_worker
// file:   ../../shared/js/shadowbroker/mock/shared_worker.js
define("shared/shadowbroker/mock/shared_worker", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core = require('bolt/core');
var util = require('bolt/util');
var Events = require('bolt/mixins/events').Events;

function addEventListener(event, listener) {
  this.addListener(event, listener);
}

function removeEventListener(event, listener) {
  this.removeListener(event, listener);
}

var _iframe;
function getTestIframe() {
  if (!_iframe) {
    _iframe = document.createElement('iframe');
    _iframe.style.cssText = 'postion:absolute;left:-999em;width:1px;height:1px';
    document.body.appendChild(_iframe);
  }
  return _iframe;
}

/**
 * Current Event manager does not let me to override anythign but type and data.
 * And I need to override target and ports.
 */
function invokeSpecial(eventObject) {
  var args = [eventObject];
  var listener;

  if (this._tokenList) {
    var tokens = this._tokenList.getTokensForType(eventObject.type);
    for (var i = 0, l = tokens.length; i < l; i++) {
      var item = tokens[i];
      if (!item.isDestroyed && item.listener) {
        item.listener.apply(
          item.context || this,
          item.args ? item.args.concat(args) : args);
      }
    }
  }
  var method = 'on' + eventObject.type;
  if (this[method]) {
    this[method](eventObject);
  }
  return this;
}


var Port = core.createClass({
  name: 'Port',
  mixins: [Events],

  _other: null,

  addEventListener: addEventListener,
  removeEventListener: removeEventListener,
  invokeSpecial: invokeSpecial,

  _setOther: function(other) {
    this._other = other;
  },

  postMessage: function(data) {
    // Send a message to a dummy iframe to invoke structural clone algorithm
    // So we can check if the data is clonable
    getTestIframe().contentWindow.postMessage(data, '*');
    this._other.invokeSpecial({
      type: 'message',
      target: this._other,
      data: data
    });
  },

  start: function() {
    // do nothing, just support the API
  }
});

var SharedWorker = core.createClass({
  name: 'SharedWorker',

  _context: null,
  port: null,

  construct: function(context) {
    this._context = context;
    var workerPort = new Port();
    this.port = new Port();
    workerPort._setOther(this.port);
    this.port._setOther(workerPort);

    this._context.invokeSpecial({
      type: 'connect',
      ports: [workerPort]
    });
  }
});


var SharedWorkerContext = core.createClass({
  name: 'SharedWorkerContext',

  mixins: [Events],

  addEventListener: addEventListener,
  removeEventListener: removeEventListener,
  invokeSpecial: invokeSpecial
});


exports.SharedWorkerContext = SharedWorkerContext;
exports.SharedWorker = SharedWorker;
});

// module: shared/event_manager
// file:   ../../shared/js/event_manager.js
define("shared/event_manager", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var util   = require('bolt/util');
var Events = require('bolt/mixins/events').Events;
var EventManager = require('bolt_touch/util/event_manager').EventManager;
var logger = require('shared/logger').logger;
var global = this;

exports.EventManager = EventManager;

// load glitter if available
var glitter = global.FBAPI && FBAPI.use('glitter');

function handleAll(event) {
  this.listener.apply(
    this.context,
    [event.type].concat(Array.prototype.slice.call(arguments, 1)));
}

function handleSingle() {
  this.listener.apply(this.context, Array.prototype.slice.call(arguments, 1));
}

// broadcast an event out to other webviews using the Java bridge.
EventManager.broadcastEvent = function(evt, data) {
  var loggerId = logger.startTimer('broadcastEvent', logger.ALLOW_OVERLAPPING);
  data = data || {};
  this.invoke(evt, data);
  if (glitter) {
    glitter.sendSystemMessage(
      'event_manager.BROADCAST_EVENT',
      JSON.stringify({evt: evt, data: data, loggerId: loggerId}));
  }
};

// send a message to the core web view
EventManager.notifyCore = function(evt, data) {
  data = data || {};
  if (glitter) {
    glitter.sendSystemMessage(evt, JSON.stringify(data));
  }
};

EventManager.addListener = function(type, callback, contextOrNull) {
  if (glitter) {
    glitter.sendSystemMessage(
      'event_manager.LISTEN',
      JSON.stringify({evt: type}));
  }

  if (!this._hasDomListener && global.document) {
    document.addEventListener('systemmessage', this.domListener, false);
    this._hasDomListener = true;
  }

  return Events.addListener.call(this, type, callback, contextOrNull || this);
};

EventManager.listen = function(type, callback, contextOrNull) {
  // We have to wrap the handler with this one because the signature of the
  // handler has been changed in bolt but not here yet (see handleSingle for
  // details).
  var token =
    this.addListener.call(this, type, callback, contextOrNull || this);
  token.boundListener = type === 'all' ? handleAll : handleSingle;
  return token;
};

EventManager.domListener = function(evt) {
  var data;
  if (typeof evt.detail.data === 'string') {
    try {
      data = JSON.parse(evt.detail.data);
    } catch (e) {
      var msg = 'Error occurred parsing json event detail data in EventManager';
      console.error(msg);
      throw e;
    }
  } else {
    data = evt.detail.data;
  }
  EventManager.invoke(evt.detail.evt, data);
};

EventManager.removeListener = function(evt) {
  if (glitter) {
    glitter.sendSystemMessage(
      'event_manager.REMOVE_LISTENER',
      JSON.stringify({evt: evt}));
  }
  return Events.removeListener.apply(this, arguments);
};
});

// module: views/contacts_table/search_contacts_table
// file:   ../../views/contacts_table/search_contacts_table.js
define("views/contacts_table/search_contacts_table", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core                   = require('bolt/core');
var util                   = require('bolt/util');

var Collection             = require('bolt/collection').Collection;
var ContactCell =
  require('views/contacts_table/contacts_cell').ContactsCell;
var TableView              = require("views/deprecated/table_view").TableView;
var TableViewCollectionSource =
  require('bolt_touch/mixins/table_view_collection_source').TableViewCollectionSource;
var View                   = require('bolt_touch/view').View;

var SearchContactsTable = exports.SearchContactsTable = core.createClass({
  name: 'SearchContactsTable',
  extend: View,

  properties: {
    filter: ''
  },

  mixins: [TableViewCollectionSource],

  declare: function(options) {
    return {
      childViews: [
        {
          view: 'TableView',
          ref: 'table',
          additionalClasses: 'bt-contacts-table',
          flex: 1,
          sectioned: false,
          bufferSize: 4,
          fixedRowHeight: 64
        }
      ]
    };
  },

  ready: function() {
    console.warn('ScrollContactsTable is broken until its rewired to use ' +
      'new Contacts data');
    this.table = this.refs.table;
    this.setTableView(this.table);
    this.filterForSearch = util.bind(this.filterForSearch, this);
  },

  resetFilter: function() {
    this.setCollection(new Collection());
    this.table.refresh();
  },

  setFilter: function(filter) {
    this.set('filter', filter);
    this.filterRegex = new RegExp('\\b' + filter, 'i');
    // TODO: Collection should be set to a filtered collection of the
    // using the filterForSearch function.
    var matches = null;
    this.setCollection(matches);
    this.table.refresh();
    this.table.scrollToTop();
  },

  setFilterFunction: function(filter) {
    if (filter === this.filterFunction) {
      return;
    }
    this.filterFunction = filter;
    if (this.filterRegex) {
      // TODO: Collection should be set to a filtered collection of the
      // using the filterForSearch function.
      var matches = null;
      this.setCollection(matches);
      this.table.refresh();
    }
  },

  filterForSearch: function(model) {
    if (this.filterFunction) {
      return this.filterFunction(model) &&
        this.filterRegex.test(model.get('name'));
    }
    return this.filterRegex.test(model.get('name'));
  },

  createTableViewCell: function(tableView, model, row, section) {
    return new ContactCell();
  },

  cellSelectedAtRowInSection: function(tableView, row, section, cell) {
    var owner = this.getOwner();
    if (owner && owner.onContactSelect) {
      owner.onContactSelect(cell.getModel());
    }
  }
});
});

// module: shared/shadowbroker/broker/channel
// file:   ../../shared/js/shadowbroker/broker/channel.js
define("shared/shadowbroker/broker/channel", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*global undefined:false*/
var core = require('bolt/core');
var util = require('bolt/util');

/**
 * An object that maintains an open channel between a client and a worker
 * Both client and worker can send messages to the Channle objects on it's side.
 * Messages will be received by Channle object on the other side and propagated
 * to the actor (if available).
 *
 *     +----+         /\
 *     |    |       /    \
 *     |    |     /-+----+-\
 *   \-+----+-/     |    |
 *     \    /       |    |
 *       \/         +----+
 *
 *
 * @example
 *
 *   // client.js
 *   var consoleChannel = new Channel();
 *   channel.setActor({
 *     reactToMessage: function(text) {
 *       console.log(text);
 *     }
 *   });
 *   broker.callMethod('system', 'initConsole', consoleChannel)
 *
 *   // worker.js
 *   broker.registerController('system', {
 *     initConsole: function(consoleChannel) {
 *       consoleChannel.sendMessage('hello from a worker');
 *     }
 *   });
 *
 */
var Channel = core.createClass({
  name: 'Channel',

  _id: null,
  _broker: null,
  _actor: {},
  _data: null,
  _open: undefined,

  /**
   * Called right after connection is created by the broker
   */
  construct: function(id, data) {
    this._id   = id || util.generateUUID();
    this._data = data || null;
  },

  setInitialData: function(data) {
    this._data = data;
    return this;
  },

  getInitialData: function() {
    return this._data;
  },

  clearInitialData: function() {
    this._data = null;
  },

  getId: function() {
    return this._id;
  },

  setActor: function(actor) {
    this._actor = actor;
    return this;
  },

  isOpen: function() {
    return this._open;
  },


  // Channel API
  close: function() {
    this._broker.closeChannel(this);
  },

  /**
   * Send message to the client counterpart. Wait for activate before using this
   * method
   */
  sendMessage: function(message) {
    this._broker.sendChannelMessage(this, message);
  },


  // Broker API
  // Will be called by broker. Do not invoke
  /**
   * Called right after the data has been sent to the client
   */
  reactToOpen: function(broker) {
    if (this._open !== undefined) {
      return;
    }
    this._broker = broker;
    this._open = true;
    if (this._actor.reactToOpen) {
      this._actor.reactToOpen(broker);
    }
  },

  reactToClose: function() {
    if (this._open === undefined) {
      this.reactToOpen();
    }
    this._open = false;
    if (this._actor.reactToClose) {
      this._actor.reactToClose();
    }
  },

  reactToMessage: function(message) {
    if (this._actor.reactToMessage) {
      this._actor.reactToMessage(message);
    }
  }
});


exports.Channel = Channel;
});

// module: bolt/compat/util
// file:   ../../../frameworks/bolt/lib/compat/util.js
define("bolt/compat/util", function(require, exports, module) {
/**
 * Copyright (c) 2011-2012, Facebook, Inc.
 * All rights reserved.
 *
 * @option preserve-header
 *
 */

var util = require('../util');

util.copy = function(dest, source, keepExisting) {
  require('../core').deprecated('util.copy');
  for (var name in source) {
    if (!keepExisting || !dest.hasOwnProperty(name)) {
      dest[name] = source[name];
    }
  }
  return dest;
};

util.reject = function(obj, iterator, context) {
  require('../core').deprecated('util.reject');
  if (!obj) {
    return [];
  }
  var hasLength = util.isNumber(obj.length);
  var results = (hasLength ? [] : {});
  util.forEach(obj, function(value, index, list) {
    if (!iterator.call(context, value, index, list)) {
      if (hasLength) {
        results[results.length] = value;
      } else {
        results[index] = value;
      }
    }
  });
  return results;
};

util.rejectKeys = function(obj, keys) {
  require('../core').deprecated('util.rejectKeys');
  return util.reject(obj, function(value, key) {
    return util.contains(keys, key);
  });
};

util.filterKeys = function(obj, keys) {
  require('../core').deprecated('util.filterKeys');
  // use reject because filter doesn't work on objects
  return util.reject(obj, function(value, key) {
    return !util.contains(keys, key);
  });
};

util.isBlank = function(obj) {
  require('../core').deprecated('util.isBlank');
  return util.isUndefined(obj) || util.isNull(obj) || (!util.isNumber(obj) && util.isEmpty(obj));
};

util.toBoolean = function(obj) {
  require('../core').deprecated('util.toBoolean');
  if (!util.isBoolean(obj)) {
    if (util.isString(obj)) {
      obj = ((/^t/i).test(obj)) || ('0' === obj);
    } else {
      obj = !!obj;
    }
  }
  return obj;
};

function _getProp(/*Array*/parts, /*Boolean*/create, /*Object*/context){
  var obj = context || window;
  for(var i = 0, p; obj && (p = parts[i]); i++) {
   obj = (p in obj ? obj[p] : (create ? obj[p] = {} : undefined));
  }
  return obj; // mixed
}

util.getObject = function(/*String*/name, /*Boolean?*/create, /*Object?*/context) {
  require('../core').deprecated('util.getObject');
  // summary:
  //    Get a property from a dot-separated string, such as "A.B.C"
  //  description:
  //    Useful for longer api chains where you have to test each object in
  //    the chain, or when you have an object reference in string format.
  //  name:
  //    Path to an property, in the form "A.B.C".
  //  create:
  //    Optional. Defaults to `false`. If `true`, Objects will be
  //    created at any point along the 'path' that is undefined.
  //  context:
  //    Optional. Object to use as root of path. Defaults to
  //    'dojo.global'. Null may be passed.
  return _getProp(name.split("."), create, context); // Object
};
});

// module: bolt_touch/mixins/has_event_listeners
// file:   ../../../frameworks/bolt_touch/lib/mixins/has_event_listeners.js
define("bolt_touch/mixins/has_event_listeners", function(require, exports, module) {
// This mixin provides event delegation. It uses querySelectorAll for that and
// is therefore not compatible with older browsers.

var util = require('bolt/util');

function removeFromNodeAndList() {
  this.node.removeEventListener(this.e, this.callback);

  var eventListeners = this.context._eventListeners;
  if (eventListeners) {
    for (var i = 0; i < eventListeners.length; i++) {
      if (eventListeners[i] === this) {
        eventListeners.splice(i,1);
        break;
      }
    }
  }
}

// add an event listener
// TODO: we currently have 3 addListener methods:
//  * bolt/mixins/container
//  * bolt/dom_event
//  * bolt_touch/mixins/has_event_listener
// There should really be only one of them.
function addListener(e, selector, callback) {
  var node = this.getNode();
  // wrap the callback invocation in a matching function that provides the
  // event delegation capability
  var self = this;
  function wrapper(e) {
    var matches = node.querySelectorAll(selector);
    for (var target = e.target; target && target !== node; target = target.parentNode) {
      for (var i = 0; i < matches.length; i++) {
        if (matches[i] === target) {
          self[callback](e, target);
        }
      }
    }
  }
  this._eventListeners = this._eventListeners || [];
  var listener = {
    e: e,
    selector: selector,
    callback: wrapper,
    node: node,
    context: this,
    remove: removeFromNodeAndList
  };
  this._eventListeners.push(listener);
  node.addEventListener(e, wrapper);
  return listener;
}

var HasEventListeners = exports.HasEventListeners = {
  mixinReady: function() {
    console.error('The HasEventListeners mixin is being deprecated. ' +
      'Please use the normal view event listening and flow');
  },

  // declaratively set event listeners
  setEventListeners: function(listeners) {
    this.clearEventListeners();
    // event listeners are defined with the format:
    // [comma separated event] [query selector]: [string callback name]
    // e.g.
    // 'mousedown,touchstart .foo.bar': 'onFooBarTouch'
    var splitter = /^(\S+)\s+(.*)$/;
    for (var eventKey in listeners) {
      var callback = listeners[eventKey];
      var match = eventKey.match(splitter);
      var events = match[1].split(',');
      var selector = match[2];
      for (var i = 0; i < events.length; i++) {
        var evt = events[i];
        addListener.call(this, evt, selector, callback);
      }
    }
  },

  // clear all event listeners
  clearEventListeners: function() {
    // must clone _eventListeners since it will mutate while traversing the
    // the array, or this will only remove every other listener
    util.invoke(
      this._eventListeners ? util.clone(this._eventListeners) : [],
      'remove'
    );
  }

};
});

// module: view/message_composer_scene/recipient_collection
// file:   view/message_composer_scene/recipient_collection.js
define("view/message_composer_scene/recipient_collection", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var Model = require('bolt/model').Model;
var Collection = require('bolt/collection').Collection;
var PhoneNumberUtil = require('third-party/libphonenumber').PhoneNumberUtil;

function modelToIdent(model) {
  return model.get('ident');
}

var RecipientCollection = core.createClass({
  name: 'RecipientCollection',
  extend: Collection,

  properties: {
    selectedModel: null,
    contactsList: null
  },

  construct: function(options) {
    this._idents = [];
    this.addListener('all', this._handleUpdate, this);

    if (options && options.contactsList) {
      this.setContactsList(options.contactsList);
    }

    Collection.call(this, options);
  },

  getIdents: function() {
    return this._idents;
  },

  setSelectedModel: function(model) {
    var selectedModel = this.getSelectedModel();
    if (selectedModel && selectedModel !== model) {
      selectedModel.set('selected', false);
    }
    if (model) {
      model.set('selected', true);
      return this.set('selectedModel', model);
    } else {
      return this.set('selectedModel', null);
    }
  },

  addRecipient: function(recipient) {
    if (!util.include(this.getIdents(), recipient.get('ident'))) {
      this.add(recipient);
    }
  },

  addContactRecipient: function(contact) {
    var name = contact.get('name') ||
      contact.getName(); // is a function in the contacts object
    var ident = '';
    if (contact.get('facebookId') * 1) {
      ident = 'fbid:' + contact.get('facebookId');
    } else {
      ident = 'lid:' + contact.get('id');
    }
    this.addRecipient(new Model({
      label: name,
      ident: ident
    }));
  },

  addEmailRecipient: function(email) {
    this.getContactsList().allContactsWithEmail(email)
      .then(this._addEmailRecipient, this, email);
  },

  addPhoneRecipient: function(phone) {
    this.getContactsList().allContactsWithPhoneNumber(phone)
      .then(this._addPhoneRecipient, this, phone);
  },

  _addEmailRecipient: function(email, contacts) {
    if (contacts && contacts.length > 0) {
      this.addContactRecipient(contacts[0]);
    } else {
      this.addRecipient(new Model({
        label: email,
        ident: 'email:' + email
      }));
    }
  },

  _addPhoneRecipient: function(phone, contacts) {
    if (contacts && contacts.length > 0) {
      this.addContactRecipient(contacts[0]);
    } else {
      this.addRecipient(new Model({
        label: PhoneNumberUtil.normalize(phone),
        ident: 'phone:' + PhoneNumberUtil.normalize(phone)
      }));
    }
  },

  _handleUpdate: function(e) {
    this._idents = this.map(modelToIdent);
  }
});

exports.RecipientCollection = RecipientCollection;
});

// module: views/composer/js/photo_action_sheet
// file:   ../../views/composer/js/photo_action_sheet.js
define("views/composer/js/photo_action_sheet", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core                   = require('bolt/core');
var View                   = require('bolt_touch/view').View;
var ActionSheet            = require('bolt_touch/views/action_sheet').ActionSheet;
var util              = require('bolt/util');

var PhotoActionSheet = exports.PhotoActionSheet = core.createClass({

  name: 'PhotoActionSheet',

  extend: View,

  declare: function(options) {
    return {
      eventListeners: {
      },

      childViews: [
        {
          tagName: 'img',
          ref: 'img',
          additionalClasses: 'composer-anim-thumbnail'
        },
        {
          view: ActionSheet,
          ref: 'actionSheet',
          actions: [
            {
              action: '_onRemovePhoto',
              additionalClasses: 'bt-on-camera',
              value: 'Remove'
            },
            {
              additionalClasses: 'bt-cancel',
              value: 'Cancel',
              action: '_onCancelRemovePhoto'
            }
          ]
        }
      ]
    };
  },

  ready: function() {
    this._actionSheet = this.findRef('actionSheet');
    this._actionSheet.findRef('actionContainer')
      .setStyle('margin-top', '100px');
    this._img = this.findRef('img');
    this._target = null;

    this._animHandler = util.bind(this._anim, this);
  },

  _onRemovePhoto: function() {
    if (this.getOwner().onRemovePhoto) {
      this.getOwner().onRemovePhoto(this._target.id);
    }
  },

  _onCancelRemovePhoto: function() {
    if (this.getOwner().onCancelRemovePhoto) {
      this.getOwner().onCancelRemovePhoto();
    }
  },

  // Show the action sheet, with an animation showing the thumbnail
  // flying from the start position to the end position.
  show: function(startTop,
                 startLeft,
                 endTop,
                 endLeft,
                 shieldHeight,
                 thumbnail) {

    this._actionSheet.show();
    this._actionSheet.setStyle({
      height: shieldHeight + 'px',
      bottom: - 2 * shieldHeight + 'px'
    });

    this._target = thumbnail;
    this._endTop = endTop;
    this._endLeft = endLeft;

    this._img.removeClass('anim');
    this._img.getNode().src = thumbnail.src;

    // Animate the photo moving into the
    // photo action sheet from its original
    // position.
    this._img.setStyle({
      'top': startTop + 'px',
      'left': startLeft + 'px'
    });

    setTimeout(this._animHandler, 1);
  },

  hide: function() {
    this._actionSheet.hide();
    this._img.removeClass('anim');
    this._img.getNode().style.left = '-1000px';
  },

  _anim: function() {
    this._img.addClass('anim');
    this._img.setStyle({
      'top': this._endTop + 'px',
      'left': this._endLeft + 'px'
    });
  }
});
});

// module: shared/data2/local/migration/index
// file:   ../../shared/js/data2/local/migration/index.js
define("shared/data2/local/migration/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var util = require('bolt/util');
var Deferred = require('shared/deferred').Deferred;
var sqlHelper = require('./sql_helper');

function _doMigration(migrations, transaction, currentVersion, desiredVersion) {
  var currentIndex, desiredIndex;
  var i;
  for (i = 0; i < migrations.length; i++) {
    if (migrations[i].getVersion() === currentVersion) {
      currentIndex = i;
    }
    if (migrations[i].getVersion() === desiredVersion) {
      desiredIndex = i;
    }
  }

  if (currentVersion === null) {
    // migrate from the start
    currentIndex = -1;
  }

  // use a Deferred to keep track of current progress of migrations; if
  // migration returns a Deferred this ensures the each migration won't start
  // until the previous one finishes
  var d = new Deferred().succeed();

  if (util.isUndefined(desiredIndex)) {
    // uh oh... cannot migrate to a version we can't find
    throw new Error('Cannot migrate to ' + desiredIndex + ': ' +
                    'version not found.');
  }

  if (util.isUndefined(currentIndex)) {
    // someone probably deleted a migration
    // best guess: someone was working on a branch with migration and switched
    // to a new branch without the migration.  reset from the latest version
    // (since the current version is probably newer), then start migrating from
    // scratch
    var latestMigration = migrations[migrations.length - 1];
    console.warn('Cannot migrate from ' + currentVersion + ': ' +
                 'version not found.  Resetting using version ' +
                 latestMigration.getVersion() + ' and starting migration ' +
                 'from scratch.');
    d = d.then(latestMigration.reset, latestMigration, transaction);
    currentIndex = -1;
  }

  if (currentIndex > desiredIndex) {
    // can't migrate backwards; gotta reset and start from scratch (losing all
    // data in the process).
    console.warn('Cannot migrate backwards from version ' +
                 currentVersion + ' to ' + desiredVersion + ': ' +
                 'resetting database and starting from scratch.');
    var currentMigration = migrations[currentIndex];
    d = d.then(currentMigration.reset, currentMigration, transaction);
    currentIndex = -1;
  }
  for (i = currentIndex + 1; i <= desiredIndex; i++) {
    d = d.then(migrations[i].up, migrations[i], transaction);
  }
}

function migrate(versionedDatabase, tableName, migrations, targetVersion) {
  if (util.isUndefined(targetVersion)) {
    // migrate to latest version
    targetVersion = migrations[migrations.length - 1].getVersion();
  }
  var doMigration = _doMigration.bind(null, migrations);
  return versionedDatabase.changeVersion(tableName, targetVersion, doMigration);
}

exports.migrate = migrate;
});

// module: talk/client/model/message/common_message_api
// file:   ../client/model/message/common_message_api.js
define("talk/client/model/message/common_message_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var STATE   = require('shared/data2/store/constants').STATE;
var util    = require('bolt/util');
var session = require('shared/session');

// matches MessageType in Orca
var MESSAGE_TYPES = require('./message_types').MESSAGE_TYPES;

var TEXTS_FOR_CALLS = {
  missed: 'Missed call from',
  cancelled: 'Missed call from',
  incoming: 'Call from',
  outgoing: 'Call to'
};

function add0(x) {
  return x < 10 ? '0' + x : x;
}


var CommonMessageAPI = {
  isLocal: function() {
    return this.get('remoteState') == STATE.LOCAL;
  },

  isFromMe: function() {
    if (this.get('sender') && this.get('sender').user_id &&
          session.getUid() == this.get('sender').user_id) {
      return true;
    } else {
      return false;
    }
  },

  getDateTime: function() {
    return new Date(this.get('timestamp') * 1);
  },

  getSource: function() {
    var source = '';

    // look at tags, then log_message, otherwise assume 'web'
    var tags = this.get('tags');
    for (var i = 0; i < tags.length; i++) {
      if (tags[i].indexOf('source:') === 0) {
        source = tags[i].substring('source:'.length);
        break;
      }
    }
    if (!source && this.get('log_message')) {
      if (this.get('log_message').smsLog ||
          this.get('log_message').callLog ||
          this.get('log_message').voiceMailLog) {
        source = 'mobile';
      }
    }
    if (!source) {
      source = 'web';
    }

    return source;
  },

  hasAttachments: function() {
    return this.get('attachments') && this.get('attachments').length;
  },

  hasError: function() {
    return this.get('localData').error ||
      (this.isLocal() &&
      !this.get('sending') &&
      !this.get('log_message').smsLog &&
      !this.get('log_message').callLog &&
      !this.get('log_message').voiceMailLog);
  },

  isSending: function() {
    return !!this.get('sending');
  },

  getSnippet: function() {
    return this.getText().substring(0, 2000);
  },

  getText: function() {
    var body = this.getCallMessage() || this.get('body') || '';
    if (this.get('subject')) {
      body = this.get('subject') + ' \u204D ' + body;
    }
    return body;
  },

  getCallMessage: function() {
    var log = this.get('log_message').callLog;
    if (!log) {
      return '';
    } else {
      var incall = require('shared/incall');
      var text = TEXTS_FOR_CALLS[log.type] + ' ';
      var peers = this.get('localData').callLogPeers;
      text += log.callEndPoint.split('|').join(', ');
      var duration = Math.round(log.duration / 1000);
      if (duration) {
        text += ' (' +
          Math.floor(duration / 60) + ':' + add0(duration % 60) +
          ')';
      }
      return text + '.';
    }
  }
};


exports.CommonMessageAPI = CommonMessageAPI;
});

// module: mock/security_api
// file:   ../../mock/js/security_api.js
define("mock/security_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var db = require('shared/data/db');

module.exports = {

  _showPasswords: false,
  _allowPopups: false,
  _defaultPin: '514732',
  // the pin should be the same in __tests__/security-test.js
  _allowThirdPartyCookies: false,

  _init: function() {
    if (!localStorage['pin']) {
      localStorage['pin'] = '514732';
    }
  },

  checkPin: function(pin) {
    this._init();
    return (pin === localStorage['pin']);
  },

  isDefaultPin: function(pin) {
    return pin === this._defaultPin;
  },

  isUsingDefaultPin: function() {
    this._init();
    return localStorage['pin'] === this._defaultPin;
  },

  setPin: function(pin) {
    this._init();
    localStorage['pin'] = pin;
    return true;
  },

  getShowPasswords: function() {
    return this._showPasswords;
  },

  setShowPasswords: function(enable) {
    this._showPasswords = enable;
    return true;
  },

  toggleShowPasswords: function() {
    return this.setShowPasswords(!this.getShowPasswords());
  },

  getAllowPopups: function() {
    return this._allowPopups;
  },

  toggleAllowPopups: function() {
    this._allowPopups = !this._allowPopups;
    return true;
  },

  acceptThirdPartyCookie: function() {
    return this._allowThirdPartyCookies;
  },

  toggleAcceptThirdPartyCookie: function() {
    this._allowThirdPartyCookies = !this._allowThirdPartyCookies;
    return true;
  },

  action: function() {
    console.error('Not implemented!');
  },

  clearCache: function() {
  },

  clearPasswords: function() {
  },

  clearCookies: function() {
  },

  clearStorage: function() {
  },

  doFactoryReset: function() {
    // clear localStorage, but preserve the developer's
    // requested log levels, the currently selected mock control panel,
    // and the state of the phone's skin
    var logLevels = window.top.ConsoleManager.getLogLevels();
    var MockControlPanelWidget = window.top.localStorage.MockControlPanelWidget;
    var hidePhoneSkin = window.top.localStorage.hidePhoneSkin;

    localStorage.clear();

    window.top.ConsoleManager.setLogLevels(logLevels);
    window.top.localStorage.MockControlPanelWidget = MockControlPanelWidget;
    if (hidePhoneSkin) {
      window.top.localStorage.hidePhoneSkin = hidePhoneSkin;
    }

    db.transaction(function(tx) {
      var sql = 'SELECT name FROM sqlite_master WHERE type = "table"';
      tx.executeSql(sql, [], function (tx, results) {
        for (var i = 0; i < results.rows.length; i++) {
          var table = results.rows.item(i).name;
          if (table === '__WebKitDatabaseInfoTable__') {
            continue;
          }

          tx.executeSql('DROP TABLE ' + table);
        }
      });
    }, null, function() {
      // Success Callback
       window.top.location.reload();
    });
  }
};
});

// module: system/mixins/springy_transform
// file:   ../../system/lib/mixins/springy_transform.js
define("system/mixins/springy_transform", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core            = require('bolt/core');
var util            = require('bolt/util');
var View            = require('bolt_touch/view').View;
var SpringAnimation = require('shared/springs').SpringAnimation;

// SpringyTransform
// Whatever mixes this in will have the following springy properties:
// - scale
// - translateX
// - translateY

// Since it can be annoying to call each of these properties individually,
// two helper methods are given:

// setTransform(transform)
//   where transform is: { scale: #, translate: [#, #] }
// As if calling the regular setScale/Translate

// setTransformDirect(transform)
// Same format as setTransform, but calls setDirect, and immediately
// resets each of the springs. This ends up setting the transform
// immediately without any spring effect.

var SpringyTransform = exports.SpringyTransform = {
  properties: {
    opacity: 1,
    scale: 1,
    translateX: 0,
    translateY: 0
  },

  springAnimation: {
    properties: [ 'opacity', 'scale', 'translateX', 'translateY'],
    ruleFunction: 'computeTransform'
  },

  mixinReady: function() {
    SpringAnimation.mixinReady.call(this);

    this.springAnimation.animator._springs[0].updateProperties({
      tolerance: 0.01
    });
    this.springAnimation.animator._springs[1].updateProperties({
      tolerance: 0.01
    });
  },

  setTransform: function(transform) {
    if (!transform.scale || !transform.translate ||
        transform.translate.length != 2) {
      // I don't care. It's a test.
      return;
    }

    this.setScale(transform.scale);
    this.setTranslateX(transform.translate[0]);
    this.setTranslateY(transform.translate[1]);
  },

  setTransformDirect: function(transform) {
    if (!transform.scale || !transform.translate ||
        transform.translate.length != 2) {
      // I don't care. It's a test.
      return;
    }

    this.setScaleDirect(transform.scale);
    this.setTranslateXDirect(transform.translate[0]);
    this.setTranslateYDirect(transform.translate[1]);
  },

  computeTransform: function(values) {
    var scale = Math.max(0, values.scale);
    return {
      opacity: Math.max(0, Math.min(1, values.opacity)),
      WebkitTransform:
        'translate3d(' + Math.round(values.translateX) + 'px, ' +
                         Math.round(values.translateY) + 'px, 0) ' +
        'scale3d(' + scale + ', ' + scale + ', 1)'
    };
  }
};

// Yo dawg, I heard you like mixins, so I mixed in your mixin so you can mix
// mix ins in.
var mixinReady = exports.SpringyTransform.mixinReady;
util.extend(exports.SpringyTransform, SpringAnimation);
exports.SpringyTransform.mixinReady = mixinReady;

exports.SpringyTransformView = core.createClass({
  name: 'SpringyTransformView',
  extend: View,

  mixins: [ SpringyTransform ]
});
});

// module: bolt_touch/views/data_list/scroll_view_adapter
// file:   ../../../frameworks/bolt_touch/lib/views/data_list/scroll_view_adapter.js
define("bolt_touch/views/data_list/scroll_view_adapter", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');

/**
 * @class ScrollViewAdapter
 * @classdesc ScrollViewAdapter abstracts all interactions with a ScrollView
 * from a DataList. The goal is to have optimized versions of ScrollViewAdapters
 * for different types of ScrollViews, like ScrollViewJ or native ScrollView.
 *
 * The API is limited. Adapter should be able to return the size of the
 * viewport and efficiently update the height. It should also notify dataList
 * when viewport changes.
 */
var ScrollViewAdapter = core.createClass({

  name: 'ScrollViewAdapter',

  _scrollView: null,
  _dataList: null,
  _isReverse: null,
  _offsetHeight: 0,
  _offsetTop: 0,
  _desiredHeight: 0,


  construct: function(scrollView, dataList, isReverse) {
    this._scrollView = scrollView;
    this._dataList = dataList;
    this._isReverse = isReverse;

    this._scrollView.addListener('scroll', this._onScroll, this);
    this._scrollView.addListener('resize', this._onResize, this);
    this._updateCache();
    this._performHeightUpdate = util.debounce(this._performHeightUpdate, 100);
  },

  destroy: function() {
    this._scrollView.removeListener('scroll', this._onScroll, this);
    this._scrollView.removeListener('resize', this._onResize, this);
  },

  updateHeight: function(height) {
    this._desiredHeight = height;
    this._performHeightUpdate();
  },

  getVisibleRange: function() {
    this._visibleRange = this._visibleRange || { from: 0, to: 0 };

    var height = this._scrollView.getViewportHeight();
    var topOffset = this._scrollView.getScrollTop() - this._offsetTop;

    if (this._isReverse) {
      var bottom = Math.max(this._offsetHeight - topOffset - height, 0);
      this._visibleRange.from = bottom;
      this._visibleRange.to   = bottom + height;
    } else {
      var top = Math.max(0, topOffset);
      this._visibleRange.from = top;
      this._visibleRange.to   = top + height;
    }
    return this._visibleRange;
  },

  _updateCache: function() {
    var node = this._dataList.getNode();
    this._offsetHeight = node.offsetHeight;
    this._offsetTop = node.offsetTop;
  },

  _onResize: function() {
    this._updateCache();
    this._dataList.update();
  },

  _onScroll: function() {
    this._dataList.update();
  },

  _performHeightUpdate: function() {
    if (this._isReverse) {
      bottom = this.getVisibleRange().from;
    }
    this._dataList.getNode().style.height = this._desiredHeight + 'px';
    if (this._scrollView.refresh) {
      this._scrollView.refresh();
    }
    if (this._isReverse) {
      var desiredScroll = this._scrollView.getScrollableAreaHeight() - bottom -
        this._scrollView.getRect().height;
      this._scrollView.setScrollTop(desiredScroll);
    }
  }
});


exports.ScrollViewAdapter = ScrollViewAdapter;
});

// module: talk/client/model/message/client_message
// file:   ../client/model/message/client_message.js
define("talk/client/model/message/client_message", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core             = require('bolt/core');
var util             = require('bolt/util');
var Model            = require('bolt/model').Model;
var Deferred         = require('shared/deferred').Deferred;
var attachmentUtil   = require('./attachment_util');
var CommonMessageAPI = require('./common_message_api').CommonMessageAPI;


var ClientMessage = exports.ClientMessage = core.createClass({
  extend: Model,

  name: 'ClientMessage',

  mixins: [CommonMessageAPI],

  _thread: null,
  _senderProfile: null,

  setSenderProfile: function(profile) {
    this._senderProfile = profile;
    return this;
  },

  setThread: function(thread) {
    this._thread = thread;
    return this;
  },

  getSenderProfile: function() {
    return this._senderProfile;
  },

  getThread: function() {
    return this._thread;
  },

  getThumbnailConstraints: function() {
    var totalAttachments = this.get('attachments').length;
    var maxHeight = 130;
    var maxWidth = 175;
    var preserveHeight = false;

    if (totalAttachments == 1) {
      maxHeight = 200;
      maxWidth = 350;
      preserveHeight = true;
    } else if (totalAttachments == 2) {
      maxHeight = 200;
      maxWidth = 175;
    } else if (totalAttachments == 3) {
      maxHeight = 150;
      maxWidth = 110;
    }
    return {
      height: maxHeight,
      width: maxWidth,
      preserveHeight: preserveHeight
    };
  },

  // Options
  // - thumbnail: true to get a small version of the image (default: false)
  //     if this is false, callback will be called with real URL, otherwise
  //     it will be called with an object containing data. To be refactored
  getAttachmentData: function(attachment, options) {
    var deferred = new Deferred();
    var defaultOptions = {
      thumbnail: false
    };
    options = util.defaults(options || {}, defaultOptions);

    if (options.thumbnail) {
      var constraints = this.getThumbnailConstraints();

      var url = attachmentUtil.urlForAttachment({
        attachmentId: attachment.id,
        messageId: this.get('id'),
        thumbnail: options.thumbnail,
        maxHeight: constraints.height,
        maxWidth: constraints.width
      });

      attachmentUtil.resizeAttachment({
        url: url,
        height: constraints.height,
        maxWidth: constraints.width,
        preserveHeight: constraints.preserveHeight,
        callback: function(status, data) {
          if (status === attachmentUtil.STATUS_ERROR) {
            deferred.fail();
          }
          deferred.succeed({
            dataURI: data.localUrl,
            width: data.width,
            height: data.height
          });
        }
      });
    } else {
      deferred.succeed(attachmentUtil.urlForAttachment({
          attachmentId: attachment.id,
          messageId: this.get('id')
        })
      );
    }
    return deferred;
  }

});
});

// module: view/home_scene/home_scene
// file:   view/home_scene/home_scene.js
define("view/home_scene/home_scene", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

// HomeScene is the main scene of talk app

var core          = require('bolt/core');
var build         = require('bolt/builder').build;
var Scene         = require('bolt_touch/views/scene').Scene;

var TabView       = require('view/tab_view/tab_view').TabView;
var Tab           = require('view/tab_view/tab_view').Tab;

var ThreadsScene  =
  require('view/threads_scene/threads_scene').ThreadsScene;
var DialerScene   =
  require('views/dialer/dialer_scene').DialerScene;
var DtmfKeypad    = require('incall/dtmf_keypad').DtmfKeypad;


var HomeScene = exports.HomeScene = core.createClass({
  name: 'Home',
  extend: Scene,

  properties: {
    controller: null,
  },

  declare: function(options) {
    return {
      boxOrientation: 'vertical',
      childViews: [
        {
          id: 'talkHomeScene',
          ref: 'tabview',
          flex: 1,
          view: TabView
        }
      ]
    };
  },

  ready: function() {
    var tab, scene;
    // Threads
    this._threadsScene = new ThreadsScene();
    this._threadsScene.setController(this.getController());

    tab = new Tab({
      id: 'recentsTab',
      content: 'Recents'
    });
    tab.view = build(this._threadsScene);

    this.findRef('tabview').addTab(tab);

    // Contacts
    tab = new Tab({
      id: 'contactsTab',
      content: 'Contacts',
      controller: this.getController()
    });
    var _this = this;
    //This is a bit of a hack, need to double back and clean up the tab view
    //stuff. It is needed to be able to lazy load the contacts scene
    tab.addListener('selected', function() {
      _this.invoke('contactsSelected');
    });

    var View = require('bolt_touch/view').View;
    tab.view = new View();
    this.findRef('tabview').addTab(tab);
    this._contactsTab = tab;

    // Dialer
    scene = new DialerScene({
      controller: this.getController(),
      purpose: DtmfKeypad.PURPOSE_TALK
    });

    tab = new Tab({
      id: 'dialpadTab',
      content: 'Dialpad'
    });
    tab.view = build(scene);
    this.findRef('tabview').addTab(tab);
  },

  setMailbox: function(mailbox) {
    this._threadsScene.setMailbox(mailbox);
  },

  getMailbox: function() {
    return this._threadsScene.getMailbox();
  },

  /**
   * Display the browse contacts scene instead of the all contacts scene.
   */
  showBrowseContactsScene: function() {
    // create the browsing scene if it doesn't exist yet
    if (!this._browseContactsScene) {
      this._browseContactsScene =
        this.getController()._browseContactsSection.getScene();
    }

    this.findRef('tabview')
      .setViewForTab(this._contactsTab, this._browseContactsScene);
  },

  /**
   * Return to all contacts scene instead of browse contacts scene.
   */
  showAllContactsScene: function(scene) {
    this.findRef('tabview')
      .setViewForTab(this._contactsTab, scene);
  }

});
});

// module: contacts/display_contact_section/ui/display_contact_scene
// file:   contacts/display_contact_section/ui/display_contact_scene.js
define("contacts/display_contact_section/ui/display_contact_scene", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var Scene = require('bolt_touch/views/scene').Scene;
var Image = require('bolt_touch/views/image').Image;
var ActionableView = require('bolt_touch/views/actionable_view').ActionableView;
var PhoneNumbersSection =
  require('./phone_numbers/phone_numbers_section').PhoneNumbersSection;

var DisplayContactScene = core.createClass({
  name: 'DisplayContactScene',
  extend: Scene,

  useHeader: function() {
    return false;
  },

  properties: {
    contact: null
  },

  declare: function(options) {
    return {
      id: 'displayContactScene',
      className: 'contact-scene',
      childViews: [
        {
          className: 'buttons-section',
          childViews: [
            {
              view: ActionableView,
              className: 'button left-button',
              content: 'Back',
              id: 'backFromDisplayContact',
              action: 'backClicked'
            },
            {
              view: ActionableView,
              className: 'button right-button',
              content: 'Edit',
              id: 'editContact',
              action: 'editClicked'
            }
          ]
        },
        {
          className: 'top-section',
          childViews: [
            {
              ref: 'image',
              className: 'picture-section',
              view: Image
            },
            {
              ref: 'name',
              className: 'name-section'
            }
          ]
        },
        {
          // temporary button, just need a way to get to profile while waiting
          // for someone to design it for real
          view: ActionableView,
          action: 'viewProfilePressed',
          className: 'button',
          style: {
            width: '120px',
            marginLeft: '20px'
          },
          content: 'See Timeline'
        },
        {
          ref: 'phoneNumbersSection',
          view: PhoneNumbersSection,
          onphoneClicked: 'phoneClicked'
        }
      ]
    };
  },

  setContact: function(contact) {
    this._snapshot = contact;
    this.findRef('name').setContent(contact.name);
    this.findRef('image').setSrc(contact.profileUrl);
    this.findRef('phoneNumbersSection').setPhoneNumbers(contact.phoneNumbers);
  },

  backClicked: function(event) {
    this.invoke('backFromDisplayContact');
  },

  editClicked: function(event) {
    this.invoke('editContact', {
      snapshot: this._snapshot
    });
  },

  phoneClicked: function(evt) {
    evt.stopPropagation();
    this.invoke('callNumber', evt.data);
  },

  sendMessagePressed: function(event) {
    this.invoke('messageContact', {
      snapshot: this._snapshot
    });
  },

  viewProfilePressed: function(event) {
    this.invoke('viewProfile', {
      snapshot: this._snapshot
    });
  }
});

exports.DisplayContactScene = DisplayContactScene;
});

// module: mock/log_api
// file:   ../../mock/js/log_api.js
define("mock/log_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

module.exports = {
  _hasLogMessage : false,
  _perfLogEnabled : true,

  CMlog: function() {
    window.top.ConsoleManager && window.top.ConsoleManager.send('logapi', 'log',
      Array.prototype.slice.call(arguments));
  },

  log: function(args) {
    this._hasLogMessage = true;
    this.CMlog(JSON.stringify(args));
  },

  _setPerfLogEnabled : function(flag) {
    if (flag) {
      this._perfLogEnabled = true;
    } else {
      this._perfLogEnabled = false;
    }
  },

  perfLogEnabled : function() {
    return this._perfLogEnabled;
  },

  ALLOW_NESTING : 0,
  DISALLOW_NESTING : 1,
  COLLAPSE_NESTING : 2,
  ALLOW_OVERLAPPING : 3,

  logTimeDirect : function(id, kind, value, info) {
    this.CMlog("{\"id\":" + JSON.stringify(id) + "," +
                       JSON.stringify(kind) + ":" + value + "," +
                       "\"info\":" + JSON.stringify(info) + "}");
  },

  _uniqueId : 0,
  _timers : {},

  startTimer : function(id, nesting) {
    if (id === null || id === "") {
      this.CMlog("Timer id cannot be null or empty.");
      return;
    }
    if (id.indexOf(' ') >= 0) {
      this.CMlog("Timer id \"" + id + "\" cannot contain space.");
      return;
    }

    if (nesting === this.ALLOW_OVERLAPPING) {
      id = ' ' + id + ' ' + (this._uniqueId++);
    }

    if (this._timers.hasOwnProperty(id)) {
      if (nesting === this.ALLOW_NESTING) {
        this._timers[id].push(Date.now());
      } else if (nesting === this.DISALLOW_NESTING) {
        this.CMlog("startTimer: nesting is disallowed.");
      } else {
        this._timers[id][this._timers[id].length - 1] = Date.now();
      }
    } else {
      this._timers[id] = [Date.now()];
    }

    return id;
  },

  clearTimer : function(id) {
    if (this._timers[id].length === 1) {
      delete this._timers[id];
    } else {
      this._timers[id].pop();
    }
  },

  endTimer : function(id, info) {
    if (!this._timers.hasOwnProperty(id)) return;

    var now = Date.now();
    if (id.charAt(0) === ' ') {
      // ALLOW_OVERLAPPING
      this.logTimeDirect(id.substring(1, id.indexOf(' ', 1)), 'latency',
                         now - this._timers[id][this._timers[id].length - 1],
                         info);
    } else {
      this.logTimeDirect(id, 'latency',
                         now - this._timers[id][this._timers[id].length - 1],
                         info);
    }

    this.clearTimer(id);
  },

  queryTimer: function(id) {
    if (!this._timers.hasOwnProperty(id)) {
      return -1;
    }
    return Date.now() - this._timers[id][this._timers[id].length - 1];
  },

  reportJSException: function() {},

  logBootTime: function() { },

  hasLogMessage: function() {
    return this._hasLogMessage;
  },

  resetLogFlag: function() {
    this._hasLogMessage = false;
  },

  bumpKey: function() {
  },

  addRawPerfLog: function(tabData) {
  }
};
});

// module: bolt_touch/views/scrubber/index
// file:   ../../../frameworks/bolt_touch/lib/views/scrubber/index.js
define("bolt_touch/views/scrubber/index", function(require, exports, module) {
var util = require('bolt/util');
var View = require('bolt_touch/view').View;

var Scrubber = require('bolt/core').createClass({
  extend: View,

  name: 'Scrubber',

  properties: {
    characters: 'abcdefghijklmnopqrstuvwxyz#',
    caps: true
  },

  createDom: function() {
    var node = View.prototype.createDom.apply(this, arguments);

    if (this.getCaps()) {
      this.addClass('bolt-upper-case');
    }

    this.setBoxOrientation(this.getBoxOrientation() || 'vertical');
    this.handleTouch = util.bind(this.handleTouch, this);

    var kids = [];
    var chars = this.getCharacters();
    for (var i = 0; i < chars.length; i++) {
      var c = chars.charAt(i).toLowerCase();
      kids.push({
        view: View,
        content: c,
        flex: 1,
        metadata: {letter: c}
      });
    }

    var touchEvents = View.touchEvents;

    this.addClass('bolt-' + this.getBoxOrientation());
    this.setLayout(kids);

    this.addListener(touchEvents.TOUCHSTART, this.handleTouchStart, this);
    this.addListener(touchEvents.TOUCHEND, this.handleTouchEnd, this);
    this.addListener(touchEvents.TOUCHMOVE, this.handleTouch, this);

    return node;
  },

  handleTouchStart: function(evt) {
    var rawEvt = this.getRawEvent(evt);
    var target = rawEvt.target;
    if (target && target.nodeType === 3) {
      target = target.parentNode;
    }

    if (!target.getAttribute('data-letter')) {
      return;
    }
    var h = target.offsetHeight;
    this.touchPos = {
      x: rawEvt.pageX,
      y: rawEvt.pageY,
      nodeIndex: util.indexOf(this.getNode().childNodes, target)
    };
    this.letterHeight = target.offsetHeight;

    this.addClass('touched');
    this.handleTouch(evt);
  },


  handleTouchEnd: function(evt) {
    this.touchPos = null;
    this.removeClass('touched');
    var owner = this.getOwner();
    if (owner && owner.onScrubEnd) {
      owner.onScrubEnd(this);
    }
  },

  handleTouch: function(evt) {
    if (!this.touchPos) {
      if (evt.kill) {
        this.handleTouchStart(evt);
      }
      return;
    }
    if (evt.kill) {
      evt.kill();
    } else {
      evt.stopPropagation();
      evt.preventDefault();
    }
    this.addClass('touched');
    var owner = this.getOwner();
    var rawEvt = this.getRawEvent(evt);

    var diffY = this.touchPos.y - rawEvt.pageY;
    var siblings = this.getNode().childNodes;
    var childIdx =
      Math.max(0,
        Math.min(siblings.length - 1,
          Math.round(this.touchPos.nodeIndex - (diffY / this.letterHeight))
        )
      );
    var target = siblings[childIdx];
    var letter = target.getAttribute('data-letter');
    if (owner && owner.onScrub && letter) {
      owner.onScrub(letter);
    }
  },

  getRawEvent: function(evt) {
    var rawEvt = evt.getRawEvent ? evt.getRawEvent() : evt;
    if (rawEvt.touches) {
      rawEvt = rawEvt.touches[0];
    }
    return rawEvt;
  }

});

exports.Scrubber = Scrubber;
});

// module: shared/data2/model/mixin/likeable
// file:   ../../shared/js/data2/model/mixin/likeable.js
define("shared/data2/model/mixin/likeable", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var util = require('bolt/util');
var apixhr = require('shared/api_xhr');
var sharedUtil = require('shared/util');

/**
 * This is a mixin for models that can be liked (such as posts, photos, etc);
 *
 * To be able to use this mixin a model must have a property 'likes' that is an
 * object with the following properties:
 *
 *  count - how many people like the object
 *  user_likes - true if the user likes the object, false if not
 *  can_like - true if the user can like the object
 *
 * The model must also either have a method called getFeedbackId that returns
 * the fbid or a propery named 'id' that is the fbid of the model.
 */
exports.Likeable = {

  /**
   * @return the fbid of the model
   */
  getFeedbackId: function() {
    return this.get('id');
  },

  /**
   * @abstract
   * Classes that mixin Likeable need to implement a storeModel function that
   * permanently save the changes to model after the server change is confirmed.
   */
  storeModel: function() {
    sharedUtil.abstractMethod('Likeable.storeModel');
  },

  /**
   * Toggles the like state between liking/unliking.
   */
  toggleLike: function() {
    // Optimisitcally update the local state.
    this.localToggleLike();
    if (this._savingLikes || !this.get('likes').can_like) {
      return;
    }
    this._savingLikes = true;
    this.sendLikeToggle();
  },

  sendLikeToggle: function() {
    var likedAtTimeOfRequest = this.get('likes').user_likes;
    apixhr.graph(
      likedAtTimeOfRequest ? 'post' : 'delete',
      this.getFeedbackId() + '/likes').addCallback(function(res) {
        if (res.error) {
          console.warn('Error liking/unliking', res.error.type,
            res.error.message);
          this.invoke(
            'likeError',
            {message: 'The API returned an error.'}
          );
          // Reverse the optimistic liking from before, on failure.
          this.localToggleLike();
          this._savingLikes = false;
        } else if (this.get('likes').user_likes !== likedAtTimeOfRequest) {
          // user toggled like state during API call, so we must undo the damage
          this.sendLikeToggle();
        } else {
          this.storeModel();
          this._savingLikes = false;
        }
      }, this)
      .addErrback(function() {
        this._savingLikes = false;
        console.warn('Connection error: could not like');
        this.invoke(
          'likeError',
          {message: 'Connection error: The request to the server failed.'}
        );
        // Reverse the optimistic liking from before, on failure.
        this.localToggleLike();
      }, this);
  },

 /**
  * Toggle the model's like count and user_like values.
  */
  localToggleLike: function() {
    var likes = this.get('likes');

    var new_likes = {
      count: likes.user_likes ? likes.count - 1 : likes.count + 1,
      user_likes: !likes.user_likes,
      can_like: likes.can_like
    };
    this.set('likes', new_likes);
  }
};
});

// module: shared/perf/timer
// file:   ../../shared/js/perf/timer.js
define("shared/perf/timer", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var PERF_TIMERS = 0;

exports.start = exports.stop = exports.report = exports.reportString =
  function() {};

if (PERF_TIMERS) {
  var uid = 1;
  var prefix = 0;

  function Timer() {};

  Timer.prototype.start = function() {
    this.started = +new Date();
  };

  Timer.prototype.stop = function() {
    this.elapsed = +new Date() - this.started;
  };

  function typify(type, obj) {
    if (typeof type !== 'string') {
      return [type.getDeclaredClass(), identify(obj || type)];
    }

    if (type && obj) {
      return [type, identify(obj)];
    }
    if (type) {
      return [type, type];
    }
    return ['*', '*'];
  }

  function identify(obj) {
    return obj.__timer_id || (obj.__timer_id = prefix + uid++);
  }

  if (window.top === window) {
    window.PerfTimers = {};
    window.PerfTimersIdMap = {};
  } else {
    prefix = Math.random() + '_';
  }

  function getGlobalTimers() {
    if (window.top === window) {
      return window.PerfTimers;
    }
    return window.top.PerfTimers || (window.top.PerfTimers = {});
  }

  function getGlobalIdMap() {
    if (window.top === window) {
      return window.PerfTimersIdMap;
    }
    return window.top.PerfTimersIdMap || (window.top.PerfTimersIdMap = {});
  }

  exports.start = function(type, obj) {
    var parts = typify(type, obj);
    var timers = getGlobalTimers();
    var idmap = getGlobalIdMap();
    if (!idmap[parts[0] + parts[1]]) {
      var timer = new Timer();
      idmap[parts[0] + parts[1]] = timer;
      timers[parts[0]] || (timers[parts[0]] = []);
      timers[parts[0]].push(timer);
      timer.start();
    } else {
      console.warn('starting timer twice', type, obj);
    }
  };

  exports.stop = function(type, obj) {
    var parts = typify(type, obj);
    var idmap = getGlobalIdMap();
    if (idmap[parts[0] + parts[1]]) {
      idmap[parts[0] + parts[1]].stop();
    } else {
      console.warn('stopping timer that does not exist', type, obj);
    }
  };

  exports.clear = function() {
    window.top.PerfTimers = {};
    window.top.PerfTimersIdMap = {};
  };

  exports.report = function() {
    var report = [];
    var timers = getGlobalTimers();

    for (var type in timers) {
      if (timers.hasOwnProperty(type)) {
        var row = {
          type: type,
          finished: 0,
          running: 0,
          elapsed: 0
        };
        report.push(row);
        for (var i = 0, l = timers[type].length; i < l; i++) {
          if ('elapsed' in timers[type][i]) {
            row.elapsed += timers[type][i].elapsed;
            row.finished++;
          } else {
            row.running++;
          }
        }
      }
    }
    return report;
  };

  exports.reportString = function() {
    return exports.report().map(function(row) {
      return row.type +
        ' finished: ' + row.finished +
        ', elapsed: ' + row.elapsed + 'ms' +
        ', avg: ' + row.elapsed / row.finished + 'ms' +
        ', running: ' + row.running;
    }).join('\n');
  };
}
});

// module: shared/data2/store/store_with_broadcast
// file:   ../../shared/js/data2/store/store_with_broadcast.js
define("shared/data2/store/store_with_broadcast", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core  = require('bolt/core');
var util  = require('bolt/util');
var EventManager = require('shared/event_manager').EventManager;
var Store = require('./store').Store;

exports.StoreWithBroadcast = core.createClass({
  extend: Store,

  construct: function(remoteMapper, localMapper, schema) {
    this._schema = schema;
    Store.call(this, remoteMapper, localMapper);

    var suffix = this.getDeclaredClass();
    this._storeEventName = 'store.' + suffix + '.store';
    this._removeEventName = 'store.' + suffix + '.remove';
    EventManager.listen(this._storeEventName, this._onStore, this);
    EventManager.listen(this._removeEventName, this._onRemove, this);
  },

  destroy: function() {
    EventManager.removeListener(this._storeEventName, this._onStore, this);
    EventManager.removeListener(this._removeEventName, this._onRemove, this);
  },

  /**
   * To send data about models across different webviews, we need to serialize
   * the models and remove cycles. The local mapper's transformModelToLocal
   * is guaranteed to produce acyclical return values, so this is utilized.
   *
   * @param {Model} a model to serialize.
   * @return {Object} object representing the model.
   */
  _serializeModel: function(model) {
    var obj = {};
    this._schema.getPropertyNames().forEach(function(name) {
      var info = this._schema.getPropertyInfo(name);
      var value = model.get(name);
      obj[name] = info.transformModelToLocal(value);
    }, this);
    return obj;
  },

  /**
   * Converts an object transformed by _serializeModel to a model.
   *
   * @param {Object} object previously transformed by _serializeModel.
   * @return {Model} model version of the object.
   */
  _deserializeModel: function(object) {
    var obj = {};
    this._schema.getPropertyNames().forEach(function(name) {
      var info = this._schema.getPropertyInfo(name);
      obj[name] = info.transformLocalToModel(object[name]);
    }, this);
    var ModelType = this.getModelType();
    return new ModelType(obj);
  },

  // instead of triggering event directly on the store, we send it
  // to the EventManager, then catch it, and finally trigger on itself
  _triggerStoreEvent: function(models) {
    var data = {models: util.map(models, this._serializeModel, this)};
    EventManager.broadcastEvent(this._storeEventName, data);
  },

  _onStore: function(data) {
    var models = new Array(data.models.length);
    data.models.forEach(function(model, i) {
      model = this._deserializeModel(model).toObject();
      if (this._memoryCache.get(model.id)) {
        this._memoryCache.get(model.id).merge(model);
      }
      models[i] = this._memoryCache.get(model.id) || model;
    }, this);
    Store.prototype._triggerStoreEvent.call(this, models);
  },

  _triggerRemoveEvent: function(ids) {
    EventManager.broadcastEvent(
      this._removeEventName,
      { ids: ids }
    );
  },

  _onRemove: function(data) {
    Store.prototype._triggerRemoveEvent.call(this, data.ids);
  }
});
});

// module: system/config
// file:   ../../system/lib/config.js
define("system/config", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var KEYS = exports.KEYS = {
  SYSTEM_DEBUG_MODE:         'systemDebugMode',
  DASH_DISABLED:             'dashDisabled',
  BACKGROUND_TASKS_DISABLED: 'backgroundTasksDisabled',
  FB_WEBSITE_AUTH_DISABLED:  'fbWebsiteAuthDisabled',
  DEV_TOOLS_ENABLED:         'devToolsEnabled'
};

var getSetting = exports.getSetting = function getSetting(key) {
  var settings = JSON.parse(localStorage.systemSettings || '{}');
  return settings[key];
};

var setSetting = exports.setSetting = function setSetting(key, val) {
  var settings = JSON.parse(localStorage.systemSettings || '{}');
  settings[key] = val;
  localStorage.systemSettings = JSON.stringify(settings);
  return settings[key];
};

////////////////////////////////////////////////
// property list for rendering system settings
////////////////////////////////////////////////
exports.settings = [
  {
    label: 'System Debug Mode',
    type: 'boolean',
    key: KEYS.SYSTEM_DEBUG_MODE
  },
  {
    label: 'Disable Background Tasks',
    type: 'boolean',
    key: KEYS.BACKGROUND_TASKS_DISABLED
  },
  {
    label: 'Disable Dash',
    type: 'boolean',
    key: KEYS.DASH_DISABLED
  },
  {
    label: 'Disable FB Website Auth',
    type: 'boolean',
    key: KEYS.FB_WEBSITE_AUTH_DISABLED
  },
  {
    label: 'Enable Dev Tools',
    type: 'boolean',
    key: KEYS.DEV_TOOLS_ENABLED
  }
];

////////////////////////////////////////////////
// DEBUGGING
////////////////////////////////////////////////

exports.facbookWebsiteAuthenticationDisabled = function() {
  return getSetting(KEYS.FB_WEBSITE_AUTH_DISABLED);
};

exports.backgroundTasksDisabled = function() {
  return getSetting(KEYS.BACKGROUND_TASKS_DISABLED);
};

exports.dashDisabled = function() {
  return getSetting(KEYS.DASH_DISABLED);
};

exports.devToolsEnabled = function() {
  return getSetting(KEYS.DEV_TOOLS_ENABLED);
};

var DEBUG = false;
exports.getDebugMode = function() {
  return DEBUG || getSetting(KEYS.SYSTEM_DEBUG_MODE);
};
exports.setDebugMode = function(bool) {
  DEBUG = bool;
};

var isAutoTesting =
  new RegExp('/?autoTesting=([^&]*)').exec(window.location.search);
exports.isAutoTesting = function() {
  return isAutoTesting;
};

var isMonkeyTesting =
  new RegExp('/?monkeyTesting=([^&]*)').exec(window.location.search);
exports.isMonkeyTesting = function() {
  return isMonkeyTesting;
};

var disableLockScreen =
  new RegExp('disableLockscreen=([^&]*)').test(window.location.search);
exports.lockScreenDisabled = function() {
  return disableLockScreen;
};

var disableCalls =
  new RegExp('disableCall=([^&]*)').test(window.location.search);
exports.callDisabled = function() {
  return disableCalls;
};

exports.getMonkeyUrl = function() {
  if (isMonkeyTesting) {
    return isMonkeyTesting[1];
  } else {
    return null;
  }
};

exports.isAngel = function() {
  return window.top.IS_ANGEL;
};

exports.KILL_TIMEOUT = 0;
exports.LOW_MEM_KILLER_ENABLED = true;
exports.MAX_OPEN_CONTEXTS = 10;
exports.IS_ENG_BUILD = FBAPI.use('info').getBuildType() === 'eng';
});

// module: shared/init
// file:   ../../shared/js/init.js
define("shared/init", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var decycle    = require('third-party/json/cycle').decycle;
var config     = require('shared/config');

var EventManager = require('shared/event_manager').EventManager;
// Uncomment to view a log of all global events:
// EventManager.listen('all', function(evt, data){
//  console.log('received event:' + evt + ' payload:' + JSON.stringify(data || {}));
// });

// The ready function invokes your callback onDOMContentLoaded.
var ready = exports.ready = function(callback) {
  var procede = function() {
    init();
    callback && callback();
  };

  if (document.readyState === 'interactive') {
    // if the document is already loaded then we just procede
    procede();
  } else {
    // otherwise wait for onDOMContentLoaded
    document.addEventListener('DOMContentLoaded', procede);
  }
};

window.openTab = function(data) {
  EventManager.broadcastEvent('tab_bar.REQUEST_OPEN', data);
};

window.openUrl = function(url) {
  EventManager.broadcastEvent('tab_bar.REQUEST_OPEN_URL', {url: url});
};

window.openTalkWithRecipient = function(recipient) {
  var url = 'fbcf:///apps/talk/index.html#recipient=' +
    recipient;
  window.openUrl(url);
};

window.openProfile = function(profileId) {
  var profileKey = 'profile-' + profileId;
  window.openTab({
    url: 'fbcf:///apps/profile/index.html#profileId=' + profileId,
    // the id of the browsing context used for managing the users nav state
    id: profileKey,
    // the id of the webview to render the context with. In the future we may
    // recycle profile webviews so this will not always be the same as the
    // context id.
    webViewId: profileKey,
    iconUrl: 'https://graph.facebook.com/' + profileId + '/picture?type=normal'
  });
};

var initialized = false;
// init provides a place to install common global setup code for all
// applications. We should be judicious about what code is added here.
var init = exports.init = function() {
  // make sure we don't double initialize a webview
  if (initialized) {
    console.log('WARNING: initialize called more than once');
    return;
  }
  initialized = true;

  if(!config.isWorker()) {
    // setup the cross webview event bus
    setupWindowManager();

    // setup the default error handler
    setupWindowErrorHandler();
  }
};

var setupWindowManager = function() {
  window.WindowManager = require('shared/window_manager').WindowManager;
};

// Sets a default window.onerror handler that reports the js exception to via
// LogReporter. Only do this if window.onerror is not already set.
var setupWindowErrorHandler = function() {
  // Don't do this for Angel because it hides errors from Chrome
  if (!window.onerror && !window.top.IS_ANGEL) {
    window.onerror = function (message, source, line) {
      if (window.FBAPI) {
        var api = FBAPI.use("log");
        var data = { message: message, source: source, line: line };
        api.reportJSException(JSON.stringify(decycle(data)), false);
      }
    };
  }
};

var logger = require('shared/logger').logger;
});

// module: views/feedback/ufi/composer/index
// file:   ../../views/feedback/ufi/composer/index.js
define("views/feedback/ufi/composer/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var View = require('bolt_touch/view').View;
var Button = require('bolt_touch/views/button_new').ButtonNew;

var sharedUtil = require('shared/util');
var dialogUtil = require('shared/dialogs');
var UfiClient = require('ufi/client').getInstance();

var UfiComposer = core.createClass({

  name: 'UfiComposer',

  extend: View,

  properties: {
    /**
     * @property {Model} target - a model that has mixed in Commentable.
     */
    target: null
  },

  declare: function(options) {
    return {
      disabled: true,
      className: 'bt-ufi-row',
      boxOrientation: 'horizontal',
      childViews: [
        {
          className: 'bt-ufi-composer--textarea-wrapper',
          flex: 1,
          childViews: [
            {
              className: 'bt-ufi-composer--textarea',
              tagName: 'textarea',
              ref: 'textarea',
              disabled: true,
              placeholder: 'Write a comment...',
              onfocus: 'handleEdit',
              onblur: 'handleEdit',
              onkeyup: 'handleEdit'
            }
          ]
        },
        {
          view: Button,
          className: 'bt-ufi-composer--button',
          label: 'Post',
          onclick: 'send',
          ref: 'sendButton',
          disabled: true
        }
      ]
    };
  },

  setTarget: function(target) {
    this.set('target', target);
    if (this._commentErrorListener) {
      this._commentErrorListener.remove();
    }
    this.findRef('textarea').setDisabled(false);
  },

  setDisabled: function(disabled) {
    this.set('disabled', this);
    this.findRef('textarea').setDisabled(true);
    this.findRef('sendButton').setDisabled(true);
  },

  onDocumentInsertion: function() {
    var textarea = this.findRef('textarea');
    this._textareaOriginalHeight = textarea.getHeight();
    sharedUtil.autogrow(textarea, 6);
  },

  focus: function() {
    this.findRef('textarea').getNode().focus();
  },

  // Toggle the state of the send button so it's only enabled when there's text
  // in the composer.
  handleEdit: function(event) {
    var sendButton  = this.findRef('sendButton');
    var textareaNode = this.findRef('textarea').getNode();
    if (!!textareaNode.value === sendButton.getDisabled()) {
      sendButton.setDisabled(!textareaNode.value);
    }
  },

  send: function(event) {
    UfiClient
      .postComment(this.findRef('textarea').getNode().value, this.getTarget())
      .addErrback(this._postCommentError, this);
    this.reset();
  },

  _postCommentError: function (errorMessage) {
    this._showError(errorMessage);
  },

  _showError: function(message) {
    var id = dialogUtil.createDialog();
    dialogUtil.appendText(id, message);
    dialogUtil.showModalDialog(id);
  },

  reset: function() {
    var textareaNode = this.findRef('textarea').getNode();
    textareaNode.value = '';
    this.findRef('sendButton').setDisabled(true);
    textareaNode.blur();
  }
});

exports.UfiComposer = UfiComposer;
});

// module: photos/app/lib/model/video/video_store
// file:   ../../photos/app/lib/model/video/video_store.js
define("photos/app/lib/model/video/video_store", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core   = require('bolt/core');
var util   = require('bolt/util');
var LocalMapper  = require('shared/data2/local/local_mapper').LocalMapper;
var RemoteMapper = require('shared/data2/remote/remote_mapper').RemoteMapper;
var StoreWithBroadcast =
  require('shared/data2/store/store_with_broadcast').StoreWithBroadcast;
var Schema       = require('shared/data2/store/schema').Schema;
var Filter       = require('shared/data2/store/filter').Filter;
var Video        = require('./video').Video;


function createSchema() {
  return new Schema(
    {
      id: {
        searchable: true,
        remote: 'vid',
        localType: 'TEXT PRIMARY KEY'
      },
      created_time: {},
      updated_time: {
        searchable: true
      },
      from: {
        remote: 'owner'
      },
      picture: {
        remote: 'thumbnail_link'
      },
      name: {
        remote: 'title'
      },
      source: {
        remote: 'src'
      },
      source_hq: {
        remote: 'src_hq'
      },
      description: {},
      length: {}
      // TODO
      // likes: {
      //   remote: 'like_info',
      //   transformRemoteToModel: function(data) {
      //     return {
      //       can_like: data.can_like || false,
      //       user_likes: data.user_likes || false,
      //       count: 'count' in data ? parseInt(data.count, 10) : 0
      //     };
      //   }
      // },
      // comments: {
      //   remote: 'comment_info',
      //   transformRemoteToModel: function(data) {
      //     return {
      //       can_post: data.can_post || false,
      //       count: 'count' in data ? parseInt(data.count, 10) : 0
      //     };
      //   }
      // }
    },
    Video
  );
}

function createLocalMapper(schema) {
  var mapper = new LocalMapper(schema, 'video');
  mapper.createIndexes = function(tx) {
    tx.executeSql('CREATE UNIQUE INDEX IF NOT EXISTS ' +
      'idx_video__id ON ' + mapper.getTableName() +
      '(id)');
    tx.executeSql('CREATE INDEX IF NOT EXISTS ' +
      'idx_video__updated_time ON ' + mapper.getTableName() +
      '(updated_time DESC)');
  };
  return mapper;
}

function createRemoteMapper(schema) {
  return new RemoteMapper(schema, 'video');
}

var VideoStore = exports.VideoStore = core.createClass({
  name: 'VideoStore',

  extend: StoreWithBroadcast,

  properties: {
    modelType: Video
  },

  fetchVideoCollection: function() {
    var filter = new Filter(
      {},
      'updated_time DESC'
    );

    filter.set('FQLQuery', 'owner=me()');

    return this.fetchCollection(filter, 200);
  }
});

var _instance = null;
exports.createLocalMapper = createLocalMapper;
exports.createRemoteMapper = createRemoteMapper;
exports.createSchema = createSchema;
exports.getInstance = function(remoteMapper, localMapper, schema) {
  if (!_instance) {
    schema = schema || createSchema();
    localMapper = localMapper || createLocalMapper(schema);
    remoteMapper = remoteMapper || createRemoteMapper(schema);
    _instance = new VideoStore(remoteMapper, localMapper, schema);
  }
  return _instance;
};
});

// module: view/text_field/auto_grow_text_field
// file:   view/text_field/auto_grow_text_field.js
define("view/text_field/auto_grow_text_field", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var util              = require('bolt/util');

exports.AutoGrowTextField = core.createClass({
  name: 'AutoGrowTextField',
  extend: View,

  delegateProperties: {
    textarea: ['height', 'width', 'placeholder']
  },

  properties: {
    maxRows: 5
  },

  declare: function() {
    return {
      ontouchstart: util.bind(this.onTouchStart, this),
      childViews: [{
        owner: this,
        tagName: 'textarea',
        ref: 'textarea',
        flex: 1,
        className: 'btAutoGrowTextField--textarea'
      }]
    };
  },

  ready: function() {
    this.textarea = this.refs.textarea;
  },

  getTextarea: function() {
    return this.refs.textarea;
  },

  onTouchStart: function(e) {
    e.preventDefault();
    this.focus();
  },

  focus: function() {
    var textarea = this.refs.textarea.getNode();
    textarea.focus();
  },

  blur: function() {
    this.refs.textarea.getNode().blur();
  },

  clear: function() {
    this.refs.textarea.getNode().value = '';
    this._onValueChange();
  },

  getValue: function() {
    return this.refs.textarea.getNode().value;
  },

  setValue: function(value) {
    this.refs.textarea.getNode().value = value;
    return this;
  },

  onDocumentInsertion: function() {
    var style = window.getComputedStyle(this.textarea.getNode());
    var shadow = this._shadow = document.createElement('pre');
    shadow.className = 'btAutoGrowTextField-shadow';
    [
      'width', 'fontSize', 'fontFamily', 'lineHeight',
      'paddingLeft', 'paddingRight', 'paddingBottom', 'paddingTop',
      'marginRight', 'marginBottom',
      'wordWrap', 'whiteSpace',
      'borderTopWidth', 'borderBottomWidth',
      'borderLeftWidth', 'borderRightWidth',
      'borderTopStyle', 'borderBottomStyle',
      'borderLeftStyle', 'borderRightStyle',
      'minHeight'
    ].forEach(function(name) {
      shadow.style[name] = style[name];
    });
    this._shadow.innerText = this.getValue() + "\n";
    document.body.appendChild(shadow);

    this.textarea.addListener('keyup', this._onValueChange, this);
    this.textarea.addListener('change', this._onValueChange, this);

    this._lineHeight = parseInt(style.lineHeight, 10);
    this._updateFromShadow();
    // add animation with delay, to prevent initial jump
    setTimeout(
      util.bind(this.addClass, this.textarea, 'btAutoGrowTextField'),
      10
    );
  },

  _onValueChange: function() {
    this._shadow.innerText = this.getValue() + "\n";
    this._updateFromShadow();
  },

  _updateFromShadow: function() {
    var newHeight = Math.min(
      this.getMaxRows() * this._lineHeight,
      this._shadow.offsetHeight);
    newHeight = Math.max(newHeight, this._lineHeight);
    this.textarea.setStyle('height', newHeight + 'px');
  },

  destroy: function() {
    View.prototype.destroy.call(this);
    if (this._shadow) {
      this._shadow.parentNode.removeChild(this._shadow);
    }
  },

  _nodeForEvent: function(name) {
    return this.findRef('textarea').getNode();
  }

});
});

// module: views/picker/album_picker/picker_view
// file:   ../../views/picker/album_picker/picker_view.js
define("views/picker/album_picker/picker_view", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core             = require('bolt/core');
var Scene            = require('bolt_touch/views/scene').Scene;
var util             = require('bolt/util');
var Actionable       = require('bolt_touch/mixins/actionable').Actionable;
var View             = require('bolt_touch/view').View;
var CollectionView   = require('bolt/collection_view').CollectionView;

var PickerAlbumThumbnailCollectionView =
  exports.PickerAlbumThumbnailCollectionView = core.createClass({
  name: 'PickerAlbumThumbnailCollectionView',

  extend: CollectionView,

  properties: {
    thumbnailTouchStart: null
  },

  viewForModel: function(model) {
    var that = this;
    var view = new PickerAlbumThumbnail({
      action: function(view) {
        var cb = that.getThumbnailTouchStart();
        cb && cb(view);
      }
    });

    view.setBinding(
      model, [
        { modelProperty: 'picture', viewProperty: 'thumb' },
        { property: 'selected' }
      ]);

    return view;
  }
});

var PickerSelectedThumbnailCollectionView =
  exports.PickerSelectedThumbnailCollectionView = core.createClass({
  name: 'PickerSelectedThumbnailCollectionView',

  extend: CollectionView,

  properties: {
    thumbnailTouchStart: null
  },

  viewForModel: function(model) {
    var that = this;
    var view = new PickerSelectedThumbnail({
      action: function(view) {
        var cb = that.getThumbnailTouchStart();
        cb && cb(view);
      }
    });

    view.setBinding(
      model, [
        { modelProperty: 'picture', viewProperty: 'thumb' }
      ]);

    return view;
  }
});

//intermediate class to reduce code redundancy
var PickerThumbnail = core.createClass({
  name: 'PickerThumbnail',

  extend: View,

  ready: function() {
    this.thumbnail = this.findRef('thumbnail');
  },

  setThumb: function(thumbnail) {
    var photo = this.getModel();
    if (photo.get('orientation')) {
      this.thumbnail.addClass('rotate' + photo.get('orientation'));
    }

    this.thumbnail.setStyle('backgroundImage', 'url(' + thumbnail + ')');
  }

});

var PickerAlbumThumbnail = core.createClass({
  name: 'PickerAlbumThumbnail',

  extend: PickerThumbnail,

  mixins: [Actionable],

  construct: function(options) {
    PickerThumbnail.call(this, options);
  },

  declare: function(options) {
    return {
      childViews: [
        {
          additionalClasses: 'thumbnail',
          ref: 'thumbnail',
        }
      ]
    };
  },

  setSelected: function(selected) {
    this.set('selected',selected);
    if (selected) {
      this.findRef('thumbnail').addClass('selected-opacity');
    }
    else {
      this.findRef('thumbnail').removeClass('selected-opacity');
    }
  }
});

var PickerSelectedThumbnail = core.createClass({
  name: 'PickerSelectedThumbnail',

  extend: PickerThumbnail,

  mixins: [Actionable],

  construct: function(options) {
    PickerThumbnail.call(this, options);
  },

  declare: function(options) {
    return {
      childViews: [
        {
          additionalClasses: 'thumbnail',
          ref: 'thumbnail'
        }
      ]
    };
  }
});
});

// module: contacts/contact_filters_section/filters_data_source
// file:   contacts/contact_filters_section/filters_data_source.js
define("contacts/contact_filters_section/filters_data_source", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var Model = require('bolt/model').Model;
var Collection = require('bolt/collection').Collection;

var session = require('shared/session');

var groupMemberStore =
  require('shared/data2/model/group/group_member_store').getInstance();
var friendListStore =
  require('shared/data2/model/friend_list/friend_list_store').getInstance();

/**
 * Sort by the bookmark order (some magical number we get from the api saying
 * how relevent the group or list is to us)
 */
function sortByBookmarkOrder(model) {
  return model.get('bookmark_order');
}

/**
 * Sort by alphabetical order of the name of the model.
 */
function sortByAlphabeticalOrder(model) {
  return model.get('name');
}

/**
 * Thing that owns the collection of "filters" and manages downloading from
 * the stores.
 */
var FiltersDataSource = core.createClass({
  name: 'FiltersDataSource',

  construct: function(options) {
    groupMemberStore.initialize();
    groupMemberStore.fetchGroupMemberCollectionByUid(session.getUid())
      .addCallback(this._handleGroupMembers, this)
      .addErrback(this._groupMembersError, this);
    friendListStore.initialize();
    friendListStore.fetchFriendListCollection()
      .addCallback(this._handleFriendLists, this)
      .addErrback(this._friendListsError, this);
  },

  getGroupCollection: function() {
    var collection = this.get('groupCollection');
    if (!collection) {
      collection = new Collection();
      collection.comparator = sortByBookmarkOrder;
      this.set('groupCollection', collection);
    }
    return collection;
  },

  getListCollection: function() {
    var collection = this.get('listCollection');
    if (!collection) {
      collection = new Collection();
      collection.comparator = sortByAlphabeticalOrder;
      this.set('listCollection', collection);
    }
    return collection;
  },

  // GroupMembers
  _handleGroupMembers: function(groupMembers) {
    this.groupMemberCollection = groupMembers;
    groupMembers.addListener('endUpdate', this._processGroupMembers, this);
    groupMembers.downloadHead(1000);
    this._processGroupMembers();
  },

  _processGroupMembers: function() {
    var collection = this.getGroupCollection();
    collection.merge(this.groupMemberCollection.models);
  },

  _groupMembersError: function(error) {
    console.error('Error getting group members:', error);
  },

  // FriendLists
  _handleFriendLists: function(friendLists) {
    this.friendListCollection = friendLists;
    friendLists.addListener('endUpdate', this._processFriendLists, this);
    friendLists.downloadHead(1000);
    this._processFriendLists();
  },

  _processFriendLists: function() {
    var collection = this.getListCollection();
    collection.merge(this.friendListCollection.models);
  },

  _friendListsError: function(error) {
    console.error('Error getting friend lists:', error);
  }
});

var _instance = null;
exports.getInstance = function() {
  if (!_instance) {
    _instance = new FiltersDataSource();
  }
  return _instance;
};
});

// module: views/feedback/ufi/like_row/index
// file:   ../../views/feedback/ufi/like_row/index.js
define("views/feedback/ufi/like_row/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;

var Deferred = require('shared/deferred').Deferred;
var LikeStore = require('shared/data2/model/like/store').getInstance();
var UfiClient = require('ufi/client').getInstance();
var LikeButton = require('views/feedback/buttons/like_button').LikeButton;

/**
 * @class UfiLikeRow
 * @classdesc UfiLikeRow shows a summary of the people who liked a story
 * (Alice and Bob like this.).
 */
var UfiLikeRow = core.createClass({

  name: 'UfiLikeRow',

  extend: View,

  properties: {
    likeCollection: null,
    likes: null
  },

  construct: function(options) {
    this._ready = new Deferred();
    View.call(this, options);
  },

  declare: function(options) {
    return {
      className: 'bt-ufi-row',
      boxOrientation: 'horizontal',
      childViews: [
        {
          view: LikeButton,
          ref: 'likeButton',
          action: 'likeButtonPressed',
          className: 'bt-ufi-like-row--like-button'
        },
        {
          className: 'bt-ufi-like-row--label',
          ref: 'label',
          flex: 1
        }
      ]
    };
  },

  ready: function() {
    this._ready.succeed();
  },

  setModel: function(model) {
    if (model === this.getModel()) {
      return;
    }
    this.set('model', model);
    this._ready.addCallback(this._afterReady, this);
  },

  _afterReady: function() {
    var model = this.getModel();
    var propertyList = [{property: 'likes'}];
    this.setBinding(model, propertyList);
    this.findRef('likeButton').setBinding(model, propertyList);
    UfiClient.fetchLikeCollection(model, true)
      .addCallback(function(collection) {
        this.setLikeCollection(collection);
        collection.download().addCallback(this._afterDownload, this);
      }, this
    );
  },

  _afterDownload: function() {
    var likeCollection = this.getLikeCollection();
    var currentLikes = this.getLikes();
    var likeCount = currentLikes.count;
    var length = likeCollection.length;
    var likes = Math.max(likeCount, length);

    // remove the binding to the original model now that we have the real deal
    this.removeBinding();

    // TODO: Add all like sentence cases. Use this for reference:
    // https://phabricator.fb.com/diffusion/E/browse/tfb/trunk/www/flib/feedback/like/ui/renderers/LikeSentenceRenderers.php
    if (length > 0) {
      this.show();
      this.findRef('label').setContent(
        likeCollection.at(0).get('user').name + ' and ' + (likes - 1) + ' ' +
        (likes > 2 ? 'others' : 'other') + ' like this.');
    }
  },

  likeButtonPressed: function() {
    this.getModel().toggleLike();
  },

  setLikes: function(likes) {
    this.set('likes', likes);
    var count = likes.count;
    if (!count) {
      this.hide();
    } else if (!this.getLikeCollection()) {
      this.show();
      if (count === 1) {
        this.findRef('label').setContent('1 person likes this');
      } else if (count > 1) {
        this.findRef('label').setContent(count + ' people like this');
      }
    }
  }
});

exports.UfiLikeRow = UfiLikeRow;
});

// module: view/thread_row/index
// file:   view/thread_row/index.js
define("view/thread_row/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

// The ThreadRow is a representation of a Thread used to render the
// ThreadListScene Table view. ThreadRow is not a subclass of Bolt View.
// It is optimized for emitting an html string representation of itself
// in order to make rendering large numbers of cells as performant as
// possible.
var core        = require('bolt/core');
var dateUtil    = require('shared/date_util');
var View        = require('bolt_touch/view').View;
var MultiAvatar = require('views/multiavatar').MultiAvatar;
var contacts    = require('talk/client/model/thread/contacts');

// ThreadRow
exports.ThreadRow = core.createClass({
  name: 'ThreadRow',

  extend: View,

  properties: {
    model: null
  },

  declare: function(options) {
    return {
      className: 'talk-thread-row',
      childViews: [
        {
          view: MultiAvatar,
          ref: 'avatar',
          className: 'talk-thread-row--avatar'
        },
        {
          className: 'talk-thread-row--name',
          ref: 'name'
        },
        {
          className: 'talk-thread-row--body',
          ref: 'body',
          childViews: [
            {
              className: 'talk-thread-row--body--icon',
              ref: 'bodyIcon'
            },
            {
              className: 'talk-thread-row--body--text',
              ref: 'bodyText'
            },
            {
              className: 'talk-thread-row--timestamp',
              ref: 'timestamp'
            }
          ]
        }
      ]
    };
  },

  setHighlighted: function(state) {
    return this.toggleClass('talk-thread-row_selected', state);
  },

  setModel: function(model) {
    if (!model) {
      return;
    }
    var dtString = dateUtil.shortTimestamp(model.getDateTime());
    this.refs.name.setContent(model.getTitle());
    this.refs.timestamp.setContent(dtString);
    this.refs.bodyText.setContent(model.get('snippet'));

    this.toggleClass('talk-thread-row_unread', model.isUnread());
    this.toggleClass('talk-thread-row_reply', model.isReply());
    this._setAvatarImage(model);
    if (model.get('participantsHash') == 'N/A') {
      this.setStyle('opacity', 0.3);
      var dom = require('bolt/dom');
      var span =
        dom.createElement('span', { className: 'broken-thread' }, '!!!!! ');
      this.refs.name.setContent([span, model.getTitle()]);
    } else {
      this.setStyle('opacity', 1);
    }
  },

  _setAvatarImage: function(model) {
    var participants  = model.participantsForAvatar();
    var profiles      = model.getParticipantProfiles();
    var avatarOptions = [];
    var ident, localContact, i, j;

    for (i = 0; i < participants.length; i++) {
      ident = contacts.buildInfoIdent(participants[i]);
      localContact = null;
      for (j = 0; j < profiles.length; j++) {
        if (profiles[j].get('ident') == ident) {
          localContact = profiles[j];
          break;
        }
      }
      var url = contacts.profileURL(participants[i], localContact);
      if (url) {
        avatarOptions.push({ avatarUrl: url });
      }
    }
    this.findRef('avatar').setParticipants(avatarOptions);
  }
});
});

// module: contacts/browse_contacts_section
// file:   contacts/browse_contacts_section.js
define("contacts/browse_contacts_section", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var InMemorySearchCommand =
  require('./all_contacts_section/in_memory_search_command')
  .InMemorySearchCommand;
var ContactsListScene =
  require('./all_contacts_section/ui/contacts_list_scene').ContactsListScene;
var ContactsPortfolio =
  require('../contacts/contacts_portfolio').ContactsPortfolio;
var FacebookContactsBrowser =
  require('./browse_contacts_section/facebook_contacts_browser')
  .FacebookContactsBrowser;
var FacebookUsersContactsList =
  require('./browse_contacts_section/facebook_users_contacts_list')
  .FacebookUsersContactsList;

var AjaxGroupContactsServer =
  require('./browse_contacts_section/ajax_group_contacts_server')
  .AjaxGroupContactsServer;
var AjaxFriendListContactsServer =
  require('./browse_contacts_section/ajax_friend_list_contacts_server')
  .AjaxFriendListContactsServer;

var ContactsPortfolioTableModel =
  require('./shared/ui/contacts_portfolio_table_model').ContactsPortfolioTableModel;

var Announcer = require('./util/announcer').Announcer;

var groupServer = function() {
  if (window.__ACCEPTANCE_TEST__) {
    return require('./stubs/group_contacts').server;
  } else {
    return new AjaxGroupContactsServer();
  }
};

var friendListServer = function() {
  if (window.__ACCEPTANCE_TEST__) {
    return require('./stubs/group_contacts').server;
  } else {
    return new AjaxFriendListContactsServer();
  }
};

/**
 * This section displays a list of "contacts" (not necessarily people in your
 * contacts list) who are members of a particular group or list.
 */
var BrowseContactsSection = core.createClass({
  name: 'BrowseContactsSection',

  construct: function(options) {
    var announcer = this._announcer = new Announcer();
    var portfolio = new ContactsPortfolio();
    var contactsList =
      new FacebookUsersContactsList(groupServer(), friendListServer());
    var inMemorySearchCommand = new InMemorySearchCommand();
    this.contactsBrowser = new FacebookContactsBrowser(contactsList, portfolio);

    var tableModel = new ContactsPortfolioTableModel(portfolio);

    this._contactsListScene = new ContactsListScene({
      tableModel: tableModel,
      searchManager: inMemorySearchCommand
    });
    this._contactsListScene.addEventListener(inMemorySearchCommand);

    var externalEventsProxy = {
      contactSelected: function(contactSnapshot) {
        announcer.announce('contactSelected', contactSnapshot);
      },

      filterContacts: function() {
        announcer.announce('filterContacts');
      }
    };
    this._contactsListScene.addEventListener(externalEventsProxy);
  },

  getScene: function() {
    return this._contactsListScene;
  },

  displayContactsInGroup: function(groupData) {
    this._contactsListScene.setTitle(groupData.name);
    this.contactsBrowser.browseByGroup(groupData.gid);
  },

  displayContactsInList: function(listData) {
    this._contactsListScene.setTitle(listData.name);
    this.contactsBrowser.browseByList(listData.flid);
  },

  addListener: function(listener) {
    this._announcer.addListener(listener);
  }
});

exports.BrowseContactsSection = BrowseContactsSection;
});

// module: photos/app/lib/view/photo_tags/photo_tag
// file:   ../../photos/app/lib/view/photo_tags/photo_tag.js
define("photos/app/lib/view/photo_tags/photo_tag", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var View = require('bolt_touch/view').View;
var PHONE_DIMENSION = require('shared/screen_constants').PHONE_DIMENSION;
var ActionableView = require('bolt_touch/views/actionable_view').ActionableView;

var DELETE_BUTTON_WIDTH = 45;
var OFFSET_HEURISTIC = 30;
var NO_NAME = -1;

/**
 * Tag View is a view that accept a tag position in photos.
 * Tag should be an object of:
 *   {
 *     x: x position of tag (in %)
 *     y: y position of tag (in %)
 *     name: name of people in tag
 *   }
 */
exports.PhotoTag = core.createClass({
  name: 'PhotoTag',
  extend: View,

  properties: {
    boundingBox: null
  },

  declare: function(options) {
    return {
      boxOrientation: 'horizontal',

      childViews: [
        {
          view: ActionableView,
          ref: 'tagName',
          className: 'tagName',
          action: 'onTagTouched'
        },
        {
          view: ActionableView,
          ref: 'deleteButton',
          className: 'deleteButton',
          content: 'x',
          action: 'onDeleteButtonTouched'
        }
      ]
    };
  },

  ready: function() {
    this.tagName = this.findRef('tagName');
    this.showingDeleteButton = false;
    this.findRef('deleteButton').hide();
  },

  onDocumentInsertion: function() {
    this.update();
  },

  update: function() {
    var model = this.getModel();

    var name = null;
    if (model.get('id') === NO_NAME) {
      name = 'Who is this?';
    } else {
      name = model.get('text');
    }

    this.tagName.setContent(name);

    var dimension = this.get('boundingBox');
    // Figure out pixel position, rather than %.
    var left = Math.floor(dimension.left + model.get('xcoord') *
        dimension.width / 100) - OFFSET_HEURISTIC;
    var top = Math.floor(dimension.top + model.get('ycoord') *
        dimension.height / 100) + OFFSET_HEURISTIC;

    this.setStyle({
      left: left + 'px',
      top: top + 'px'
    });

    // useful for debugging and testing
    this.setAttributes({
      xcoord: model.get('xcoord'),
      ycoord: model.get('ycoord')
    });
  },

  toggleDeleteButton: function() {
    if (!this.showingDeleteButton) {
      this.showDeleteButton();
    } else {
      this.hideDeleteButton();
    }
  },

  showDeleteButton: function() {
    this.showingDeleteButton = true;
    this.findRef('deleteButton').show();
  },

  hideDeleteButton: function() {
    this.showingDeleteButton = false;
    this.findRef('deleteButton').hide();
  },

  onTagTouched: function(view, evt) {
    this.invoke('photoTagTouched', {
      photo_tag: this.getModel(),
      view: this
    });

    evt.stopPropagation();
  },

  onDeleteButtonTouched: function(view, evt) {
    this.invoke('photoTagDeleteTouched', {
      photo_tag: this.getModel(),
      view: this
    });

    evt.stopPropagation();
  },

  getMeasuredDimension: function() {
    var node = this.getNode();
    var width = this.tagName.getNode().offsetWidth;
    var height = this.tagName.getNode().offsetHeight;

    return {
      left: node.offsetLeft,
      top: node.offsetTop,
      width: width,
      height: height
    };
  }
});
});

// module: views/framed_image/index
// file:   ../../views/framed_image/index.js
define("views/framed_image/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var View = require('bolt_touch/view').View;
var imageQueue = require('bolt_touch/util/image_queue');

var PHONE_DIMENSION = require('shared/screen_constants').PHONE_DIMENSION;

/**
 * @class FramedImage
 * @classdesc An image centered and cropped within a div. Requires frameHeight
 * and frameWidth properties to be specified in order for image to be properly
 * centered.
 */
exports.FramedImage = require('bolt/core').createClass({

  name: 'FramedImage',

  extend: View,

  properties: {
    /*
    * @property frameHeight {number} The height, in pixels, of the image
     * frame
     */
    frameHeight: null,
    /**
     * @property frameWidth {number} The width, in pixels, of the image
     * frame
     */
    frameWidth: null,
    imageMaxWidth: null,
    /**
     * @property src {string} The URL of the image to fetch.
     */
    src: null,
    /**
     * @property srcWidth {number} the height of the original image
     */
    srcHeight: null,
    /**
     * @property srcWidth {number} the width of the original image
     */
    srcWidth: null
  },

  declare: function() {
    return {
      className: 'bt-framed-image--wrap',
      childViews: [
        {
          className: 'bt-framed-image--image',
          ref: 'image',
          tagName: 'img'
        }
      ]
    };
  },

  setSrc: function(url) {
    this.set('src', url);
    if (this.enqueued) {
      this.findRef('image').setSrc(null);
      imageQueue.remove(url, this.handleQueueCallback, this);
    }
    if (this.getInDocument()) {
      this.queueImage(url);
      this.enqueued = true;
    }
  },

  onDocumentInsertion: function() {
    var url = this.getSrc();
    if (!this.enqueued && url) {
      this.queueImage(url);
    }
  },

  queueImage: function(url) {
    this.findRef('image').addClass('hidden');
    imageQueue.add(url, this.handleQueueCallback, this);
  },

  handleQueueCallback: function(url, width, height) {
    if (!this.isDestroyed && url === this.get('src')) {
      var image = this.findRef('image');
      var rect = this.getRect();
      var frameWidth = rect.width;
      var frameHeight = rect.height;
      var style = {};
      var MAX_WIDTH = PHONE_DIMENSION.width;
      // if the image is wider than the screen, and the frame is the screen's
      // width, we scale the image down to the screen width. Otherwise, we
      // horizontally center the image.
      if (width > MAX_WIDTH && frameWidth >= MAX_WIDTH) {
        style.width = MAX_WIDTH + 'px';
        height = height * MAX_WIDTH / width;
        width = MAX_WIDTH;
        style.left = 0;
      } else {
        style.width = null;
        style.left = (frameWidth - width) / 2 + 'px';
      }
      style.top = (frameHeight - height) / 2 + 'px';
      image.setStyle(style);
      image.setAttributes({src: url});
      this.findRef('image').removeClass('hidden');
      this.setSrcWidth(width);
      this.setSrcHeight(height);
      this.setFrameHeight(frameHeight);
      this.setFrameWidth(frameWidth);
    }
  },

  destroy: function() {
    if (this.enqueued) {
      imageQueue.remove(this.get('src'), this.handleQueueCallback, this);
    }
    View.prototype.destroy.call(this);
  }
});

});

// module: shared/batch_filter
// file:   ../../shared/js/batch_filter.js
define("shared/batch_filter", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*
 * This class is used for making more responsive filtering of collections
 * e.g. contacts search
 *
 * Filtering is made within chunks, results from each chunk are returned as
 * soon as chunk is finished, then filtering continues after some timeout.
 */
var core        = require('bolt/core');
var builder     = require('bolt/builder');
var util        = require('bolt/util');
var Events      = require('bolt/mixins/events').Events;
var Collection  = require('bolt/collection').Collection;

var DEFAULT_CHUNK_SIZE = 50;
var DEFAULT_TIMEOUT = 20;
var DEFAULT_TOTAL_RESULTS_MAX = -1;

var BatchFilter = exports.BatchFilter = core.createClass({

  mixins: [Events],

  chunkSize: DEFAULT_CHUNK_SIZE,
  timeout: DEFAULT_TIMEOUT,
  maxResults: DEFAULT_TOTAL_RESULTS_MAX,

  construct: function(data, options) {
    this.items = data;
    if (options && options.chunkSize) {
      this.chunkSize = options.chunkSize;
    }
    if (options && options.timeout) {
      this.timeout = options.timeout;
    }
    if (options && options.maxResults) {
      this.maxResult = options.maxResults;
    }

    this._initialChunkSize = this.chunkSize;
    this.filterStep = util.bind(this._filterChunk, this);
    this._collection = new Collection();
  },

  getCollection: function() {
    return this._collection;
  },

  clear: function() {
    this._collection.clear();
  },

  search: function(matchFunction, context) {
    this.stopSearch();
    this.clear();

    this.matchFunction = matchFunction;
    this.context = context;
    this._currentIterator = this._createIterator();
    this.chunkSize = this._initialChunkSize;

    this.invoke(
      'searchStart',
      {iterator: this._currentIterator}
    );

    this._filterChunk();
  },

  _createIterator: function() {
    return {
      iteration: 0,
      found: 0
    };
  },

  _filterChunk: function() {
    var iterator = this._currentIterator;
    var filtered = 0,
        results = [],
        item;

    while (iterator.iteration < this.items.length) {
      if (filtered === this.chunkSize) {
        // Another chunk finished, return results
        if (results.length) {
          this._mergeChunk(results);
          if (this.chunkSize === this._initialChunkSize) {
            this.chunkSize *= 2;
          }
        }
        if (iterator.found < this.maxResults || this.maxResults < 0) {
          // If we already found maxResults matches, we do not need to continue
          this._currentIterator = iterator;
          this._searchTimer = setTimeout(this.filterStep, this.timeout);
        }
        return;
      }
      item = this.items[iterator.iteration];

      if (item && this.matchFunction.call(this.context, item)) {
        iterator.found++;
        results.push(item);
      }

      iterator.iteration++;
      filtered++;
    }

    this._mergeChunk(results);

    this.stopSearch();
    this.invoke(
      'searchFinish',
      {iterator: iterator}
    );
  },

  _mergeChunk: function(results) {
    this._collection.merge(results);
  },

  stopSearch: function() {
    if (this._searchTimer) {
      clearTimeout(this._searchTimer);
      this._searchTimer = false;
      this._currentIterator = null;
    }
  }
});
});

// module: view/thread_phone_numbers_scene/thread_phone_numbers_scene
// file:   view/thread_phone_numbers_scene/thread_phone_numbers_scene.js
define("view/thread_phone_numbers_scene/thread_phone_numbers_scene", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

// ThreadPhoneNumbersScene lets the user view all
// phone numbers of all participants of a certain thread

var core              = require('bolt/core');
var sharedUtil        = require('shared/util');

var ActionableView    = require('bolt_touch/views/actionable_view').ActionableView;
var Scene             = require('bolt_touch/views/scene').Scene;
var TableView         = require('bolt_touch/views/table_view').TableView;
var TableViewCell     = require('bolt_touch/views/table_view').TableViewCell;

var dom = require('bolt/dom');
function classDiv(clazz, body) {
  return dom.createElement('div', {className: clazz}, body);
}

var ThreadPhoneNumbersScene =
  exports.ThreadPhoneNumbersScene = core.createClass({

  name: 'ThreadPhoneNumbersScene',

  extend: Scene,

  properties: {
    controller: null,
    numbers: []
  },

  declare: function(options) {
    return {
      boxOrientation: 'vertical',
      flex: 1,
      height: '100%',
      childViews: [
        {
          className: 'bt-bar',
          boxOrientation: 'horizontal',
          childViews: [
            {
              view: ActionableView,
              action: 'onDown',
              className: 'bt-bar-button left bt-down-button'
            },
            {
              className: 'bt-bar-title',
              flex: 1,
              content: 'Select the number to dial'
            }
          ]
        },
        {
          view: TableView,
          ref: 'numbersTable',
          flex: 1,
          className: 'bt-numbers-table',
          useNativeScroll: true,
          bufferSize: 4,
          sectioned: false,
          selectable: false,
          fixedRowHeight: 91
        }
      ]
    };
  },

  numberOfRowsInSection: function(tableView, section) {
    return this.getNumbers().length + 1;
  },

  cellSelectedAtRowInSection: function(tableView, row, section, cell) {
    if (row === 0) {
      this.getController().openDialer();
    } else {
      var record = this.getNumbers()[row - 1];
      sharedUtil.makeCall(
        record.phone,
        JSON.stringify({profile: {name: record.name}}))
        .then(this._dismissOnDialed, this);
    }
  },

  _dismissOnDialed: function(callStatus) {
    var phoneApi = FBAPI.use('phone');
    if (callStatus === phoneApi.CALL_DIALED) {
      this.getController().backToThreads();
    }
  },

  cellForRowInSection: function(tableView, row, section) {
    var cell = tableView.dequeueReusableCellWithIdentifier('cell');
    if (!cell) {
      cell = new TableViewCell({
        reuseIdentifier: 'cell',
        className: 'bt-number-choice'
      });
    }

    var content;
    if (row === 0) {
      content = 'Open Dialer';
    } else {
      var number = this.getNumbers()[row - 1];
      if (number.name) {
        // This apparently never happens
        content = classDiv('hasextra',
                           [classDiv('main', number.name),
                            classDiv('extra', number.phone)]);
      } else {
        content = classDiv('noextra',
                           classDiv('main', number.phone));
      }
    }

    cell.setContent(classDiv('content', content));
    return cell;
  },

  onDown: function() {
    this.getController().backToThread();
  }
});
});

// module: shared/uri_util
// file:   ../../shared/js/uri_util.js
define("shared/uri_util", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*global undefined: false */

// parseUri 1.2.2
// // (c) Steven Levithan <stevenlevithan.com>
// // MIT License
// http://blog.stevenlevithan.com/archives/parseuri
var parseUri = exports.parseUri = function(str) {
  var o   = parseUri.options;
  var m   = o.parser[o.strictMode ? "strict" : "loose"].exec(str);
  var uri = {};
  var i   = 14;

  while (i--) {
    uri[o.key[i]] = m[i] || "";
  }

  uri[o.q.name] = {};
  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
    if ($1) {
      uri[o.q.name][$1] = $2;
    }
  });

  return uri;
};



parseUri.options = {
  strictMode: false,
  key: [
    "source", "protocol", "authority", "userInfo", "user", "password", "host",
    "port", "relative", "path", "directory", "file", "query", "anchor"
  ],
  q: {
    name:   "queryKey",
    parser: /(?:^|&)([^&=]*)=?([^&]*)/g
  },
  parser: {
    strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
    loose:  /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
  }
};

exports.encodeObj = function (params, sep, encode) {
  sep    = sep === undefined ? '&' : sep;
  encode = encode === false ?
    function(s) {
      return s;
    } :
    encodeURIComponent;

  var pairs = [];
  for (var key in params) {
    if (params[key] !== null) {
      pairs.push(encode(key) + '=' + encode(params[key]));
    }
  }
  pairs.sort();

  return pairs.join(sep);
};

/**
 * Retrieve GET parameters by name.
 */
exports.getParam = function(name, url) {
  var index = url.indexOf(name + '=');
  if (index == -1) {
    return null;
  }
  var remainder = url.substr(index);
  var ampersandIndex = remainder.indexOf('&');
  if (ampersandIndex != -1) {
    remainder = remainder.slice(name.length + 1, ampersandIndex);
  }
  return remainder;
};

/**
 * Ensure that the given url has a protocol identifier.
 */
var sanitizeUrlProtocol = exports.sanitizeUrlProtocol = function(url) {
  url = url.trim();
  if (!url.match(/^[a-zA-Z]+:/)) {
    url = "http://" + url.replace(/^[a-zA-Z]*:\/*/, "");
  }
  return url;
};

function urlHostname(url) {
  // This is based on
  // http://stackoverflow.com/questions/441755/regular-expression-to-remove-hostname-and-port-from-url
  var urlRegex = /^(.*?:\/\/.*?)\/.*$/;
  var match = url.match(urlRegex);
  if (!match || match.length < 2) {
    return null;
  } else {
    return match[1];
  }
}

/**
 * Determine if a given URL is under facebook.com
 */
exports.isFacebookUrl = function(url) {
  return exports.stringEndsWith(urlHostname(url), 'facebook.com');
};

/**
 * Return whether the url refers to local resource
 */
exports.isLocalUrl = function(url) {
  url = url.trimLeft();
  return this.stringStartsWith(url, 'fbcf:') ||
         this.stringStartsWith(url, 'file:');
};

exports.flatten = function(obj) {
  var flat = {};
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      var value = obj[key];
      if (null === value || undefined === value) {
        continue;
      } else if (typeof value == 'string') {
        flat[key] = value;
      } else {
        flat[key] = JSON.stringify(value);
      }
    }
  }
  return flat;
};
});

// module: shared/shadowbroker/shadow/collection/collection_shadow
// file:   ../../shared/js/shadowbroker/shadow/collection/collection_shadow.js
define("shared/shadowbroker/shadow/collection/collection_shadow", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core = require('bolt/core');
var util = require('bolt/util');
var Collection = require('bolt/collection').Collection;
var Model = require('bolt/model').Model;

var Shadow = require('../base/shadow').Shadow;

var EVENT_TYPE_ADD          = 1;
var EVENT_TYPE_REMOVE       = 2;
var EVENT_TYPE_CHANGE       = 3;
var EVENT_TYPE_UPDATE       = 4;
var EVENT_TYPE_BEGIN_UPDATE = 5;
var EVENT_TYPE_END_UPDATE   = 6;


var CollectionShadowMixin = util.defaults({
  initFromData: function(data) {
    this.merge(this._createModels(data));
  },

  _createModels: function(array) {
    for (var i = 0; i < array.length; i++) {
      array[i] = new this.modelType(array[i], true);
    }
    return array;
  },

  reactToMessage: function(event) {
    var eventType = event.type;
    if (eventType === EVENT_TYPE_ADD) {
      this.insert(event.index, new this.modelType(event.data, true));
    } else if (eventType === EVENT_TYPE_REMOVE) {
      // TODO: add remove/add functionality to CollectionShadowMixin
      Collection.prototype.remove.call(this, this.at(event.index));
    } else if (eventType === EVENT_TYPE_CHANGE) {
      this.at(event.index).setAll(event.data);
    } else if (eventType === EVENT_TYPE_UPDATE) {
      this.replace(this._createModels(event.data));
    } else if (eventType === EVENT_TYPE_BEGIN_UPDATE) {
      this._beginBatchUpdate();
    } else if (eventType === EVENT_TYPE_END_UPDATE) {
      this._endBatchUpdate();
    }
  },

  insert: function(idx, model) {
    var cid = model.cid;
    var id = model.id;
    if (!this._byCid[cid] && (!id || !this._byId[id])) {
      this.models.splice(idx, 0, model);
      this._byCid[cid] = model;
      if (model.id !== null) {
        this._byId[id] = model;
      }
      this.length++;
      this._listeners[cid] = model.addListener('changed',
        this._onModelChanged, this);
      this.invoke('modelAdded', { model: model, index: idx });
      return model;
    }
    return false;
  },

  destroy: function() {
    Collection.prototype.destroy.call(this);
    Shadow.destroy.call(this);
  }
}, Shadow);

/**
 * Default Collection's shadow implementation.
 *
 * CollectionShadow is a shadow of a collection in a SharedWorker. It
 * automatically updates when the original colleciton changes. CollectionShadow
 * exposes standard Collection api and events.
 *
 * SharedWorker should wrap an original Collection into CollectionUpdater so
 * CollectionShadow can recieve change events. To create a CollectionShadow
 * from a CollectionUpdater channel:
 *
 *   broker.callMethod('store', 'fetchCollection')
 *     .then(function(collectionChannel) {
 *       var shadowCollection = new CollectionShadow();
 *       shadowCollection.setChannel(collectionChannel);
 *       return shadowCollection;
 *     });
 */
var CollectionShadow = core.createClass({
  extend: Collection,
  name: 'CollectionShadow',

  mixins: [CollectionShadowMixin],

  statics: {
    modelType: Model
  }
});

exports.EVENT_TYPE_ADD          = EVENT_TYPE_ADD;
exports.EVENT_TYPE_REMOVE       = EVENT_TYPE_REMOVE;
exports.EVENT_TYPE_CHANGE       = EVENT_TYPE_CHANGE;
exports.EVENT_TYPE_UPDATE       = EVENT_TYPE_UPDATE;
exports.EVENT_TYPE_BEGIN_UPDATE = EVENT_TYPE_BEGIN_UPDATE;
exports.EVENT_TYPE_END_UPDATE   = EVENT_TYPE_END_UPDATE;
exports.CollectionShadow      = CollectionShadow;
exports.CollectionShadowMixin = CollectionShadowMixin;
});

// module: view/thread_actions/index
// file:   view/thread_actions/index.js
define("view/thread_actions/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

// ThreadActionsView lets the user perform actions on a thread

var core        = require('bolt/core');
var util        = require('bolt/util');
var ActionSheet = require('bolt_touch/views/action_sheet').ActionSheet;
var session     = require('shared/session');
var threadChangesClient = require('talk/client/thread_changes_client');

exports.ThreadActionsView = core.createClass({
  name: 'ThreadActionsView',

  extend: ActionSheet,

  properties: {
    model: null,
    controller: null,
    threadScene: null
  },

  declare: function(options) {
    var model = options.model;
    var isArchived = model.isArchived();
    var is1To1 = model.is1to1();
    var isSubscribed = model.hasSubscribedParticipant(session.getUid());
    var actions = [
      {
        className: 'bt-archive ' + (isArchived ? '' : 'bt-destroy'),
        value: isArchived ? 'Unarchive' : 'Archive',
        action: 'onArchive',
        owner: this
      },
      {
        className: 'bt-mark-spam',
        value: 'Mark Spam',
        action: 'onSpam',
        owner: this
      },
      {
        className: 'bt-mark-unread',
        value: 'Mark Unread',
        action: 'onUnread',
        owner: this
      },
      {
        className: 'bt-forward',
        value: 'Forward',
        action: 'onForward',
        owner: this
      },
      {
        className: 'bt-delete',
        value: 'Delete',
        action: 'onDelete',
        owner: this
      }
    ];
    if (!is1To1 && isSubscribed) {
      actions.push({
        className: 'bt-unsubscribe',
        value: 'Leave Conversation',
        action: 'onUnsubscribe',
        owner: this
      });
    }
    actions.push({
      value: 'Cancel',
      className: 'bt-cancel'
    });
    return {
      actions: actions
    };
  },

  onArchive: function() {
    var thread = this.getModel();
    threadChangesClient.getInstance()
      .markAsArchived(thread.getId(), !thread.isArchived());
    threadChangesClient.getInstance().uploadChanges(thread.getId());
    this.getController().backToThreads();
  },

  onSpam: function() {
    var thread = this.getModel();
    threadChangesClient.getInstance().markAsSpam(thread.getId(), true);
    threadChangesClient.getInstance().uploadChanges(thread.getId());
    this.getController().backToThreads();
  },

  onUnread: function() {
    var thread = this.getModel();
    var client = threadChangesClient.getInstance();
    client.markAsRead(thread.getId(), false)
      .addCallback(client.uploadChanges, client, thread.getId());
    this.getController().backToThreads();
  },

  onForward: function() {
    var _this = this;
    this.getOwner().startSelection({
      actionButtonLabel: 'OK',
      oncomplete: function(msgs) {
        var ids = util.pluck(msgs, 'id');
        _this.getController().openMessageComposer({
          forwards: msgs
        });
      }
    });
  },

  onDelete: function() {
    this.getOwner().startSelection({
      actionButtonLabel: 'DEL',
      oncomplete: function(msgs) {
        var ids = util.pluck(msgs, 'id');
        var sendMessageClient =
          require('talk/client/send_message_client');
        return sendMessageClient.getInstance().deleteMessages(ids);
      }
    });
  },

  onUnsubscribe: function() {
    var thread = this.getModel();
    threadChangesClient.getInstance().leave(thread.getId());
    threadChangesClient.getInstance().uploadChanges(thread.getId());
  }
});
});

// module: shared/data2/local/migration/spec_migration
// file:   ../../shared/js/data2/local/migration/spec_migration.js
define("shared/data2/local/migration/spec_migration", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var Deferred = require('shared/deferred').Deferred;
var sqlHelper = require('./sql_helper');
var Migration = require('./migration').Migration;

function _questionMark() {
  return "?";
}

function _createTable(transaction, spec) {
  var createTableSql = sqlHelper.createTable(spec);     // String
  var createIndexesSql = sqlHelper.createIndexes(spec); // Array of strings
  var statements = [createTableSql].concat(createIndexesSql);
  statements.forEach(function(sql) {
    transaction.executeSql(sql);
  });
}

function _dropTable(transaction, spec) {
  transaction.executeSql(sqlHelper.dropTable(spec));
}

// number of rows to read at a time when backing up tables
var CHUNK_SIZE = 100;

var SpecMigration = core.createClass({
  name: 'SpecMigration',
  extend: Migration,

  properties: {
    spec: null
  },

  construct: function(options) {
    if (options.spec) {
      this.setSpec(options.spec);
    }
    if (options.rowUp) {
      this._rowUp = options.rowUp;
    }

    Migration.call(this, options);
  },

  up: function(transaction) {
    var spec = this.getSpec();
    if (this._rowUp) {
      var columns = util.pluck(spec.getColumns(), 'name');
      transaction.executeSql("CREATE TEMPORARY TABLE __migration__ " +
        "(" + columns.join(", ") + ")");
      this._backupDataWithRowUp(transaction)
      .then(function() {
        _dropTable(transaction, spec);
        _createTable(transaction, spec);
        transaction.executeSql("INSERT INTO " + spec.getTableName() +
          " (" + columns.join(", ") + ")" +
          " SELECT " + columns.join(", ") + " FROM __migration__");
        transaction.executeSql("DROP TABLE __migration__");
      });
    } else {
      _dropTable(transaction, spec);
      _createTable(transaction, spec);
    }
  },

  reset: function(transaction) {
    _dropTable(transaction, this.getSpec());
  },

  _backupDataWithRowUp: function(transaction) {
    var tableName = this.getSpec().getTableName();
    var rowTransform = this._rowUp;
    function backupWithOffset(offset, deferred) {
      var sql = "SELECT * FROM " + tableName +
        " LIMIT " + CHUNK_SIZE + " OFFSET " + offset;
      transaction.executeSql(sql)
      .then(function(result) {
        var rows = result.rows;
        for (var i = 0; i < rows.length; i++) {
          // make a copy of the row before passing it into rowTransform so
          // rowCopy is mutable in rowTransform; then rowTransform can just
          // modify rowCopy and return it
          var key;
          var row = rows.item(i);
          var rowCopy = {};
          for (key in row) {
            if (row.hasOwnProperty(key)) {
              rowCopy[key] = row[key];
            }
          }
          var newRow = rowTransform(rowCopy);
          var columns = [];
          var values = [];
          for (key in newRow) {
            columns.push(key);
            values.push(newRow[key]);
          }
          sql = "INSERT INTO __migration__ (" + columns.join(", ") + ") " +
            "VALUES (" + values.map(_questionMark).join(", ") + ")";
          transaction.executeSql(sql, values);
        }

        if (rows.length < CHUNK_SIZE) {
          deferred.succeed();
        } else {
          backupWithOffset(offset + CHUNK_SIZE, deferred);
        }
      });
    }
    var d = new Deferred();
    backupWithOffset(0, d);
    return d;
  }
});

exports.SpecMigration = SpecMigration;
});

// module: shared/auth_manager
// file:   ../../shared/js/auth_manager.js
define("shared/auth_manager", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var api_key       = require('shared/config').api_key;
var core          = require('bolt/core');

/* Manages the authentication object.
 * An auth object has the following fields:
 *
 *   sessionKey
 *   sessionSecret
 *   accessToken
 *   expires
 *   name
 *   userId
 *
 * The checks in this class are very defensive,
 * since we want to catch an abnormal case in
 * which some auth information could get lost.
 */
var AuthManager = core.createClass({
  name: 'AuthManager',

  isLoggedIn: function() {
    var auth = this.getAuth();

    if (auth && auth.accessToken &&
      (!auth.sessionKey || !auth.userId || !api_key)) {
      // A safety check to resolve the bug that
      // we could lose login credentials.
      console.error('Auth Manager: Incomplete login information! ' +
        JSON.stringify(auth));
      var authApi = this.getAuthAPI();

      console.error('Auth Manager: Authenticated URL = ' +
        authApi.getAuthenticatedURL('http://m.facebook.com'));
    }

    // Make sure we have all the credentials,
    // if we happen to lose any of them which
    // would casue the m-site auth to fail,
    // we can graciously bring up the login
    // screen to make sure we have all the
    // credentials
    return !!(auth && auth.accessToken && api_key &&
      auth.sessionKey && auth.userId);
  },

  // Getter for the auth object
  getAuth: function() {
    return JSON.parse(localStorage.getItem('auth'));
  },

  // Setter for the auth object
  setAuth: function(auth) {
    if (!api_key || !auth.accessToken || !auth.sessionKey ||
      !auth.sessionSecret || !auth.userId) {
      console.error(
        'Auth Manager: Incomplete auth when setting auth. Auth is:' +
          JSON.stringify(auth));
    }

    localStorage.setItem('auth', JSON.stringify(auth));

    this.updateAuthAPI(auth);
  },

  // Convenient getters
  getUserId: function() {
    var auth = this.getAuth();
    if (!auth) {
      return null;
    }

    return auth.userId;
  },

  getAccessToken: function() {
    return this.getAuth().accessToken;
  },

  // Create a session object
  createSessionObject: function() {
    var session = null;

    if (this.isLoggedIn()) {
      var auth = this.getAuth();

      session = {
        access_token: auth.accessToken || null,
        expires: auth.expires || null,
        uid: auth.userId || null,
        session_key: auth.sessionKey,
        session_secret: auth.sessionSecret
      };
    }

    return session;
  },

  // Safely return the auth api
  getAuthAPI: function() {
    return window.FBAPI ? window.FBAPI.use("auth") : null;
  },

  // Update the auth api
  // Note that we use constant for the api_key
  // There is a bug that we could lose api_key
  // when storing in the local storage.
  // See task 722218 for the details.
  // -ahu
  updateAuthAPI: function() {
    var authApi = this.getAuthAPI();
    var auth = this.getAuth();

    if (!api_key || !auth.accessToken || !auth.sessionKey ||
      !auth.sessionSecret || !auth.userId) {
      console.error(
        'Auth Manager: Incomplete auth when updating API. Auth is:' +
          JSON.stringify(auth));
    }

    if (auth && authApi) {
      authApi.setApiKey(api_key);
      authApi.setAccessToken(auth.accessToken || null);
      authApi.setUserId(auth.userId ? auth.userId.toString() :  null);
      authApi.setSessionKey(auth.sessionKey || null);
      authApi.setSessionSecret(auth.sessionSecret || null);
    }
  }
});

exports.AuthManager = new AuthManager();
});

// module: bolt_touch/views/scene
// file:   ../../../frameworks/bolt_touch/lib/views/scene.js
define("bolt_touch/views/scene", function(require, exports, module) {
var view = require('bolt/view');
var util = require('bolt/util');

var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var Button = require('./button').Button;


var Scene = core.createClass({
  name: 'Scene',

  extend: View,

  properties: {
    /**
    * Will be set by stack once scene is pushed into the stack
    *
    * @type {SceneStack}
    */
    stack: null,

    /**
    * Track if a scene was pushed as modal. The out and reverse.in
    * animations are skipped on the preceding scene if true
    */
    modal: null,

    /**
     * The PageHeader for this scene.  This is created and managed by
     * the stack
     */
    header: null,

    /**
     * This is managed by the stack to indicate if the scene is active or not.
     */
    isActive: false,

    /**
     * This is managed by the stack to indicate if a scene should be popped
     * when the scene above it is popped. Used to remove scenes from the stack
     * when they are not already on top.
     */
    isPopped: false,

    // TODO make this a static constant for each class
    /**
     * Subclasses of scene should set this to true if they would only like one
     * instance of that scene to exist on the stack. When a new instance of a
     * Scene is pushed, and isSingleton is true, it will check for a previous
     * instance and remove it from the stack after adding the new instance.
     */
    isSingleton: false,

    title: ''
  },

  // header API
  /**
   * Returns true if a header should be created for the scene,
   * false otherwise
   *
   * @return {Boolean}
   */
  useHeader: function() {
    return true;
  },

  setTitle: function(value) {
    this.set('title', value);
    var header = this.getHeader();
    if (header) {
      header.setLabel(value);
    }
  },

  /**
  * Return header left button
  * Either a description or a view
  *
  * @return {Object|View}
  */
  getHeaderLeft: function() {
    // If there is more than one Scene in the Stack, add a back button
    // This function can be overridden by child Scenes to not do this
    if (this.getStack().getDepth() > 0) {
      return {
        view: Button,
        value: 'Back',
        action: 'pop'
      };
    }
    return null;
  },

  /**
  * Return header left button
  * Either a description or a view
  *
  * @return {Object|View}
  */
  getHeaderRight: function() {
    return null;
  },

  pop: function(data, options) {
    this.getStack().pop(data, options);
  },


  // lifecycle
  /**
  * Called by SceneStack after being pushed first time.
  * May return Deferred object, if setup is asynchronous
  *
  * @return {null|Deferred}
  */
  prepare: function() {},

  /**
  * Will be called by SceneStack during:
  * a) push
  * b) pop when current scene is previous to the one being popped
  *
  * @param {object} data Optional data which can be supplied by
  *                      another scene popped off the stack
  */
  activate: function(data) {},

  /**
  * Will be called by SceneStack during:
  * a) pop
  * b) push when current scene is previous to the one being pushed
  */
  deactivate: function() {},

  /**
  * Will be called by SceneStack during transition.
  * Transition won't start unti activate/deactivate is complete
  *
  * @param {String} transition Possible values: 'in', 'in.reverse',
  *                            'out', 'out.reverse'
  */
  startTransition: function(transition) {},

  /**
  * @see startTransition
  *
  * @param {String} transition
  */
  endTransition: function(transition) {}
});


exports.Scene = Scene;
view.Scene = Scene;
});

// module: mock/sms_api
// file:   ../../mock/js/sms_api.js
define("mock/sms_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;

var FBOOK = '32665';
var MOCK_REQUEST_MESSAGE = 'F';
var MOCK_CONFIRMATION_MESSAGE = 'confirmation code: TESTING';

module.exports = {
  _timeout: 1000,

  sendSMS: function(number, message, msgCtx) {
    var _this = this;
    var uuid = 'A9FE0213-9631-421C-AA91-AA1F4F4D16C4';
    var length = message.length;
    /*
    * The max length for a single sms is 160 chars but it
    * is 153 chars for multi-part sms due to a 7 byte header
    * that is sent with each part.
    */
    var max = message.length > 160 ? 153 : 160;
    var numParts = Math.ceil(message.length / max);
    var extra = {ok: true,
                 code: 'RESULT_OK',
                 codeStr: 'ok',
                 id: uuid,
                 part: 0,
                 numparts: numParts };
    var partLength;
    for (var i = 0; i < numParts; i++) {
      setTimeout(
        function() {
          partlength = length - i * max;
          partLength = partLength < max ? partLength : max;
          EventManager.broadcastEvent('messaging.SENT', extra);
          extra.part++;
        },
      _this._timeout);
      _this._timeout += 1000;
    }
    var resp = {
      parts: numParts, //number of parts sent
      id: uuid
    };

    if (number === FBOOK && message === MOCK_REQUEST_MESSAGE) {
      this.queuePhoneConfirmationResponse(number, _this._timeout);
    }

    return JSON.stringify(resp);
  },

  queuePhoneConfirmationResponse: function(number, timeout) {
    timeout = Math.max(timeout, 1000 * 3); // wait at least 3 seconds
    setTimeout(
      function() {
        var PhoneNumberUtil =
          require('third-party/libphonenumber').PhoneNumberUtil;
        var sms = {
          from: number,
          message: MOCK_CONFIRMATION_MESSAGE,
          attachments: [],
          attachment_map: {},
          log_message: {
            smsLog: {
              type: 'incoming',
              callEndPoint: PhoneNumberUtil.normalize(number)
            }
          },
          is_unread: true
        };

        EventManager.broadcastEvent('messaging.RECEIVED', sms);
      },
      timeout
    );
  },

  sendMMS: function(recipientsJson, subject, message,
                    attachmentsJson, attachmentsType) {
    // Usage example:
    // smsApi.sendMMS(
    //   JSON.stringify(['206-555-6666']),
    //   'MMS subject',
    //   'MMS message text',
    //   JSON.stringify(['file:///mnt/sdcard/DCIM/Camera/Photo.jpg']),
    //   'image/jpg'
    // );
    var uuid = 'BB92BB4F-A3D0-406E-B9B3-84EF3B3BDDFB';

    setTimeout(
      function() {
        var data ={
          ok: true,
          id: uuid
        };
        EventManager.broadcastEvent('messaging.SENT', data);
      },
      this._timeout);

    // returns opaque string id that can be matched with
    // the success/failure event
    return uuid;
  },

  constants: function() {
    return JSON.stringify({
      RESULT_OK: -1,
      RESULT_ERROR_GENERIC_FAILURE: 1,
      RESULT_ERROR_RADIO_OFF: 2,
      RESULT_ERROR_NULL_PDU: 3,
      RESULT_ERROR_NO_SERVICE: 4
    });
  },

  codeToString: function(code) {
    switch (code) {
      case -1: return "ok";             // RESULT_OK
      case 1: return "generic failure"; // RESULT_ERROR_GENERIC_FAILURE
      case 2: return "radio off";       // RESULT_ERROR_RADIO_OFF
      case 3: return "null pdu";        // RESULT_ERROR_NULL_PDU
      case 4: return "no service";      // RESULT_ERROR_NO_SERVICE
      default: return "";
    }
  }
};
});

// module: contacts/shared/ui/contacts_list_table
// file:   contacts/shared/ui/contacts_list_table.js
define("contacts/shared/ui/contacts_list_table", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var TableViewSectionHeader =
  require("bolt_touch/views/table_view").TableViewSectionHeader;
var TableViewCell = require("bolt_touch/views/table_view").TableViewCell;
var Image = require('bolt_touch/views/image').Image;
var ActionableView = require('bolt_touch/views/actionable_view').ActionableView;

var HeaderFactory = function() {
  this._tableView = {
    dequeueReusableCellWithIdentifier: function() {
      return null;
    }
  };
};

var ContactsTableSectionHeader = core.createClass({
  extend: TableViewSectionHeader,

  declare: function(options) {
    return {
      className: 'contacts-list-table-section-header',
      childViews: [
        {
          ref: 'letter',
          className: 'section-header-letter'
        }
      ]
    };
  },

  setContent: function(letter) {
    this.findRef('letter').setContent(letter);
  }
});

HeaderFactory.prototype = {
  buildViewFor: function(letter) {
    var view;
    view = this._tableView.dequeueReusableCellWithIdentifier('contact_header');

    if (!view) {
      view = new ContactsTableSectionHeader({
        reuseIdentifier: 'contact_header',
      });
    }

    view.setContent(letter);
    return view;
  },

  setTableView: function(tableView) {
    this._tableView = tableView;
  }
};

var ViewAllContactsCell = core.createClass({
  extend: TableViewCell,

  construct: function() {
    TableViewCell.apply(this, arguments);
    this._announcer = arguments[0].announcer;
  },

  declare: function(options) {
    return {
      childViews: [{
        view: ActionableView,
        boxOrientation: 'horizontal',
        className: 'contact-cell',
        action: 'selectContact',
        childViews: [
          {
            ref: 'image',
            className: 'profile-picture',
            view: Image,
            queued: true,
            width: 100,
            height: 100,
            src: 'empty_profile.gif'
          },
          {
            className: 'contact-name',
            childViews: [
              {
                ref: 'firstName',
                className: 'first-name'
              },
              {
                ref: 'lastName',
                className: 'last-name'
              }
            ]
          }
        ]
      }]
    };
  },

  setSnapshot: function(snapshot) {
    this._currentSnapshot = snapshot;
    this.findRef('firstName').setContent(snapshot.firstName);
    // If sort by first name, set class to bold first name.
    this.findRef('firstName').addClass('sort-by');
    this.findRef('lastName').setContent(snapshot.lastName);
    var img = snapshot.profileUrl ? snapshot.profileUrl : 'empty_profile.gif';
    this.findRef('image').setSrc(img);
  },

  selectContact: function(event) {
    this._announcer.announce('contactSelected', this._currentSnapshot);
  }
});

var CellFactory = function(announcer) {
  this._announcer = announcer;
  this._tableView = {
    dequeueReusableCellWithIdentifier: function() {
      return null;
    }
  };
};

CellFactory.prototype = {
  buildViewFor: function(snapshot) {
    var view;
    view = this._tableView.dequeueReusableCellWithIdentifier('contact_cell');

    if (!view) {
      var announcer = this._announcer;
      view = new ViewAllContactsCell({
        reuseIdentifier: 'contact_cell',
        announcer: announcer
      });
    }

    view.setSnapshot(snapshot);
    return view;
  },

  setTableView: function(tableView) {
    this._tableView = tableView;
  }

};

exports.HeaderFactory = HeaderFactory;
exports.CellFactory = CellFactory;
});

// module: shared/data2/model/comment/store
// file:   ../../shared/js/data2/model/comment/store.js
define("shared/data2/model/comment/store", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var Deferred = require('shared/deferred').Deferred;
var Store = require('shared/data2/store/store').Store;
var LocalMapper = require('shared/data2/local/local_mapper').LocalMapper;
var STATE = require('shared/data2/store/constants').STATE;
var MultiFQLRemoteMapper =
  require('../../remote/multi_fql_remote_mapper').MultiFQLRemoteMapper;
var Schema = require('shared/data2/store/schema').Schema;
var Filter = require('shared/data2/store/filter').Filter;
var SEQUENCE_STATE = require('../../store/constants').SEQUENCE_STATE;
var CommentModel = require('./model').CommentModel;
var Profile = require('shared/model/profile/profile').Profile;
var TypeTimestamp =
  require('shared/data2/store/schema/type/timestamp').TypeTimestamp;
var db = require('shared/data/db');

function createSchema() {
  return new Schema({
      id: {
        searchable: true,
        localType: 'TEXT PRIMARY KEY'
      },
      post_id: {
        searchable: true
      },
      object_id: {
        searchable: true
      },
      actor: {
        remote: 'fromid',
        multi_fetch: {
          remote_table: 'profile',
          columns: ['id', 'name', 'pic_big', 'type'],
          key: 'id'
        }
      },
      text: {},
      likes: {
        remote: ['likes', 'user_likes'],
        transformRemoteToModel: function(data) {
          return {
            // TODO: Get real can_like
            can_like: true,
            user_likes: data.user_likes || false,
            count: parseInt(data.likes, 10)
          };
        }
      },
      time: new TypeTimestamp({
        x1000: true,
        searchable: true
      }),
      remoteState: {
        remote: false,
        searchable: true,
        localType: 'TINYINT'
      }
    },
    CommentModel
  );
}

function createLocalMapper(schema) {
  var mapper = new LocalMapper(schema, 'comment');
  mapper.createIndexes = function(tx) {
    tx.executeSql('CREATE INDEX IF NOT EXISTS ' +
      'idx_CommentStore__timestamp ON comment ' +
      '(time DESC)');
  };
  return mapper;
}

function createRemoteMapper(schema) {
  return new MultiFQLRemoteMapper(schema, 'comment').setSeqProperty('time');
}

var CommentStore = core.createClass({

  name: 'CommentStore',

  extend: Store,

  properties: {
    modelType: CommentModel
  },

  /**
   * Fetch a comment collection for a given FBID.
   * @param {Object} targetIdInfo an object containing a field called idType,
   * which is either 'post_id' or 'object_id', and a field called id, which is
   * the FBID of the object for which we are fetching comments.
   * @return {Deferred} A Deferred that succeeds when the collection is fetched.
   */
  fetchCommentCollection: function(targetIdInfo) {
    var deferred = new Deferred();
    var constraint = {};
    constraint[targetIdInfo.idType] = targetIdInfo.id;
    var filter = new Filter(constraint, 'time DESC');
    this.fetchCollection(filter).addCallback(function(collection) {
      deferred.succeed(collection);
    });
    return deferred;
  }
});

var _instance = null;
exports.createLocalMapper = createLocalMapper;
exports.createRemoteMapper = createRemoteMapper;
exports.createSchema = createSchema;
exports.getInstance = function(remoteMapper, localMapper, schema) {
  if (!_instance) {
    schema = schema || createSchema();
    localMapper = localMapper || createLocalMapper(schema);
    remoteMapper = remoteMapper || createRemoteMapper(schema);
    _instance = new CommentStore(remoteMapper, localMapper);
  }
  return _instance;
};
});

// module: photos/app/lib/view/photo_tags/index
// file:   ../../photos/app/lib/view/photo_tags/index.js
define("photos/app/lib/view/photo_tags/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core           = require('bolt/core');
var util           = require('bolt/util');
var Collection     = require('bolt/collection').Collection;
var CollectionView = require('bolt/collection_view').CollectionView;
var View           = require('bolt_touch/view').View;
var PhotoTag       = require('./photo_tag').PhotoTag;

/**
 * PhotoTags is a collection view containing PhotoTag views.
 *
 * The tagged data is comprised of x/y percentages from the left/top of
 * the photo (i.e. 25%/75% would mean the tag is near the bottom left of the
 * photo).
 *
 * We make sure the tags aren't overlapping each other by pushing any
 * overlapping tags further down. Finally, if the tags start overflowing
 * off the bottom, we push them up to at most the top of the view.
 */
exports.PhotoTags = core.createClass({
  name: 'PhotoTags',
  extend: CollectionView,

  /**
   * @param {Collection} contains generic Model objects
   * @param {Object} object describing the bounds of the photo with keys
   *                 top, left, width, height
   */
  setTags: function(tags, boundingBox) {
    this.boundingBox = boundingBox;
    this.setCollection(tags);
  },

  showTags: function() {
    var self = this;
    this._tagsShown = true;
    this.get('collection').forEach(function(model) {
      var view = self.getViewForModel(model);
      view.addClass('visible');
    });
  },

  hideTags: function() {
    var self = this;
    this._tagsShown = false;
    this.get('collection').forEach(function(model) {
      var view = self.getViewForModel(model);
      view.removeClass('visible');
    });
  },

  viewForModel: function(model) {
    var view = new PhotoTag({
      owner: this.getOwner(),
      boundingBox: this.boundingBox
    });

    if (this._tagsShown) {
      view.addClass('visible');
    }

    return view;
  },

  _forwardEvent: function(evt) {
    evt.stopPropagation();
    this.invoke(evt.type, evt.data);
  },

  /* -- methods for dealing with the shared worker -- */

  // Space tags out so they don't overlap (via a background worker)
  _spaceTagsApart: function() {
    var childViews = this.getChildViews();

    // Background workers can't receive cyclic structures or manipulate
    // the DOM. So, create a structure consisting only of the childView
    // index, and its position & size.

    // The tag worker will do its math with this plain data, and then
    // report back with updated position coordinates. Then the UI thread
    // will pass the updated coordinates to the appropriate views.

    var postTags = [];
    for (var i in childViews) {
      var node = childViews[i].getNode();
      var nodeDimension = childViews[i].getMeasuredDimension();
      postTags.push({
        index: i,
        left: nodeDimension.left,
        top: nodeDimension.top,
        width: nodeDimension.width,
        height: nodeDimension.height
      });
    }

    var tagWorker = new Worker('tag_spacer.js');
    tagWorker.onmessage = util.bind(this._onTagWorkerMessage, this);
    tagWorker.postMessage({
      childViews: postTags,
      photoWidth: this.getOwner().getNode().clientWidth
    });
  },

  // When the tag_spacer Worker finishes, it will call this function with
  // updated coordinates for each tag
  _onTagWorkerMessage: function(event) {
    var childViews = this.getChildViews();

    for (var i in event.data) {
      var item = event.data[i];
      var node = childViews[item.index].getNode();

      node.style.left = item.left + 'px';
      node.style.top = item.top + 'px';
      node.style.visibility = 'visible';
    }
  }
});
});

// module: view/tab_view/tab_view
// file:   view/tab_view/tab_view.js
define("view/tab_view/tab_view", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;

/**
 * the tab bar at the bottom of a TabView
 *
 * manages all tabs and handles switching between tabs
 */
var TabBar = core.createClass({
  name: 'TabBar',
  extend: View,

  construct: function(options) {
    View.call(this, options);
    this.tabs = [];
    this.currentTab = null;
    this.tabView = null;
  },

  /**
   * add a tab to an index in the tab bar
   *
   * if no index is given, the tab is added to the far right
   */
  addTab: function(tab) {
    this.tabs.push(tab);
    tab.tabBar = this;
    if (!this.currentTab) {
      this.currentTab = tab;
      tab.addClass('bt-tab-selected');
    }
    tab.listen('touchstart', tab.select, tab);
    this.appendChild(tab);

    if (this.tabs.length > 1) {
      tab.view.setStyle('-webkit-transform: translateX(-100%)');
    }
    this.tabView.refs.mainView.appendChild(tab.view);
  },

  /**
   * selects the tab that was touched while deselecting the previous tab
   */
  selectTab: function(tab) {
    this.currentTab.removeClass('bt-tab-selected');
    var oldTab = this.currentTab;
    oldTab.view.setStyle('-webkit-transform: translateX(-100%)');
    oldTab.selected = false;
    this.currentTab = tab;
    tab.addClass('bt-tab-selected');
    this.tabView.switchToTab(tab);
  }
});

/**
 * a single tab in a tab bar
 *
 * displays within the tab bar, while containing a view that displays
 * in the main view of the TabView
 */
var Tab = core.createClass({
  name: 'Tab',
  extend: View,

  construct: function(options) {
    View.call(this, options);
    this.selected = false;
    this.tabBar = null;
    this.view = null;
  },

  select: function() {
    if (!this.selected) {
      this.invoke('selected', this);
      this.tabBar.selectTab(this);
      this.selected = true;
    }
  }
});

/**
 * the overall view of a tab-based UI
 *
 * this class shouldn't need to be subclassed
 */
var TabView = core.createClass({
  name: 'TabView',
  extend: View,

  construct: function(options) {
    View.call(this, options);
    this.refs.tabBar.tabView = this;
    this.currentTab = null;
  },

  declare: function(options) {
    return {
      boxOrientation: 'vertical',
      childViews: [{
        view: View,
        ref: 'mainView',
        className: 'bt-tab-main-view',
        flex: 1
      },
      {
        view: TabBar,
        ref: 'tabBar',
        className: 'bt-no-text-select',
        boxOrientation: 'horizontal'
      }]
    };
  },

  switchToTab: function(newTab) {
    if (this.currentTab && this.currentTab.view &&
        this.currentTab.view.deactivate) {
      this.currentTab.view.deactivate();
    }
    newTab.view.setStyle('-webkit-transform: translateX(0%)');
    if (newTab.view.activate) {
      newTab.view.activate();
    }
    this.currentTab = newTab;
  },

  addTab: function(tab) {
    this.refs.tabBar.addTab(tab);
  },

  /**
   * Change the view for a tab.
   */
  setViewForTab: function(tab, view) {
    if (tab.view === view) {
      return;
    }

    var tabBar = this.findRef('tabBar');
    var idx = tabBar.tabs.indexOf(tab);

    if (idx < 0) {
      console.error('Cannot find tab.');
      return;
    }

    var mainView = this.findRef('mainView');
    // Remove without destroying
    if (tab.view.deactivate) {
      tab.view.deactivate();
    }
    mainView.removeChild(tab.view, true);
    mainView.insertChild(view, idx);
    if (view.activate) {
      view.activate();
    }

    tab.view = view;
  }
});

exports.Tab = Tab;
exports.TabBar = TabBar;
exports.TabView = TabView;
});

// module: shared/data/db
// file:   ../../shared/js/data/db.js
define("shared/data/db", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var util = require('shared/util');

var BUFFY_DATABASE_VERSION = exports.BUFFY_DATABASE_VERSION = '1';
var _db = null;

var init = exports.init = function() {
  // No size limit exists on Buffy device browser; but on simulator, the
  // limit is 5MB, they need increase the size of webdb in device, but also
  // want to make SlayerApps work in simulator
  var expectedVersion = BUFFY_DATABASE_VERSION;
  var db_size = util.isBuffyDevice() ? 20*1024*1024 : 5*1024*1024;
  var database = openDatabase('buffy', expectedVersion, 'buffy', db_size);
  _db = database;

  console.log('openDatabase [bolt]: the size limit is :' + db_size);
  if (database.version !== expectedVersion) {
    console.log('Version mismatch. Changing from ' + database.version +
      ' to the expected version: ' + expectedVersion);
    try {
      // this would cause an error first time internal users
      // with old DB to switch to the new one in the device
      // because it is possible that multiple webviews are doing the
      // changeVersion operation. The error is harmless though.
      //
      // we will not have this problem after this migration.
      //
      database.changeVersion(database.version, expectedVersion,
        util.nop,
        function(error) {       // error callback
          // TODO(jyuen): uncomment this when webworker supports FBAPI
          // FBAPI.use('log').bumpKey('shared.db', 'change_version_fail', 1);
          console.error('changeVersion failed: ' + error.message);
        },
        function() {            // success callback
          console.log('changeVersion succeeded: version ' + database.version);
        }
      );
    } catch (e) {
    }
  }
};

function getDB() {
  if (!_db) {
    init();
  }
  return _db;
}
exports.getDB = getDB;

/**
 * This is a wrapper around database.transaction()
 * which supports multiple success/error callbacks.
 * Additional callbacks can be added by calling
 * tx.addErrorCallback() or tx.addSuccessCallback()
 *
 * @param cb the callback function when the transaction is extablished.
 *           it would be called with a parameter tx (the transaction object)
 * @param onError the initial error handler, called with an error object
 *                if there is any error in the transaction
 * @param onSuccess the initial success handler, called with no parameter
 *                  when the transaction completes successfully
 */
exports.transaction = function(cb, onError, onSuccess) {
  transaction(cb, onError, onSuccess, false);
};

exports.readTransaction = function(cb, onError, onSuccess) {
  transaction(cb, onError, onSuccess, true);
};

function transaction(cb, onError, onSuccess, readOnly) {
  var errorCallbacks = [];
  var successCallbacks = [];
  var db = getDB();
  var method = readOnly ? db.readTransaction : db.transaction;

  method.call(
    db,
    function(tx) {
      tx.addErrorCallback = function(f) {
        errorCallbacks.push(f);
      };
      tx.addSuccessCallback = function(f) {
        successCallbacks.push(f);
      };
      onError && tx.addErrorCallback(onError);
      onSuccess && tx.addSuccessCallback(onSuccess);
      cb(tx);
    },

    // on error
    function(err) {
      if (errorCallbacks.length === 0) {
        console.error(err);
      }
      for (var i = 0; i < errorCallbacks.length; i++) {
        errorCallbacks[i](err);
      }
    },

    // on success
    function() {
      for (var i = 0; i < successCallbacks.length; i++) {
        successCallbacks[i]();
      }
    }
  );
}

exports.getDbVersion = function() {
  return getDB().version;
};
});

// module: bolt_touch/views/data_list/selection_controller
// file:   ../../../frameworks/bolt_touch/lib/views/data_list/selection_controller.js
define("bolt_touch/views/data_list/selection_controller", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
//  Selection
//  _____________________________________________________
//  |         |                                         |
//  |         /                                         |
//  |         \                                         |
//  |         |                                         |
//  |        (*)                                        |
//  |      ((   ))                                      |
//  |                                                   |
//  |           @.@         @.@     @.@                 |
//  |          (---)       (---)   (---)                |
//  |_________(>---<)_____(>---<)_(>---<)_______________|
//  |___________________________________________________|
//  |      A                                            |
//  |   << @ >>                                         |
//  |      V                                            |
//  |                                                   |
var core = require('bolt/core');
var util = require('bolt/util');
var View = require('bolt_touch/view').View;
var dom_event = require('bolt/dom_event');
var body = document.body;

var WAIT_FOR_SELECTION = 50;

/**
 * @class SelectionController
 * @classdesc SelectionController is a pathetic excuse for managing selection
 * in DataLists. It has a much healthier sibling in original uki code that
 * actually supports multi-selection. We should migrate it at some point.
 */
var SelectionController = core.createClass({
  name: 'SelectionController',

  _pendingSelectionIndex: -1,

  init: function(view) {
    this._view = view;
    this._view.addListener(View.touchEvents.TOUCHSTART, this._ondown, this);
  },

  startTrackingSelection: function() {
    this._view.addListener(View.touchEvents.TOUCHEND, this._onup, this);
    this._view.addListener(View.touchEvents.TOUCHMOVE, this._onmove, this);
  },

  stopTrackingSelection: function() {
    this._view.removeListener(View.touchEvents.TOUCHEND, this._onup, this);
    this._view.removeListener(View.touchEvents.TOUCHMOVE, this._onmove, this);
  },

  _ondown: function(e) {
    if (this._pendingSelectionIndex > -1) {
      return;
    }

    this._pendingSelectionIndex = this._view.getIndexForEvent(e);
    if (this._pendingSelectionIndex > -1) {
      this._boundondowntimeout = this._boundondowntimeout ||
        util.bind(this._ondowntimeout, this);

      this.startTrackingSelection();
      setTimeout(this._boundondowntimeout, WAIT_FOR_SELECTION);
    }
  },

  _ondowntimeout: function() {
    if (this._pendingSelectionIndex === -1) {
      return;
    }

    var succeed = this._view.invoke('selectionStart', {
      index: this._pendingSelectionIndex,
      simulateBubbling: true
    });

    if (succeed) {
      this._view.setHighlighted(this._pendingSelectionIndex, true);
    } else {
      this.stopSelection();
    }
  },

  _onup: function(e) {
    var succeed = this._view.invoke('selection', {
      index: this._pendingSelectionIndex,
      simulateBubbling: true
    });

    if (succeed) {
      this._view.setSelectedIndex(this._pendingSelectionIndex);
    }
    this.stopSelection();
  },

  _onmove: function(e) {
    this.abortSelection();
  },

  abortSelection: function() {
    this._view.invoke('selectionAbort', {
      index: this._pendingSelectionIndex,
      simulateBubbling: true
    });
    this.stopSelection();
  },

  stopSelection: function() {
    this._view.setHighlighted(this._pendingSelectionIndex, false);
    this._pendingSelectionIndex = -1;
    this.stopTrackingSelection();
  }
});


exports.SelectionController = SelectionController;
});

// module: shared/data2/model/friend_list/friend_list_store
// file:   ../../shared/js/data2/model/friend_list/friend_list_store.js
define("shared/data2/model/friend_list/friend_list_store", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var Deferred = require('../../../deferred').Deferred;
var Store = require('../../store/store').Store;
var LocalMapper = require('../../local/local_mapper').LocalMapper;
var RemoteMapper =
  require('../../remote/remote_mapper').RemoteMapper;
var Schema = require('../../store/schema').Schema;
var Filter = require('../../store/filter').Filter;

var FriendList = require('./friend_list').FriendList;
var db  = require('shared/data/db');

var DB_VERSION = '0.1';

var FriendListRemoteMapper = core.createClass({
  name: 'FriendListRemoteMapper',
  extend: RemoteMapper,

  /**
   * override where clause to query by owner=me(). not using a filter because we
   * don't need this to be stored locally (since all friend lists are owned by
   * the device owner)
   */
  getFQLQuery: function(filter) {
    var clause = RemoteMapper.prototype.getFQLQuery.call(this, filter);
    if (clause) {
      return clause + ' AND owner = me()';
    }
    return 'owner = me()';
  }
});

function drop(store, callback) {
  db.transaction(
    function(tx) {
      var localMapper = store.getLocalMapper();
      localMapper.withTransaction(tx, localMapper.drop);
    },
    null,
    callback
  );
}

function init(store, callback) {
  db.transaction(
    function(tx) {
      var localMapper = store.getLocalMapper();
      localMapper.withTransaction(tx, localMapper.init);
    },
    null,
    callback
  );
}

function prepare(store, deferred) {
  init(store, function() {
    deferred.succeed(DB_VERSION);
  });
}

function createSchema() {
  return new Schema(
    {
      // we also want icons here, but they're not in the api currently
      // also bookmark order
      id: {
        searchable: true,
        localType: 'TEXT PRIMARY KEY',
        remote: 'flid'
      },
      name: {},
      type: {}
    },
    FriendList
  );
}

function createLocalMapper(schema) {
  var mapper = new LocalMapper();
  mapper.setTableName('friend_list').setSchema(schema);
  return mapper;
}

function createRemoteMapper(schema) {
  return new FriendListRemoteMapper()
    .setSchema(schema)
    .setSeqProperty('key')
    .setTableName('friendlist');
}

/**
 * @classdesc The store for Friend List models.  Reads from the friend_list
 * FQL table. Can only get friend lists that the user owns.
 */
var FriendListStore = exports.FriendListStore = core.createClass({

  name: 'FriendListStore',

  extend: Store,

  statics: {
    DB_KEY: 'friend_list_storage_version'
  },

  initialize: function(existingVersion) {
    var deferred = new (require('shared/deferred').Deferred)();

    if (this._initialized) {
      deferred.succeed(DB_VERSION);
      return deferred;
    }

    if (existingVersion && existingVersion != DB_VERSION) {
      var _this = this;
      drop(this, function() {
        prepare(_this, deferred);
      });
    } else {
      prepare(this, deferred);
    }

    return deferred;
  },

  fetchFriendListCollection: function() {
    var filter = new Filter({});
    return this.fetchCollection(filter, 1000);
  }

});

var _instance = null;
exports.createLocalMapper = createLocalMapper;
exports.createRemoteMapper = createRemoteMapper;
exports.createSchema = createSchema;
exports.getInstance = function(remoteMapper, localMapper, schema) {
  if (!_instance) {
    schema = schema || createSchema();
    localMapper = localMapper || createLocalMapper(schema);
    remoteMapper = remoteMapper || createRemoteMapper(schema);
    _instance = new FriendListStore(remoteMapper, localMapper, schema);
  }
  return _instance;
};
});

// module: mock/init
// file:   ../../mock/js/init.js
define("mock/init", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var mockFBApi = function() {
  // Stub out Native APIS for compatibility with browser
  // testing and testing on non BFF mobile platforms
  var FBAPI = {

    apis: {
      "alarm": function() { return require('./alarm_api'); },
      "audio": function() { return require('./audio_api'); },
      "audiorecord": function() { return require('./audio_record_api'); },
      "auth": function() { return require('./auth_api'); },
      "bluetooth": function() { return require('./bluetooth_api'); },
      "clipboardmanager": function() {
        return require('./clipboardmanager_api');
      },
      "connectivity": function() { return require('./connectivity_api'); },
      "datetime": function() { return require('./datetime_api'); },
      "display": function() { return require('./display_api'); },
      "dogfood": function() { return require('./dogfood_api'); },
      "facerecognition": function() {
        return require('./face_recognition_api');
      },
      "glitter": function() { return require('./glitter_api'); },
      "handsensor": function() { return require('./hand_sensor_api'); },
      "info": function() { return require('./info_api'); },
      "keyboard": function() { return require('./keyboard_api'); },
      "location": function() { return require('./location_api'); },
      "locationmanager": function() { return require('./location_manager_api'); },
      "log": function() { return require('./log_api'); },
      "mail": function() { return require('./mail_api'); },
      "mediaplayer": function() { return require('./media_player_api'); },
      "mediastorage": function() { return require('./media_storage_api'); },
      "orientation": function() { return require('./orientation_api'); },
      "perflogging": function() { return require('./perflogging_api'); },
      "phone": function() { return require('./phone_api'); },
      "power": function() { return require('./power_api'); },
      "push": function() { return require('./push_api'); },
      "security": function() { return require('./security_api'); },
      "sensor": function() { return require('./sensor_api'); },
      "spelling": function() { return require('./spelling_api'); },
      "sms": function() { return require('./sms_api'); },
      "specialdialog": function() { return require('./special_dialog_api'); },
      "systemupdate": function() { return require('./system_update_api'); },
      "telephony": function() { return require('./telephony_api'); },
      "touch": function() { return require('./touch_api'); },
      "uploadmanager": function() { return require('./uploadmanager_api'); },
      "vibration": function() { return require('./vibration_api'); },
      "voicemail": function() { return require('./voicemail_api'); },
      "webview": function() { return require('./webview_api'); },
      "wifi": function() { return require('./wifi_api'); }
    },
    use: function(api) {
      if (!this.apis[api]) {
        console.error(api + " does not exist in mock.");
        return;
      }
      return this.apis[api]();
    },

    init: function(cb) {
      if (cb) {
        window[cb]();
      }
    }
  };
  return FBAPI;
};

function mockFBPerms() {
  // Simulator and non-device browser compatability.
  var FBPerms = {
    defineRequiredCapabilities : function(caps) {},
    validateOriginWithCapabilities : function(requestid, origin, caps, valid) {}
  };
  return FBPerms;
};

exports.init = function() {
  // this may be attempted multiple times. only do it once.
  if (!window.FBAPI) {
    var openTabs = {};

    window.FBAPI = mockFBApi();
    window.FBPerms = mockFBPerms();
  }
};
});

// module: views/dialer/contact_entry_display
// file:   ../../views/dialer/contact_entry_display.js
define("views/dialer/contact_entry_display", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core          = require('bolt/core');
var util          = require('bolt/util');
var sharedUtil    = require('shared/util');
var View          = require('bolt_touch/view').View;
var EntryDisplay  = require('views/dialer/entry_display').EntryDisplay;
var Contact       = require('talk/app/contacts/contact').Contact;
var LocalContactsList =
  require('talk/app/contacts/local_contacts_list').LocalContactsList;

// If we see this code entered into the dialer, we need to show the IMEI.
var MMI_SHOW_IMEI = '*#06#';

var ContactEntryDisplay = exports.ContactEntryDisplay = core.createClass({
  name: 'ContactEntryDisplay',
  extend: EntryDisplay,

  properties: {
    profile: null
  },

  declare: function(options) {
    this.contactsList = this.contactsList || new LocalContactsList();

    options.addChildren =
      [{
        ref: 'detailedView',
        additionalClasses: 'detailedView',
        childViews: [
          {
            ref: 'avatar',
            additionalClasses: 'avatar'
          },
          {
            ref: 'text',
            additionalClasses: 'text',
            childViews: [
              {
                ref: 'name',
                additionalClasses: 'name'
              },
              {
                ref: 'number',
                additionalClasses: 'number'
              }
            ]
          }
        ]
      }];

    return EntryDisplay.prototype.declare.call(this, options);
  },

  ready: function() {
    EntryDisplay.prototype.ready.call(this);
    this.basicView = this.findRef('dialString');
    this.detailedView = this.findRef('detailedView');
    this.detailedName = this.findRef('name');
    this.detailedNumber = this.findRef('number');

    this.currentView = 'basic';
    this.detailedView.hide();
  },

  updateNumber: function(number, clear) {
  // TODO: this code assumes that the responses come back in order
  //       and before the next digit was entered.
    if (number === MMI_SHOW_IMEI) {
      var telephonyApi = FBAPI.use('telephony');
      var message = 'IMEI: ' + telephonyApi.getImei();
      var dialogUtil = require('shared/dialogs');
      var dialogId = dialogUtil.createDialog();
      dialogUtil.appendText(dialogId, message);
      dialogUtil.showModalDialog(dialogId);
      number = '';
      this.updateNumber(number, clear);
      return;
    }

    EntryDisplay.prototype.updateNumber.call(this, number, clear);
    var formattedNum = this.basicView.getText();

    this.contactsList.allContactsWithPhoneNumber(number)
      .then(this._onUpdateNumber, this, formattedNum);
  },

  _onUpdateNumber: function(formattedNum, contacts) {
    //verify the user hasn't already moved on from the resulting number
    if (contacts.length > 0 && formattedNum == this.basicView.getText()) {
      var profile = contacts[0];
      this.setProfile(profile);
      this.setContext(formattedNum, profile);
    } else {
      this.setProfile(null);
    }
  },

  setNumber: function(number) {
    this.basicView.setText(number, false);
    if (this.currentView !== 'basic') {
      this.basicView.show();
      this.detailedView.hide();
      this.detailedView.setStyle('backgroundImage', '');
      this.currentView = 'basic';
    }
  },

  setContext: function(number, profile) {
    if (profile.toObject) {
      profile = new Contact(profile);
    }
    this.detailedName.setContent(profile.getName());
    this.detailedNumber.setContent(number);
    this.refs.avatar.setStyle('backgroundImage', 'url(' + profile.getProfileUrl() + ')');
    if (this.currentView !== 'detailed') {
      this.basicView.hide();
      this.detailedView.show();
      this.currentView = 'detailed';
    }
  }
});
});

// module: shared/data2/model/like/store
// file:   ../../shared/js/data2/model/like/store.js
define("shared/data2/model/like/store", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var Deferred = require('shared/deferred').Deferred;
var Store = require('shared/data2/store/store').Store;
var LocalMapper = require('shared/data2/local/local_mapper').LocalMapper;
var LikeRemoteMapper = require('./remote_mapper').LikeRemoteMapper;
var Schema = require('shared/data2/store/schema').Schema;
var Filter = require('shared/data2/store/filter').Filter;
var TypeBoolean = require('shared/data2/store/schema/type/boolean').TypeBoolean;
var LikeModel = require('./model').LikeModel;

var FRIEND_SUBQUERY = {subquery: 'SELECT uid2 FROM friend WHERE uid1 = me()'};

function createSchema() {
  return new Schema({
    id: {
      searchable: true,
      generatedRemote: true,
      transformRemoteToModel: function(param, data) {
        if (data.post_id) {
          return data.post_id + '_' + data.user_id.id;
        } else if (data.object_id) {
          return data.object_id + '_' + data.user_id.id;
        }
      },
      localType: 'TEXT PRIMARY KEY'
    },
    post_id: {
      searchable: true
    },
    object_id: {
      searchable: true
    },
    user: {
      remote: 'user_id',
      multi_fetch: {
        remote_table: 'profile',
        columns: ['id', 'name', 'pic_square'],
        key: 'id'
      }
    },
    is_friend: new TypeBoolean({remote: false}),
    object_type: {}
  },
  LikeModel
  );
}

function createLocalMapper(schema) {
  var mapper = new LocalMapper(schema, 'like');
  mapper.createIndexes = function(tx) {
    tx.executeSql('CREATE INDEX IF NOT EXISTS ' +
      'idx_LikeStore__post_id ON like ' +
      '(post_id DESC)');
    tx.executeSql('CREATE INDEX IF NOT EXISTS ' +
      'idx_LikeStore__object_id ON like ' +
      '(object_id DESC)');
  };
  return mapper;
}

function createRemoteMapper(schema) {
  return new LikeRemoteMapper(schema, 'like');
}

/**
 * @class LikeStore
 * @classdesc The LikeStore stores LikeModels in the database. It also allows
 * for fetching collections of likes on a target model, potentially restricted
 * to friends only.
 */
var LikeStore = core.createClass({

  name: 'LikeStore',

  extend: Store,

  properties: {
    modelType: LikeModel
  },

  /**
   * Fetch a like collection for a given FBID.
   * @param {Object} targetIdInfo an object containing a field called idType,
   * which is either 'post_id' or 'object_id', and a field called id, which is
   * the FBID of the object for which we are fetching comments.
   * @param {Boolean} friends Whether this collection should be restricted to
   * friends or not.
   * @return {Deferred} A Deferred that succeeds when the collection is fetched.
   */
  fetchLikeCollection: function(targetIdInfo, friends) {
    var deferred = new Deferred();
    var constraint = {};
    if (friends) {
      constraint.user = FRIEND_SUBQUERY;
    }
    constraint[targetIdInfo.idType] = targetIdInfo.id;
    // Sorting by uid because there isn't any other column orderable column
    // and we want to be able to sequence likes in some way.
    var filter = new Filter(constraint, 'user ASC');
    this.fetchCollection(filter).addCallback(function(collection) {
      deferred.succeed(collection);
    });
    return deferred;
  }
});

var _instance = null;
exports.createLocalMapper = createLocalMapper;
exports.createRemoteMapper = createRemoteMapper;
exports.createSchema = createSchema;
exports.getInstance = function(remoteMapper, localMapper, schema) {
  if (!_instance) {
    schema = schema || createSchema();
    localMapper = localMapper || createLocalMapper(schema);
    remoteMapper = remoteMapper || createRemoteMapper(schema);
    _instance = new LikeStore(remoteMapper, localMapper);
  }
  return _instance;
};
});

// module: shared/shadowbroker/system/client
// file:   ../../shared/js/shadowbroker/system/client.js
define("shared/shadowbroker/system/client", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core = require('bolt/core');
var EventManager = require('shared/event_manager').EventManager;
var Channel = require('shared/shadowbroker/broker/channel').Channel;

/**
 * Receives console events from a worker and prints them to the client's
 * console.
 */
var ConsoleClient = core.createClass({
  name: 'ConsoleClient',

  _broker: null,
  _channel: null,

  construct: function(broker) {
    this._broker = broker;
  },

  reactToMessage: function(event) {
    console[event.method].apply(console,
      ['[worker console] '].concat(event.args));
  },

  init: function() {
    this._channel = new Channel();
    this._channel.setActor(this);
    return this._broker.callMethod('system', 'initConsole', this._channel);
  },

  destroy: function() {
    this._channel.close();
  }
});


/**
 * Broadacasts all client's events to the worker and vice versa.
 */
var EventManagerClient = core.createClass({

  _channel: null,
  _broker: null,
  _counts: null,
  _listeningAll: false,

  construct: function(broker) {
    this._broker = broker;
    this._counts = {};
  },

  init: function() {
    this._channel = new Channel();
    this._channel.setActor(this);
    return this._broker.callMethod('system', 'initEventManager', this._channel);
  },

  reactToMessage: function(e) {
    if (e.action) {
      var handler;
      if (e.action === 'addListener') {
        handler = e.type == 'all' ? this._onAllEvent : this._onEvent;
        EventManager.addListener(e.type, handler, this);
        if (e.type == 'all') {
          this._listeningAll = true;
        }
      } else if (e.action == 'removeListener') {
        handler = e.type == 'all' ? this._onAllEvent : this._onEvent;
        EventManager.removeListener(e.type, handler, this);
        if (e.type == 'all') {
          this._listeningAll = false;
        }
      }
    } else {
      this._broadcasting = true;
      EventManager.broadcastEvent(e.evt, e.data);
      this._broadcasting = false;
    }
  },

  _onAllEvent: function(evt) {
    if (this._broadcasting) {
      return;
    }
    this._channel.sendMessage({ evt: evt.type, data: evt.data });
  },

  _onEvent: function(evt) {
    if (this._broadcasting || this._listeningAll) {
      return;
    }
    this._channel.sendMessage({ evt: evt.type, data: evt.data });
  },

  destroy: function() {
    this._channel.close();
  }
});



var FBAPIController = core.createClass({
  method: function(use, method, args) {
    var object = FBAPI.use(use);
    return object[method].apply(object, args);
  }
});



/**
 * Facade to all system clients.
 * Initilizes console, EventManager, session and minimal FBAPI support
 */
var Client = core.createClass({
  _broker: null,

  construct: function(broker) {
    this._broker = broker;
  },

  init: function() {
    this.initConsole();
    this.initEventManager();
    this.initSession();
    return this.initFBAPI();
  },

  initConsole: function() {
    this._console = new ConsoleClient(this._broker);
    return this._console.init();
  },

  initEventManager: function() {
    this._eventManager = new EventManagerClient(this._broker);
    return this._eventManager.init();
  },

  initSession: function() {
    var session = require('shared/session');
    return this._broker.callMethod(
      'system',
      'initSession',
      session._getSession());
  },

  initFBAPI: function() {
    this._broker.registerController('FBAPI', FBAPIController);
    return this._broker.callMethod('system', 'initFBAPI');
  },

  destroy: function() {
    if (this._eventManager) {
      this._eventManager.destroy();
    }
    if (this._console) {
      this._console.destroy();
    }
  }
});


exports.ConsoleClient = ConsoleClient;
exports.EventManagerClient = EventManagerClient;
exports.Client = Client;
});

// module: bolt_touch/views/data_list/offset_cache
// file:   ../../../frameworks/bolt_touch/lib/views/data_list/offset_cache.js
define("bolt_touch/views/data_list/offset_cache", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core = require('bolt/core');

/**
 * @class OffsetCache
 * @classdesc Manages cache of offsets (heights) for DataList.
 * Uses pointer to the last found position, so it's relatively efficient for
 * scrolling and very simple to implement (compared to SkipList for example).
 *
 * OffsetCache maintains a pointer to the current offset (getCurrentOffset())
 * and index (getCurrentIndex()). You can move this pointer by calling
 * seekOffset() or seekIndex(). Pointer is updated when you add or remove
 * elements before it.
 *
 * @example
 *
 *    var cache = new OffsetCache();
 *    cache.push(10);
 *    cache.push(11);
 *    cache.push(14);
 *    cache.push(10);
 *    cache.push(12);
 *    cache.push(15);
 *    cache.push(13);
 *    cache.push(12);
 *
 *    cache.seekIndex(3);
 *    cache.getCurrentIndex(); => 3
 *    cache.getCurrentOffset(); => 35
 *
 *    cache.seekOffset(50);
 *    cache.getCurrentIndex(); => 4
 *    cache.getCurrentOffset(); => 45
 */
var OffsetCache = core.createClass({
  construct: function() {
    this._offsets = [];
    this._index = 0;
    this._offset = 0;
    this._total = 0;
    this._length = 0;
  },

  getCurrentOffset: function() {
    return this._offset;
  },

  getCurrentIndex: function() {
    return this._index;
  },

  getNextOffset: function() {
    return this._index < this._length ?
      this._offset + this._offsets[this._index] :
      this._offset;
  },

  getTotalOffset: function() {
    return this._total;
  },

  getLength: function() {
    return this._length;
  },

  getOffsetAt: function(index) {
    return this._offsets[index];
  },

  push: function(offset) {
    this._offsets.push(offset);
    this._total += offset;
    this._length++;
    return offset;
  },

  set: function(index, offset) {
    if (this._offsets.length <= index) {
      return this.push(offset);
    }
    var diff = offset - this._offsets[index];
    this._offsets[index] = offset;
    if (index < this._index) {
      this._offset += diff;
    }
    this._total += diff;
    return diff;
  },

  insert: function(index, offset) {
    if (this._offsets.length <= index) {
      return this.push(offset);
    }
    this._offsets.splice(index, 0, offset);
    if (index <= this._index) {
      this._index++;
      this._offset += offset;
    }
    this._total += offset;
    this._length++;
    return offset;
  },

  remove: function(index) {
    var offset = this._offsets.splice(index, 1)[0];
    if (index < this._index) {
      this._index--;
      this._offset -= offset;
    }
    this._total -= offset;
    this._length--;
    return offset;
  },

  seekIndex: function(index) {
    return index < this._index ?
    this._seekIndexBWD(index) :
    this._seekIndexFWD(index);
  },

  seekOffset: function(offset) {
    return offset < this._offset ?
      this._seekOffsetBWD(offset) :
      this._seekOffsetFWD(offset);
  },

  _seekOffsetFWD: function(offset) {
    var length = this._offsets.length - 1;
    while (offset > this._offset && this._index < length) {
      this._offset += this._offsets[this._index++];
    }
    // do not move to much forward
    if (this._offset > offset && this._index > 0) {
      this._offset -= this._offsets[--this._index];
    }
  },

  _seekOffsetBWD: function(offset) {
    while (offset < this._offset && this._index > 0) {
      this._offset -= this._offsets[--this._index];
    }
  },

  _seekIndexFWD: function(index) {
    var length = this._offsets.length - 1;
    while (index > this._index && this._index < length) {
      this._offset += this._offsets[this._index++];
    }
  },

  _seekIndexBWD: function(index) {
    while (index < this._index && this._offset > 0) {
      this._offset -= this._offsets[--this._index];
    }
  }
});


exports.OffsetCache = OffsetCache;
});

// module: talk/client/model/message/attachment_util
// file:   ../client/model/message/attachment_util.js
define("talk/client/model/message/attachment_util", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var REST_SERVER_URL = 'https://api.facebook.com/restserver.php';
var PREVIEW_MAX_WIDTH = 350;
var PREVIEW_MAX_HEIGHT = 100;
var STATUS_ERROR = exports.STATUS_ERROR = "ERROR";
var STATUS_SUCCESS = exports.STATUS_SUCCESS = "SUCCESS";

/**
 * Generates a URL for an attachment in a thread or message.  This URL should
 * not be cached because it will expire with the access token.
 * Options:
 * - attachmentId
 * - messageId
 * - threadId
 * - hash
 * - preview
 */
exports.urlForAttachment = function(options) {
  var requestParams = {};
  requestParams.method = 'messaging.getAttachment';
  requestParams.aid = options.attachmentId || 1;
  if (options.messageId) {
    requestParams.mid = options.messageId;
  }
  if (options.threadId) {
    requestParams.tid = options.threadId;
  }
  if (options.hash) {
    requestParams.pic_hash = options.hash;
  }
  if (options.thumbnail) {
    requestParams.preview = 1;
    requestParams.max_width = options.maxWidth || PREVIEW_MAX_WIDTH;
    requestParams.max_height = options.maxHeight || PREVIEW_MAX_HEIGHT;
  }
  requestParams.access_token = require('shared/session').getAccessToken();
  requestParams.format = 'binary';

  var sharedUtil = require('shared/util');
  return REST_SERVER_URL + '?' +
    sharedUtil.encodeObj(sharedUtil.flatten(requestParams));
};

var calculateResizeDimensions =
  exports.calculateResizeDimensions = function(constraints, imageDimensions) {
  var dimensions = {
    thumbnailHeight: 0,
    thumbnailWidth: 0,
    imageHeight: 0
  };
  var imageH = constraints.height || 200;
  var maxW = constraints.maxWidth || 100000;

  if (imageDimensions.height >= imageH) {
    dimensions.thumbnailHeight = imageH;
    dimensions.thumbnailWidth =
      Math.round((imageDimensions.width * dimensions.thumbnailHeight) /
        imageDimensions.height);
  } else {
    dimensions.thumbnailHeight = imageDimensions.height;
    dimensions.thumbnailWidth =
      Math.round((imageDimensions.width * dimensions.thumbnailHeight) /
        imageDimensions.height);
  }

  if (dimensions.thumbnailWidth > maxW) {
    dimensions.thumbnailWidth = maxW;
    dimensions.thumbnailHeight =
      Math.round((dimensions.thumbnailWidth * imageDimensions.height) /
        imageDimensions.width);
  }

  if (constraints.preserveHeight) {
    dimensions.imageHeight = dimensions.thumbnailHeight;
  } else {
    dimensions.imageHeight = imageH;
  }
  return dimensions;
};

var resizeAttachment = exports.resizeAttachment = function(options) {
  var callback = options.callback;

  if (!options || !options.url) {
    console.log('Must provide image url.');
    if (callback) {
      callback(STATUS_ERROR);
    }
  }
  var url = options.url;

  var img = new Image();

  img.onload = function() {
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext("2d");
    var resizeDimensions = calculateResizeDimensions(
      {
        height: options.height,
        maxWidth: options.maxWidth,
        preserveHeight: options.preserveHeight
      },
      {
        height: img.height,
        width: img.width
      }
    );

    canvas.height = resizeDimensions.imageHeight;
    canvas.width = resizeDimensions.thumbnailWidth;

    // Copy the image contents to the canvas
    ctx.drawImage(img, 0, 0, img.width, img.height,
      0,
      Math.round((resizeDimensions.imageHeight -
        resizeDimensions.thumbnailHeight) / 2),
      resizeDimensions.thumbnailWidth,
      resizeDimensions.thumbnailHeight);

    // Convert to string and save to localStorage
    var dataUrl = canvas.toDataURL("image/png");

    if (callback) {
      callback(STATUS_SUCCESS, {
        url: url,
        localUrl: dataUrl,
        width: canvas.width,
        height: canvas.height
      });
    }
  };
  img.src = url;
};
});

// module: mock/media_player_api
// file:   ../../mock/js/media_player_api.js
define("mock/media_player_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager

module.exports = {
  init: function() {
    if (!this.inited) {
      var audioTag = document.createElement('audio');
      audioTag.controls = false;
      document.body.appendChild(audioTag);
      this.audioTag = audioTag;
      this.inited = true;
      this.queue = [];
      this.currentlyPlaying = 0;
      var util = require('bolt/util');
      audioTag.addEventListener("ended", util.bind(this._internalEnded, this), true);
      audioTag.addEventListener("pause", util.bind(this._internalChange, this), true);
      audioTag.addEventListener("play", util.bind(this._internalChange, this), true);
      audioTag.addEventListener("playing", util.bind(this._internalChange, this), true);
    }
  },
  _internalEnded: function() {
    this.next();
  },
  _internalChange: function() {
    console.log("In internal change");
    var obj = { playing: !this.audioTag.paused,
                track: this.queue[this.currentlyPlaying].title,
                album: this.queue[this.currentlyPlaying].album,
                artist: this.queue[this.currentlyPlaying].artist};
    EventManager.broadcastEvent("mediaplayer.PLAYER_CHANGED", obj);
  },
  _internalPlay: function() {
    this.audioTag.src = this.queue[this.currentlyPlaying].url;
    this.audioTag.load();
    this.audioTag.play();
    var obj = { playing: !this.audioTag.paused,
                track: this.queue[this.currentlyPlaying].title,
                album: this.queue[this.currentlyPlaying].album,
                artist: this.queue[this.currentlyPlaying].artist};
    EventManager.broadcastEvent("mediaplayer.PLAYER_CHANGED", obj);
  },
  setURL: function(url, isAudio, title, artist, album) {
    this.init();
    this.audioTag.pause();
    this.queue = [];
    this.currentlyPlaying = 0;
    this.queue.push({url: url, title: title, artist: artist, album: album});
    this._internalPlay();
  },
  enqueueTrack: function(url, title, artist, album) {
    this.init();
    this.queue.push({url: url, title: title, artist: artist, album: album});
    if(this.audioTag.paused) {
      this.currentlyPlaying = this.queue.length - 1;
      this._internalPlay();
    }
    var obj = { playing: !this.audioTag.paused,
                track: this.queue[this.currentlyPlaying].title,
                album: this.queue[this.currentlyPlaying].album,
                artist: this.queue[this.currentlyPlaying].artist};
    EventManager.broadcastEvent("mediaplayer.QUEUE_CHANGED", obj);
  },
  removeTracks: function(first, last) {
    this.init();
    this.queue.splice(first, (last-first));
  },
  getCurrentPlaylist: function() {
    this.init();
    return JSON.stringify(this.queue);
  },
  play: function() {
    this.init();
    this.audioTag.play();
  },
  pausePlayback: function() {
    this.init();
    this.audioTag.pause();
  },
  next: function() {
    this.init();
    this.currentlyPlaying++;
    if (this.currentlyPlaying >=this.queue.length) {
      this.stop();
    } else {
      this._internalPlay();
    }
  },
  prev: function() {
    this.init();
    this.currentlyPlaying--;
    if (this.currentlyPlaying < 0) {
      this.stop();
    } else {
      this._internalPlay();
    }
  },
  isPlaying: function() {
    this.init();
    return !this.audioTag.paused;
  },
  seek: function(ms) {
    this.init();
    this.audioTag.currentTime = ms;
  },
  getQueuePosition: function() {
    this.init();
    return this.currentlyPlaying;
  },
  buffered: function() {
    this.init();
    return 100;
  },
  getDuration: function() {
    this.init();
    return this.audioTag.duration;
  },
  getPosition: function() {
    this.init();
    return this.audioTag.currentTime;
  },
  stop: function() {
    this.init();
    this.currentlyPlaying = 0;
    this.audioTag.pause();
  }
};
});

// module: shared/data2/model/story/story_store_spec-1_1
// file:   ../../shared/js/data2/model/story/story_store_spec-1_1.js
define("shared/data2/model/story/story_store_spec-1_1", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var util = require('bolt/util');
var TableSpec = require('shared/data2/local/spec').TableSpec;
var Schema = require('shared/data2/store/schema').Schema;
var Story = require('./story').Story;
var TypeTimestamp =
  require('../../store/schema/type/timestamp').TypeTimestamp;

var _sizeRegex = /[a-z]\.jpg/;

function createSchema() {
  return new Schema(
    {
      id: {
        searchable: true,
        remote: 'post_id',
        localType: 'TEXT PRIMARY KEY'
      },
      actor: {
        remote: 'actor_id',
        multi_fetch: {
          remote_table: 'profile',
          columns: ['id', 'name', 'pic_big', 'type'],
          key: 'id'
        }
      },
      attachment: {
        transformRemoteToModel: function(data) {
          var media = data.media;
          if (!media) {
            return data;
          }
          var href, src;
          for (var i = 0, len = media.length; i < len; i++) {
            href = media[i].href;
            if (href) {
              media[i].href = href.replace('://www.', '://m.');
            }
            src = media[i].src;
            if (src) {
              media[i].src =
                src.replace(_sizeRegex, 'n.jpg').replace('s320x320/', '');
            }
          }
          return data;
        }
      },
      comments: {
        transformRemoteToModel: function(data) {
          data = data || {};
          return {
            can_post: data.can_post ||  false,
            count: 'count' in data ? parseInt(data.count, 10) : 0
          };
        }
      },
      created_time: new TypeTimestamp({
        x1000: true,
        searchable: true
      }),
      description: {},
      description_tags: {},
      filter_key: {searchable: true},
      is_highlight: {},
      likes: {
        transformRemoteToModel: function(data) {
          data = data || {};
          return {
            can_like: data.can_like ||  false,
            user_likes: data.user_likes || false,
            count: 'count' in data ? parseInt(data.count, 10) : 0
          };
        }
      },
      message: {},
      message_tags: {
        transformRemoteToModel: function(data) {
          data = data || {};
          util.each(data, function(tag) {
            if (tag.length === 1) {
              tag[0].offset = parseInt(tag[0].offset, 10);
              tag[0].length = parseInt(tag[0].length, 10);
            }
          });
          return data;
        }
      },
      place: {
        transformRemoteToModel: function(data) {
          if (util.isEmpty(data)) {
            return null;
          }
          data.id = data.page_id;
          delete data.page_id;
          return data;
        },
        multi_fetch: {
          remote_table: 'place',
          columns: ['page_id', 'name', 'latitude', 'longitude'],
          key: 'page_id'
        }
      },
      share_count: {},
      with_tags: {
        multi_fetch: {
          remote_table: 'profile',
          columns: ['id', 'name', 'pic_big', 'type'],
          key: 'id'
        }
      },
      target: {
        remote: 'target_id',
        multi_fetch: {
          remote_table: 'profile',
          columns: ['id', 'name', 'pic_big', 'type'],
          key: 'id'
        }
      },
      view_time_position: {
        searchable: true,
        localType: 'TEXT'
      },
      fetched_time: new TypeTimestamp({
        remote: false,
        searchable: true
      }),
      remoteState: {
        remote: false,
        searchable: true,
        localType: 'TINYINT'
      },
      parent_post_id: {},
      children_posts: {
        remote: false
      }
    },
    Story
  );
}

function createTableSpec() {
  return new TableSpec({
    tableName: 'story',
    schema: createSchema(),
    indexes: [
      {
        columns: [{ name: 'view_time_position', sort: 'DESC' }]
      }
    ]
  });
}

exports.createTableSpec = createTableSpec;
});

// module: photos/app/lib/view/photo_grid/index
// file:   ../../photos/app/lib/view/photo_grid/index.js
define("photos/app/lib/view/photo_grid/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core                  = require('bolt/core');
var util                  = require('bolt/util');
var View                  = require('bolt_touch/view').View;
var ScrollView            = require('bolt_touch/views/scroll_view').ScrollView;
var DataList              = require('bolt_touch/views/data_list').DataList;
var GridRenderingStrategy = require('bolt_touch/views/data_list/rendering_strategy/grid').GridRenderingStrategy;
var Thumbnail             = require('../thumbnail').Thumbnail;
var Loader                = require('../loader').Loader;

var PhotoGrid = exports.PhotoGrid = core.createClass({
  name: 'PhotoGrid',

  extend: View,

  properties: {
    title: null,
    photos: null
  },

  statics: {
    ROW_HEIGHT: 136,
    COLUMN_COUNT: 4
  },

  declare: function() {
    this._gridRenderingStrategy = new GridRenderingStrategy({
      allowMargins: true,
      outerMargin: 0
    });

    return {
      boxOrientation: 'vertical',
      childViews: [
        {
          view: ScrollView,
          ref: 'scrollView',
          flex: 1,
          childViews: [
            {
              view: DataList,
              ref: 'dataList',
              renderingStrategy: this._gridRenderingStrategy,
              animateChanges: true,
              createView: util.bind(this._dataListCreateView, this),
              updateView: util.bind(this._dataListUpdateView, this),
              doesEventTriggerRedraw: util.bind(this._dataListDoesEventTriggerRedraw, this)
            }
          ]
        },
        {
          view: Loader,
          ref: 'loader'
        }
      ]
    };
  },

  destroy: function() {
    View.prototype.destroy.call(this);

    if (this.get('photos')) {
      this.get('photos').removeListener('endUpdate', this._onPhotosEndUpdate, this);
    }
    this.set('photos', null);
  },

  load: function() {
    this._onPhotosEndUpdate();
    this.get('photos').listen('endUpdate', this._onPhotosEndUpdate, this);
    this.refs.dataList.setData(this.get('photos'));
  },

  getPhotoRect: function(index) {
    return this._getThumbnail(index).getPhotoRect();
  },

  showPhoto: function(index) {
    this._getThumbnail(index).showPhoto();
  },

  hidePhoto: function(index) {
    this._getThumbnail(index).hidePhoto();
  },

  scrollToPhoto: function(index) {
    var viewportHeight = this.refs.scrollView._jScroll.viewportSize.height;
    var scrollTop = this.refs.scrollView.getScrollTop();
    var row = Math.floor(index / PhotoGrid.COLUMN_COUNT);
    var firstVisibleRow = Math.ceil(scrollTop / PhotoGrid.ROW_HEIGHT);
    var lastVisibleRow = Math.floor((scrollTop + viewportHeight) / PhotoGrid.ROW_HEIGHT);

    if (row < firstVisibleRow || row > lastVisibleRow) {
      var y = (row * PhotoGrid.ROW_HEIGHT) - (viewportHeight / 2) + (PhotoGrid.ROW_HEIGHT / 2);
      this.refs.scrollView.setScrollTop(y);
    }
  },

  _getThumbnail: function(index) {
    var model = this.get('photos').at(index);
    return this.refs.dataList.getViewManager().fetch(model);
  },

  _thumbnailTouched: function(evt) {
    // Figure out the index of the photo
    for (var i = 0; i < this.get('photos').length; i++) {
      if (this.get('photos').at(i) === evt.data.photo) {
        break;
      }
    }

    this.invoke('thumbnailTouched', {
      photo: evt.data.photo,
      view: evt.data.view,
      index: i
    });
  },

  _onPhotosEndUpdate: function() {
    if (this.get('photos').length > 0) {
      this.refs.loader.hide();
    }
  },

  // DataList
  _dataListCreateView: function(model) {
    var thumbnail = new Thumbnail({
      model: model
    });
    thumbnail.addListener('thumbnailTouched', this._thumbnailTouched, this);
    return thumbnail;
  },

  // DataList
  _dataListUpdateView: function(view, model) {
    view.setModel(model);
  },

  // DataList
  _dataListDoesEventTriggerRedraw: function(evt) {
    return evt.type === 'modelChanged';
  }
});
});

// module: photos/app/lib/model/album/album_remote_mapper
// file:   ../../photos/app/lib/model/album/album_remote_mapper.js
define("photos/app/lib/model/album/album_remote_mapper", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core         = require('bolt/core');
var util         = require('bolt/util');
var Deferred     = require('shared/deferred').Deferred;
var DeferredList = require('shared/deferred').DeferredList;
var RemoteMapper = require('shared/data2/remote/remote_mapper').RemoteMapper;
var videoStore   = require('../video/video_store').getInstance();
var photoStore   = require('../photo/photo_store').getInstance();
var Album        = require('./album').Album;
var Constants    = require('../../controller/constants');

exports.AlbumRemoteMapper = core.createClass({
  name: 'AlbumRemoteMapper',

  extend: RemoteMapper,

  download: function(filter, limit, _orderingWhere) {
    var deferred = new Deferred();

    var deferredList = new DeferredList([
      RemoteMapper.prototype.download.call(this, filter, limit, _orderingWhere),
      this._downloadUnpublishedAlbum(),
      this._downloadVideoAlbum()
    ]);

    deferredList.addCallback(function(status, albumArguments, unpublishedAlbumArguments, videoAlbumArguments) {
      var albums = albumArguments[1];
      var unpublishedAlbum = unpublishedAlbumArguments[1];
      var videoAlbum = videoAlbumArguments[1];

      if (unpublishedAlbum) {
        albums.push(unpublishedAlbum);
      }

      if (videoAlbum) {
        albums.push(videoAlbum);
      }

      deferred.succeed(albums);
    });

    deferredList.startWaiting();

    return deferred;
  },

  _downloadUnpublishedAlbum: function() {
    var deferred = new Deferred();

    photoStore.fetchPhotosByAlbumId(Constants.UNPUBLISHED_ALBUM_ID, null, 200)
      .addCallback(function(photos) {
        photos.downloadHead(200)
          .addCallback(function() {
            var unpublishedAlbum = null;

            if (photos.length > 0) {
              unpublishedAlbum = new Album({
                id: Constants.UNPUBLISHED_ALBUM_ID,
                // TODO: Should probably be sorted by created_time, so I'll want to check
                // for the latest updated_time myself.
                updated_time: photos.at(0).get('updated_time'),
                count: photos.length,
                cover_photo: photos.at(0).get('thumbnail_url'),
                //created_time: photos.at(0).get('created_time'), // TODO: needed?
                from: null, // TODO
                local: true,
                name: Constants.UNPUBLISHED_ALBUM_NAME,
                type: 'unpublished',
                likes: {
                  can_like: false,
                  user_likes: false,
                  count: 0
                },
                comments: {
                  can_post: false,
                  count: 0
                }
              });
            }

            deferred.succeed(unpublishedAlbum);
          });
      }, this);

    return deferred;
  },

  _downloadVideoAlbum: function() {
    var deferred = new Deferred();

    videoStore.fetchVideoCollection()
      .addCallback(function(videos) {
        videos.downloadHead(200)
          .addCallback(function() {
            var videoAlbum = null;

            if (videos.length > 0) {
              videoAlbum = new Album({
                id: Constants.VIDEO_ALBUM_ID,
                updated_time: videos.at(0).get('updated_time'), // TODO: We should probably use the most recent updated time of the photos?
                count: videos.length,
                cover_photo: videos.at(0).get('picture'),
                //created_time: videos.at(0).get('created_time'), // TODO: needed?
                from: null, // TODO
                local: true,
                name: 'My Videos',
                type: 'video',
                likes: {
                  can_like: false,
                  user_likes: false,
                  count: 0
                },
                comments: {
                  can_post: false,
                  count: 0
                }
              });
            }

            deferred.succeed(videoAlbum);
          });
      }, this);

    return deferred;
  }
});
});

// module: views/picker/album_picker/album_picker_controller
// file:   ../../views/picker/album_picker/album_picker_controller.js
define("views/picker/album_picker/album_picker_controller", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core                   = require('bolt/core');
var EventManager           =
  require('shared/event_manager').EventManager;
var PickerAlbumListScene   =
  require('./picker_album_list_scene').PickerAlbumListScene;
var util                   = require('bolt/util');
var Deferred               = require('shared/deferred').Deferred;
var DeferredList           = require('shared/deferred').DeferredList;
var storageAPI             = FBAPI.use('mediastorage');
var Photo                  = require('photos/app/lib/model/photo/photo').Photo;

var PickerController       = require('views/picker/common/picker_controller')
                             .PickerController;

var photoStore             = require('photos/app/lib/model/photo/photo_store').getInstance();

// AlbumPickerController launches a picker with which user can
// select photos from albums.
exports.AlbumPickerController = core.createClass({

  name: 'AlbumPickerController',

  extend: PickerController,

  construct: function(options) {
    options.startScene = PickerAlbumListScene;
    PickerController.prototype.construct.call(this, options);
  },

  setupEvents: function() {
    EventManager.listen('storage.COMPLETE', this.onStorageComplete, this);
    EventManager.listen('storage.ERROR', this.onStorageError, this);
  },

  cleanUpEvents: function() {
    EventManager.removeListener('storage.COMPLETE',
      this.onStorageComplete, this);
    EventManager.removeListener('storage.ERROR', this.onStorageError, this);
  },

  _onPickerDone: function(photos) {
    //callback will be called with "null" if user cancels photo
    //or does not select photo
    if (photos && (util.isUndefined(photos.length) || photos.length > 0)) {
      if (util.isUndefined(photos.length)) {
        photos = [photos];
      }

      var deferredList = new DeferredList();
      this.storageData = [];

      for (var i = 0; i < photos.length; i++) {
        var photo = photos[i];
        var deferred = deferredList.createWaitForDeferred();
        var key = Date.now().toString() + '_' + photo.id;
        this.storageData[key] = {deferred: deferred};

        storageAPI.storeURL(key, photo.get('source'), 0, '', 1);
      }

      deferredList.addCallback(util.bind(function() {
        console.log('Successfully stored the selected photos');

        var photoIds = [];
        for (var key in this.storageData) {
          var path = this.storageData[key].path;
          var url = this.storageData[key].url;

          var photoId = Photo.addPhoto(path, url, path, url);
          photoIds.push(photoId);
        }

        this.cleanUpEvents();

        photoStore.fetchPhotosByIds(photoIds)
          .addCallback(function(photos) {
            // TODO: It might be possible that photos is empty and that
            // we'd want to wait for all the photos to be added before
            // doing this.
            this.callback(photos.toArray());
          }, this);
      }, this));

      deferredList.addErrback(util.bind(function() {
        console.error('Failed to store the selected photos');
        this.callback(null);
      }, this));

      deferredList.startWaiting();
    }
    else {
      this.callback(null);
    }
  },

  onStorageComplete: function(obj) {
    var data = this.storageData[obj.key];

    // Data might be undefined if the photo picker is being used
    // from another WebView (until task 665321 is fixed).
    if (data) {
      var deferred = data.deferred;

      data.path = storageAPI.getStoredAbsolutePath(obj.key);
      data.url = storageAPI.getStoredURL(obj.key);

      console.log('Successfully stored photo ' + obj.key + ' to ' + data.path);
      deferred.succeed();
    }
  },

  onStorageError: function(obj) {
    var data = this.storageData[obj.key];

    // Data might be undefined if the photo picker is being used
    // from another WebView (until task 665321 is fixed).
    if (data) {
      var deferred = data.deferred;

      console.error('Failed to store photo ' + obj.key + ': ' + obj.error);
      deferred.fail();
    }
  }
});
});

// module: views/contacts_table/scroll_contacts_table
// file:   ../../views/contacts_table/scroll_contacts_table.js
define("views/contacts_table/scroll_contacts_table", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core                   = require('bolt/core');
var table_view             = require("views/deprecated/table_view");
var util                   = require('bolt/util');

var ContactCell =
  require('views/contacts_table/contacts_cell').ContactsCell;
var Scrubber               = require('bolt_touch/views/scrubber').Scrubber;
var TableView              = require("views/deprecated/table_view").TableView;
var TableViewCollectionSource =
  require('bolt_touch/mixins/table_view_collection_source').TableViewCollectionSource;
var TableViewSectionHeader = require("views/deprecated/table_view").TableViewSectionHeader;
var View                   = require('bolt_touch/view').View;

var ScrollContactsTable = exports.ScrollContactsTable = core.createClass({
  name: 'ScrollContactsTable',
  extend: View,

  statics: {
    indices: 'abcdefghijklmnopqrstuvwxyz'
  },

  mixins: [TableViewCollectionSource],

  declare: function(options) {
    return {
      childViews: [
        {
          view: 'TableView',
          ref: 'table',
          flex: 1,
          bufferSize: 4,
          fixedSectionHeaderHeight: 23,
          fixedRowHeight: 64,
          sectioned: true,
          stickySectionHeaders: true
        },
        {
          view: Scrubber,
          ref: 'scrubber',
          additionalClasses: 'bolt-table-scrubber'
        }
      ]
    };
  },

  ready: function() {
    console.warn('ScrollContactsTable is broken until its rewired to use ' +
      'new Contacts data');
    this.table = this.refs.table;
    this.setTableView(this.table);
    this.refreshCollections();
  },

  refreshCollections: function() {
    this.collections = {};
    var collection, collections = [];
    var index;
    for (var i = 0, l = ScrollContactsTable.indices.length; i < l; i++) {
      index = ScrollContactsTable.indices[i];
      // TODO: Collection should be set to a filtered collection of the
      // using the filterForIndex function.
      collection = null;
      this.collections[index] = collection;
      collections.push(collection);
    }
    this.setCollections(collections);
    this.table.refresh();
  },

  setFilterFunction: function(filter) {
    if (filter === this.filterFunction) {
      return;
    }
    this.filterFunction = filter;
    this.refreshCollections();
  },

  _filterForModel: function(index, model) {
    if (this.filterFunction && !this.filterFunction(model)) {
      return false;
    }
    var name = model.get('name');
    return name.length && name[0].toLowerCase() === index;
  },

  filterForIndex: function(index) {
    return util.bind(this._filterForModel, this, index);
  },

  onScrub: function(letter) {
    var closestIndex, scrubIndex = letter.toLowerCase();
    this.table.setShowScrollbar(false);
    if (scrubIndex === '#') {
      closestIndex = ScrollContactsTable.indices.length - 1;
    } else {
      closestIndex = util.sortedIndex(
        ScrollContactsTable.indices,
        scrubIndex);
    }
    this.table.scrollToSection(closestIndex);
  },

  onScrubEnd: function(scrubber) {
    this.table.setShowScrollbar(true);
  },

  show: function() {
    View.prototype.show.call(this, '-webkit-box');

    this.table._onResize();
  },

  viewForHeaderInSection: function(tableView, section, floatHeader) {
    var header = (
      floatHeader ?
      null :
      tableView.dequeueReusableCellWithIdentifier('header')
    );
    if (!header) {
      header = this.build({
        view: 'TableViewSectionHeader',
        reuseIdentifier: 'header'
      });
    }
    header.setContent(ScrollContactsTable.indices[section].toUpperCase());
    if (this.getCollectionForSection(section).length) {
      header.show('-webkit-box');
    } else {
      header.hide();
    }
    return header;
  },

  createTableViewCell: function(tableView, model, row, section) {
    return new ContactCell();
  },

  cellSelectedAtRowInSection: function(tableView, row, section, cell) {
    var owner = this.getOwner();
    if (owner && owner.onContactSelect) {
      owner.onContactSelect(cell.getModel());
    }
  }
});
});

// module: shared/data2/remote/multi_fql_remote_mapper
// file:   ../../shared/js/data2/remote/multi_fql_remote_mapper.js
define("shared/data2/remote/multi_fql_remote_mapper", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var RemoteMapper = require('./remote_mapper').RemoteMapper;
var Deferred = require('shared/deferred').Deferred;

var queryName = '_query';

/**
 *  @classdesc MultiFQLRemoteMapper allows for more complex FQL queries.
 *    Specifically it handles the case where a column entry in a table is the
 *    key to fetch data from another column and not the data desired itself.
 *    For example on the "stream" table the column "actor_id" is not enough data
 *    for story rendering. Instead of creating a relationshp between the story
 *    store and the profile store (which would require two round trips to the
 *    server), using MultiFQLRemoteMapper allows for fetching data from the
 *    profile table and putting it in place of "actor_id".
 */
exports.MultiFQLRemoteMapper = core.createClass({

  name: 'MultiFQLRemoteMapper',

  extend: RemoteMapper,

  download: function(filter, limit, _orderingWhere) {
    var params = {
      method: 'fql.multiquery',
      queries: this.getQueries(filter, limit, _orderingWhere)
    };
    var migrationsOverride = this.getMigrationsOverride();
    if (migrationsOverride) {
      params.migrations_override = migrationsOverride;
    }

    return this._apiRequester.rest(params, true)
      .then(this._processMultiFqlResults, this, limit, params);
  },

  _processMultiFqlResults: function(limit, params, results) {
    var i;
    var schema = this.getSchema();
    if (!(results instanceof Array)) {
      if (results && results.error_msg && results.error_code) {
        console.error('Error downloading: ' + results.error_msg +
          'and error Code: ' + results.error_code + ' for request: ' +
          JSON.stringify(params));
      } else {
        console.error('Error downloading.');
      }
      return (new Deferred()).fail();
    }
    var queryResult;
    var propertyQueryResultMap = {};
    results.forEach(function(result) {
      if (result.name === queryName) {
        queryResult = util.values(result.fql_result_set);
      } else  {
        propertyQueryResultMap[result.name] = {};
        var remoteIdName = schema.getRemoteKeyForProperty(result.name);
        util.forEach(result.fql_result_set, function(propertyData) {
          propertyQueryResultMap[result.name][propertyData[remoteIdName]] =
            propertyData;
        });
      }
    }, this);
    queryResult.forEach(function(result) {
      util.forEach(propertyQueryResultMap,
        function(propertyMap, propertyName) {
          var info = schema.getPropertyInfo(propertyName);
          var resultProperty = result[info.remote];
          if (resultProperty instanceof Array) {
            var multiResultProperty = [];
            for (i = 0; i < resultProperty.length; i++) {
              multiResultProperty[i] = propertyMap[resultProperty[i]] || {};
            }
            result[info.remote] = multiResultProperty;
          } else {
            result[info.remote] =
              propertyMap[resultProperty] || null;
          }
        }
      );
    });
    var models = [];
    var l = Math.min(queryResult.length, limit);
    for (i = 0; i < l; i++) {
      models.push(this.remoteToModel(queryResult[i]));
    }
    return (new Deferred()).succeed(models, models.length > 0);
  },

  getQueries: function(filter, limit, _orderingWhere) {
    var i;
    var schema = this.getSchema();
    var fql = this.getFqlQuery(filter, limit, _orderingWhere);
    var queries = {};
    var queriableProperties = schema.getQueriableProperties();
    for (i = 0; i < queriableProperties.length; i++) {
      var propertyName = queriableProperties[i];
      var info = schema.getPropertyInfo(propertyName);
      queries[propertyName] = 'SELECT ' +
        schema.getRemoteColumnsForProperty(propertyName).join(',') +
        ' FROM ' + schema.getRemoteTableForProperty(propertyName) +
        ' WHERE ' + schema.getRemoteKeyForProperty(propertyName) +
        ' IN (SELECT ' + info.remote + ' FROM #' + queryName + ')';
    }
    queries[queryName] = fql;
    return queries;
  }
});
});

// module: place_picker/location_manager
// file:   ../../place_picker/js/location_manager.js
define("place_picker/location_manager", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

/*
Manages location for the place picker.

This keeps track of a current gps location and city that will update
automatically based off some heuristics.  The location manager purposely keeps
itself out of date unless it is manually refreshed.
*/

var core    = require('bolt/core');
var util    = require('bolt/util');
var api_xhr = require('shared/api_xhr');
var Coords  = require('shared/geo/coords').Coords;

var locationManager = null;

exports.getLocationManager = function() {
  if (!locationManager) {
    locationManager = new LocationManager();
  }
  return locationManager;
};

var LocationManager = core.createClass({
  name: 'LocationManager',

  /**
  location - current location
  city - current city
  updateFrequency - maximum time between updates (in milliseconds)
  updateDistance - maximum distance between updates (in meters)
  */
  properties: {
    updateFrequency: 300000,
    updateDistance: 100,
    // TODO: remove this fallback location once API works properly on phone
    location: {
      provider: 'gps',
      timestamp: 0,
      coords: {
        latitude: 37.41603,
        longitude: -122.15213,
        accuracy: 10,
        altitude: 100,
        heading: 0,
        speed: 0
      }
    },
    city: null
  },

  construct: function() {
    util.delay(util.bind(this.refresh, this), 3000);
  },

  /** getLocation makes an asynchronous call to get the location */
  getLocation: function(callback) {
    if (this._outOfDate() || this._getLocation() === null) {
      // don't need to wait for refresh to finish because location refresh is
      // instantaneous
      this.refresh();
    }
    callback(this._getLocation());
  },

  /** getCity makes an asynchronous call to get the city */
  getCity: function(callback) {
    if (this._outOfDate()) {
      this.refresh(function(data) {
        callback(data.city);
      });
    } else if (this.city === null) {
      this._refreshCity(function(data) {
        callback(data.city);
      });
    } else {
      callback(this._getCity());
    }
  },

  _getLocation: function() {
    return this.get('location');
  },

  _getCity: function() {
    return this.get('city');
  },

  /**
  Forces the location manager to update the current location using the best
  known gps value.  This also updates the city.  Because this update is
  asynchronous, a callback is passed in and will be called when the operation
  completes.
  */
  refresh: function(callback) {
    this._refreshLocation();
    this._refreshCity(callback);
  },

  _refreshLocation: function() {
    var loc = JSON.parse(FBAPI.use('location').getLastKnownPosition());
    if (loc) {
      this.setLocation(loc);
    }
  },

  _refreshCity: function(callback) {
    var loc = this._getLocation();
    var lat = loc.coords.latitude;
    var lon = loc.coords.longitude;

    var query = "SELECT abbr_name, type, page_fbid FROM geo_region " +
      "WHERE latitude='" + lat + "' AND longitude='" + lon + "' " +
      "AND type='city'";

    api_xhr.fql(query).addCallback(function(response) {
      if (response.length) {
        var city = {
          name: response[0].abbr_name,
          page_id: response[0].page_fbid
        };
        this.setCity(city);
        if (callback) {
          callback({'location': this._getLocation(), 'city': city});
        }
      }
    }, this);
  },

  /* Checks to see if the current information is very out of date. */
  _outOfDate: function() {
    var loc = JSON.parse(FBAPI.use('location').getLastKnownPosition());
    if (!loc) {
      return false;
    }

    var lastLoc = this._getLocation();
    if (!lastLoc) {
      return true;
    }

    var updateFrequency = this.getUpdateFrequency();
    var updateDistance = this.getUpdateDistance();

    if (loc.timestamp - lastLoc.timestamp > updateFrequency) {
      return true;
    }

    var lat1 = loc.coords.lat;
    var lon1 = loc.coords.lon;
    var lat2 = lastLoc.coords.lat;
    var lon2 = lastLoc.coords.lon;
    var dist = new Coords.haversineDist(lat1, lon1, lat2, lon2);

    if (dist * 1000 > updateDistance) {
      return true;
    }

    return false;
  }
});
});

// module: photos/app/lib/view/video_list_scene/index
// file:   ../../photos/app/lib/view/video_list_scene/index.js
define("photos/app/lib/view/video_list_scene/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core              = require('bolt/core');
var util              = require('bolt/util');
var Scene             = require('bolt_touch/views/scene').Scene;
var TableView         = require("views/deprecated/table_view").TableView;
var TableViewCell     = require("views/deprecated/table_view").TableViewCell;

var EventManager      = require('shared/event_manager').EventManager;
var videoStore        = require('../../model/video/video_store').getInstance();
var VIDEO_ID_IDENTIFIER = require('../../controller/constants').VIDEO_ID_IDENTIFIER;
var VideoPlayerScene  = require('../video_player_scene').VideoPlayerScene;

var VideoListRow = exports.VideoListRow = core.createClass({
  name: 'VideoListRow',
  extend: TableViewCell,

  properties: {
    reuseIdentifier: null,
    video: null
  },

  declare: function(options) {
    return {
      reuseIdentifier: 'video_cell',
      boxOrientation: 'horizontal',
      additionalClasses: 'videoRow',

      childViews: [
        {
          ref: 'videoThumb',
          additionalClasses: 'videoThumb'
        },
        {
          boxOrientation: 'horizontal',
          additionalClasses: 'videoDetails',
          flex: 1,

          childViews: [
            {
              ref: 'videoName',
              additionalClasses: 'videoName'
            }
          ]
        }
      ]
    };
  },

  ready: function() {
    this.videoThumb = this.findRef('videoThumb');
    this.videoName = this.findRef('videoName');
  },

  setVideo: function(video) {
    this.set('video', video);

    this.videoThumb.setStyle('backgroundImage', 'url(' + video.get('picture') + ')');

    this.videoName.setContent(video.getDisplayName());
  }
});

var VideoListScene = exports.VideoListScene = core.createClass({
  name: 'VideoListScene',
  extend: Scene,

  declare: function(options) {
    return {
      boxOrientation: 'vertical',
      flex: 1,

      childViews: [
        {
          boxOrientation: 'horizontal',
          additionalClasses: 'bt-bar',
          childViews: [
            {
              additionalClasses: 'bt-bar-button bt-back-button left',
              onclick: 'pop'
            },
            {
              ref: 'title',
              content: 'Videos...',
              additionalClasses: 'bt-bar-title',
              flex: 1
            },
            {
              additionalClasses: 'bt-bar-button right'
            }
          ]
        },
        {
          view: 'TableView',
          flex: 1,
          fixedRowHeight: 111,
          ref: 'videoListTable',
          sectioned: false,
          bufferSize: 2,
          useNativeScroll: true
        }
      ]
    };
  },

  ready: function() {
    this.table = this.refs.videoListTable;
    this.table.setLoading(true);
    this.videoTag = document.createElement('video');
    document.body.appendChild(this.videoTag);

    videoStore.fetchVideoCollection()
      .addCallback(function(videos) {
        this.videoList = videos;
        this.videoList.listen('endUpdate', this._onVideoEvent, this);
        if (this.videoList.length > 0) {
          this._onVideoEvent();
        }

        videos.downloadHead(200)
          .addCallback(function() {
            this.refs.title.setContent('Videos');
          }, this);
      }, this);
  },

  _onVideoEvent: function(data) {
    this.table.refresh();
    this.table.setLoading(false);
  },

  // ### Table Owner Protocol implementation

  numberOfRowsInSection: function(tableView, section) {
    if (!this.videoList) {
      return false;
    }

    return this.videoList.length;
  },

  cellSelectedAtRowInSection: function(tableView, row, section, cell) {
    tableView.deselectRowInSection(row, section);

    var video = cell.getVideo();

    this.getStack().pushModal({
      view  : VideoPlayerScene,
      video : video
    }, { transition: 'drawer' });
  },

  cellForRowInSection: function(tableView, row, section) {
    var video = this.videoList.at(row);

    var cell = tableView.dequeueReusableCellWithIdentifier('video_cell');
    if (!cell) {
      cell = this.build({ view: 'VideoListRow' });
    }
    cell.setVideo(video);

    return cell;
  }
});
});

// module: bolt_touch/views/data_list/circular_buffer
// file:   ../../../frameworks/bolt_touch/lib/views/data_list/circular_buffer.js
define("bolt_touch/views/data_list/circular_buffer", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core = require('bolt/core');

/**
 * @class Circular
 * @classdesc Circular Buffer data structure implementation for bolt.
 * See http://en.wikipedia.org/wiki/Circular_buffer for more info.
 */
var CircularBuffer = core.createClass({
  length: 0,

  /**
   * @param {Integer} size of the buffer, defaults to 20
   * @return CircularBuffer
   */
  construct: function(size) {
    this._start = 0;
    this._storage = new Array(size || 20);
  },

  /**
   * Finds index of the "value" in a sorted CircularBuffer using binary search
   * @param {*} value
   * @param {function|null} iterator
   */
  sortedIndex: function(value, iterator) {
    iterator = iterator || identity;
    var low = 0, high = this.length;
    while (low < high) {
      var mid = (low + high) >> 1;
      iterator(this.get(mid)) < iterator(value) ? low = mid + 1 : high = mid;
    }
    return low;
  },

  /**
   * @param {Integer} index
   * @return value at the index
   */
  get: function(index) {
    return this._storage[(this._start + index) % this._storage.length];
  },

  /**
   * @param {Integer} index
   * @param {Object} value
   */
  set: function(index, value) {
    this._storage[(this._start + index) % this._storage.length] = value;
  },

  /**
   * @param {Integer} index
   * @param {Object} value
   *
   * Inserts value at the given index. Offsets all values after index.
   * [1, 2, 3, 5, 6, 7]
   * -> insert(3, 4);
   * [1, 2, 3, 4, 5, 6, 7]
   */
  insert: function(index, value) {
    if (index >= this.length) {
      this.push(value);
      return;
    }
    if (index === 0) {
      this.unshift(value);
      return;
    }
    this._allocateIfNeeded();

    // move everything fwd
    var length = this.length;
    for (var i = length; i > index; i--) {
      this.set(i, this.get(i - 1));
    }
    this.length++;
    this.set(index, value);
  },

  /**
   * @param {Integer} index
   *
   * Removes a value at the given index. Offsets all values after index.
   * [1, 2, 3, 4, 5, 6, 7]
   * -> remove(3);
   * [1, 2, 3, 5, 6, 7]
   */
  remove: function(index) {
    if (index === this.length - 1) {
      return this.pop();
    }
    if (index === 0) {
      return this.shift();
    }

    // move everything bwd
    var ret = this.get(index);
    var length = --this.length;
    for (var i = index; i < length; i++) {
      this.set(i, this.get(i + 1));
    }
    return ret;
  },

  /**
   * @param {Object} value
   * Adds value to the end of the buffer
   */
  push: function(value) {
    this._allocateIfNeeded();
    this._storage[(this._start + this.length) % this._storage.length] = value;
    this.length++;
  },

  /**
   * Removes and returns value at the end of the buffer
   *
   * This implementation does not actually remove values from the buffer when
   * you pop or shift. It only updates the pointers. Example:
   *
   *   buffer.push(2);
   *   buffer.pop()   // 2
   *   buffer.get(0)  // still 2
   *
   * @return {Object} value
   */
  pop: function() {
    return this.get(--this.length);
  },

  /**
   * @param {Object} value
   * Adds value to the beginig of the buffer
   */
  unshift: function(value) {
    this._allocateIfNeeded();
    if (this.length > 0) {
      this._start =
        (this._storage.length + this._start - 1) % this._storage.length;
    }
    this.length++;
    this._storage[this._start] = value;
  },

  /**
   * @return {Object} value
   * Removes and returns value at the beginning of the buffer
   */
  shift: function() {
    var ret = this.get(0);
    this._start = (this._start + 1) % this._storage.length;
    this.length--;
    return ret;
  },

  clear: function() {
    this._start = 0;
    this.length = 0;
  },

  _allocateIfNeeded: function() {
    if (this.length >= this._storage.length) {
      this._allocate();
    }
  },

  _allocate: function() {
    var storage = this._storage;
    var length = this.length;
    var newStorage = new Array(this._storage.length * 2);

    for (var i = 0; i < length; i++) {
      newStorage[i] = this.get(i);
    }
    this._storage = newStorage;
    this._start = 0;
  }
});

function identity (x) {
  return x;
}

exports.CircularBuffer = CircularBuffer;
});

// module: contacts/contact_filters_section/ui/contact_filters_scene/index
// file:   contacts/contact_filters_section/ui/contact_filters_scene/index.js
define("contacts/contact_filters_section/ui/contact_filters_scene/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var Scene = require('bolt_touch/views/scene').Scene;
var ScrollView = require('bolt_touch/views/scroll_view_j').ScrollView;
var ActionableView =
  require('bolt_touch/views/actionable_view').ActionableView;
var Actionable = require('bolt_touch/mixins/actionable').Actionable;
var DataList = require('bolt_touch/views/data_list').DataList;

var baseClass = 'bt-contact-filter-scene--';

/**
 * Scene for picking a filter for your contacts. Possible filters include
 * groups, friend lists, etc.
 */
var ContactFiltersScene = core.createClass({
  name: 'ContactFiltersScene',
  extend: Scene,

  delegateProperties: {
    groupDataList: [{alias: 'groupCollection', name: 'data'}],
    listDataList: [{alias: 'listCollection', name: 'data'}]
  },

  useHeader: function() {
    return false;
  },

  declare: function(options) {
    return {
      boxOrientation: 'vertical',
      childViews: [
        {
          boxOrientation: 'horizontal',
          className: 'bt-bar',
          childViews: [
            {
              className: 'bt-bar-button left bt-x-button',
              view: ActionableView,
              action: '_onCancel',
              ref: 'cancelBtn'
            },
            {
              flex: 1,
              childViews: [
                {
                  ref: 'title',
                  className: 'bt-bar-title',
                  content: 'Contacts Filters',
                  flex: 1
                }
              ]
            }
          ]
        },
        {
          view: ScrollView,
          ref: 'scroller',
          flex: 1,
          childViews: [
            {
              view: ActionableView,
              className: baseClass + 'filter',
              action: '_onAllContactsSelect',
              content: 'All Contacts'
            },
            {
              content: 'LISTS',
              className: baseClass + 'header'
            },
            {
              view: DataList,
              ref: 'listDataList',
              createView: function(model) {
                var view = new ActionableView({
                  className: baseClass + 'filter',
                  action: '_onListSelect'
                });
                this.updateView(view, model);
                return view;
              },
              updateView: function(view, model) {
                view.setContent(model.get('name'));
                view.set('model', model);
                return view;
              }
            },
            {
              content: 'GROUPS',
              className: baseClass + 'header'
            },
            {
              view: DataList,
              ref: 'groupDataList',
              createView: function(model) {
                var view = new ActionableView({
                  className: baseClass + 'filter',
                  action: '_onGroupSelect'
                });
                this.updateView(view, model);
                return view;
              },
              updateView: function(view, model) {
                var group = model.get('group');
                view.setContent(group.name);
                view.setStyle('backgroundImage', 'url(' + group.icon34 + ')');
                view.set('model', model);
                return view;
              }
            }
          ]
        }
      ]
    };
  },

  ready: function() {
    var scroller = this.findRef('scroller');
    this.findRef('groupDataList').setScrollableParent(scroller);
    this.findRef('listDataList').setScrollableParent(scroller);
  },

  _onCancel: function() {
    this.invoke('cancel');
  },

  _onAllContactsSelect: function() {
    this.invoke('allContactsSelected');
  },

  _onGroupSelect: function(view) {
    var model = view.get('model');
    this.invoke('groupFilterSelected', {
      gid: model.get('gid'),
      name: model.get('group').name
    });
  },

  _onListSelect: function(view) {
    var model = view.get('model');
    this.invoke('listFilterSelected', {
      flid: model.get('id'),
      name: model.get('name')
    });
  }
});

exports.ContactFiltersScene = ContactFiltersScene;
});

// module: shared/shadowbroker/shadow/managed_collection/managed_collection_shadow
// file:   ../../shared/js/shadowbroker/shadow/managed_collection/managed_collection_shadow.js
define("shared/shadowbroker/shadow/managed_collection/managed_collection_shadow", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core  = require('bolt/core');
var util  = require('bolt/util');
var Model = require('bolt/model').Model;
var Deferred = require('shared/deferred').Deferred;

var STATE = require('shared/data2/store/constants').STATE;
var SEQUENCE_STATE = require('shared/data2/store/constants').SEQUENCE_STATE;

var CollectionShadow =
  require('../collection/collection_shadow').CollectionShadow;


var EVENT_TYPE_CALL         = 7;
var EVENT_TYPE_RESPOND      = 8;
var EVENT_TYPE_STATE_CHANGE = 9;

var eventPrototype = {
  method: '',
  id: '',
  data: 0,
  type: EVENT_TYPE_CALL
};

/**
 * Shadow for a ManagedCollection
 *
 * ManagedCollectionShadow is a shadow of a ManagedCollection in a SharedWorker.
 * It extens CollectionShadow so it automatically updates when the original
 * colleciton changes. On top of that it maintains remoteState and hasMore
 * state. It also exposes standard ManagedCollection api like fetchMore() or
 * downloadHead()
 *
 * SharedWorker should wrap an original collection into
 * ManagedCollectionUpdater so ManagedCollectionShadow can recieve change
 * events. To create a ManagedCollectionShadow from a channel:
 *
 *   broker.callMethod('store', 'fetchCollection')
 *     .then(function(collectionChannel) {
 *       var shadowCollection = new ManagedCollectionShadow();
 *       shadowCollection.setChannel(collectionChannel);
 *       return shadowCollection;
 *     });
 */
var ManagedCollectionShadow = core.createClass({
  extend: CollectionShadow,
  name: 'ManagedCollectionShadow',

  _deferreds: null,

  properties: {
    hasMore: false,
    remoteState: SEQUENCE_STATE.NORMAL
  },

  statics: {
    modelType: Model
  },

  construct: function() {
    this._deferreds = {};
    CollectionShadow.apply(this, arguments);
  },

  initFromData: function(data) {
    CollectionShadow.prototype.initFromData.call(this, data.data);
    this.setRemoteState(data.remoteState);
    this.setHasMore(data.hasMore);
  },

  _callWorkerMethod: function(method, limit) {
    eventPrototype.data  = limit;
    eventPrototype.method = method;
    eventPrototype.id     = util.generateUUID();
    var deferred = new Deferred();
    this._deferreds[eventPrototype.id] = deferred;
    this.getChannel().sendMessage(eventPrototype);
    return deferred;
  },

  reactToMessage: function(event) {
    var eventType = event.type;
    if (eventType === EVENT_TYPE_RESPOND) {
      this._deferreds[event.id].setStatus(event.status);
      delete this._deferreds[event.id];
    } else if (eventType === EVENT_TYPE_STATE_CHANGE) {
      this.setRemoteState(event.remoteState);
      this.setHasMore(event.hasMore);
    } else {
      CollectionShadow.prototype.reactToMessage.call(this, event);
    }
  },

  _modelToObject: function(model) {
    // model.toObject() creates a copy of the object. And this is more expensive
    // then not creating an object (c) KO
    // So return model._properties instead, since we never modify or store the
    // returned value
    return model._properties;
  },

  downloadAfter: function(limit) {
    return this._callWorkerMethod('downloadAfter', limit);
  },

  downloadBefore: function(limit) {
    return this._callWorkerMethod('downloadBefore', limit);
  },

  downloadHead: function(limit) {
    return this._callWorkerMethod('downloadHead', limit);
  },

  download: function(limit) {
    return this._callWorkerMethod('download', limit);
  },

  fetchMore: function(limit) {
    return this._callWorkerMethod('fetchMore', limit);
  },

  // TODO: move this functionality (and add other functions like add)
  // to CollectionShadow/CollectionUpdater
  remove: function(model) {
    return this._callWorkerMethod('remove', this._modelToObject(model));
  },

  hasRemoteAfter: function() {
    var last = this.at(this.length - 1);
    return this.getRemoteState() === SEQUENCE_STATE.NORMAL &&
      (!last || last.get('remoteState') != STATE.LAST);
  },

  hasMore: function() {
    return this.getHasMore();
  }

});

exports.ManagedCollectionShadow = ManagedCollectionShadow;
exports.EVENT_TYPE_CALL         = EVENT_TYPE_CALL;
exports.EVENT_TYPE_RESPOND      = EVENT_TYPE_RESPOND;
exports.EVENT_TYPE_STATE_CHANGE = EVENT_TYPE_STATE_CHANGE;
});

// module: shared/data2/model/group/group_member_store
// file:   ../../shared/js/data2/model/group/group_member_store.js
define("shared/data2/model/group/group_member_store", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var Deferred = require('../../../deferred').Deferred;
var Store = require('../../store/store').Store;
var LocalMapper = require('../../local/local_mapper').LocalMapper;
var MultiFQLRemoteMapper =
  require('../../remote/multi_fql_remote_mapper').MultiFQLRemoteMapper;
var Schema = require('../../store/schema').Schema;
var Filter = require('../../store/filter').Filter;

var GroupMember = require('./group_member').GroupMember;
var db  = require('shared/data/db');

var DB_VERSION = '0.1';

function drop(store, callback) {
  db.transaction(
    function(tx) {
      var localMapper = store.getLocalMapper();
      localMapper.withTransaction(tx, localMapper.drop);
    },
    null,
    callback
  );
}

function init(store, callback) {
  db.transaction(
    function(tx) {
      var localMapper = store.getLocalMapper();
      localMapper.withTransaction(tx, localMapper.init);
    },
    null,
    callback
  );
}

function prepare(store, deferred) {
  init(store, function() {
    deferred.succeed(DB_VERSION);
  });
}

function createSchema() {
  return new Schema(
    {
      id: {
        searchable: true,
        localType: 'TEXT PRIMARY KEY',
        generatedRemote: true,
        transformRemoteToModel: function(param, data) {
          return data.gid.gid + '|' + data.uid;
        }
      },
      uid: {
        searchable: true
      },
      gid: {
        searchable: true
      },
      group: {
        remote: 'gid',
        multi_fetch: {
          remote_table: 'group',
          columns: ['gid', 'name', 'icon34'],
          key: 'gid'
        }
      },
      bookmark_order: {}
    },
    GroupMember
  );
}

function createLocalMapper(schema) {
  var mapper = new LocalMapper();
  mapper.setTableName('group_member').setSchema(schema);
  return mapper;
}

function createRemoteMapper(schema) {
  return new MultiFQLRemoteMapper()
    .setSchema(schema)
    .setSeqProperty('key')
    .setTableName('group_member');
}

/**
 * @classdesc The store for Group models.  Reads from the group_member and group
 * FQL tables. Can be queried by uid (to find groups a user is in) or by gid (to
 * find users that are in a group).
 */
var GroupMemberStore = exports.GroupMemberStore = core.createClass({

  name: 'GroupMemberStore',

  extend: Store,

  statics: {
    DB_KEY: 'group_member_storage_version'
  },

  initialize: function(existingVersion) {
    var deferred = new (require('shared/deferred').Deferred)();

    if (this._initialized) {
      deferred.succeed(DB_VERSION);
      return deferred;
    }

    if (existingVersion && existingVersion != DB_VERSION) {
      var _this = this;
      drop(this, function() {
        prepare(_this, deferred);
      });
    } else {
      prepare(this, deferred);
    }

    return deferred;
  },

  /**
   * override to only store models with the uid of the user
   */
  store: function(models) {
    var uid = this.get('uid');
    var modelsToStore = [];
    for (var i = 0; i < models.length; i++) {
      if (!uid || (uid === models[i].get('uid'))) {
        modelsToStore.push(models[i]);
      }
    }
    var result = this._localMapper.store(modelsToStore.map(function(model) {
      return model.toObject();
    }));
    this._triggerStoreEvent(models);
    return result;
  },

  fetchGroupMemberCollectionByUid: function(uid) {
    // Specify the filter, for the given profile ID
    var filter = new Filter({
      uid: uid
    });

    return this.fetchCollection(filter, 1000);
  },

  fetchGroupMemberCollectionByGid: function(gid) {
    // Specify the filter, for the given group ID
    var filter = new Filter({
      gid: gid
    });

    return this.fetchCollection(filter, 1000);
  }

});

var _instance = null;
exports.createLocalMapper = createLocalMapper;
exports.createRemoteMapper = createRemoteMapper;
exports.createSchema = createSchema;
exports.getInstance = function(remoteMapper, localMapper, schema) {
  if (!_instance) {
    schema = schema || createSchema();
    localMapper = localMapper || createLocalMapper(schema);
    remoteMapper = remoteMapper || createRemoteMapper(schema);
    _instance = new GroupMemberStore(remoteMapper, localMapper, schema);
  }
  return _instance;
};
});

// module: contacts/all_contacts_section/ui/contacts_list_scene
// file:   contacts/all_contacts_section/ui/contacts_list_scene.js
define("contacts/all_contacts_section/ui/contacts_list_scene", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var Scene = require('bolt_touch/views/scene').Scene;
var TextInput = require('bolt_touch/views/textinput').TextInput;
var SearchBox = require('../../shared/ui/search_box').SearchBox;
var ImageQueue = require('bolt_touch/util/image_queue');
var ActionableView = require('bolt_touch/views/actionable_view').ActionableView;

var TableView = require("bolt_touch/views/table_view").TableView;
var HeaderFactory = require('../../shared/ui/contacts_list_table').HeaderFactory;
var CellFactory = require('../../shared/ui/contacts_list_table').CellFactory;

var Announcer = require('../../util/announcer').Announcer;

var ContactsListScene = core.createClass({
  name: 'ContactsListScene',
  extend: Scene,

  useHeader: function() {
    return false;
  },

  construct: function(options) {
    this._announcer = new Announcer();
    this._tableModel = this._createTableModel(options.tableModel);
    if (options.searchManager) {
      options.searchManager.setModel(this._tableModel);
    }
    Scene.call(this, options);
  },

  declare: function(options) {
    var displayAddContact = !options.canNotAddContact;
    var title = options.title || 'Contacts';
    return {
      flex: 1,
      id: 'contactsListScene',
      boxOrientation: 'vertical',
      childViews: [
        {
          boxOrientation: 'horizontal',
          className: 'bt-bar',
          childViews: [
            {
              className: 'bt-bar-button left bt-filter-button' +
                ' contactsFilterBtn',
              view: ActionableView,
              action: '_onContactsFilter'
            },
            {
              flex: 1,
              className: 'search-bar',
              childViews: [
                {
                  ref: 'title',
                  className: 'bt-bar-title',
                  content: title,
                  flex: 1
                }
                //{
                  //view: SearchBox,
                  //textFieldId: 'contactsListSearchBox',
                  //ref: 'searchBox',
                  //announcer: this._announcer
                //}
              ]
            },
            {
              view: ActionableView,
              id: 'addNewContact',
              className: 'bt-bar-button right bt-plus-button' +
                (displayAddContact ? '' : ' hidden'),
              action: 'addContact'
            }
          ]
        },
        {
          flex: 1,
          id: 'contactsList',
          boxOrientation: 'vertical',
          childViews: [
            {
              flex: 1,
              boxOrientation: 'vertical',
              childViews: [
                {
                  ref: 'table',
                  view: TableView,
                  className: 'bt-contacts-list-scene--contacts-table',
                  delegate: this._tableModel,
                  dataSource: this._tableModel,
                  fixedRowHeight: 95,
                  fixedSectionHeaderHeight: 60
                }
              ]
            }
          ]
        }
      ]
    };
  },

  activate: function() {
    this._tableModel.activate();
  },

  ready: function() {
    var tableView = this.findRef('table');
    this._tableModel.addTableModelListener(tableView);
    this._cellFactory.setTableView(tableView);
    this._headerFactory.setTableView(tableView);
  },

  /**
   * Override scene's function that changes the unused header
   */
  setTitle: function(title) {
    this.refs.title.setContent(title);
  },

  addContact: function(event) {
    var contactName = '';//this.findRef('searchBox').getValue();
    this._announcer.announce('addContact', contactName);

    //this.findRef('searchBox').clear();
  },

  _onContactsFilter: function() {
    this._announcer.announce('filterContacts');
  },

  addEventListener: function(listener) {
    this._announcer.addListener(listener);
  },

  _createTableModel: function(tableModel) {
    this._cellFactory = new CellFactory(this._announcer);
    this._headerFactory = new HeaderFactory();
    tableModel.setCellFactory(this._cellFactory);
    tableModel.setHeaderFactory(this._headerFactory);
    return tableModel;
  }
});

exports.ContactsListScene = ContactsListScene;
});

// module: view/thread_list/thread_list
// file:   view/thread_list/thread_list.js
define("view/thread_list/thread_list", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core  = require('bolt/core');
var BaseList = require('view/base_list/base_list').BaseList;
var ThreadRow = require('view/thread_row').ThreadRow;
var ScrollView = require('bolt_touch/views/scroll_view_j').ScrollView;
var Loading = require('view/loading/loading').Loading;
var DataList = require('bolt_touch/views/data_list').DataList;
var statusBar = require('view/status_bar/status_bar');
var loggerUtil = require('shared/logger').loggerUtil;
var global = this;

exports.ThreadList = core.createClass({
  name: 'ThreadList',

  extend: BaseList,

  properties: {
    refreshMessage: 'Refreshing threads',
    mailbox: null,
    refreshTimeout: 5000
  },

  declare: function() {
    return {
      className: 'talk-thread-list',

      childViews: [
        {
          view: ScrollView,
          className: 'talk-thread-list--scroll-view',
          ref: 'scrollView',
          childViews: [
            {
              view: DataList,
              ref: 'dataList',
              createView: function(thread) {
                var view = new ThreadRow();
                this.updateView(view, thread);
                return view;
              },
              updateView: function(view, thread) {
                view.setHighlighted(false);
                view.setModel(thread);
                return view;
              },
              doesEventTriggerRedraw: function(e) {
                var changedProperties = e.data.changedProperties;
                if (changedProperties.timestamp ||
                  changedProperties.num_unread ||
                  changedProperties.participantsIdents) {
                  return true;
                }
                return false;
              }
            },
            // shown when downloading from the server
            {
              view: Loading,
              ref: 'loading',
              style: 'display: none'
            }
          ]
        }
      ]
    };
  },

  _dataIsDisplayed: function() {
    if (global.MEASURE_TALK_USABLE) {
      var uptime = FBAPI.use('info').getWebviewUptime();
      require('shared/logger').logger.logTimeDirect(
        'talk:usable', 'latency', uptime);
      global.MEASURE_TALK_USABLE = false;
    }
  },

  getScrollTop: function() {
    return this.refs.scrollView.getScrollTop();
  },

  didScrollStart: function() {
    loggerUtil.startFPSLogging();
  },

  didScrollTo: function() {
    loggerUtil.endFPSLogging("talk:scrollFPS:threadList");
  },

  _lastDownloadTimeKey: function() {
    return 'last_download_time.' + this.getMailbox();
  },

  _addRelationships: function(collection) {
    var RelationshipCollection =
      require('shared/data2/relationship/relationship_collection')
        .RelationshipCollection;
    var Relationship =
      require('shared/data2/relationship/relationship').Relationship;
    var contacts = require('talk/client/model/thread/contacts');

    var listCollection = new RelationshipCollection([
      new Relationship()
        .setQueryPropGetter(function(m) {
          return m.getRelevantParticipants().map(contacts.buildInfoIdent);
        })
        .setTargetProp('participantProfiles')
        .setFetcher(contacts.fetchContacts)
        .setRelatedProp('ident')
    ]);
    listCollection.setCollection(collection);

    return listCollection.waitForFetch().then(function() {
      return listCollection;
    });
  },

  _onscroll: function() {
    var scrollView = this.refs.scrollView;
    var scrollViewHeight = scrollView.getViewportHeight();
    var scrollViewTop = scrollView.getScrollTop();
    var scrollableAreaHeight = scrollView.getScrollableAreaHeight();
    if (scrollableAreaHeight - scrollViewHeight - scrollViewTop < 100) {
      this.tryLoadingMore();
    }
  },

  _refreshRemote: function() {
    this._downloading = true;
    if (!this.getCollection().length) {
      this.findRef('loading').show();
    }
    var threadClient = require('talk/client/thread_client').getInstance();

    threadClient
      .refreshMailboxHead(this.getMailbox().key, 30)
      .addCompleteCallback(this._afterDownload, this);
      // .then(
      //   threadClient.eliminateGapsInCollection,
      //   threadClient,
      //   this.getMailbox().key,
      //   this.getCollection(),
      //   30);
  }
});
});

// module: contacts/find_facebook_contact_section/ui/find_contact_scene
// file:   contacts/find_facebook_contact_section/ui/find_contact_scene.js
define("contacts/find_facebook_contact_section/ui/find_contact_scene", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var Scene = require('bolt_touch/views/scene').Scene;
var TextInput = require('bolt_touch/views/textinput').TextInput;
var TableView = require("views/deprecated/table_view").TableView;
var ActionableView = require('bolt_touch/views/actionable_view').ActionableView;
var SearchBox = require('../../shared/ui/search_box').SearchBox;
var HeaderFactory = require('../../shared/ui/contacts_list_table').HeaderFactory;
var CellFactory = require('../../shared/ui/contacts_list_table').CellFactory;
var ContactsTableModel = require('../../shared/ui/contacts_table_model').ContactsTableModel;
var ContactSnapshotBuilder = require('../../contact').ContactSnapshotBuilder;

var Announcer = require('../../util/announcer').Announcer;

var FindContactScene = core.createClass({
  name: 'FindContactScene',
  extend: Scene,

  useHeader: function() {
    return false;
  },

  construct: function() {
    this._announcer = new Announcer();
    var portfolio = arguments[0].portfolio;
    this._tableModel = this._createTableModel(portfolio);
    Scene.apply(this, arguments);
  },

  declare: function(options) {
    var initialSearchValue = this._initialSearchValueFromOptions(options);
    return {
      id: 'findContactScene',
      childViews: [
        {
          boxOrientation: 'horizontal',
          className: 'bt-bar',
          childViews: [
            {
              view: ActionableView,
              id: 'cancelFind',
              className: 'bt-bar-button left bt-back-button',
              action: 'cancelFind'
            },
            {
              content: 'Find Contact',
              className: 'bt-bar-title',
              flex: 1
            },
            {
              view: ActionableView,
              className: 'bt-bar-button right bt-plus-button',
              action: 'createContact',
              id: 'createContact'
            }
          ]
        },
        {
          boxOrientation: 'horizontal',
          childViews: [
            {
              flex: 1,
              view: SearchBox,
              textFieldId: 'searchBox',
              ref: 'searchBox',
              initialValue: initialSearchValue,
              announcer: this._announcer
            }
          ]
        },
        {
          flex: 1,
          id: 'findFacebookProfile',
          boxOrientation: 'vertical',
          childViews: [
            {
              flex: 1,
              boxOrientation: 'vertical',
              childViews: [
                {
                  ref: 'table',
                  view: TableView,
                  className: 'bt-contacts-list-scene--contacts-table',
                  delegate: this._tableModel,
                  dataSource: this._tableModel,
                  fixedRowHeight: 95,
                  fixedSectionHeaderHeight: 60
                }
              ]
            }
          ]
        }
      ]
    };
  },

  ready: function() {
    var tableView = this.findRef('table');
    this._tableModel.activate();
    this._tableModel.addTableModelListener(tableView);
    this._cellFactory.setTableView(tableView);
    this._headerFactory.setTableView(tableView);
  },

  cancelFind: function() {
    this._announcer.announce('cancelFind');
  },

  createContact: function() {
    var contactName = this._currentSearchValue();
    this._announcer.announce('createNewContact',
                             new ContactSnapshotBuilder()
                                 .withName(contactName)
                                 .build());
  },

  addEventListener: function(listener) {
    this._announcer.addListener(listener);
  },

  _currentSearchValue: function() {
    return this.findRef('searchBox').getValue();
  },

  _createTableModel: function(portfolio) {
    this._cellFactory = new CellFactory(this._announcer);
    this._headerFactory = new HeaderFactory();
    var model = new ContactsTableModel(this._headerFactory, this._cellFactory);
    portfolio.addEventListener(model);
    return model;
  },

  _initialSearchValueFromOptions: function(options) {
    if (options && options.initialSearchValue) {
      return options.initialSearchValue;
    } else {
      return '';
    }
  }
});

exports.FindContactScene = FindContactScene;
});

// module: photos/app/lib/view/photo_viewer/index
// file:   ../../photos/app/lib/view/photo_viewer/index.js
define("photos/app/lib/view/photo_viewer/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core            = require('bolt/core');
var util            = require('bolt/util');
var View            = require('bolt_touch/view').View;
var PhotoCarousel   = require('../photo_carousel').PhotoCarousel;
var ExpandablePhoto = require('../expandable_photo').ExpandablePhoto;

exports.PhotoViewer = core.createClass({
  name: 'PhotoViewer',

  extend: View,

  properties: {
    closeOnTouch: true
  },

  declare: function() {
    return {
      childViews: [
        {
          view: PhotoCarousel,
          ref: 'photoCarousel',
          onphotoSelected: '_photoSelected',
          onphotoTouched: '_photoTouched',
          ontagTouched: '_tagTouched'
        },
        {
          view: ExpandablePhoto,
          ref: 'expandablePhoto',
          onphotoExpanded: '_photoExpanded',
          onphotoShrinked: '_photoShrinked'
        }
      ]
    };
  },

  construct: function(options) {
    this._getPhotoRect = options.getPhotoRect;
    this._showPhoto = options.showPhoto;
    this._hidePhoto = options.hidePhoto;
    this._scrollToPhoto = options.scrollToPhoto;

    View.call(this, options);
  },

  ready: function() {

    // Initially hide the carousel
    this.refs.photoCarousel.hide();
  },

  open: function(photos, index, title, selectable) {
    this._photos = photos;
    this._index = index || 0;
    this._title = title || '';
    this._selectable = selectable || false;
    var photo = this._photos.at(this._index);

    // Decide which photo to use
    var photoUrl = (photo.get('cacheState') === 'full' ?
      photo.get('full_url') :
      photo.get('thumbnail_url')
    );

    // Expand the photo
    this.refs.expandablePhoto.expand(
      photoUrl,
      photo.get('width'),
      photo.get('height'),
      this._getPhotoRect(this._index),
      document.body.getBoundingClientRect()
    );

    // Hide the thumbnail
    this._hidePhoto(this._index);
  },

  openImmediately: function(photos, index, title, selectable) {
    this._photos = photos;
    this._index = index || 0;
    this._title = title || '';
    this._selectable = selectable || false;

    // Show the Photo Carousel
    this._openPhotoCarousel();
  },

  showTags: function() {
    this.refs.photoCarousel.showPhotoTags();
  },

  hideTags: function() {
    this.refs.photoCarousel.hidePhotoTags();
  },

  _photoExpanded: function() {
    // Show the Photo Carousel
    this._openPhotoCarousel();

    // Show the thumbnail
    this._showPhoto(this._index);
  },

  _openPhotoCarousel: function() {
    // Show the Photo Carousel
    this.refs.photoCarousel.setTitle(this._title);
    this.refs.photoCarousel.set('photos', this._photos);
    this.refs.photoCarousel.set('startingIndex', this._index);
    this.refs.photoCarousel.set('selectable', this._selectable);
    this.refs.photoCarousel.load();
    this.refs.photoCarousel.show();

    // Inform the owner we have opened the photo carousel
    this.invoke('opened');
  },

  _photoTouched: function(evt) {
    // #EventCompatibilityHack
    if (typeof evt.data.index === 'undefined') {
      return;
    }

    if (this.get('closeOnTouch')) {
      this._index = evt.data.index;
      var photo = evt.data.photo;

      // Scroll to the thumbnail
      this._scrollToPhoto && this._scrollToPhoto(this._index);

      // Shrink the photo
      this.refs.expandablePhoto.shrink(
        photo.get('thumbnail_url'),
        photo.get('width'),
        photo.get('height'),
        this._getPhotoRect(this._index),
        document.body.getBoundingClientRect()
      );

      // Hide the thumbnail
      this._hidePhoto(this._index);

      // Hide the Photo Carousel
      this.refs.photoCarousel.hide();

      // Inform the owner we're about to close the photo carousel
      this.invoke('closing');
    }

    this.invoke('photoTouched', evt.data);
  },

  _photoShrinked: function() {
    // Show the thumbnail
    this._showPhoto(this._index);

    // Inform the owner we have closed the photo carousel
    this.invoke('closed');
  },

  _photoSelected: function(evt) {
    // #EventCompatibilityHack
    if (!require('bolt/event_dispatcher').defaultEventDispatcher.getEnabled()) {
      this.invoke('photoSelected', evt.data);
    }
  },

  _tagTouched: function(evt) {
    evt.stopPropagation();
    this.invoke(evt.type, evt.data);
  }
});
});

// module: photos/app/lib/model/album/album_store
// file:   ../../photos/app/lib/model/album/album_store.js
define("photos/app/lib/model/album/album_store", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core               = require('bolt/core');
var util               = require('bolt/util');
var Deferred           = require('shared/deferred').Deferred;
var LocalMapper        = require('shared/data2/local/local_mapper').LocalMapper;
var StoreWithBroadcast =
  require('shared/data2/store/store_with_broadcast').StoreWithBroadcast;
var Schema             = require('shared/data2/store/schema').Schema;
var Filter             = require('shared/data2/store/filter').Filter;
var Album              = require('./album').Album;
var AlbumRemoteMapper  = require('./album_remote_mapper').AlbumRemoteMapper;

function createSchema() {
  return new Schema(
    {
      id: {
        searchable: true,
        remote: 'object_id',
        localType: 'TEXT PRIMARY KEY'
      },
      aid: {},
      type: {
        searchable: true
      },
      created_time: {
        remote: 'created'
      },
      updated_time: {
        searchable: true,
        remote: 'modified'
      },
      count: {
        remote: 'size'
      },
      cover_photo: {
        remote: 'cover_object_id'
      },
      description: {},
      from: {
        remote: 'owner'
      },
      name: {},
      likes: {
        remote: 'like_info',
        transformRemoteToModel: function(data) {
          return {
            can_like: data.can_like,
            user_likes: data.user_likes,
            count: parseInt(data.like_count, 10)
          };
        }
      },
      comments: {
        remote: 'comment_info',
        transformRemoteToModel: function(data) {
          return {
            can_post: data.can_comment,
            count: parseInt(data.comment_count, 10)
          };
        }
      },
      last_sync_time: {
        remote: false
      }
    },
    Album
  );
}

function createLocalMapper(schema) {
  var mapper = new LocalMapper(schema, 'album');
  mapper.createIndexes = function(tx) {
    tx.executeSql('CREATE UNIQUE INDEX IF NOT EXISTS ' +
      'idx_album__id ON ' + mapper.getTableName() +
      '(id)');
    tx.executeSql('CREATE INDEX IF NOT EXISTS ' +
      'idx_album__updated_time ON ' + mapper.getTableName() +
      '(updated_time DESC)');
  };
  return mapper;
}

function createRemoteMapper(schema) {
  return new AlbumRemoteMapper(schema, 'album');
}

var AlbumStore = exports.AlbumStore = core.createClass({
  name: 'AlbumStore',

  extend: StoreWithBroadcast,

  properties: {
    modelType: Album
  },

  fetchAlbumCollection: function() {
    var filter = new Filter(
      {},
      'updated_time DESC'
    );
    filter.setComparator(function(album) {
      if (album.get('type') === 'unpublished') {
        return -1 * Number.MAX_VALUE;
      }
      else if (album.get('type') === 'video') {
        return 0;
      }
      else {
        return -1 * album.get('updated_time');
      }
    });

    filter.set('FQLQuery', 'owner=me()');

    return this.fetchCollection(filter, 200);
  },

  fetchAlbumById: function(id) {
    var deferred = new Deferred();

    this.fetchCollection({ id: id }, 1)
      .addCallback(function(albums) {
        if (!albums || !albums.at(0)) {
          deferred.succeed();
        }

        deferred.succeed(albums.at(0));
      }, this);

    return deferred;
  },

  fetchMobileAlbum: function() {
    var deferred = new Deferred();

    this.fetchCollection({ type: 'mobile' }, 1)
      .addCallback(function(albums) {
        if (!albums || !albums.at(0)) {
          deferred.succeed();
        }

        deferred.succeed(albums.at(0));
      }, this);

    return deferred;
  },

  fetchPrivateAlbum: function() {
    var deferred = new Deferred();

    this.fetchCollection({ id: '-1' }, 1)
      .addCallback(function(albums) {
        if (!albums || !albums.at(0)) {
          deferred.succeed();
        }

        deferred.succeed(albums.at(0));
      }, this);

    return deferred;
  }
});

var _instance = null;
exports.createLocalMapper = createLocalMapper;
exports.createRemoteMapper = createRemoteMapper;
exports.createSchema = createSchema;
exports.getInstance = function(remoteMapper, localMapper, schema) {
  if (!_instance) {
    schema = schema || createSchema();
    localMapper = localMapper || createLocalMapper(schema);
    remoteMapper = remoteMapper || createRemoteMapper(schema);
    _instance = new AlbumStore(remoteMapper, localMapper, schema);
  }
  return _instance;
};
});

// module: shared/boltwidget/ellipsified_text
// file:   ../../shared/js/boltwidget/ellipsified_text.js
define("shared/boltwidget/ellipsified_text", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var View = require('bolt_touch/view').View;
var measurer = require('shared/text_measurer').Measurer;

/**
 * A simple text widget that will show ellipsis on the left of the text if
 * the length exceeds a certain value.  It will also scale down the font size of
 * the text in order to fit it in the desired width.
 */
var EllipsifiedText = exports.EllipsifiedText = core.createClass({
  name: 'EllipsifiedText',

  extend: View,

  properties: {
    text: '',
    maxLength: 30,
    fontSize: 50,
    elmWidth: 420,
    //if the text is < this many characters, don't worry about resize
    resizeLength: 0
  },

  construct: function(options) {
    this.currentFontSize = this.getFontSize();
    View.call(this, options);
  },

  declare: function(options) {
    return {
      childViews: [
        {
          ref: 'visibleText',
          className: 'visibletext'
        },
        {
          ref: 'hiddenText',
          className: 'hiddentext'
        }
      ]
    };
  },

  ready: function() {
    this.textElm = this.findRef('visibleText');
    //required for starting size since we're not always checking now
    this.textElm.setStyle('fontSize', this.getFontSize() + 'px');
  },

  /**
    * Sets the text in the ellipsified textfield.  A fast mode is offered
    * that will probably be rarely used.
    *
    * In new fast mode we predict the width by computing the "additional
    * width" of every character. Picture is not pixel-perfect, by takes 1ms
    * to calculate instead of 10-15 for old fastmode version.
    *
    * Parameters:
    *   (String) text - the text to put in the field
    *   (Boolean) fastmode - whether or not to enable fastmode.
    */
  setText: function(text, fastmode) {
    this.set('text', text);
    var formattedText = this.getFormattedText(text);

    // only check if text is longer than resized length or shorter than the max
    // length. If larger than max length, then ellipses prevent the text to be
    // larger than the area
    if (text.length > this.getResizeLength() &&
        text.length <= this.getMaxLength() + 1) {
      var predictionFunc = (fastmode) ? this.predictFast : this.predictAccurate;
      var textFontSize = this.getFontSizeToFit(formattedText, predictionFunc);
      this.textElm.setStyle('fontSize', textFontSize + 'px');
      this.currentFontSize = textFontSize;
    }
    this.textElm.setContent(formattedText);
  },

  predictFast: function(text, size) {
    var style = window.getComputedStyle(this.textElm.getNode());
    return measurer.measure(text, {
      fontSize: size + 'px',
      fontFamily: style.fontFamily,
      fontWeight: style.fontWeight
    });
  },

  predictAccurate: function(text, size) {
    var elm = this.findRef('hiddenText');
    elm.setContent(text);
    elm.setStyle('fontSize', size + 'px');
    return elm.getNode().clientWidth;
  },

  /**
    * The idea is that we need to pick a font size such that the number fits
    * in its element without horizontally overflowing. It turns out this can
    * be done with a hidden element, whereby we insert the text into the
    * element, set its font size, then measure its width.  We can then
    * adjust its font size until it fits within the desired bounds. Then we
    * have the font size to use!
    */
  getFontSizeToFit: function(text, predictionFunction) {
    // interpolation search
    var elmWidth = this.getElmWidth();
    var low = 1;
    var high = this.getFontSize();
    var size = this.currentFontSize;
    while (high > low) {
      var textWidth = predictionFunction.call(this, text, size);
      if (textWidth > elmWidth) {
        high = size - 1;
      } else {
        low = size;
      }
      // guess the correct size using linear interpolation
      size = Math.round(elmWidth / textWidth * size);
      size = Math.max(size, low + 1);
      size = Math.min(size, high);
    }
    return size;
  },

  getFormattedText: function(text) {
    var formattedText;
    if (!text) {
      formattedText = '';
    } else if (text.length > this.getMaxLength()) {
      // we are using symbol-by-symbol measurer, so can't use &hellip; in the
      // raw string
      formattedText = '...' + text.slice(text.length - this.getMaxLength());
    } else {
      formattedText = text;
    }

    return formattedText;
  }
});
});

// module: shared/data2/store/schema/index
// file:   ../../shared/js/data2/store/schema/index.js
define("shared/data2/store/schema/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var Model = require('bolt/model').Model;

var TypeBase = require('../schema/type/base').TypeBase;

var LOCAL_DATA_COLUMN = 'data';

/**
 * @classdesc Describes store schema: model properties, local db columns, and
 * remote columns. By default uses propertyMap option that defines the table
 * structure.
 *
 * Schema allows for creating a structure layer to be used by
 * MultiFQLRemoteMapper for mapping an entry in a colum to a several columns on
 * related table.
 *
 * For example, the "stream" table has a column "actor_id". If we wanted to
 * fetch some more data about the actor from the profile table format the
 * "actor_id" entry into the schema as such:
 *
 *  actor: {
 *    remote: 'actor_id', // rename the property since its more than the id
 *    multi_fetch: {
 *      remote_table: 'profile',
 *      columns: ['id', 'name', 'pic_big'],
 *      key: 'id'
 *    }
 *  }
 *
 * For this feature add the following to a property's config:
 * {Object} multi_fetch
 * {string} multi_fetch.remote_table the remote table to query
 * {array of strings} multi_fetch.columns the columns to query and return
 * {string} multi_fetch.key: the key to match values with
 *
 * @example
 *
 *   new Schema({
 *     id:                  { searchable: true },
 *     thread_id:           { searchable: true },
 *     timestamp:           { searchable: true },
 *     folder:              { searchable: true },
 *     num_unread:          { searchable: true },
 *     name:                { localType: 'TEXT' },
 *     pic_hash:            { },
 *     mute:                { localType: 'INTEGER' },
 *     snippet:             { },
 *     senders:             { },
 *     participants:        { },
 *     former_participants: { },
 *     object_participants: { },
 *     num_messages:        { },
 *     action_id:           { },
 *     single_recipient:    { },
 *     archived:            { },
 *     subject:             { },
 *     tags:                { },
 *
 *     pendingActions:      { remote: false, searchable: true }
 *   });
 *
 */


exports.Schema = core.createClass({

  name: 'Schema',

  construct: function(propertyMap, modelType) {
    this._propertyMap = propertyMap;
    this._properties = util.keys(this._propertyMap);
    this._queriableProperties = util.filter(this._properties,
      function(property) {
        return propertyMap[property].multi_fetch;
      });
    this._jsonPathProperties = util.filter(this._properties,
      function(property) {
        return propertyMap[property].json_path_requests;
      });
    this.setModelType(modelType);

    // normalize local and remote names
    for (var i = 0; i < this._properties.length; i++) {
      var name = this._properties[i];
      var info = this._propertyMap[name];
      if (!(info instanceof TypeBase)) {
        info = this._propertyMap[name] = new TypeBase(info);
      }
      if (info.local !== false) {
        info.local = typeof info.local == 'string' ? info.local : name;
      }
      if (!('remote' in info) && !info.generatedRemote) {
        info.remote = name;
      }
    }
  },

  getModelType: function() {
    return this._modelType;
  },

  setModelType: function(modelType) {
    this._modelType = modelType || Model;
  },

  getPropertyNames: function() {
    return this._properties;
  },

  getPropertyInfo: function(name) {
    return this._propertyMap[name];
  },

  getQueriableProperties: function() {
    return this._queriableProperties;
  },

  getJsonPathProperties: function() {
    return this._jsonPathProperties;
  },

  getRemoteTableForProperty: function(propertyName) {
    return this._propertyMap[propertyName].multi_fetch.remote_table;
  },

  getRemoteColumnsForProperty: function(propertyName) {
    return this._propertyMap[propertyName].multi_fetch.columns;
  },

  getRemoteKeyForProperty: function(propertyName) {
    return this._propertyMap[propertyName].multi_fetch.key;
  },

  getRemoteColumn: function(propertyName) {
    return this._propertyMap[propertyName].remote;
  },

  getModelProperties: function() {
    return this._properties;
  },

  getPropertiesForModel: function() {
    var properties = {};
    for (var key in this._propertyMap) {
      if (this._propertyMap[key].notAModelProperty !== true) {
        properties[key] = this._propertyMap[key].defaultValue;
      }
    }
    return properties;
  }
});
});

// module: bolt/mixins/events
// file:   ../../../frameworks/bolt/lib/mixins/events.js
define("bolt/mixins/events", function(require, exports, module) {
/**
 * Copyright (c) 2011-2012, Facebook, Inc.
 * All rights reserved.
 *
 * @option preserve-header
 *
 */

var util = require('../util');
var TokenList = require('../token_list').TokenList;

var EventShim = require('../compat/event').EventShim;

var slice = Array.prototype.slice;

var Events = exports.Events = {
  // Bind an event, specified by a string name, `ev`, to a `listener` function.
  // Passing `"all"` will bind the listener to all events fired.
  addListener : function(type, listener, contextOrNull) {
    if (listener === undefined && contextOrNull === undefined) {
      listener = type;
      // we'll want the listener's functions invoked in their own scope
      contextOrNull = type;
      type = 'all';
    } else if (contextOrNull === undefined && typeof type !== 'string') {
      // passing in an event function and a context, with no type
      contextOrNull = listener;
      listener = type;
      type = 'all';
    }

    contextOrNull = contextOrNull || this;

    var list = this._tokenList || (this._tokenList = new TokenList());
    var args = arguments.length > 3 ? slice.call(arguments, 3) : null;

    return list.addListener(type, listener, contextOrNull, args);
  },

  // Remove one or many listeners. If `listener` is null, removes all
  // listeners for the event. If `ev` is null, removes all bound listeners
  // for all events.
  removeListener : function(type, listener, contextOrNull) {
    if (listener === undefined && contextOrNull === undefined) {
      listener = type;
      // we'll want the listener's functions invoked in their own scope
      contextOrNull = type;
      type = 'all';
    } else if (contextOrNull === undefined && typeof type !== 'string') {
      // passing in an event function and a context, with no type
      contextOrNull = listener;
      listener = type;
      type = 'all';
    }

    if (this._tokenList) {
      this._tokenList.removeListener(type, listener, contextOrNull || this);
    }
    return this;
  },

  // Invoke an event, firing all bound listeners.
  invoke : function(eventObject, data) {
    if (typeof eventObject !== 'string' || arguments.length > 2) {
      console.error('Events#invoke is being called with a deprecated API. ' +
        'Passing arbitrary arguments is no longer supported. Update your code to invoke ' +
        'the event with .invoke(type, data). Your listener will be invoked with ' +
        'an event object containing a type and data property.');
    }

    if (!this._tokenList) { return this; }
    var args = util.toArray(arguments);
    if (util.isString(eventObject)) {
      eventObject = new EventShim(eventObject, data);
      args[0] = eventObject;
    }
    var listener;

    var tokens = this._tokenList.getTokensForType(eventObject.type)
      .concat(this._tokenList.getTokensForType('all'));

    for (var i = 0, l = tokens.length; i < l; i++) {
      var item = tokens[i];
      if (!item.isDestroyed) {
        if (item.boundListener) {
          item.boundListener.apply(item, item.args ? item.args.concat(args) : args);
        } else if (item.listener) {
          listener = item.listener;
          if (listener.apply) {
            // passed listener was a function
            listener.apply(item.context || this, item.args ? item.args.concat(args) : args);
          } else if (listener[eventObject.type] && listener[eventObject.type].apply) {
            // passed an object that implements a function of the event name
            listener[eventObject.type].apply(item.context || this, item.args ? item.args.concat(args) : args);
          }
        }
      }
    }
    return this;
  }
};

// COMPAT

var deprecated = require('../core').deprecated;
var slice = Array.prototype.slice;

function handleAll(event) {
  this.listener.apply(
    this.context,
    [event.type].concat(slice.call(arguments, 1)));
}

function handleSingle() {
  this.listener.apply(this.context, slice.call(arguments, 1));
}

Events.listen = function(type, callback, contextOrNull) {
  deprecated('listen', 'addListener');

  console.error(this.getDeclaredClass() + '.listen is deprecated. Use addListener instead.' +
    ' This function will be removed very soon, please fix your code.');

  var token = this.addListener(type, callback, contextOrNull || this);
  token.boundListener = type === 'all' ? handleAll : handleSingle;
  return token;
};

Events.stopListening = function(){
  deprecated('stopListening', 'removeListener');
  Events.removeListener.apply(this, arguments);
};
});

// module: shared/logger
// file:   ../../shared/js/logger.js
define("shared/logger", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core     = require('bolt/core');
var isWorker = require('shared/config').isWorker;

var PerfQuery = (typeof(FBNativeAPI) === 'undefined' ?
  null : FBNativeAPI.use('PerfQuery'));

var _logApi;
if (!isWorker() && this.FBAPI) {
  if (this.console) {
    console.info("logger is not worker");
  }
  _logApi = FBAPI.use("log");

}

if (!_logApi) {
  if (this.console) {
    console.info("logger is worker");
  }
  _logApi = {
    perfLogEnabled: function () {return false;}
  };
}

var logger = exports.logger = new (core.createClass({
  name: 'FBLogger',

  ALLOW_NESTING : _logApi.ALLOW_NESTING,
  DISALLOW_NESTING : _logApi.DISALLOW_NESTING,
  COLLAPSE_NESTING : _logApi.COLLAPSE_NESTING,
  ALLOW_OVERLAPPING : _logApi.ALLOW_OVERLAPPING,

  properties: {
    enabled: false,
    perfLogEnabled: false
  },

  construct: function() {
    this._ids = {};
  },

  enable: function() {
    this.setEnabled(true);
  },

  disable: function() {
    this.setEnabled(false);
    this.setPerfLogEnabled(false);
  },

  log: function(args) {
    if (!this.getEnabled()) return;

    try {
      if (!args.time) {
        args.time = Date.now();
      }
      // encode logging info in JSON and append line breaker after.
      if (_logApi && _logApi.log) {
        _logApi.log(JSON.stringify(args)+"\n");
      }
    } catch (e) {
      console.error(e);
    }
  },

  enablePerfLog : function() {
    if (this.getEnabled() && _logApi.perfLogEnabled()) {
      this.setPerfLogEnabled(true);
    }
  },

  disablePerfLog : function() {
    this.setPerfLogEnabled(false);
  },

  /**
   * Start a latency timer.
   *
   * @param: {string} Primary ID for logging
   * @param: {Integer} Method to handle duplicate timers
   * @param: {string} Sub-ID that does not appear in logs
   *                  (multiple sub-IDs per ID)
   */
  startTimer: function(id, nesting, subId) {
    if (this.getPerfLogEnabled()) {
      if (typeof(nesting) !== "number") {
        nesting = this.COLLAPSE_NESTING;
      }

      if (subId) {
        var fullId = this._getFullId(id, subId);
        var tmpId = _logApi.startTimer(fullId, nesting);
        this._ids[fullId] = tmpId;
        return tmpId;
      }

      return _logApi.startTimer(id, nesting);
    }
  },

  endTimer: function(id, info, subId) {
    if (this.getPerfLogEnabled()) {
      if (subId) {
        var fullId = this._getFullId(id, subId);
        var tmpId = this._ids[fullId];
        if (!tmpId) {
          console.warn('No timer with id = ' + id + ', subId = ' + subId);
          return;
        }
        var timeTaken = _logApi.queryTimer(tmpId);
        _logApi.clearTimer(timeTaken);
        var kind = 'latency';
        return _logApi.logTimeDirect(id, kind, timeTaken, JSON.stringify(info));
      }

      return _logApi.endTimer(id, JSON.stringify(info));
    }
  },

  clearTimer : function(id, subId) {
    if (this.getPerfLogEnabled()) {
      if (subId) {
        var fullId = this._getFullId(id, subId);
        var tmpId = this._ids[fullId];
        if (!tmpId) {
          console.warn('No timer with id = ' + id + ', subId = ' + subId);
          return;
        }
        delete this._ids[fullId];
        return _logApi.clearTimer(tmpId);
      }

      return _logApi.clearTimer(id);
    }
  },

  queryTimer : function(id, subId) {
    if (this.getPerfLogEnabled()) {
      if (subId) {
        var fullId = this._getFullId(id, subId);
        var tmpId = this._ids[fullId];
        if (!tmpId) {
          console.warn('No timer with id = ' + id + ', subId = ' + subId);
          return -1;
        }
        return _logApi.queryTimer(tmpId);
      }

      return _logApi.queryTimer(id);
    }
  },

  logTimeDirect : function(id, kind, value, info) {
    if (this.getPerfLogEnabled()) {
      return _logApi.logTimeDirect(id, kind, value, JSON.stringify(info));
    }
  },

  addRawPerfLog : function(log) {
    if (this.getPerfLogEnabled()) {
      return _logApi.addRawPerfLog(log);
    }
  },

  logBootTime : function() {
    if (this.getPerfLogEnabled()) {
      return _logApi.logBootTime();
    }
  },

  _getFullId : function(id, subId) {
    var fullId = id + ':' + subId;
    return fullId;
  }

}))();

exports.loggerUtil = {
  startFPSLogging: function() {
    if (PerfQuery) {
      PerfQuery.startFrameCounter();
    }
  },

  endFPSLogging: function(id) {
    if (PerfQuery) {
      var fps = JSON.parse(PerfQuery.endFrameCounter()).fps;
      if (id) {
        logger.logTimeDirect(id, "fps", fps);
      }
    }
  }
};

logger.enable();
logger.enablePerfLog();
});

// module: talk/app/contacts/local_contacts_list
// file:   contacts/local_contacts_list.js
define("talk/app/contacts/local_contacts_list", function(require, exports, module) {
module.exports = require("contacts/local_contacts_list");});

// module: contacts/local_contacts_list
// file:   contacts/local_contacts_list.js
define("contacts/local_contacts_list", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var Contact = require('./contact').Contact;
var Announcer = require('./util/announcer').Announcer;
var MemoryCache = require('shared/data2/store/memory_cache').MemoryCache;
var Filter = require('shared/data2/store/filter').Filter;
var Deferred = require('shared/deferred').Deferred;

var ContactsLocalMapper =
  require('./contacts_local_mapper').ContactsLocalMapper;

var LocalContactsList = function() {
  this._localMapper = new ContactsLocalMapper();
  this._localMapper.init();
  this._announcer = new Announcer();
  this._memoryCache = new MemoryCache();
  this._facebookIdToLocalIdMap = {};
};

LocalContactsList.prototype = {
  drop: function() {
    this._localMapper.drop();
  },

  createContact: function(newContactInformation) {
    var contact = new Contact(newContactInformation);
    this._localMapper.store([contact.toObject()])
                     .then(this._notifyContactCreated, this, contact);
    contact.addEventListener(this);
    this._cacheContact(contact);
    return contact;
  },

  contactFor: function(newContactInformation) {
    var contact = new Contact(newContactInformation);
    this._localMapper.store([contact.toObject()]);
    contact.addEventListener(this);
    this._cacheContact(contact);
    return contact;
  },

  _cacheContact: function(contact) {
    this._memoryCache.hold(contact);
    this._facebookIdToLocalIdMap[contact.getFacebookId()] = contact.getId();
  },

  allContacts: function() {
    return this._localMapper.fetchInformationForFilter(new Filter({}))
                            .then(this._returnAllModels, this);
  },

  findById: function(id) {
    var contact = this._memoryCache.get(id);
    if (contact) {
      return new Deferred().succeed(contact);
    } else {
      return this._localMapper.fetchInformationForFilter(new Filter({id: id}))
                              .then(this._returnSingleModel, this);
    }
  },

  allContactsWithPhoneNumber: function(phoneNumber) {
    var filter = new Filter().setSQLWhere(
      "phoneNumbers LIKE '%\"" + phoneNumber + "\"%'"
    );
    return this._localMapper.fetchInformationForFilter(filter)
                            .then(this._returnAllModels, this);
  },

  allContactsWithEmail: function(email) {
    var filter = new Filter({email: email});
    return this._localMapper.fetchInformationForFilter(filter)
                            .then(this._returnAllModels, this);
  },

  findByFacebookId: function(id) {
    var localId = this._facebookIdToLocalIdMap[id];
    if (localId) {
      return this.findById(localId);
    } else {
      var filter = new Filter({facebookId: id});
      return this._localMapper.fetchInformationForFilter(filter)
                              .then(this._returnSingleModel, this);
    }
  },

  updateContact: function(snapshot) {
    var announcer = this._announcer;
    var contact = new Contact(snapshot);

    this._localMapper.store([contact])
                     .then(this._notifyContactUpdated, this, snapshot);
  },

  contactStateChanged: function(snapshot) {
    var contact = new Contact(snapshot);
    this._localMapper.store([contact]);
  },

  contactDeleted: function(snapshot) {
    var repository = this;
    this.findById(snapshot.id).then(function(contact) {
      if (contact) {
        repository._memoryCache.release(contact);
      }
      repository._localMapper.remove([snapshot.id]);
    });
  },

  addEventListener: function(listener) {
    this._announcer.addListener(listener);
  },

  _returnAllModels: function(models) {
    var repository = this;
    var cachedModels = models.map(function(modelAttributes) {
      var contact = repository._memoryCache.get(modelAttributes.id);
      if (contact) {
        return contact;
      } else {
        contact = new Contact(modelAttributes);
        repository._cacheContact(contact);
        return contact;
      }
    });
    return cachedModels;
  },

  _returnSingleModel: function(models) {
    if (models.length !== 0) {
      var modelAttributes = models[0];
      var contact = this._memoryCache.get(modelAttributes.id);
      if (contact) {
        return contact;
      } else {
        contact = new Contact(modelAttributes);
        this._cacheContact(contact);
        return contact;
      }
    } else {
      return null;
    }
  },

  _notifyContactCreated: function(contact) {
    this._announcer.announce('contactCreated', contact);
  },

  _notifyContactUpdated: function(snapshot) {
    this._announcer.announce('contactUpdated', snapshot);
  }
};

exports.LocalContactsList = LocalContactsList;
});

// module: shared/boltwidget/dialog
// file:   ../../shared/js/boltwidget/dialog.js
define("shared/boltwidget/dialog", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var dom = require('bolt/dom');
var util = require('bolt/util');
var View = require('bolt_touch/view').View;
require('bolt_touch/views/button');

/**
 * Creates an asynchronous modal dialog. It can be displayed with show().
 * Once any button on the dialog is clicked, it will run the action associated
 * with that button, then dismiss and destroy itself.
 *
 * There are two additional properties that can be passed in with the
 * constructor: body and buttons.
 *
 * body: Either an array or a single element, each of which is either a BoltJS
 * object specification or a string (will be constructed as a span)
 *
 * Example:
 * [
 *   "Your name: ",
 *   {
 *     tagName: "input",
 *     type: "text",
 *     ref: "name"
 *   }
 * ]
 *
 * actions: Array of objects, each with the following properties:
 *   value: The name of the button
 *   action (optional): A function to execute when the button is clicked.
 *     If no action is specified, the dialog will simply dismiss itself.
 *
 * Example:
 * [
 *   {
 *     value: "OK",
 *     action: function() {
 *       doSomethingWithResult(1, dialog.findRef("name").getNode().value);
 *     }
 *   },
 *   {
 *     value: "Change Name",
 *     action: function() {
 *       doSomethingWithResult(2, dialog.findRef("name").getNode().value);
 *     }
 *   },
 *   {
 *     value: "Cancel",
 *     action: function() {
 *       doSomethingWithResult(0, dialog.findRef("name").getNode().value);
 *     }
 *   }
 * ]
 *
 * Note the use of references to get data from form elements/etc inserted
 * into the dialog body.
 */
var Dialog = exports.Dialog = core.createClass({
  name: "Dialog",

  // TODO subclass ActionSheet instead
  extend: View,

  properties: {
    title: "",
    body: undefined,
    actions: undefined,
    destroyOnHide: true
  },

  declare: function(options) {
    return {
      childViews: [
        {
          ref: "dialog",
          className: "dialog",
          childViews: [
            {
              ref: "title",
              className: "title hidden"
            },
            {
              ref: "body",
              className: "body"
            },
            {
              ref: "buttons",
              className: "buttons"
            }
          ]
        }
      ]
    };
  },

  getTitle: function() {
    return this.refs.title.getNode().innerText;
  },

  setTitle: function(title) {
    this.refs.title.setContent(title);
    if (!title) {
      this.refs.title.addClass("hidden");
    } else {
      this.refs.title.removeClass("hidden");
    }
  },

  setActions: function(buttons) {
    this.refs.buttons.clearChildren();
    for (var i = 0; i < buttons.length; i++) {
      this.addAction(buttons[i]);
    }
  },

  addAction: function(buttonProps) {
    var options = {
      view: "Button",
      value: buttonProps.value,
      owner: buttonProps.owner
    };
    if (buttonProps.className) {
      options.className = buttonProps.className;
    }
    var button = this.build(options);
    if (buttonProps.action) {
      button.addAction(buttonProps.action);
    }
    // ensure dialog is dismissed after a button press
    button.addAction(util.bind(this.dismiss, this));
    this.refs.buttons.appendChild(button);
  },

  getBody: function() {
    // This can't be used for anything
    return this.refs.body.getNode().innerHTML;
  },

  /**
    * Accepts either a single piece or array of content (each being either a
    * string or BoltJS object spec), and sets the contents of the dialog to it
    */
  setBody: function(body) {
    this.refs.body.clearChildren();
    if (!body[0]) {
      this.appendBodyContent(body);
    } else {
      for (var i = 0; i < body.length; i++) {
        this.appendBodyContent(body[i]);
      }
    }
  },

  appendBodyContent: function(content) {
    var newContent;
    if ((typeof content) == "string") {
      newContent = this.build({ tagName: "span", content: content });
    } else {
      newContent = this.build(content);
    }
    this.refs.body.appendChild(newContent);
  },

  show: function() {
    this.placeIn(document.body);
    this.getNode().style.visibility = "visible";
  },

  hide: function() {
    this.getNode().style.visibility = "hidden";
    if (this.getDestroyOnHide()) {
      this.dismiss();
    }
  },

  isShowing: function() {
    return (this.getNode().style.visibility == "visible");
  },

  toggle: function() {
    if (this.isShowing()) {
      this.hide();
    } else {
      this.show();
    }
  },

  dismiss: function() {
    this.destroy();
  }
});
});

// module: views/feedback/ufi/comment_row/index
// file:   ../../views/feedback/ufi/comment_row/index.js
define("views/feedback/ufi/comment_row/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var ProfilePicture = require('views/profile_picture').ProfilePicture;
var TouchableView = require('bolt_touch/views/touchable_view').TouchableView;

var Timestamp = require('views/timestamp').Timestamp;
var FBObjectLink =
  require('views/units/component/fb_object_link').FBObjectLink;

var dialogUtil = require('shared/dialogs');

var CommentRow = core.createClass({

  name: 'CommentRow',

  extend: View,

  properties: {
    model: null
  },

  declare: function() {
    return {
      className: 'bt-ufi-row',
      boxOrientation: 'horizontal',
      childViews: [
        {
          view: FBObjectLink,
          ref: 'profilePicLink',
          onaction: 'forwardAction',
          childViews: [
            {
              view: ProfilePicture,
              className: 'bt-comment-row--profile-picture',
              ref: 'profilePicture'
            }
          ]
        },
        {
          boxOrientation: 'vertical',
          flex: 1,
          childViews: [
            {
              view: FBObjectLink,
              className: 'bt-comment-row--actor',
              onaction: 'forwardAction',
              ref: 'actor'
            },
            {
              className: 'bt-comment-row--message',
              ref: 'message'
            },
            {
              className: 'bt-comment-row--bottom-bar',
              boxOrientation: 'horizontal',
              childViews: [
                {
                  view: Timestamp,
                  className: 'bt-comment-row--timestamp',
                  ref: 'timestamp'
                },
                {
                  boxOrientation: 'horizontal',
                  ref: 'likeLinkWrapper',
                  childViews: [
                    {
                      className: 'bt-comment-row--feedback-middot',
                      content: '\u00B7'
                    },
                    {
                      view: TouchableView,
                      className: 'bt-comment-row--like-link',
                      onclick: 'handleLikeLinkClick',
                      ref: 'likeLink'
                    }
                  ]
                },
                {
                  boxOrientation: 'horizontal',
                  ref: 'likeCountWrapper',
                  childViews: [
                    {
                      className: 'bt-comment-row--feedback-middot',
                      content: '\u00B7'
                    },
                    {
                      view: TouchableView,
                      className: 'bt-comment-row--like-count',
                      ref: 'likeCount'
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    };
  },

  setModel: function(model) {
    this.set('model', model);
    this.findRef('message').setContent(model.get('text'));

    var actorModel = model.getActor();
    if (actorModel) {
      this.findRef('profilePicture')
        .setSrc(actorModel.get('pic_big'));
      this.findRef('profilePicLink')
        .setId(actorModel.get('id'))
        .setType(actorModel.get('type'));
      this.findRef('actor')
        .setId(actorModel.get('id'))
        .setType(actorModel.get('type'))
        .setContent(actorModel.get('name'));
    }

    this.findRef('timestamp')
      .setDateTime(model.get('time'));
    if (this._likeErrorListener) {
      this._likeErrorListener.remove();
    }
    this.setBinding(model, [{property: 'likes'}]);
    return this;
  },

  handleLikeLinkClick: function() {
    var model = this.getModel();
    if (!this._likeErrorListener) {
      this._likeErrorListener =
        model.addListener('likeError', this.showError, this);
    }
    model.toggleLike();
  },

  showError: function(evt) {
    var id = dialogUtil.createDialog();
    dialogUtil.appendText(id, evt.message);
    dialogUtil.showModalDialog(id);
  },

  setLikes: function(likes) {
    this.set('likes', likes);
    this.findRef('likeLinkWrapper').toggle(likes.can_like);
    this.findRef('likeLink').setContent(likes.user_likes ? 'Unlike' : 'Like');
    this.findRef('likeCountWrapper').toggle(likes.count);
    this.findRef('likeCount').setContent(likes.count);
  },

  destroy: function() {
    if (this._likeErrorListener) {
      this._likeErrorListener.remove();
    }
    View.prototype.destroy.call(this);
  },

  forwardAction: function(evt) {
    evt.stopPropagation();
    this.invoke(evt.type, evt.data);
  }
});

exports.CommentRow = CommentRow;
});

// module: view/base_list/base_list
// file:   view/base_list/base_list.js
define("view/base_list/base_list", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core  = require('bolt/core');
var View = require('bolt_touch/view').View;

var bindOnce = require('shared/util/bind_once').bindOnce;


exports.BaseList = core.createClass({
  name: 'BaseList',

  extend: View,

  _downloading: false,
  _downloads: 0,
  _fetching: false,
  _ready: false,

  properties: {
    collection: null,
    refreshMessage: 'Refreshing',
    fetchSize: 50,
    downloadSize: 50,
    refreshMinimalInterval: 10000,
    refreshInterval: null,
    autoRefresh: false
  },

  setCollection: function(collection) {
    this.set('collection', collection);

    this._addRelationships(this.getCollection())
      .addCallback(function(listCollection) {
        // wait for relationship to load before displaying the data
        this.findRef('dataList').setData(listCollection);
        (this.findRef('scrollView') || this)
          .addListener('scroll', this._onscroll, this);
        this._ready = true;
        if (this.getAutoRefresh()) {
          this.setRefreshInterval(this.getRefreshMinimalInterval());
        }

        if (!collection.length) {
          // download right away only if local data is empty
          this.refreshRemote();
        } else {
          // otherwise wait for at least 500 ms to allow all the data for
          // inital rendering to be fetched
          this.refresher = setTimeout(
            bindOnce(this.refreshRemote, this),
            500);
        }
        this._onscroll();
        this._dataIsDisplayed();
      }, this);
  },

  _dataIsDisplayed: function() {},

  refreshRemote: function() {
    if (this.isDestroyed) {
      return;
    }
    var delay = new Date() - this.getLastDownloadTime();
    if (this._ready && !this._downloading &&
        delay > this.getRefreshMinimalInterval()) {
      this._refreshRemote();
    }
    if (this.getAutoRefresh()) {
      this.setRefreshInterval(Math.round(this.getRefreshInterval() * 5 / 4));
      if (this.getRefreshInterval() > this.getRefreshMinimalInterval() * 5) {
        this.setRefreshInterval(this.getRefreshMinimalInterval() * 5);
      }
      this.refresher = setTimeout(
        bindOnce(this.refreshRemote, this),
        this.getRefreshInterval());
    }
  },

  minimizeRefreshInterval: function() {
    this.setRefreshInterval(this.getRefreshMinimalInterval());
    if (this.refresher) {
      clearTimeout(this.refresher);
    }
    this.refresher = setTimeout(
      bindOnce(this.refreshRemote, this),
      this.getRefreshInterval());
  },

  getLastDownloadTime: function() {
    var localStorage = window.localStorage || {};
    return localStorage[this._lastDownloadTimeKey()] * 1 || 0;
  },

  setLastDownloadTime: function(value) {
    var localStorage = window.localStorage || {};
    localStorage[this._lastDownloadTimeKey()] = value;
  },

  _lastDownloadTimeKey: function() {
    return 'last_download_time.';
  },

  _addRelationships: function(collection) {
    // abstract
  },

  _refreshRemote: function() {
    // abstract
  },

  _onscroll: function() {
    if (this.getScrollTop() < 100 &&
      this.findRef('dataList').getNode().offsetHeight > 0) {
      this.tryLoadingMore();
    }
  },

  _afterDownload: function() {
    this._downloads++;
    this.setLastDownloadTime(+ new Date());
    setTimeout(bindOnce(this._clearDownloading, this), 500);
  },

  _clearDownloading: function() {
    if (!this.isDestroyed) {
      this._downloading = false;
      this.findRef('loading').hide();
      this._onscroll();
    }
  },

  _afterFetch: function() {
    setTimeout(bindOnce(this._clearFetching, this), 500);
  },

  _clearFetching: function() {
    if (!this.isDestroyed) {
      this._fetching = false;
      this._onscroll();
    }
  },

  _hasRemoteAfter: function() {
    if (this._downloads && !this.getCollection().length) {
      return false;
    }
    return this.getCollection().hasRemoteAfter();
  },

  tryLoadingMore: function() {
    var collection = this.getCollection();
    // try to fetch
    if (this._fetching) {
      return;
    }
    if (collection.getHasMore()) {
      this._fetching = true;
      collection.fetchMore(this.getFetchSize())
        .addCallback(this._afterFetch, this);
      return;
    }

    // try to download
    if (this._downloading) {
      return;
    }
    if (this._hasRemoteAfter()) {
      this._downloading = true;
      this.findRef('loading').show();
      collection.downloadAfter(this.getDownloadSize())
        .addCompleteCallback(this._afterDownload, this);
      return;
    }
  },

  destroy: function() {
    View.prototype.destroy.call(this);
    if (this.getCollection()) {
      this.getCollection().destroy();
      this.set('collection', null);
    }
  }

});
});

// module: shared/shadowbroker/broker/transport
// file:   ../../shared/js/shadowbroker/broker/transport.js
define("shared/shadowbroker/broker/transport", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var Collection = require('bolt/collection').Collection;
var Channel    = require('./channel').Channel;

var MESSAGE_TYPE  = 0;

var TYPE_REQUEST         = 1;
var TYPE_MESSAGE         = 2;
var TYPE_RESPONSE        = 3;
var TYPE_CHANNEL_MESSAGE = 4;



function encodeArgs(args) {
  var result = new Array(args.length);
  for (var i = 0, l = args.length, arg; i < l; i++) {
    arg = args[i];

    if (arg instanceof Channel) {
      result[i] = { d: arg.getInitialData(), i: arg.getId(), _e: 1 };
    } else if (arg && arg._e) {
      result[i] = { d: arg, _e: 1 };
    } else {
      result[i] = arg;
    }
  }
  return result;
}

function decodeArgs(args) {
  if (!args.length) {
    return args;
  }

  var result = new Array(args.length);
  for (var i = 0, l = args.length, arg; i < l; i++) {
    arg = args[i];
    if (arg && arg._e) {
      if (arg.i) {
        result[i] = new Channel(arg.i, arg.d);
      } else {
        result[i] = arg.d;
      }
    } else {
      result[i] = arg;
    }
  }
  return result;
}


// cache and reuse response, request, and channel message objects
var REQUEST_ID     = 1;
var REQUEST_OBJECT = 2;
var REQUEST_METHOD = 3;
var REQUEST_ARGS   = 4;
var requestMessage = new Array(REQUEST_ARGS + 1);
requestMessage[MESSAGE_TYPE] = TYPE_REQUEST;
var requestData    = {
  messageType: TYPE_REQUEST,
  requestId: '',
  object: '',
  method: '',
  args: []
};

function encodeRequest(id, objectName, methodName, args) {
  requestMessage[REQUEST_ID]     = id;
  requestMessage[REQUEST_OBJECT] = objectName;
  requestMessage[REQUEST_METHOD] = methodName;
  requestMessage[REQUEST_ARGS]   = encodeArgs(args);
  return requestMessage;
}

function decodeRequest(data) {
  requestData.requestId = data[REQUEST_ID];
  requestData.object    = data[REQUEST_OBJECT];
  requestData.method    = data[REQUEST_METHOD];
  requestData.args      = decodeArgs(data[REQUEST_ARGS]);
  return requestData;
}



var MESSAGE_OBJECT = 1;
var MESSAGE_METHOD = 2;
var MESSAGE_ARGS   = 3;
var messageMessage = new Array(MESSAGE_ARGS + 1);
messageMessage[MESSAGE_TYPE] = TYPE_MESSAGE;
var messageData    = {
  messageType: TYPE_MESSAGE,
  object: '',
  method: '',
  args: []
};

function encodeMessage(objectName, methodName, args) {
  messageMessage[MESSAGE_OBJECT] = objectName;
  messageMessage[MESSAGE_METHOD] = methodName;
  messageMessage[MESSAGE_ARGS]   = encodeArgs(args);
  return messageMessage;
}

function decodeMessage(data) {
  messageData.object = data[MESSAGE_OBJECT];
  messageData.method = data[MESSAGE_METHOD];
  messageData.args   = decodeArgs(data[MESSAGE_ARGS]);
  return messageData;
}


var RESPONSE_ID     = 1;
var RESPONSE_STATUS = 2;
var RESPONSE_ARGS   = 3;
var responseMessage = new Array(RESPONSE_ARGS + 1);
responseMessage[MESSAGE_TYPE] = TYPE_RESPONSE;
var responseData    = {
  messageType: TYPE_RESPONSE,
  requestId: '',
  status: '',
  args: []
};

function encodeResponse(id, status, args) {
  responseMessage[RESPONSE_ID]     = id;
  responseMessage[RESPONSE_STATUS] = status;
  responseMessage[RESPONSE_ARGS]   = encodeArgs(args);
  return responseMessage;
}

function decodeResponse(data) {
  responseData.requestId = data[RESPONSE_ID];
  responseData.status    = data[RESPONSE_STATUS];
  responseData.args      = decodeArgs(data[RESPONSE_ARGS]);
  return responseData;
}


var CHANNEL_MESSAGE_CHANNEL_ID = 1;
var CHANNEL_MESSAGE_DATA       = 2;
var channelMessage = new Array(CHANNEL_MESSAGE_DATA + 1);
channelMessage[MESSAGE_TYPE] = TYPE_CHANNEL_MESSAGE;
var channelMessageData = {
  messageType: TYPE_CHANNEL_MESSAGE,
  channelId: '',
  data: null
};

function encodeChannelMessage(channelId, data) {
  channelMessage[CHANNEL_MESSAGE_CHANNEL_ID] = channelId;
  channelMessage[CHANNEL_MESSAGE_DATA]       = data;
  return channelMessage;
}

function decodeChannelMessage(data) {
  channelMessageData.channelId = data[CHANNEL_MESSAGE_CHANNEL_ID];
  channelMessageData.data      = data[CHANNEL_MESSAGE_DATA];
  return channelMessageData;
}

// generic decode
function decode(data) {
  var type = data[MESSAGE_TYPE];
  return type == TYPE_REQUEST         ? decodeRequest(data)        :
         type == TYPE_MESSAGE         ? decodeMessage(data)        :
         type == TYPE_RESPONSE        ? decodeResponse(data)       :
         type == TYPE_CHANNEL_MESSAGE ? decodeChannelMessage(data) : null;
}



exports.TYPE_REQUEST         = TYPE_REQUEST;
exports.TYPE_RESPONSE        = TYPE_RESPONSE;
exports.TYPE_MESSAGE         = TYPE_MESSAGE;
exports.TYPE_CHANNEL_MESSAGE = TYPE_CHANNEL_MESSAGE;

exports.encodeRequest        = encodeRequest;
exports.encodeMessage        = encodeMessage;
exports.encodeResponse       = encodeResponse;
exports.encodeChannelMessage = encodeChannelMessage;
exports.decode               = decode;
});

// module: view/attachment_scene/attachment_scene
// file:   view/attachment_scene/attachment_scene.js
define("view/attachment_scene/attachment_scene", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

/*
 * AttachmentScene displays an attachment.
 *
 * TODO:
 * - cache images in MediaStorage (or elsewhere)
 * - make images zoomable
 * - inline video and audio playback
 * - integrate photo carousel
 */

var ActionableView = require('bolt_touch/views/actionable_view').ActionableView;

exports.AttachmentScene = require('bolt/core').createClass({
  name: 'AttachmentScene',
  extend: require('bolt_touch/views/scene').Scene,

  properties: {
    controller: null,
    model: null,
    attachment: null
  },

  declare: function(options) {
    return {
      boxOrientation: 'vertical',
      childViews: [
        {
          // Header
          className: 'bt-bar',
          boxOrientation: 'horizontal',
          childViews: [
            {
              // Back button
              view: ActionableView,
              className: 'bt-bar-button left bt-back-button',
              action: 'onBack'
            },
            {
              // Title
              ref: 'title',
              className: 'bt-bar-title',
              flex: 1,
              content: 'Attachment'
            },
            {
              // Empty button (so title text is centered)
              className: 'bt-bar-button-placeholder'
            }
          ]
        },
        {
          // Body
          boxOrientation: 'vertical',
          className: 'bt-attachment-body',
          flex: 1,
          childViews: [
            {
              // Filename
              ref: 'filename',
              className: 'bt-attachment-filename'
            },
            {
              // Content
              ref: 'content',
              className: 'bt-attachment-content'
            }
          ]
        }
      ]
    };
  },

  setModel: function(model) {
    var result = this.set('model', model);
    if (this._savedAttachment) {
      this.setAttachment(this._savedAttachment);
      delete this._savedAttachment;
    }
    return result;
  },

  setAttachment: function(attachment) {
    // defer setting attachment until model has been set
    if (!this.getModel()) {
      this._savedAttachment = attachment;
      return null;
    }

    var sharedUtil = require('shared/util');

    var filename = this.findRef('filename');

    if (attachment.filename) {
      filename.setContent(attachment.filename);
      filename.show();
    } else {
      filename.hide();
    }
    if (attachment.mime_type) {
      switch (attachment.mime_type.split('/', 1)[0]) {
        case 'image':
          this.handleImageAttachment(attachment);
          break;
        case 'video':
          this.handleVideoAttachment(attachment);
          break;
        case 'audio':
          this.handleAudioAttachment(attachment);
          break;
        // TODO: Add audio attachments support
        default:
          console.warn('Unknown attachment MIME type.');
          break;
      }
    }
    return this.set('attachment', attachment);
  },

  handleImageAttachment: function(attachment) {
    var content = this.findRef('content');
    var url = attachment.local_url || attachment.local_link;
    if (url) {
      this.setImageContent(attachment, url);
    } else {
      this.getModel().getAttachmentData(attachment)
        .addCallback(this.setImageContent, this, attachment);
    }
  },

  setImageContent: function(attachment, url) {
    var content = this.findRef('content');
    content.clearChildren();
    content.appendChild(this.build({
      tagName: 'img',
      className: 'bt-attachment-content--image',
      src: url
    }));
  },

  handleVideoAttachment: function(attachment) {
    var url = attachment.local_url || attachment.local_link;
    if (url) {
      this.setVideoContent(attachment, url);
    } else {
      this.getModel().getAttachmentData(attachment)
        .addCallback(this.setVideoContent, this, attachment);
    }
  },

  setVideoContent: function(attachment, url) {
    var content = this.findRef('content');
    content.clearChildren();
    content.appendChild(this.build({
      tagName: 'video',
      className: 'bt-attachment-content--video',
      controls: 'controls',
      src: url
    }));
  },

  handleAudioAttachment: function(attachment) {
    var url = attachment.local_url || attachment.local_link;
    if (url) {
      this.setAudioContent(attachment, url);
    } else {
      this.getModel().getAttachmentData(attachment)
        .addCallback(this.setAudioContent, this, attachment);
    }
  },

  setAudioContent: function(attachment, url) {
    var content = this.findRef('content');
    content.clearChildren();
    content.appendChild(this.build({
      tagName: 'audio',
      className: 'bt-attachment-content--audio',
      controls: 'controls',
      src: url
    }));
  },

  onBack: function() {
    this.getController().backToThread();
  }
});
});

// module: views/feedback/ufi/comment_list/index
// file:   ../../views/feedback/ufi/comment_list/index.js
define("views/feedback/ufi/comment_list/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var DataList = require('bolt_touch/views/data_list').DataList;
var TouchableView = require('bolt_touch/views/touchable_view').TouchableView;
var CommentRow = require('../comment_row').CommentRow;
var UfiClient = require('ufi/client').getInstance();
var DeferredList = require('shared/deferred').DeferredList;
var bindOnce = require('shared/util/bind_once').bindOnce;

var UfiCommentList = core.createClass({

  name: 'UfiCommentList',

  extend: View,

  properties: {
    target: null,
    collection: null,
    loading: false
  },

  statics: {
    FETCH_SIZE: 30,
    DOWNLOAD_SIZE: 30
  },

  delegateProperties: {
    dataList: ['scrollableParent']
  },

  declare: function(options) {
    var _this = this;
    return {
      loading: false,
      childViews: [
        {
          view: TouchableView,
          boxOrientation: 'veritcal',
          className: 'bt-ufi-row bt-ufi-comment-list--loading',
          onclick: 'handleLoadingClick',
          ref: 'loading'
        },
        {
          view: DataList,
          ref: 'dataList',
          reverse: true,
          manageSelection: false,
          createView: function(comment) {
            var view = new CommentRow({
              onaction: 'forwardAction',
              owner: _this
            });
            this.updateView(view, comment);
            return view;
          },
          updateView: function(view, comment) {
            view.setModel(comment);
          },
          animateChanges: true
        }
      ]
    };
  },

  setTarget: function(target) {
    this.set('target', target);
    UfiClient
      .fetchCommentCollection(target)
      .addCallback(this.setCollection, this);
  },

  setCollection: function(collection) {
    if (this.isDestroyed) {
      return;
    }
    this.set('collection', collection);
    var dataList = this.findRef('dataList');
    if (collection.length === 0) {
      dataList.setStyle('opacity', 0);
    }
    dataList.setData(collection);
    // TODO: Eliminate gaps in CommentStore
    collection
      .downloadHead(UfiCommentList.DOWNLOAD_SIZE)
      .addCallback(this._afterDownload, this);
    this.setLoading(true);
    this.refreshLoadingView();
  },

  /**
   * This toggles the loading view based on whether or not there are more
   * comments to load. This should be called on all updates.
   */
  refreshLoadingView: function() {
    var collection = this.getCollection();
    var target = this.getTarget();
    this.findRef('loading')
      .toggle(target && target.get('comments').count > 0 &&
        (collection.hasMore() || collection.hasRemoteAfter()));
  },

  /**
   * Sets the loading view state between a clickable area to load more comments
   * and displaying that comments are being loaded in.
   */
  setLoading: function(loading) {
    var prevLoadingValue = this.getLoading();

    this.set('loading', loading);
    var loadingView = this.findRef('loading');
    var target = this.getTarget();
    loadingView.setIsDisplayed(target && target.get('comments').count > 0);
    if (loading) {
      loadingView.setContent('Loading...');
    } else {
      loadingView.setContent('View previous comments...');
    }

    if (prevLoadingValue && !loading) {
      this.findRef('dataList').setStyle('opacity', 1);
    }
  },

  handleLoadingClick: function() {
    var collection = this.getCollection();
    if (!collection) {
      return;
    }
    // try to fetch
    if (this._fetching) {
      return;
    }
    if (collection.hasMore()) {
      this._fetching = true;
      collection.fetchMore(UfiCommentList.FETCH_SIZE)
        .addCallback(this._afterFetch, this);
      return;
    }

    // try to download
    if (this._downloading) {
      return;
    }
    if (collection.hasRemoteAfter()) {
      this._downloading = true;
      collection.downloadAfter(UfiCommentList.DOWNLOAD_SIZE)
        .addCompleteCallback(this._afterDownload, this);
      return;
    }
  },

  _afterDownload: function() {
    setTimeout(bindOnce(this._clearDownloading, this), 500);
  },

  _clearDownloading: function() {
    if (!this.isDestroyed) {
      this._downloading = false;
      this.setLoading(false);
      this.refreshLoadingView();
    }
  },

  _afterFetch: function() {
    setTimeout(bindOnce(this._clearFetching, this), 500);
  },

  _clearFetching: function() {
    if (!this.isDestroyed) {
      this._fetching = false;
      this.setLoading(false);
      this.refreshLoadingView();
    }
  },

  destroy: function() {
    View.prototype.destroy.call(this);
    if (this.getCollection()) {
      this.getCollection().destroy();
      this.set('collection', null);
    }
  },

  forwardAction: function(evt) {
    evt.stopPropagation();
    this.invoke(evt.type, evt.data);
  }
});

exports.UfiCommentList = UfiCommentList;
});

// module: views/picker/photo_picker/photo_picker
// file:   ../../views/picker/photo_picker/photo_picker.js
define("views/picker/photo_picker/photo_picker", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

/** The photo_picker app provides a shared photoPicker that can be used by
 * any app for selecting photos.

 * Include the photo picker in any app by including its js and css pkg
 * files in the apps index.html. Alternatively, add its js and css folders
 * to your app's package.json to directly add the code to your compiled
 * pkg files.
 *
 * Then to use the photoPicker call:
 *
 * var photoPicker = require('photo_picker').photoPicker;
 * photoPicker.show(callbackToInvokeWhenphotoSelected);
 *
 * The photoPicker will call the above callback with an array of photo models.
 * If the user cancels the photo-picker or does not select a photo,
 * callback will be called with "null".
 *
 * You can access attributes of this photo with get()
 * i.e. photo.get('thumb')
 */

var core                   = require('bolt/core');
var View                   = require('bolt_touch/view').View;
var ActionSheet            =
  require('bolt_touch/views/action_sheet').ActionSheet;
var util                   = require('bolt/util');

var AlbumPickerController  =
  require('views/picker/album_picker/album_picker_controller')
    .AlbumPickerController;

var CameraPickerController =
  require('views/picker/camera_picker/camera_picker_controller')
    .CameraPickerController;

var SceneStack             =
  require('bolt_touch/views/scene_stack').SceneStack;

var PhotoPicker = exports.PhotoPicker = core.createClass({

  name: 'PhotoPicker',

  extend: View,

  declare: function(options) {
    return {
      childViews: [
        //this view exists behind the actionsheet.
        //It prevents the user from interacting with the app
        //while the photo-picker is active.
        //
        //If the user clicks outside the actionsheet, the photo_picker will
        //quit.
        {
          ref: 'cancel-on-click-view',
          additionalClasses: 'cancel-on-click-view'
        },
        {
          view: 'ActionSheet',
          ref: 'actionSheet',
          actions: [
            {
              action: 'onAlbum',
              additionalClasses: 'bt-on-album',
              value: 'Choose From Albums'
            },
            {
              action: 'onCamera',
              additionalClasses: 'bt-on-camera',
              value: 'Take Photo'
            },
            {
              additionalClasses: 'bt-cancel',
              value: 'Cancel',
              action: 'onCancel'
            }
          ]
        }
      ]
    };
  },

  ready: function() {
    console.log('Construct photo picker');
    this.actionSheet = this.findRef('actionSheet');
    this.cancelOnClickView = this.findRef('cancel-on-click-view');

    this._onMediaReturnHandler = util.bind(
      this._onMediaReturn,
      this
    );

    this._albumPickerController = new AlbumPickerController({
      callback: this._onMediaReturnHandler
    });

    this._cameraPickerController = new CameraPickerController({
      callback: this._onMediaReturnHandler
    });
  },

  onAlbum: function() {
    this.appendChild(this.build({
      ref: 'stack',
      view: SceneStack,
      additionalClasses: 'photo-picker-scene-stack',
      hideInactiveScene: true
    }, this));

    this._albumPickerController.setSceneStack(this.refs.stack);
    this._albumPickerController.startPicker();
  },

  onCamera: function() {
    this.appendChild(this.build({
      ref: 'stack',
      view: SceneStack,
      additionalClasses: 'camera-picker-scene-stack',
      hideInactiveScene: true,
      disableHeaders: true
    }, this));

    this._cameraPickerController.setSceneStack(this.refs.stack);
    this._cameraPickerController.startPicker();
  },

  onCancel: function() {
    this.callback(null);
    this.cancelOnClickView.hide();
  },

  show: function(callback, actionSheetHeight) {
    this.callback = callback;
    this.actionSheet.show();
    if (typeof actionSheetHeight != 'undefined') {
      this.actionSheet.setStyle({
        'height': actionSheetHeight + 'px',
        'bottom': - (actionSheetHeight + 1) + 'px'
      });
      //calculate margin-top to vertical-center the buttons in the actionsheet
      var actionContainerMarginTop =
        (actionSheetHeight - 26 -
          this.actionSheet.findRef('actionContainer').getNode()
            .offsetHeight) / 2;
      this.actionSheet.findRef('actionContainer').setStyle('margin-top', actionContainerMarginTop + 'px');
    }
    this.cancelOnClickView.show();
  },

  hide: function() {
    this.callback = null;
    this.actionSheet.hide();
    this.cancelOnClickView.hide();
  },

  _onMediaReturn: function(result) {
    if (this.refs.stack) {
      this.removeChild(this.refs.stack);
    }

    this.callback(result);
    this.cancelOnClickView.hide();
  }
});

//automatically places the photoPicker in the document.body in a hidden state
//when this js file is included.
var photoPicker = exports.photoPicker = new PhotoPicker();
photoPicker.placeIn(document.body);
});

// module: bolt_touch/views/data_list/view_manager
// file:   ../../../frameworks/bolt_touch/lib/views/data_list/view_manager.js
define("bolt_touch/views/data_list/view_manager", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var View = require('bolt/view').View;

var ViewPool = require('./view_pool').ViewPool;

/**
 * @class ViewManager
 * @classdesc ViewManager uses ViewPool to enforce reuse of Views. See Flyweight
 * pattern for more info. ViewManager is used by DataList to manage individual
 * row Views.
 *
 * Generally you need to extend 'createView', 'updateView' and 'getReusableType'
 * to create your custom views. See 'getReusableType' for more info on creating
 * different types of views through the same ViewManager.
 *
 * If you need to clean your views after they are removed from the DataList and
 * before being reused, extend 'cleanView'.
 *
 * @example
 *
 *   var manager = new ViewManager({
 *     createView: function(model) {
 *       return new CustomView({ model: model });
 *     },
 *
 *     updateView: function(view, model) {
 *       view.setModel(model);
 *     },
 *
 *     cleanView: function(view) {
 *       view.cleanUp();
 *     }
 *   });
 *
 *
 *   var v1 = manager.acquire(new Model());
 *   var v2 = manager.acquire(new Model());
 *   var v3 = manager.acquire(new Model());
 *   var v4 = manager.acquire(new Model());
 *
 *   manager.release(v2);
 *   manager.release(v3);
 *
 *   // v5 will be the same view as v2 or v3
 *   var v5 = manager.acquire(new Model());
 *
 * @example
 *
 *   var manager = new ViewManager({
 *     getReusableType: function(object) {
 *       return object.type == 'header' ? 'Header' : 'Row';
 *     },
 *
 *     createHeader: function(object) {
 *       return new Header({content: object.text });
 *     },
 *     updateHeader: function(view, object) {
 *       view.setContent(object.text);
 *     },
 *
 *     createRow: function(object) {
 *       return new Row({ model: object });
 *     },
 *     updateRow: function(view, object) {
 *       view.setModel(object);
 *     }
 *   });
 *
 */
var ViewManager = core.createClass({

  name: 'DataListViewManager',

  construct: function(options) {
    if (options.createView && !options.updateView) {
      this.getReusableType = function() {
        return false;
      };
    }
    this._options = options;
    this._viewPool = new ViewPool();
  },

  acquire: function(object) {
    var reusableType = this.getReusableType(object);
    var view;
    if (reusableType) {

      view = this._viewPool.acquire(reusableType, object && object.id);
      if (view) {
        this.updateView(view, object, reusableType);
      } else {
        view = this.createView(object, reusableType);
        this._viewPool.hold(view, reusableType, object && object.id);
      }
      return view;
    } else {
      return this.createView(object, reusableType);
    }
  },

  fetch: function(object) {
    return this._viewPool.fetch(object && object.id);
  },

  release: function(view) {
    var options = this._options;
    var reusableType = this._viewPool.release(view);
    var method = 'clean' + reusableType;
    if (options[method]) {
      return options[method](view, reusableType);
    }
    if (options.cleanView) {
      return options.cleanView(view, reusableType);
    }
  },

  createView: function(object, reusableType) {
    var options = this._options;
    var method = 'create' + reusableType;
    if (options[method]) {
      return options[method](object, reusableType);
    }
    if (options.createView) {
      return options.createView(object, reusableType);
    }
    return new View({ content: object });
  },

  updateView: function(view, object, reusableType) {
    var options = this._options;
    var method = 'update' + reusableType;
    if (options[method]) {
      options[method](view, object, reusableType);
      return;
    }
    if (options.updateView) {
      options.updateView(view, object, reusableType);
      return;
    }
    view.setContent(object);
  },

  /**
   * By default all views share the same type an can be reused
   * Override (see view_data_list options) to return the correct type for
   * different types of object. If views cannot be reused return a falsy value.
   *
   * @example
   *
   *   // Views are not reused. New view is created whenever a row is rendered
   *   new DataList({
   *     getReusableType: function() {
   *       return false;
   *     }
   *   });
   *
   *   // create reusable headers for objects with header
   *   new DataList({
   *     getReusableType: function(object) {
   *       return object.header ? 'HeaderView' : 'View';
   *     },
   *
   *     createView: function(object, type) {
   *       if (type === 'HeaderView') return new HeaderView(object.header);
   *       return new View(object);
   *     }
   *   })
   *
   *
   * @return {String}
   */
  getReusableType: function(object) {
    var options = this._options;
    if (options.getReusableType) {
      return options.getReusableType(object);
    }
    return 'View';
  },

  destroy: function() {
    this._viewPool.destroy();
    this._options = null;
  }
});


exports.ViewManager = ViewManager;
});

// module: views/menu_search_list/index
// file:   ../../views/menu_search_list/index.js
define("views/menu_search_list/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var CollectionView = require('bolt/collection_view').CollectionView;
var BackgroundImage =
  require('bolt_touch/views/background_image').BackgroundImage;
var ScrollView = require('bolt_touch/views/scroll_view').ScrollView;
var Actionable = require('bolt_touch/mixins/actionable').Actionable;

var baseClass = 'bt-menu-search-list--';

/**
 * @classdesc A single row contained in a MenuSearchList.  It contains an image
 *            to the left and a label on the right.
 */
var MenuSearchListTagRow = exports.MenuSearchListTagRow = core.createClass({
  name: 'MenuSearchListTagRow',
  extend: View,

  mixins: [Actionable],

  delegateProperties: {
    image: [{alias: 'image', name: 'src'}],
    label: [{alias: 'label', name: 'content'}]
  },

  declare: function() {
    return {
      boxOrientation: 'horizontal',

      childViews: [
        {
          ref: 'image',
          className: baseClass + 'image',
          view: BackgroundImage
        },
        {
          ref: 'label',
          className: baseClass + 'label',
          flex: 1
        }
      ]
    };
  }
});

/**
 * @classdesc A CollectionView that displays a list of MenuSearchListTagRow
 *            views.  It expects its owner to have the functions
 *            getImageFromModel and getImageFromModel.
 */
var TagCollectionView = core.createClass({
  name: 'TagCollectionView',

  extend: CollectionView,

  viewForModel: function(model) {
    var owner = this.getOwner();
    return new MenuSearchListTagRow({
      image: owner.getImageFromModel(model),
      label: owner.getLabelFromModel(model),
      model: model,
      owner: owner,
      action: 'handleSelect'
    });
  }
});

/**
 * @classdesc A view that contains a search box at the top and a list of search
 *            results below.  It expects to be given a delegate with the
 *            functions:
 *            - menuSearchListUpdate: passed two parameters, a reference to
 *              the MenuSearchList and the current search term.  This function
 *              should update the Collection that was passed to the
 *              MenuSearchList view
 *
 *            If no delegate is provided, the view Owner is the delegate.
 */
exports.MenuSearchList = core.createClass({
  name: 'MenuSearchList',

  extend: View,

  events: ['select'],

  delegateProperties: {
    /**
     * @property collection {Collection} the collection containing the models
     *             which is populated by the delegate/owner
     */
    collectionView: ['collection']
  },

  properties: {
    /**
     * @property delegate {Object} The delegate which contains the required
     *   functions for fetching data
     */
    delegate: null,

    /**
     * @property imageProperty {String} The name of the property to retrieve
     *   from each model which defines the image to place to the left of each
     *   row
     */
    imageProperty: null,

    /**
     * @property labelProperty {String} The name of the property to retrieve
     *   from each model which defines the label to place to the right of each
     *   row
     */
    labelProperty: null
  },

  declare: function(options) {
    return {
      boxOrientation: 'vertical',

      childViews: [
        {
          className: baseClass + 'input-wrapper',

          childViews: [
            {
              tagName: 'input',
              className: baseClass + 'input',
              ref: 'searchInput',
              placeholder: options.placeholder || '',
              onkeyup: 'update',
              onfocus: 'handleFocus',
              onblur: 'handleBlur'
            }
          ]
        },
        {
          ref: 'scroller',
          view: ScrollView,
          flex: 1,
          childViews: [
            {
              ref: 'collectionView',
              view: TagCollectionView,
              boxOrientation: 'vertical'
            }
          ]
        }
      ]
    };
  },

  getImageFromModel: function(model) {
    return model.get(this.getImageProperty());
  },

  getLabelFromModel: function(model) {
    return model.get(this.getLabelProperty());
  },

  onDocumentInsertion: function() {
    if (!this.getDelegate()) {
      // Default the delegate to the owner
      this.setDelegate(this.getOwner());
    }

    this.update();
  },

  /**
   * Focus the search input
   */
  focus: function() {
    this.findRef('searchInput').getNode().focus();
  },

  handleFocus: function() {
    this.addClass('focused');
  },

  handleBlur: function() {
    this.removeClass('focused');
  },

  /**
   * Update the delegate with the search term
   */
  update: function() {
    var searchTerm = this.findRef('searchInput').getNode().value;

    // Perform the search.  This should update the collection which is being
    // used to populate the contained CollectionView
    this.getDelegate().menuSearchListUpdate(this, searchTerm);

    this.findRef('scroller').refresh();
    this.findRef('scroller').scrollTo(0, 0);
  },

  handleSelect: function(view) {
    this.invoke('select', {
      model: view.getModel()
    });
  }
});
});

// module: photos/app/lib/model/photo/photo_remote_mapper
// file:   ../../photos/app/lib/model/photo/photo_remote_mapper.js
define("photos/app/lib/model/photo/photo_remote_mapper", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core         = require('bolt/core');
var util         = require('bolt/util');
var apixhr       = require('shared/api_xhr');
var Deferred     = require('shared/deferred').Deferred;
var DeferredList = require('shared/deferred').DeferredList;
var RemoteMapper = require('shared/data2/remote/remote_mapper').RemoteMapper;
var Constants    = require('../../controller/constants');

exports.PhotoRemoteMapper = core.createClass({
  name: 'PhotoRemoteMapper',

  extend: RemoteMapper,

  properties: {
    tableName: 'photo'
  },

  download: function(filter, limit, _orderingWhere) {
    var deferred = new Deferred();

    var deferredList = new DeferredList();

    if (filter._filter.album_id !== Constants.UNPUBLISHED_ALBUM_ID) {
      deferredList.waitFor(this._downloadPhotos(filter, limit, _orderingWhere));
    }
    else {
      deferredList.waitFor((new Deferred).succeed(null));
    }

    if (!filter._filter.album_id || filter._filter.album_id === Constants.UNPUBLISHED_ALBUM_ID) {
      deferredList.waitFor(
        this._downloadUnpublishedPhotos(filter, limit, _orderingWhere));
    }
    else {
      deferredList.waitFor((new Deferred).succeed(null));
    }

    deferredList.addCallback(function(status, photoArguments, unpublishedPhotoArguments) {
      var photos = photoArguments[1];
      var unpublishedPhotos = unpublishedPhotoArguments[1];

      if (photos) {
        if (unpublishedPhotos) {
          photos = photos.concat(unpublishedPhotos);
        }
      }
      else {
        photos = unpublishedPhotos;
      }

      deferred.succeed(photos);
    });

    deferredList.startWaiting();

    return deferred;
  },

  _downloadPhotos: function(filter, limit, _orderingWhere) {
    var deferred = new Deferred();

    // TODO: Is there a limit to how many tags you can have?
    var queries = {
      query1: this.getFqlQuery(filter, limit, _orderingWhere),
      query2: 'SELECT object_id, pid, subject, text, ycoord, xcoord ' +
              'FROM photo_tag WHERE pid IN (SELECT pid FROM #query1)',
      query3: 'SELECT photo_id, src ' +
              'FROM photo_src WHERE size="180x540" ' +
              'AND photo_id IN (SELECT object_id FROM #query1)'
    };

    var params = {
      method: 'fql.multiquery',
      queries: queries
    };

    this._apiRequester.rest(params, true).then(function(data) {
      if (data.error_msg) {
        throw new Error('Error Message: ' + data.error_msg +
          'and error Code: ' + data.error_code + ' for request: ' +
          JSON.stringify(params));
      }

      var models = [];
      var modelsById = [];
      var photos = data[0].fql_result_set;
      for (var i = 0, l = photos.length; i < l; i++) {
        var model = this.remoteToModel(photos[i]);
        model.set('tags', []);
        models.push(model);
        modelsById[model.get('fbid')] = model;
      }

      var photoTags = data[1].fql_result_set;
      for (i = 0, l = photoTags.length; i < l; i++) {
        var photoTag = photoTags[i];
        delete photoTag.id;
        modelsById[photoTag.object_id].get('tags').push(photoTag);
      }

      var photoSources = data[2].fql_result_set;
      var photoSource;
      for (i = 0, l = photoSources.length; i < l; i++) {
        photoSource = photoSources[i];
        modelsById[photoSource.photo_id].set('thumbnail_url', photoSource.src);
      }

      deferred.succeed(models);

      return deferred;
    }, this);

    return deferred;
  },

  _downloadUnpublishedPhotos: function(filter, limit, _orderingWhere) {
    var deferred = new Deferred();

    var query2 = 'SELECT ' + this.getRemoteColumns().join(',') +
      ' FROM photo WHERE object_id IN (SELECT object_id FROM #query1) ';
    if (_orderingWhere) {
      query2 +=  ' AND ' + _orderingWhere;
    }
    query2 += ' ORDER BY position DESC LIMIT ' + limit;

    var queries = {
      query1: 'SELECT object_id FROM photo_unpublished WHERE id=me()',
      query2: query2,
      query3: 'SELECT photo_id, src ' +
              'FROM photo_src WHERE size="180x540" ' +
              'AND photo_id IN (SELECT object_id FROM #query2)'
    };

    var params = {
      method: 'fql.multiquery',
      queries: queries
    };

    this._apiRequester.rest(params, true).then(function(data) {
      if (data.error_msg) {
        throw new Error('Error Message: ' + data.error_msg +
          'and error Code: ' + data.error_code + ' for request: ' +
          JSON.stringify(params));
      }

      var models = [];
      var modelsById = [];
      var photos = data[1].fql_result_set;
      for (var i = 0, l = photos.length; i < l; i++) {
        var model = this.remoteToModel(photos[i]);
        model.set('tags', []);
        model.set('album_id', Constants.UNPUBLISHED_ALBUM_ID);
        models.push(model);
        modelsById[model.get('fbid')] = model;
      }

      var photoSources = data[2].fql_result_set;
      var photoSource;
      for (i = 0, l = photoSources.length; i < l; i++) {
        photoSource = photoSources[i];

        modelsById[photoSource.photo_id].set('thumbnail_url', photoSource.src);
      }

      deferred.succeed(models);

      return deferred;
    }, this);

    return deferred;
  }
});
});

// module: views/feedback/bar/index
// file:   ../../views/feedback/bar/index.js
define("views/feedback/bar/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var View = require('bolt_touch/view').View;
var ActionableView = require('bolt_touch/views/actionable_view').ActionableView;

var LikeButton = require('../../feedback/buttons/like_button').LikeButton;
var CommentButton =
  require('../../feedback/buttons/comment_button').CommentButton;

var dialogUtil = require('shared/dialogs');

/**
 * @class FeedbackBar
 * @classdesc The UFI bar under every story row.
 */
var FeedbackBar = core.createClass({

  name: 'FeedbackBar',

  extend: View,

  properties: {
    /**
     *@property {boolean} isPermalink true if this is a story rendered in a
     * permalink, false if this is a story rendered in a stream.
     */
    isPermalink: null,
    hasFeedback: null,
    /**
     * @property overlay {boolean} If true, the view will be stylized to stand
     * out better over an image. If false, it will look better over white.
     */
    overlay: false
  },

  declare: function() {
    return {
      // TODO: Make it so Actionable doesn't always call the owner
      childViews: [
        {
          view: ActionableView,
          boxOrientation: 'horizontal',
          className: 'bt-feedback-bar--bar',
          action: 'feedbackTargetClick',
          ref: 'bar',
          childViews: [
            {
              boxOrientation: 'horizontal',
              ref: 'feedbackLinks',
              className: 'bt-feedback-bar--feedback-links',
              childViews: [
                {
                  view: LikeButton,
                  action: 'likeButtonPressed',
                  className: 'bt-feedback-bar--like-button',
                  ref: 'likeButton'
                },
                {
                  flex: 1 // spacer
                },
                {
                  view: CommentButton,
                  action: 'commentButtonPressed',
                  className: 'bt-feedback-bar--comment-button',
                  ref: 'commentButton'
                }
              ]
            },
            {
              flex: 1 // spacer
            },
            {
              className: 'bt-feedback-bar--like-count',
              ref: 'likeCount'
            },
            {
              className: 'bt-feedback-bar--comment-count',
              ref: 'commentCount'
            }
          ]
        }
      ]
    };
  },

  setBinding: function(options) {
    if (this._likeErrorListener) {
      this._likeErrorListener.remove();
    }
    this.findRef('likeButton').setBinding({
      model: options.model,
      options: [{property: 'likes'}]
    });
    View.prototype.setBinding.call(this, options);
  },

  setIsPermalink: function(isPermalink) {
    this.set('isPermalink', isPermalink);
    this.findRef('bar')
      .toggleClass('bt-feedback-bar--bar_is-permalink', isPermalink)
      .setIsTouchable(!isPermalink);
    this.findRef('likeCount').toggle(!isPermalink);
    this.findRef('commentCount').toggle(!isPermalink);
    return this;
  },

  setOverlay: function(overlay) {
    this.set('overlay', overlay);
    this.setMode('overlay', overlay);
    this.refs.likeButton.setOverlay(overlay);
    this.refs.commentButton.setOverlay(overlay);
  },

  likeButtonPressed: function() {
    var model = this.getModel();
    if (!this._likeErrorListener) {
      this._likeErrorListener =
        model.addListener('likeError', this.showError, this);
    }
    model.toggleLike();
  },

  commentButtonPressed: function() {
    var rect = this.getRect();
    this.invoke('action', {
      type: 'commentButtonPress',
      yCoordinate: rect.top + rect.height / 2
    });
  },

  feedbackTargetClick: function() {
    if (!this.getHasFeedback() || this.getIsPermalink()) {
      return;
    }
    var rect = this.getRect();
    this.invoke('action', {
      type: 'feedbackTargetClick',
      yCoordinate: rect.top + rect.height / 2
    });
  },

  showError: function(evt) {
    var id = dialogUtil.createDialog();
    dialogUtil.appendText(id, evt.message);
    dialogUtil.showModalDialog(id);
  },

  setLikes: function(likes) {
    this.set('likes', likes);
    var likeCount = likes.count;
    this.findRef('likeCount')
      .setContent(likeCount + ' ' + (likeCount > 1 ? 'Likes' : 'Like'));
    this.findRef('likeCount').toggle(likeCount && !this.getIsPermalink());
    this._onFeedbackChange();
  },

  setComments: function(comments) {
    this.set('comments', comments);
    var count = comments.count;
    this.findRef('commentCount')
      .setContent(count + ' ' + (count > 1 ? 'Comments' : 'Comment'));
    this.findRef('commentCount').toggle(count &&
      !this.getIsPermalink());
    this._onFeedbackChange();
  },

  _onFeedbackChange: function() {
    var model = this.getModel();
    var likes = model.get('likes');
    var comments = model.get('comments');
    var canFeedback = likes.can_like && comments.can_post;
    this.findRef('feedbackLinks').toggle(canFeedback);
    this.toggle(canFeedback || likes.count || comments.count);
    this.setHasFeedback(likes.count || comments.count);
  },

  destroy: function() {
    if (this._likeErrorListener) {
      this._likeErrorListener.remove();
    }
    View.prototype.destroy.call(this);
  }
});

exports.FeedbackBar = FeedbackBar;
});

// module: mock/display_api
// file:   ../../mock/js/display_api.js
define("mock/display_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var dom = require('bolt/dom');

// Mock DisplayApi Object used by the Simulator for testing purpose.

/**
 * The mock DisplayApi Object used by the Simulator for testing purpose.
 * @type {Object}
 */
module.exports = {
  MINIMUM_BRIGHTNESS: 10,
  MAXIMUM_BRIGHTNESS: 255,

  _timeout : 60000,

  _isAutoBrightnessEnabled : false,

  _brightness : 100,

  _isKeepAwakeEnabled : false,

  _isAutoBrightnessEnabled : false,

  _lockscreenBackground : '',

  _isShowFpsEnabled : false,

  _isShowDebugBordersEnabled : false,

  /**
   * Sets the length of inactivity before the screen turns off.
   * @param number timeout
   */
  setScreenTimeout : function(timeout) {
    this._timeout = timeout;
  },

  /**
   * @return number The length of inactivity before the screen turns off.
   */
  getScreenTimeout : function() {
    return this._timeout;
  },

  /**
   * @return boolean Whether the auto-brightness management is enabled.
   */
  isAutoBrightnessEnabled : function() {
    return this._isAutoBrightnessEnabled;
  },

  /**
   * Enables/disables auto-brightness management.
   * @param boolean Whether the auto-brightness management should be enabled.
   * @return true if the operation succeeded
   */
  setIsAutoBrightnessEnabled : function(enable) {
    this._isAutoBrightnessEnabled = enable;
    return true;
  },

  /**
   * Toggles auto-brightness management.
   * @return true if the toggle succeeded
   */
  toggleAutoBrightness : function() {
    this._isAutoBrightnessEnabled = !this._isAutoBrightnessEnabled;
    return true;
  },

  /**
   * @return number The brightness.
   */

  getBrightness : function() {
    return this._brightness;
  },

  /**
   * Sets the display's backlight brightness
   * @param number brightness The brightness value.
   */
  setBrightness : function(brightness) {
    brightness = Math.round(brightness);
    brightness = Math.max(10, brightness);
    brightness = Math.min(255, brightness);
    this._brightness = brightness;
    console.log('Brightness changed to ' + this._brightness);
  },

  /**
   * Sets the backlight brightness, but the setting will not persist.
   * Use #setBrightness to set a persistent value
   * @param number brightness The brightness value.
   */
  previewBrightness : function(brightness) {
    // Do nothing.
  },

  /**
   * @return boolean Whether the screen will stay on while charging.
   */
  isKeepAwakeEnabled : function() {
    return this._isKeepAwakeEnabled;
  },

  /**
   * Controls whether or not the screen will always stay on while the phone is
   * plugged in.
   * @param boolean enable Whether to enable this feature.
   * @return boolean True if the operation succeeded.
   */
  setIsKeepAwakeEnabled : function(enable) {
    this._isKeepAwakeEnabled = enable;
    return true;
  },

  /**
   * Toggles keep awake mode.
   * @return boolean True if the toggle succeeded.
   */
  toggleKeepAwake : function() {
    this._isKeepAwakeEnabled = !this._isKeepAwakeEnabled;
    return true;
  },

  /**
   * Gets the URL of the background image
   * @return string The URL of the background image
   */
  getLockscreenBackground : function() {
    return this._lockscreenBackground;
  },

  /**
   * Sets the URL of the background image
   * @param string background the URL of the background image.
   */
  setLockscreenBackground : function(background) {
    this._lockscreenBackground = background;
  },

  /**
   * Determines whether or not the FPS display is visible
   * @return true if the FPS display is enabled
   */
  isShowFpsEnabled : function() {
    return this._isShowFpsEnabled;
  },

  /**
   * Enables/disables FPS display
   * @param boolean True to enable, false to disable.
   */
  setShowFpsEnabled : function(enable) {
    this._isShowFpsEnabled = enable;
  },

  /**
   * Toggles FPS display.
   * @return boolean Whether the toggle succeeded.
   */
  toggleShowFps : function() {
    this._isShowFpsEnabled = !this._isShowFpsEnabled;
    return true;
  },

  /**
   * Determines whether or not the The debug borders is visible.
   * @return boolean Whether the debug borders is visible.
   */
  isShowDebugBordersEnabled : function() {
    return this._isShowDebugBordersEnabled;
  },

  /**
   * Set whether or not the The debug borders is visible.
   * @param boolean Whether to enable this feature.
   */
  setIsShowDebugBordersEnabled : function(enable) {
    this._isShowDebugBordersEnabled = enable;
  },

  /**
   * Toggles debug borders display.
   * @return boolean True if the toggle succeeded.
   */
  toggleShowDebugBorders : function() {
    this._isShowDebugBordersEnabled = !this._isShowDebugBordersEnabled;
    return true;
  },

  // ### Device screen on/off
  turnOnScreen: function() {
    dom.removeClass(document.body, 'screen-off');
    buffyGlitter._sendAndroidBroadcast(
      'android.intent.action.SCREEN_ON');
    buffyGlitter._sendAndroidBroadcast('display.SCREEN_ON');
  },

  turnOffScreen: function() {
    dom.addClass(document.body, 'screen-off');
    buffyGlitter._sendAndroidBroadcast(
      'android.intent.action.SCREEN_OFF');
    buffyGlitter._sendAndroidBroadcast('display.SCREEN_OFF');
  },

  isScreenOn: function() {
    return !dom.hasClass(document.body, 'screen-off');
  }
};
});

// module: bolt/collection_view
// file:   ../../../frameworks/bolt/lib/collection_view.js
define("bolt/collection_view", function(require, exports, module) {
/**
 *
 * Copyright (c) 2011-2012, Facebook, Inc.
 * All rights reserved.
 *
 * @option preserve-header
 *
 */

var util  = require('./util');
var build = require('./builder').build;

var View = require('./view').View;
var Collection = require('./collection').Collection;


var CollectionView = require('./core').createClass({
  name: 'CollectionView',

  extend: View,

  properties: {
    /**
     * backing collection to render this view from
     */
    collection: null,

    /**
     * provides a mapping between a model pulled from a collection
     * and a view. Allows you to pass any configuration to the view
     * that you would normally pass.
     */
    modelViewMapping: {
    },

    /**
     * The default binding configurations options to apply to
     * all bindings
     */
    defaultOptions: null
  },

  construct: function(options) {
    this.itemViews = {};
    this._collectionTokens = [];

    options.collection = options.collection || this.defaultCollection();

    // if a a viewForModel function is passed in override the default
    if (options.viewForModel) {
      this.viewForModel = util.bind(options.viewForModel, this);
      delete options.viewForModel;
    }
    View.call(this, options);
  },

  /**
  * Returns the view that corresponds to the model
  */
  getViewForModel: function(model) {
    return this.itemViews[model.cid];
  },

  /**
   * by default attempt to map from the modelViewMapping to create
   * the appropriate view for a given model
   * this method can also be overridden to generate your own model
   * outside of the mapping
   */
  viewForModel: function(model) {
    return this._viewFromModelMapping(model);
  },

  /**
   * Default collection if a collection view does not specify one.
   * Can be overridden by subclasses.
   */
  defaultCollection: function() {
    return new Collection();
  },

  /**
   * Insert the child view into the CollectionView.
   * This function can be overridden by subclasses to redirect
   * the destination of a created view.
   */
  insertCollectionChild: function(itemView, idx) {
    this.insertChild(itemView, idx);
  },

  /**
   * Remove the child view from the CollectionView.
   * This function can be overridden by subclasses to redirect
   * the destination of a created view.
   */
  removeCollectionChild: function(itemView) {
    this.removeChild(itemView);
  },

  /**
   * received when a model is added to the underlying collection
   */
  onModelAdded: function(model, idx) {
    var itemView = this.viewForModel(model);
    if (itemView.getModel() !== model) {
      itemView.setModel(model);
    }
    this.itemViews[model.cid] = itemView;
    this.insertCollectionChild(itemView, idx);
    var owner = this.getOwner();
    if (owner && owner.collectionViewDidInsertChildView) {
      owner.collectionViewDidInsertChildView(this, itemView, idx);
    }
    return itemView;
  },

  /**
   * received when a model is removed from the underlying collection
   */
  onModelRemoved: function(model, idx) {
    var view = this.itemViews[model.cid];
    if (view) {
      this.removeCollectionChild(view);
      delete this.itemViews[model.cid];
      var owner = this.getOwner();
      if (owner && owner.collectionViewDidRemoveChildView) {
        owner.collectionViewDidRemoveChildView(this, view, idx);
      }
    }
  },

  onUpdated: function() {
    // populate the initial set of models
    this.clearChildren();
    this.getCollection().each(this.onModelAdded, this);
  },

  /**
   * received when a model is changed in the underlying collection
   */
  onModelChanged: function(obj) {
    //TODO:
  },

  /**
   * set the collection that this CollectionView is based on
   * and attach listeners
   */
  setCollection: function(collection) {
    var existingCollection = this.get('collection');
    if (existingCollection) {
      util.invoke(this._collectionTokens, 'remove');
      this._collectionTokens = [];
    }
    this.set('collection', collection);
    this[name] = collection;
    if (collection) {
      var evts = ['modelChanged', 'modelAdded', 'modelRemoved', 'updated'];
      for (var i = 0; i < evts.length; i++) {
        this._collectionTokens.push(
          collection.addListener(evts[i], this._onCollectionEvent, this));
      }
    }
    this.onUpdated();
    return this;
  },

  /**
   * destroy the collection view
   */
  destroy: function() {
    util.invoke(this._collectionTokens, 'remove');
    View.prototype.destroy.call(this);
  },

  /**
   * handle model events and delegate to the appropriate
   * callback based on the type of event
   */
  _onCollectionEvent: function(event) {
    var data = event.data;
    var handlerName = util.eventHandler(event.type);
    if (this[handlerName]) {
      this[handlerName](data.model, data.index);
    }
  },

  /**
   * return a view for a model
   */
  _viewFromModelMapping: function(model) {
    var config = this.getModelViewMapping()[model.klass.klassName];
    if (!config) {
      throw 'received a model without a mapping';
    }
    //TODO: should be able to pass this in directly
    var view = this.build(config);
    view.setBinding({
      model: model,
      options: config.bindingConfig,
      defaultOptions: this.getDefaultOptions()
    });
    return view;
  }
});


exports.CollectionView = CollectionView;
});

// module: place_picker/place_picker
// file:   ../../place_picker/js/place_picker.js
define("place_picker/place_picker", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

// The place_picker app provides a shared placePicker that can be used by
// any app for selecting places.
//
// Include the place picker in any app by including its js and css pkg
// files in the app's index.html.  Then to use the placePicker call:
//
//    var placePicker = require('place_picker').placePicker;
//    placePicker.show(callbackToInvokeWhenPlaceSelected);
//
// Optionally can provide the currently selected place (using pageId)
//
//    placePicker.show(callback, pageIdOfCurrentPlace);

var core              = require('bolt/core');
var util              = require('bolt/util');
var Scene             = require('bolt_touch/views/scene').Scene;
var screen_dims       = require('shared/screen_constants').PHONE_DIMENSION;

var PlacesTable = require('./places_table').PlacesTable;

var PlacePicker = exports.PlacePicker = core.createClass({

  name: 'PlacePicker',

  extend: Scene,

  declare: function(options) {
    options = options || {};
    return {
      additionalClasses: 'bt-hidden',
      boxOrientation: 'vertical',
      height: '100%',
      childViews: [
        {
          additionalClasses: 'bt-bar',
          boxOrientation: 'horizontal',
          childViews: [
            {
              additionalClasses: 'bt-bar-button left bt-down-button',
              onclick: 'goBack'
            },
            {
              additionalClasses: 'bt-bar-title',
              flex: 1,
              content: options.title || 'Nearby Places'
            }
          ]
        },
        {
          ref: 'placeField',
          additionalClasses: 'bt-picker-field',
          boxOrientation: 'horizontal',
          onkeyup: 'onSearchKeyup',
          childViews: [
            {
              ref: 'searchIcon',
              additionalClasses: 'bt-search-button'
            },
            {
              tagName: 'input',
              ref: 'pickerInput',
              flex: 20,
              type: 'text',
              additionalClasses: 'bt-picker-input',
              ontouchstart: 'onPickerInputTouched'
            },
            {
              flex: 1,
              ref: 'cancelButton',
              additionalClasses: 'bt-composer-x-button',
              onclick: 'blur'
            }
          ]
        },
        {
          ref: 'table',
          flex: 1,
          view: 'PlacesTable',
          additionalClasses: 'bt-places-table',
          ontouchmove: 'blur'
        }
      ]
    };
  },

  ready: function() {
    this.table = this.findRef('table');
    this.searchText = this.findRef('pickerInput');
    this.searchIcon = this.findRef('searchIcon');
    this.placeField = this.findRef('placeField');
    this.cancelButton = this.findRef('cancelButton');

    this.searchText.getNode().placeholder = 'Where are you at?';
    this.resetHandler = util.bind(this.table.resetFilterRegex, this.table);
  },

  onSearchKeyup: function(e) {
    this.keyup = this.keyup || util.debounce(util.bind(function(e, lastValue) {
      var text = this.searchText.getNode().value;
      if (text.trim() === '') {
        this.table.resetFilterRegex();
        this.blur();
      } else {
        this.table.setFilterRegex(new RegExp('\\b' + text, 'i'));
      }
    }, this), 100);
    this.keyup(e, e.target.value);
  },

  onPlaceSelect: function(place) {
    this.hide();
    this.callback && this.callback(place);
  },

  /**
    Shows the place picker.
    The callback will return the object selected or null if none.
    A custom overlay can be passed in, otherwise the overlay will display
    the current city.
  */
  show: function(callback, customOverlayText) {
    this.callback = callback;
    this.table.setCallback(util.bind(this.onPlaceSelect, this));

    // See the comments in audience_picker. We can avoid this
    // timeout once we know the exact screen dimension when
    // window manager is instantiated.
    setTimeout(this.resetHandler, 250);
    this.table.show(customOverlayText);

    this.blur();

    this.searchText.getNode().value = '';
    this.setStyle('webkitTransform', null);
  },

  goBack: function() {
    this.hide();
    if (this.callback) {
      if (this.table.getClearPlace()) {
        this.callback(null, true);
      } else {
        this.callback(null);
      }
    }
  },

  hide: function() {
    // TODO: Once we can get exact screen dimension in windowmanager
    // instantiation. Remove the buffer.
    this.setStyle('webkitTransform',
      'translate3d(0,' + screen_dims.height + 'px,0)');
  },

  // TODO: Move all the location related thigns to a separate place.
  getCurrentCity: function(cb) {
    if (this.table.getCity()) {
      cb(this.table.getCity());
    } else {
      this.table.getCurrentCity(cb);
    }
  },

  onPickerInputTouched: function(e) {
    this.focus();
    e.preventDefault();
  },

  focus: function() {
    this.searchIcon.hide();
    this.searchText.getNode().focus();
    this.cancelButton.show();
  },

  blur: function() {
    this._clearPickerInput();
    this.searchIcon.show();
    this.searchText.getNode().blur();
    this.cancelButton.hide();
  },

  _clearPickerInput: function() {
    this.searchText.getNode().value= '';
  }
});

// insert the place picker in the document
// initially in a hidden state
var placePicker = exports.placePicker = new PlacePicker();
placePicker.hide();
placePicker.placeIn(document.body);
});

// module: views/composer/js/composer_textarea
// file:   ../../views/composer/js/composer_textarea.js
define("views/composer/js/composer_textarea", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core               = require('bolt/core');
var util               = require('bolt/util');
var View               = require('bolt_touch/view').View;

var ComposerTextarea = exports.ComposerTextarea = core.createClass({
  name: 'ComposerTextarea',

  extend: View,

  statics: {
    LINE_HEIGHT: 30
  },

  declare: function(options) {
    return {
      childViews: [
        /* There are two layers of elements.
         * The <textarea> on the top is the one that receives
         * keyboard events.
         * The <div> beneath it has exactly the content as the
         * textarea, but with some styled html
         * content trailing it.
         * This way, we could create the effect that
         * there looks to be some styled html
         * content inside a <textarea>
         */
        {
          ref: 'shadow',
          additionalClasses: 'composer-text-shadow',
          childViews: [
            {
              tagName: 'span',
              ref: 'shadowInput'
            },
            {
              tagName: 'span',
              ref: 'shadowStyledContent'
            }
          ]
        },
        {
          tagName: 'textarea',
          additionalClasses: 'composer-text-input',
          ref: 'textarea'
        }
      ]
    };
  },

  ready: function() {
    this._textarea = this.refs.textarea;
    this._shadow = this.refs.shadow;
    this._shadowInput = this.refs.shadowInput;
    this._shadowStyledContent = this.refs.shadowStyledContent;
    this._keys = [];

    this._updateShadowInputHandler = util.bind(this._updateShadowInput, this);

    this._updateScrollTopHandler = util.bind(this._updateScrollTop, this);
    this._timer = null;
    this._lineBuffer = 0;
  },

  setupTimer: function() {
    if (this._timer === null) {
      this._timer = setInterval(this._updateScrollTopHandler, 10);
    }
  },

  cleanShadow: function() {
    this._shadowInput.setContent('');
    this._shadowStyledContent.setContent('');
    this._lineBuffer = 0;
    this._keys = [];
  },

  getInputNode: function() {
    return this._textarea.getNode();
  },

  getInputValue: function() {
    return this._textarea.getNode().value;
  },

  setInputValue: function(value) {
    this._textarea.getNode().value = value;
    this._updateShadowInput(false);
  },

  setStyledContent: function(html) {
    this._shadowStyledContent.setContent(html);
    this._updateShadowInput(false);
  },

  destroy: function() {
    if (this._timer) {
      clearInterval(this._timer);
    }

    View.prototype.destroy.call(this);
  },

  _onKeyup: function(e) {
    var _this = this;
    // Yield so that the new input displays on screen immediately
    this._keyCode = e.keyCode;
    setTimeout(this._updateShadowInputHandler(), 1);
  },

  _updateShadowInput: function(keyUp) {
    // Default keyup to true
    keyUp = keyUp !== undefined ? keyUp : true;

    if (keyUp) {
      var keyCode = this._keyCode;

      var content = '';
      var value = this._textarea.getNode().value;

      // Translate from textarea value to html.
      // TODO: Be aware of localization issues.
      for (var i = 0; i < value.length - this._lineBuffer; i++) {
        var code = value.charCodeAt(i);
        if (code === 10) {
          content += '<br/>';
        } else if (code === 32) {
          content += '&nbsp;';
        } else {
          content += value[i];
        }
      }

      this._shadowInput.setContent(content);
    }

    // Make sure after inserting new content, the scrolltop
    // of the real textarea and the shadowed area have the same
    // scrolltop.
    this._updateScrollTop();

    // The idea is to append some line buffers to the
    // end of the "real" textarea, so that this area could be
    // scrolled down to the same location as the shadow
    // textarea. Meanwhile, make the styled content in the
    // shadow area be on a higher layer, so that the people/
    // places tags are clickable, and the user will not
    // be able to  click on the line buffers. This way we
    // could achieve the desired effect that:
    // 1) The textarea is scrollable.
    // 2) There "looks" to be html element in the textarea.
    this._updateLineBuffer();
  },

  _updateScrollTop: function() {
    this._shadow.getNode().scrollTop =
      this._textarea.getNode().scrollTop;
  },

  _updateLineBuffer: function() {
    var textareaNode = this._textarea.getNode();
    var rows = this._getRowNum(textareaNode.scrollHeight) - this._lineBuffer;

    var shadowRows = this._getRowNum(this._shadow.getNode().scrollHeight);

    var lineBuffer = shadowRows - rows;
    if (lineBuffer != this._lineBuffer) {
      var length = textareaNode.value.length;
      var value = textareaNode.value.substring(0, length - this._lineBuffer);
      for (var i = 0; i < lineBuffer; i++) {
        value += '\n';
      }
      textareaNode.value = value;
      this._lineBuffer = lineBuffer;
    }

    this._updateSelectionPosition();
  },

  // Make sure the cursor does not go into line buffers.
  _updateSelectionPosition: function() {
    var node = this._textarea.getNode();
    var pos = Math.min(
      node.selectionStart,
      node.value.length - this._lineBuffer);

    if (pos !== node.selectionStart) {
      node.selectionStart = node.selectionEnd = pos;
    }
  },

  _getRowNum: function(height) {
    return parseInt(height / ComposerTextarea.LINE_HEIGHT, 10);
  },

  textareaKeyup: function(evt) {
    this._onKeyup(evt);
  }
});
});

// module: view/composer/composer
// file:   view/composer/composer.js
define("view/composer/composer", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var View = require('bolt_touch/view').View;

var AutoGrowTextField =
  require('view/text_field/auto_grow_text_field').AutoGrowTextField;

var LocationButton    =
  require('view/location_button/location_button').LocationButton;
var PhotoButton       =
  require('view/photo_button/photo_button').PhotoButton;
var ActionableView = require('bolt_touch/views/actionable_view').ActionableView;

var pinUtil = require('shared/simpin/pin_util');
var WindowManager     = require('shared/window_manager').WindowManager;
var Dialog            = require('shared/boltwidget/dialog').Dialog;
var telephonyApi      = FBAPI.use('telephony');


exports.Composer = core.createClass({
  name: 'Composer',

  extend: View,

  delegateProperties: {
    textField: [{name: 'value', alias: 'text'}]
  },

  declare: function(options) {
    return {
      childViews: [
        {
          className: 'bt-composer--location-button',
          view: LocationButton,
          ref: 'locationButton',
          ontouchstart: 'dontBlur'
        },
        {
          className: 'bt-composer-left',
          boxOrientation: 'vertical',
          childViews: [{
            view: PhotoButton,
            // text button for background active effect
            className: 'bt-bar-button bt-composer--photo-button',
            ref: 'photoButton',
            onphotos: 'onPhotos',
            ontouchstart: 'dontBlur'
          }]
        },
        {
          view: AutoGrowTextField,
          className: 'bt-composer-message',
          placeholder: 'Message',
          ref: 'textField',
          onfocusout: 'onTextareaBlur',
          onfocusin: 'onTextareaFocus',
          onkeyup: '_updateSendButton'
        },
        {
          className: 'bt-composer-right',
          boxOrientation: 'vertical',
          childViews: [{
            view: ActionableView,
            ref: 'sendBtn',
            className: 'bt-bar-button bt-composer-send disabled',
            action: 'onSend',
            content: 'Send'
          }]
        }
      ]
    };
  },

  ready: function() {
    this.textField = this.refs.textField;
    this.composerTextField = this.refs.textField.getTextarea();
    this.focuser = util.bind(function() {
        this.focus();
      }, this);
    this._updateSendButton();
    this._dontBlurTextarea = false;
  },

  dontBlur: function() {
    this._dontBlurTextarea = true;
  },

  isMessageEmpty: function() {
    return !(this.getText() || this.getAttachment());
  },

  onSend: function() {
    var _this = this;
    if (this.isMessageEmpty()) {
      return;
    }

    if (telephonyApi.isAirplaneModeEnabled()) {
      var dialog = this.build({
        view: 'Dialog',
        title: "Airplane mode",
        body: "You cannot send messages while in airplane mode. " +
          "Would you like to turn it off?",
        actions: [
          {
            value: 'Yes',
            action: function() {
              telephonyApi.setIsAirplaneModeEnabled(false);
              dialog.dismiss();
              setTimeout(_this.focuser, 10);
            }
          },
          {
            value: 'No',
            action: 'dismiss'
          }
        ]
      });
      dialog.show();
    } else {
      var event = {
        simulateBubbling: true,
        text: this.getText(),
        coords: this.getLocation()
      };
      pinUtil.verifySimUnlocked().addCallback(this.invoke, this, 'send', event);
    }
  },

  // restore keyboard state on return from camera
  onPhotos: function(e) {
    this._updateSendButton();
  },

  // refocus textarea if we don't let it be blurred
  onTextareaBlur: function(e) {
    if (this._dontBlurTextarea) {
      this.focus();
      this._dontBlurTextarea = false;
    }
    this._updateSendButton();
  },

  onTextareaFocus: function() {
    this._dontBlurTextarea = false;
  },

  _updateSendButton: function() {
    if (!this.isForwarding && this.isMessageEmpty()) {
      this.refs.sendBtn.addClass('disabled');
    } else {
      this.refs.sendBtn.removeClass('disabled');
    }
  },

  getDraftMessage: function() {
    return {
      text: this.getText(),
      attachment: this.getAttachment()
    };
  },

  setDraftMessage: function(draftMessage) {
    draftMessage = draftMessage || {};
    this.textField.setValue(draftMessage.text || "");
    this.refs.photoButton.setSelectedPhoto(draftMessage.attachment || null);
  },

  getTextarea: function() {
    return this.composerTextField.getNode();
  },

  getAttachment: function() {
    var photo = this.refs.photoButton.getSelectedPhoto();
    return photo && {
      width: photo.get('width'),
      height: photo.get('height'),
      local_url: photo.get('source'),
      local_link: 'file://' +
        photo.get('path').split('/').map(encodeURIComponent).join('/')
    };
  },

  getLocation: function() {
    return this.refs.locationButton.getSendLocation() &&
             this.refs.locationButton.getCoords();
  },

  // ### ReplyComposer API

  // Give focus to the text field.
  focus: function() {
    this.textField.focus();
  },

  // Blur the text field.
  blur: function() {
    this.textField.blur();
  },

  // Clear the contents of the reply composer
  clear: function() {
    this.textField.clear();
    this.refs.photoButton.clear();
    this.refs.sendBtn.addClass('disabled');
  },

  // in case there is a forwarded message and we can always send
  setForwarding: function() {
    this.isForwarding = true;
    this._updateSendButton();
  }
});
});

// module: talk/client/model/thread/common_thread_api
// file:   ../client/model/thread/common_thread_api.js
define("talk/client/model/thread/common_thread_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var STATE        = require('shared/data2/store/constants').STATE;
var util         = require('bolt/util');
var sharedUtil   = require('shared/util');
var contactUtils = require('talk/client/model/thread/contacts');


var CommonThreadAPI = {
  isLocal: function() {
    return this.get('remoteState') == STATE.LOCAL;
  },

  isUnread: function() {
    return 0 < this.get('num_unread');
  },

  isReply: function() {
    var senders = this.get('senders');
    var session = require('shared/session');
    return (
      senders &&
      senders.length &&
      senders[0].user_id === session.getUid()
    );
  },

  isArchived: function() {
    return this.get('archived');
  },

  is1to1: function() {
    return (((this.get('participantsIdents').length == 2) &&
             (this.get('former_participants').length === 0)));
  },

  isSelf: function() {
    var session = require('shared/session');
    return ((this.get('participants').length == 1) &&
            (this.get('participants')[0].user_id === session.getUid()));
  },

  /**
   * Gets all participants, including the self participant,
   * except those who have unsubscribed.
   */
  getSubscribedParticipants: function() {
    var all = this.getAllParticipants();
    var former = this.get('former_participants') || [];

    var formerHash = {};
    util.each(former, function(p) {
      formerHash[p.user_id] = true;
    });

    return util.filter(all, function(p) {
      var valid = !formerHash[p.user_id];
      return valid;
    });
  },

  hasSubscribedParticipant: function(user_id) {
    var all = this.getSubscribedParticipants();
    for (var i = 0; i < all.length; i++) {
      if (all[i].user_id === user_id) {
        return true;
      }
    }
    return false;
  },

  getDateTime: function() {
    return new Date(this.get('timestamp'));
  },

  /**
   * for 1 to 1 conversation returns a recipient != me
   * @return {Object}
   */
  getRecipient: function() {
    var participants = this.get('participants');
    if (!this.is1to1()) {
      return null;
    }
    if (participants.length === 1) {
      return participants[0];
    }
    var session = require('shared/session');
    return participants[0].user_id !== session.getUid() ?
      participants[0] : participants[1];
  },

  /**
   * Gets all participants, including the self participant.
   */
  getAllParticipants: function() {
    var participants = this.get('participants') || [];
    var senders = this.get('senders') || [];
    var all = senders.concat(participants);

    // Filter out duplicates.
    var seen = {};
    all = util.filter(all, function(p) {
      var valid = !seen[contactUtils.buildInfoIdent(p)];
      seen[contactUtils.buildInfoIdent(p)] = true;
      return valid;
    });

    return all;
  },

  /**
   * Filter out the self participant, except when there's only one.
   */
  getRelevantParticipants: function(type) {
    var all = this.getAllParticipants(type);

    // If all we have is one participant, return that.
    if (all.length <= 1) {
      return all;
    }

    // Else, filter out self.
    var session = require('shared/session');
    var uid = session.getUid();
    return util.filter(all, function(p) {
      return p.user_id !== uid;
    });
  },

  /**
   * Get the uids needed to display the multi-avatar.
   */
  participantsForAvatar: function() {
    return this.getRelevantParticipants().slice(0, 2);
  },

  /**
   * Thread title.
   */
  getTitle: function() {
    if (this.get('name')) {
      return this.get('name');
    } else {
      return this.participantsNameString();
    }
  },

  /**
   * Get a string of the first two participant names.
   */
  participantsNameString: function() {
    var participants = this.getRelevantParticipants();
    if (participants.length == 1) {
      return participants[0].name;
    }
    if (participants.length == 2) {
      return this.getParticipantDisplayString(participants[0].name) + ' and ' +
      this.getParticipantDisplayString(participants[1].name);
    }
    if (participants.length == 3) {
      return this.getParticipantDisplayString(participants[0].name) + ', ' +
        this.getParticipantDisplayString(participants[1].name) + ' and ' +
        this.getParticipantDisplayString(participants[2].name);
    }
    return this.getParticipantDisplayString(participants[0].name) + ', ' +
    this.getParticipantDisplayString(participants[1].name) + ' and ' +
      (participants.length - 2) + ' others';
  },

  getParticipantDisplayString: function(name) {
    if (!this.phoneApi) {
      this.phoneApi = FBAPI.use("phone");
    }
    if (sharedUtil.isPhoneOrShortCode(name)) {
      return name;
    } else {
      return name.split(' ')[0];
    }
  },

  /**
   * Thread subtitle - hot state of the current user
   * TODO: use real data
   */
  getSubtitle: function() {
    // location data, music, friends with, etc?
    return 'in San Francisco';
  },

  /**
   * Thread subtitle icon to match the hot state
   * TODO: use real data
   */
  getSubtitleIcon: function() {
    //figure out the hot state type and get the icon to match
    return 'fbcf:///apps/talk/location_pin.png';
  },

  getMailbox: function() {
    var Mailbox = require('shared/model/mailbox').Mailbox;
    var mailboxes = Mailbox.MAILBOXES;
    for (var name in mailboxes) {
      if (mailboxes.hasOwnProperty(name)) {
        if (mailboxes[name].archived == this.get('archived') &&
          mailboxes[name].folder == this.get('folder')) {
          return mailboxes[name];
        }
      }
    }
    return null;
  }
};


exports.CommonThreadAPI = CommonThreadAPI;
});

// module: lib/contacts_filter
// file:   lib/contacts_filter.js
define("lib/contacts_filter", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core        = require('bolt/core');
var util        = require('bolt/util');
var BatchFilter = require('shared/batch_filter').BatchFilter;

/**
 * Sort contacts by coefficient order. Contacts with no order go last.
 */
var sortByCoefficientOrder = function(contact1, contact2) {
  var co1 = contact1.getCoefficientOrder();
  var co2 = contact2.getCoefficientOrder();
  if (typeof co1 !== 'undefined' && typeof co2 !== 'undefined') {
    return co1 - co2;
  }
  if (typeof co1 !== 'undefined') {
    return -1;
  }
  if (typeof co2 !== 'undefined') {
    return 1;
  }
  return 0;
};

/**
 * Sort by alphabetical order.
 */
var sortByAlphabeticalOrder = function(contact1, contact2) {
  var name1 = contact1.getName();
  var name2 = contact2.getName();
  if (name1 === name2) {
    return 0;
  }
  return (name2 > name1) ? -1 : 1;
};

/**
 * Does the first name match the regex?
 */
var matchesFirstName = function(contact) {
  return !!this.regexName.test(contact.getFirstName());
};

/**
 * Phases of filtering.
 */
var PHASES = {
  BY_COEFFICIENT: 0,
  FIRST_NAME_MATCHES: 1,
  OTHER_MATCHES: 2,
  FINISHED: 3
};

/**
 * Quickly filter contacts and sort by the following rules (which someone in
 * the future will change because these are kind of arbitrary):
 * - 3 top coefficient matches
 * - first name matches
 * - other matches
 */
var ContactsFilter = exports.ContactsFilter = core.createClass({

  extend: BatchFilter,

  statics: {
    NUM_COEFF_SEARCH_SPOTS: 3
  },

  construct: function(data, options) {
    BatchFilter.call(this, data, options);

    // 2 copies of array, one sorted by coefficient, the other alphabetical.
    this.items.sort(sortByAlphabeticalOrder);
    this.sortedByCoeff = [];
    for (var i = 0; i < this.items.length; i++) {
      this.sortedByCoeff.push(this.items[i]);
    }
    this.sortedByCoeff.sort(sortByCoefficientOrder);
  },

  search: function(matchFunction, context) {
    // keep track of items we checked so we don't check them more than once
    this._checked = {};
    // keep track of items we checked that match but we haven't returned them
    // yet. this is useful when doing the first name filter.
    this._matched = {};

    BatchFilter.prototype.search.call(this, matchFunction, context);
  },

  /**
   * Override iterator to contain a phase, which represents whether we are
   * searching by coefficient, alphabetically, etc.
   */
  _createIterator: function() {
    return {
      iteration: 0,
      found: 0,
      phase: 0
    };
  },

  _filterChunk: function() {
    var iterator = this._currentIterator;
    var filtered = 0,
        results = [],
        item;

    while (iterator.phase < PHASES.FINISHED) {
      if (filtered === this.chunkSize) {
        // Another chunk finished, return results
        if (results.length) {
          this._mergeChunk(results);
          if (this.chunkSize === this._initialChunkSize) {
            this.chunkSize *= 2;
          }
        }
        if (iterator.found < this.maxResults || this.maxResults < 0) {
          // If we already found maxResults matches, we do not need to continue
          this._currentIterator = iterator;
          this._searchTimer = setTimeout(this.filterStep, this.timeout);
        }
        return;
      }

      switch (iterator.phase) {
        case PHASES.BY_COEFFICIENT:

          // if we've gone through all the contacts, finish search
          if (iterator.iteration >= this.sortedByCoeff.length) {
            iterator.phase = PHASES.FINISHED;
            continue;
          }

          item = this.sortedByCoeff[iterator.iteration];

          if (item && this.matchFunction.call(this.context, item)) {
            iterator.found++;
            results.push(item);

            if (iterator.found === ContactsFilter.NUM_COEFF_SEARCH_SPOTS) {
              // reset iteration, move to alphabetical phase
              iterator.phase = PHASES.FIRST_NAME_MATCHES;
              iterator.iteration = -1;
            }
          }

          this._checked[item.id] = true;
          break;
        case PHASES.FIRST_NAME_MATCHES:
          // if we've gone through all the contacts, move to next phase
          if (iterator.iteration >= this.items.length) {
            iterator.phase = PHASES.OTHER_MATCHES;
            iterator.iteration = 0;
            continue;
          }

          item = this.items[iterator.iteration];


          if ((item && !this._checked[item.id]) &&
              this.matchFunction.call(this.context, item)) {

            if (matchesFirstName.call(this.context, item)) {
              iterator.found++;
              results.push(item);
              // only mark found items as checked
              this._checked[item.id] = true;
            } else {
              this._matched[item.id] = true;
            }
          }

          break;
        case PHASES.OTHER_MATCHES:
          // if we've gone through all the contacts, finish search
          if (iterator.iteration >= this.items.length) {
            iterator.phase = PHASES.FINISHED;
            continue;
          }

          item = this.items[iterator.iteration];

          if ((item && !this._checked[item.id]) && (this._matched[item.id] ||
              this.matchFunction.call(this.context, item))) {
            iterator.found++;
            results.push(item);
          }
          break;
        default:
          console.error('unknown phase in contacts_filter');
          break;
      }

      iterator.iteration++;
      filtered++;
    }

    this._mergeChunk(results);

    this.stopSearch();
    this.invoke(
      'searchFinish',
      {iterator: iterator}
    );
  }
});
});

// module: shared/data2/model/story/story
// file:   ../../shared/js/data2/model/story/story.js
define("shared/data2/model/story/story", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var dom = require('bolt/dom');
var util = require('bolt/util');
var Model  = require('bolt/model').Model;
var Collection = require('bolt/collection').Collection;
var sharedUtil = require('../../../util');
var sharedText = require('../../../text');
var Likeable = require('../../model/mixin/likeable').Likeable;
var Commentable = require('../../model/mixin/commentable').Commentable;
var PageProfile = require('../../../model/profile/page').PageProfile;
var Profile = require('../../../model/profile/profile').Profile;
var Photo = require('photos/app/lib/model/photo/photo').Photo;

var Story = core.createClass({

  name: 'Story',

  extend: Model,

  mixins: [Likeable, Commentable],

  storeModel: function() {
    require('./story_store').getInstance().store([this]);
  },

  getFeedbackIdType: function() {
    return Commentable.FEEDBACK_ID_POST_TYPE;
  },

  hasAttachment: function() {
    var attachment = this.get('attachment');
    // we have empty attachments currently that appear like this:
    // {description: ''}
    // this check ensures that we ignore those
    return !!(attachment && attachment.name);
  },

  hasPhotoAttachment: function() {
    var attachment = this.get('attachment');
    // TODO make sure we're filtering checkins with bad image attachments, or
    // file a bug on the API.
    return attachment &&
      attachment.media &&
      attachment.media.length &&
      attachment.media[0].type == 'photo';
  },

  hasMultiPhotoAttachment: function() {
    var attachment = this.get('attachment');
    return this.hasPhotoAttachment() && attachment.media.length > 1;
  },

  hasSimpleMultiPhotoAttachment: function() {
    var attachment = this.get('attachment');
    return this.hasPhotoAttachment() && (attachment.media.length > 1 &&
      attachment.media.length < 5);
  },

  hasSinglePhotoAttachment: function() {
    var attachment = this.get('attachment');
    return this.hasPhotoAttachment() && attachment.media.length === 1;
  },

  hasPlaceAttachment: function() {
    return !!this.getPlace();
  },

  hasSimpleAttachment: function() {
    return this.hasAttachment() &&
      !this.getPlace() &&
      !this.hasPhotoAttachment();
  },

  isAggregated: function() {
    var childrenPosts = this.getChildrenPosts();
    return childrenPosts.length > 0;
  },

  /**
   * GETTERS
   * - Story properties cannot be models so that passing the return of a story's
   *   toObject into the constructor of a new story returns an equivalent story
   *   object.
   **/
  getActor: function() {
    if (!this._actor) {
      var actor = this.get('actor');
      this._actor = actor && new Profile(actor);
    }
    return this._actor;
  },

  getTarget: function() {
    if (!this._target) {
      var target = this.get('target');
      this._target = target && new Profile(target);
    }
    return this._target;
  },

  getPlace: function() {
    if (!this._place) {
      var place = this.get('place');
      this._place = place && new PageProfile(place);
    }
    return this._place;

  },

  getWithTags: function() {
    if (!this._withTags) {
      var withTags = this.get('with_tags');
      this._withTags = [];
      if (withTags && withTags.length > 0) {
        for (var i = 0; i < withTags.length; i++) {
          this._withTags[i] = withTags[i] ?
            new Profile(withTags[i]) :
            null;
        }
      }
    }
    return this._withTags;
  },

  getChildrenPosts: function() {
    if (!this._childrenPosts) {
      var childrenPosts = this.get('children_posts');
      this._childrenPosts = [];
      if (childrenPosts && childrenPosts.length > 0) {
        for (var i = 0; i < childrenPosts.length; i++) {
          this._childrenPosts[i] = childrenPosts[i] ?
            new Story(childrenPosts[i]) :
            null;
        }
      }
    }
    return this._childrenPosts;
  },

  // TODO: This creates a collection of photos from the media array,
  // but it's missing some important bits (e.g. likes, comments, tags).
  // We need to decide if we want to query for this while fetching the
  // stories, or if it makes more sense for the Photo Viewer to do it.
  // Also, it might make more sense to do this further up (in the remote
  // mapper), but I didn't want to mess with the story model too much.
  getPhotos: function() {
    if (!this._photos) {
      this._photos = new Collection();

      var media = this.get('attachment').media;
      for (var i = 0; i < media.length; i++) {
        var mediaItem = media[i];

        // Timeline stories don't have a photo object
        if (!mediaItem.photo) {
          mediaItem.photo = {
            width: mediaItem.src_big_width,
            height: mediaItem.src_big_height
          };
        }

        // Create a photo from the media data
        var photo = new Photo({
          id: Date.now().toString() + i,
          fbid: mediaItem.photo.fbid,
          pid: mediaItem.photo.pid,
          owner: mediaItem.photo.owner,
          height: parseInt(mediaItem.photo.height, 10),
          width: parseInt(mediaItem.photo.width, 10),
          name: mediaItem.alt || mediaItem.caption,
          thumbnail_url: mediaItem.src_big || mediaItem.src,
          full_url: mediaItem.src_big || mediaItem.src,
          position: mediaItem.photo.index,
          album_id: mediaItem.photo.aid,
          likes: mediaItem.likes || {
            can_like: false,
            user_likes: false,
            count: 0
          },
          comments: mediaItem.comments || {
            can_post: false,
            count: 0
          },
          tags: null
        });

        this._photos.add(photo);
      }
    }
    return this._photos;
  }
});

exports.Story = Story;
});

// module: shared/data2/local/db
// file:   ../../shared/js/data2/local/db.js
define("shared/data2/local/db", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*global openDatabase */

var core     = require('bolt/core');
var util     = require('bolt/util');
var Deferred = require('shared/deferred').Deferred;
var logger   = require('shared/logger').logger;

var Statement = core.createClass({
  name: 'Statement',
  extend: Deferred,

  properties: {
    sqlStatement: '',
    args: []
  },

  _started: 0,
  _time: 0,

  construct: function(sqlStatement, args) {
    this.setSqlStatement(sqlStatement);
    this.setArgs(args);

    this._callback = util.bind(this._callback, this);
    this._errback = util.bind(this._errback, this);

    this._logInfo = {
      statement: sqlStatement
      // we don't log args here for privacy reasons
    };
    this._started = Date.now();

    Deferred.call(this);
  },

  getTime: function() {
    return this._time;
  },

  _callback: function(nativeTransaction, resultSet) {
    this._time = Date.now() - this._started;
    // measures how long callbacks take to run (synchronously)
    logger.logTimeDirect('webdb.statement.rows.length', 'count',
      resultSet.rows.length, this._logInfo);
    var callbackTimerId =
      logger.startTimer('webdb.statement.callbacks', logger.ALLOW_OVERLAPPING);
    this.succeed(resultSet);
    logger.endTimer(callbackTimerId, this._logInfo);
  },

  _errback: function(nativeTransaction, error) {
    this._time = Date.now() - this._started;
    // measures how long errbacks take to run (synchronously)
    var errbackTimerId =
      logger.startTimer('webdb.statement.errbacks', logger.ALLOW_OVERLAPPING);
    console.error('SQL Error: ' + error.message +
      ' (sql="' + this.getSqlStatement() + '").');
    this.fail(error);
    logger.endTimer(errbackTimerId, this._logInfo);
    // returning something falsy causes transaction to continue executing.
    // the default behavior for native transactions when there is no error
    // callback to executeSql is to fail the transaction; let's do the same
    return true;
  },

  execute: function(nativeTransaction) {
    var sqlStatement = this.getSqlStatement();
    var args = this.getArgs();
    nativeTransaction.executeSql(
      sqlStatement,
      args,
      this._callback,
      this._errback
    );
  }
});

var Transaction = core.createClass({
  name: 'Transaction',
  extend: Deferred,

  _started: 0,
  _time: 0,

  construct: function() {
    this.ready = new Deferred();

    this.ready.addCallback(this._onReady, this);

    // measures how long it takes to create the transaction
    this._logInfo = { };
    this._createTimerId =
      logger.startTimer('webdb.transaction.create', logger.ALLOW_OVERLAPPING);
    // measures the number of statements executed by this transaction
    this._statementCount = 0;
    this._started = Date.now();

    Deferred.call(this);
  },

  getTime: function() {
    return this._time;
  },

  getStatementCount: function() {
    return this._statementCount;
  },

  _onReady: function() {
    logger.endTimer(this._createTimerId, this._logInfo);
    // measures time between transaction created and transaction committed
    this._executeTimerId =
      logger.startTimer('webdb.transaction.execute', logger.ALLOW_OVERLAPPING);
  },

  succeed: function() {
    this._time = Date.now() - this._started;
    var executionTime = logger.queryTimer(this._executeTimerId);
    logger.endTimer(this._executeTimerId, this._logInfo);
    logger.logTimeDirect('webdb.transaction.statement_count', 'count',
      this._statementCount, this._logInfo);
    logger.logTimeDirect('webdb.transaction.average_statement_execute',
      'latency', executionTime / this._statementCount, this._logInfo);

    Deferred.prototype.succeed.call(this);
  },

  fail: function(error) {
    this._time = Date.now() - this._started;
    if (!this._statementFailed) {
      // failure in Statement already logged
      console.error(error.message);
    }
    if (this.ready.getStatus() === Deferred.STATUS_UNKNOWN) {
      this.ready.fail(error);
    }
    Deferred.prototype.fail.call(this, error);
  },

  /**
   * @return {Statement}
   */
  executeSql: function(sqlStatement, args) {
    this._statementCount++;

    var statement = new Statement(sqlStatement, args);
    this.ready.then(statement.execute, statement)
      .addErrback(this._statementFailed, this);
    return statement;
  },

  _statementFailed: function(error) {
    this._statementFailed = true;
  }
});

var Database = core.createClass({
  name: 'Database',

  construct: function(nativeDatabase) {
    this._database = nativeDatabase;
  },

  /**
   * @return {String}
   */
  getVersion: function() {
    return this._database.version;
  },

  /**
   * @return {Transaction}
   */
  transaction: function() {
    var transaction = new Transaction();
    this._database.transaction(
      util.bind(transaction.ready.succeed, transaction.ready),
      util.bind(transaction.fail, transaction),
      util.bind(transaction.succeed, transaction)
    );
    return transaction;
  },

  /**
   * @return {Transaction}
   */
  readTransaction: function() {
    var transaction = new Transaction();
    this._database.readTransaction(
      util.bind(transaction.ready.succeed, transaction.ready),
      util.bind(transaction.fail, transaction),
      util.bind(transaction.succeed, transaction)
    );
    return transaction;
  },

  /**
   * @return {Transaction}
   */
  changeVersion: function(oldVersion, newVersion) {
    var transaction = new Transaction();
    this._database.changeVersion(
      oldVersion,
      newVersion,
      util.bind(transaction.ready.succeed, transaction.ready),
      util.bind(transaction.fail, transaction),
      util.bind(transaction.succeed, transaction)
    );
    return transaction;
  }
});

exports.Database = Database;
});

// module: mock/location_api
// file:   ../../mock/js/location_api.js
define("mock/location_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;

module.exports = {
  //variables mocking the state of the device
  _gpsEnabled: true,
  _assistedGpsEnabled: true,
  _wirelessLocationEnabled:true,
  _currLocation: {
    provider: "gps",
    timestamp: new Date().getTime(),
    coords: {
      latitude: 37.41603,
      longitude: -122.15213,
      accuracy: 10,
      altitude: 100,
      heading: 0,
      speed: 0
    }
  },
  _mProximityAlerts:[],
  _mLastProximityAlert:-1,

  /**
   * constructs a json string containing the location information
   * (if available) with the following format:
   *  { "provider":  Source of the location fix,
   *    "timestamp": Milliseconds since the Epoch,
   *    "coords": { "latitude":  degrees,
   *                "longitude": degrees,
   *                "accuracy":  meters,
   *                "altitude":  meters,
   *                "heading":   degrees east of north,
   *                "speed":     m/s,
   *              }
   *   }
   **/
  createPositionObject: function(location) {
     var locObj = {};

     if(this._currLocation.provider != null)
       locObj.provider = this._currLocation.provider;

     if(this._currLocation.timestamp != null)
       locObj.timestamp = this._currLocation.timestamp;

     if(this._currLocation.coords != null) {
       var coords = {};

       if(this._currLocation.coords.latitude != null)
         coords.latitude = this._currLocation.coords.latitude;

       if(this._currLocation.coords.longitude != null)
         coords.longitude = this._currLocation.coords.longitude;

       if(this._currLocation.coords.accuracy != null)
         coords.accuracy = this._currLocation.coords.accuracy;

       if(this._currLocation.coords.altitude != null)
         coords.altitude = this._currLocation.coords.altitude;

       if(this._currLocation.coords.heading != null)
         coords.heading = this._currLocation.coords.heading;

       if(this._currLocation.coords.speed != null)
         coords.speed = this._currLocation.coords.speed;
       locObj.coords = coords;
     }
     return JSON.stringify(locObj);
  },

  /**
   * Returns the current mocked location
   **/
  getLastKnownPosition: function(provider) {
    this._currLocation.provider = provider;
    return this.createPositionObject(this._currLocation);
  },

  /**
   * Broadcast the current mocked location
   **/
  sendLastKnownPosition: function(provider) {
    var _this = this;
    //broadcast the location after some time
    setTimeout(
               function() {
                 EventManager.broadcastEvent('location.CHANGED', [_this._currLocation]);
               },
               1 * 1000); //in milliseconds
  },

  /**
   * Register a location for a proximity alert.
   */
  addProximityAlert: function(latitude, longitude, radius) {
    var newProximityAlert = ++this._mLastProximityAlert;
    this._mProximityAlerts.push({latitude: latitude,
                                 longitude: longitude,
                                 radius:radius});
    // nothing should happen as we assume the device is not changing locations
    // we only return the id of the alert.
    return newProximityAlert;
  },

  /**
   * Remove the location alert from our records
   **/
  removeProximityAlert: function(proximityAlert) {
    if(this._mProximityAlerts[proximityAlert] != null)
      this._mProximityAlerts[proximityAlert] = null;
  },

  /**
   * Clear the registry of locations to alert from.
   **/
  clearProximityAlerts: function() {
    this._mProximityAlerts = [];
  },

  /**
   * Query gps status
   */
  isGpsEnabled: function() {
    return this._gpsEnabled;
  },

  /**
   * Enable/disable gps
   **/
  setIsGpsEnabled: function(enable) {
    var _this = this;
    //broadcast the new status after some time
    setTimeout(
               function(){
                 _this._gpsEnabled = enable;
                 EventManager.broadcastEvent('location.ENABLED', [{enabled: enable}]);
               },
               1 * 1000); //in milliseconds
      return true;
  },

  /**
   * Toggle gps status
   **/
  toggleGps: function() {
    var enable = !this.isGpsEnabled();
    return this.setIsGpsEnabled(enable);
  },

  /**
   * Query assisted gps status
   **/
  isAssistedGpsEnabled: function() {
    return this._assistedGpsEnabled;
  },

  /**
   * Enable/disable assisted gps
   **/
  setIsAssistedGpsEnabled: function(enable) {
    var _this = this;
    //broadcast the new status after some time
    setTimeout(
               function(){
                 _this._assistedGpsEnabled = enable;
                 EventManager.broadcastEvent('location.ENABLED', [{enabled: enable}]);
               },
               1 * 1000); //in milliseconds
    return true;
  },

  /**
   * Toggle assisted gps status
   **/
  toggleAssistedGps: function() {
    var enable = !this.isAssistedGpsEnabled();
    return this.setIsAssistedGpsEnabled(enable);
  },

  /**
   * Query the status of the wireless location provider
   **/
  isWirelessLocationEnabled: function() {
    return this._wirelessLocationEnabled;
  },

  /**
   * Enable/disable the wireless location provider
   **/
  setIsWirelessLocationEnabled: function(enable) {
    var _this = this;
    //broadcast the new status after some time
    setTimeout(
               function(){
                 _this._wirelessLocationEnabled = enable;
                 EventManager.broadcastEvent('location.ENABLED', [{enabled: enable}]);
               },
               1 * 1000); //in milliseconds
    return true;
  },

  /**
   * Toggle the status of the wireless location provider
   **/
  toggleWirelessLocation: function() {
    var enable = !this.isWirelessLocationEnabled();
    return this.setIsWirelessLocationEnabled(enable);
  },

  requestLocationUpdates: function() {
    // TODO?
  },

  removeUpdates: function() {
    // TODO?
  }
};
});

// module: shared/data2/store/managed_collection
// file:   ../../shared/js/data2/store/managed_collection.js
define("shared/data2/store/managed_collection", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var Collection = require('bolt/collection').Collection;
var FilterableCollection = require('bolt/mixins/filterable_collection').FilterableCollection;
var STATE = require('./constants').STATE;
var SEQUENCE_STATE = require('./constants').SEQUENCE_STATE;

/**
 * Managed collection that guaranteed to update whenever local data changes.
 * All mutations are done only by the store. Mutating it manually is not
 * allowed.
 *
 * Provides api to navigate back and forth through the entire matching data set.
 */
var ManagedCollection = exports.ManagedCollection = core.createClass({
  name: 'ManagedCollection',
  extend: Collection,

  mixins: [FilterableCollection],

  properties: {
    store: null,
    filter: null,
    hasMore: false,
    remoteState: SEQUENCE_STATE.NORMAL
  },


  /**
   *  Remote data layout (sorted)
   *  __________________
   *  |################|
   *  |################| Head
   *  |################|
   *  |----------------|-
   *  |                | Gap
   *  |----------------|-
   *  |################|
   *  |################| Before
   *  |################|
   *  |----------------|-
   *  |################|
   *  |################|
   *  |################| Downloaded data
   *  |################|
   *  |################|
   *  |----------------|-
   *  |################|
   *  |################| After
   *  |################|
   *  |----------------|-
   *  |                |
   *  |                |
   *  |                |
   *  |                | Great Unknown
   *  |                |
   *  |                |
   *  |                |
   *  |________________|
   */
  downloadHead: function(limit) {
    return this.getStore()
      .annotate('ManagedCollection#downloadHead')
      .downloadCollectionHead(this, limit);
  },

  downloadAfter: function(limit) {
    return this.getStore()
      .annotate('ManagedCollection#downloadAfter')
      .downloadCollectionAfter(this, limit);
  },

  downloadBefore: function(limit) {
    return this.getStore()
      .annotate('ManagedCollection#downloadBefore')
      .downloadCollectionBefore(this, limit);
  },

  download: function(limit) {
    return this.getStore()
      .annotate('ManagedCollection#download')
      .downloadIntoCollection(this, limit);
  },

  fetchMore: function(limit) {
    return this.getStore()
      .annotate('ManagedCollection#fetchMore')
      .fetchMoreIntoCollection(this, limit);
  },

  // store <=> collection api
  construct: function(store, options) {
    this.setStore(store);
    Collection.call(this, options);
  },

  hasRemoteAfter: function() {
    var last = this.at(this.length - 1);
    return this.getRemoteState() === SEQUENCE_STATE.NORMAL &&
      (!last || last.get('remoteState') != STATE.LAST);
  },

  setHasMore: function(state) {
    this.set('hasMore', state);
    this.hasMoreChanged && this.hasMoreChanged();
    return this;
  },

  setRemoteState: function(state) {
    this.set('remoteState', state);
    this.remoteStateChanged && this.remoteStateChanged();
    return this;
  },

  hasMore: function() {
    return this.getHasMore();
  },

  setFilter: function(filter) {
    this.comparator = filter.getComparator();
    this.matcher = filter.getMatcher();
    this.sortKey = filter.getSortKey();
    this.getStore()
      .addListener('modelsAdded', this._onStoreModelsAdded, this);
    this.getStore()
      .addListener('modelsRemoved', this._onStoreModelsRemoved, this);
    return this.set('filter', filter);
  },

  add: function(model, quiet) {
    var result = Collection.prototype.add.call(this, model, quiet);
    if (result) {
      this.getStore().hold(result);
    }
    return result;
  },

  remove: function(model, quiet) {
    var result = Collection.prototype.remove.call(this, model, quiet);
    if (result) {
      this.getStore().release(model);
    }
    return result;
  },

  destroy: function() {
    this.forEach(this.getStore().release, this.getStore());
    if (this.getFilter()) {
      this.getStore()
        .removeListener('modelsAdded', this._onStoreModelsAdded, this);
      this.getStore()
        .removeListener('modelsRemoved', this._onStoreModelsRemoved, this);
    }
    Collection.prototype.destroy.call(this);
  },

  /**
   * Override _onModelChanged. Instead of calling super-expensive sort()
   * every time a model changes it's sortKey we remove and add this model.
   */
  _onModelChanged: function(e) {
    var model = e.data.model;

    // if model no longer satisfies matcher, remove it from collection
    if (this.matcher && !this.matcher(model)) {
      this.remove(model);
      return;
    }

    var changedProperties = e.data.changedProperties;
    if (this.comparator && this.sortKey && changedProperties[this.sortKey]) {
      var newIndex = this.sortedIndex(model, this.comparator);
      newIndex = Math.min(newIndex, this.length - 1);

      // remove and add if reorder happened
      // NOTE that modelChanged will not be triggered since it's unnesessary
      // at this point
      if (this.at(newIndex) && this.at(newIndex).id != model.id) {
        Collection.prototype.remove.call(this, model);
        Collection.prototype.add.call(this, model);
        return;
      }
    }

    // indexOf is just ridiculously expensive to do on every change for long
    // collections. Why are we doing this in bolt? why?
    var index = this.indexOf(model);
    if (index < 0) {
      return;
    }
    this.invoke('modelChanged', util.defaults({ index: index }, e.data));
  },

  _onStoreModelsAdded: function(e) {
    var modelsToMerge = e.data.models.filter(this.matcher);
    if (modelsToMerge.length) {
      this.merge(modelsToMerge, false, true);
    }
  },

  _onStoreModelsRemoved: function(e) {
    e.data.ids.forEach(function(id) {
      var model = this.getById(id);
      if (model) {
        this.remove(model);
      }
    }, this);
  }
});
});

// module: contacts/contacts_transition_manager
// file:   contacts/contacts_transition_manager.js
define("contacts/contacts_transition_manager", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

/*global undefined: true */
/*global SharedWorker: true */

var ContactsPortfolio =
  require('../contacts/contacts_portfolio').ContactsPortfolio;
var AllContactsSection =
  require('../contacts/all_contacts_section').AllContactsSection;
var FindFacebookContactSection =
  require('../contacts/find_facebook_contact_section')
  .FindFacebookContactSection;
var CreateNewContactSection =
  require('../contacts/create_new_contact_section').CreateNewContactSection;
var DisplayContactSection =
  require('../contacts/display_contact_section').DisplayContactSection;
var EditContactSection =
  require('../contacts/edit_contact_section').EditContactSection;

var ContactsDomainClient =
  require('./client/domain_client').ContactsDomainClient;

var STATES = {
  InitialLoad: {
    displayAllContacts: function() {
      this._window.displayScene(this._allContactsSection.getScene());
      this._gotoState(STATES.DisplayingAllContacts);
    }
  },
  DisplayingAllContacts: {
    contactSelected: function(contactSnapshot) {
      this._window.displayScene(
        this._displayContactSection.getScene(contactSnapshot));
      this._gotoState(STATES.DisplayingSingleContactInformation);
    },

    addContact: function(potentialContactName) {
      this._window.displayScene(
        this._findFacebookContactSection.getScene(potentialContactName));
      this._gotoState(STATES.FindFacebookContact);
    },

    filterContacts: function() {
      this._window.displayPickContactsFilter();
      this._gotoState(STATES.PickContactsFilter);
    }
  },

  PickContactsFilter: {
    cancel: function() {
      this._window.displayScene(this._allContactsSection.getScene());
      this._gotoState(STATES.DisplayingAllContacts);
    },

    allContactsSelected: function() {
      this._window.displayScene(this._allContactsSection.getScene());
      this._gotoState(STATES.DisplayingAllContacts);
    },

    groupFilterSelected: function(data) {
      this._window.displayBrowseContactsWithGroupData(data);
      this._gotoState(STATES.DisplayingAllContacts);
    },

    listFilterSelected: function(data) {
      this._window.displayBrowseContactsWithListData(data);
      this._gotoState(STATES.DisplayingAllContacts);
    }
  },

  FindFacebookContact: {
    addContact: function(contactSnapshot) {
      this._window.displayScene(
        this._createNewContactSection.getScene(contactSnapshot));
      this._gotoState(STATES.CreateNewContact);
    },

    contactSuccessfullyCreated: function(contact) {
      this._window.displayScene(this._allContactsSection.getScene());
      this._gotoState(STATES.DisplayingAllContacts);
    },

    cancel: function() {
      this._window.displayScene(this._allContactsSection.getScene());
      this._gotoState(STATES.DisplayingAllContacts);
    }
  },

  CreateNewContact: {
    contactSuccessfullyCreated: function(contact) {
      this._window.displayScene(this._allContactsSection.getScene());
      this._gotoState(STATES.DisplayingAllContacts);
    },

    cancel: function() {
      this._window.displayScene(this._allContactsSection.getScene());
      this._gotoState(STATES.DisplayingAllContacts);
    }
  },

  DisplayingSingleContactInformation: {
    edit: function(contactSnapshot) {
      this._window.displayScene(
        this._editContactSection.getScene(contactSnapshot));
      this._gotoState(STATES.EditingContact);
    },

    back: function() {
      this._window.displayScene(this._allContactsSection.getScene());
      this._gotoState(STATES.DisplayingAllContacts);
    }
  },

  EditingContact: {
    contactSuccessfullyUpdated: function(contact) {
      this._window.displayScene(this._allContactsSection.getScene());
      this._gotoState(STATES.DisplayingAllContacts);
    },

    contactSuccessfullyDeleted: function() {
      this._window.displayScene(this._allContactsSection.getScene());
      this._gotoState(STATES.DisplayingAllContacts);
    },

    cancel: function() {
      this._window.displayScene(this._displayContactSection.getScene());
      this._gotoState(STATES.DisplayingSingleContactInformation);
    }
  }
};

var ContactsTransitionManager = function(window) {
  this._window = window;
  this._currentEvents = [];
  this._setupSections();
  this._gotoState(STATES.InitialLoad);
};

var Broker = require('shared/shadowbroker/broker').Broker;
var ContactsStoreClient = require('./client/store_client').ContactsStoreClient;

ContactsTransitionManager.prototype = {
  _setupSections: function() {
    //TODO: Clean up this creation
    var worker = new SharedWorker('/apps/talk/contacts_worker.js');
    var broker = new Broker(worker.port);
    var domainClient = new ContactsDomainClient(broker);
    var contactsClient = new ContactsStoreClient(broker);

    this._allContactsSection = new AllContactsSection(contactsClient);
    this._allContactsSection.addListener(this);

    this._findFacebookContactSection = new FindFacebookContactSection();
    this._findFacebookContactSection.addListener(this);

    this._createNewContactSection = new CreateNewContactSection(domainClient);
    this._createNewContactSection.addListener(this);

    this._displayContactSection = new DisplayContactSection();
    this._displayContactSection.addListener(this);

    this._editContactSection = new EditContactSection(domainClient);
    this._editContactSection.addListener(this);
  },

  _gotoState: function(state) {
    this._removeCurrentEvents();
    this._clearCurrentEvents();
    this._setupStateEvents(state);
  },

  _removeCurrentEvents: function() {
    for (var i = 0; i < this._currentEvents.length; i++) {
      this[this._currentEvents[i]] = undefined;
    }
  },

  _setupStateEvents: function(state) {
    for (var key in state) {
      this[key] = state[key];
      this._currentEvents.push(key);
    }
  },

  _clearCurrentEvents: function() {
    this._currentEvents = [];
  }
};

exports.ContactsTransitionManager = ContactsTransitionManager;
});

// module: photos/app/lib/view/album_list_scene/index
// file:   ../../photos/app/lib/view/album_list_scene/index.js
define("photos/app/lib/view/album_list_scene/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core                  = require('bolt/core');
var util                  = require('bolt/util');
var View                  = require('bolt_touch/view').View;
var Scene                 = require('bolt_touch/views/scene').Scene;
var ScrollView            = require('bolt_touch/views/scroll_view').ScrollView;
var DataList              = require('bolt_touch/views/data_list').DataList;
var Actionable            = require('bolt_touch/mixins/actionable').Actionable;
var DeferredList          = require('shared/deferred').DeferredList;
var Thumbnail             = require('../thumbnail').Thumbnail;
var AlbumScene            = require('../album_scene').AlbumScene;
var UnpublishedAlbumScene = require('../unpublished_album_scene').UnpublishedAlbumScene;
var VideoListScene        = require('../video_list_scene').VideoListScene;
var Loader                = require('../loader').Loader;
var Photo                 = require('../../model/photo/photo').Photo;
var albumClient           = require('../../client/album_client').getInstance();
var photoClient           = require('../../client/photo_client').getInstance();
var photos_constants      = require('../../controller/constants');

var AlbumListRow = exports.AlbumListRow = core.createClass({
  name: 'AlbumListRow',

  extend: View,

  mixins: [Actionable],

  properties: {
    model: null
  },

  delegateProperties: {
    name: [{alias: 'name', name: 'content'}]
  },

  declare: function(options) {
    return {
      boxOrientation: 'horizontal',
      childViews: [
        {
          view: Thumbnail,
          ref: 'thumbnail'
        },
        {
          className: 'details',
          flex: 1,
          boxOrientation: 'vertical',
          childViews: [
            {
              ref: 'name',
              className: 'name'
            },
            {
              ref: 'count',
              className: 'count'
            }
          ]
        }
      ]
    };
  },

  doAction: function() {
    this.invoke('rowTouched', {
      view: this,
      album: this.get('model')
    });
  },

  setModel: function(model) {
    this.set('model', model);

    // TODO: It might make sense to have a Thumbnail class that just takes the
    // source of the image and then extend it with a PhotoThumbnail class that
    // takes a photo model. That way, for situations like this, we don't have
    // to create a "fake" photo.
    var photo = new Photo({
      thumbnail_url: model.getCoverPhotoURL()
    });

    this.refs.thumbnail.setModel(photo);

    this.setBinding(model, [
      { property: 'name' },
      { property: 'count' }
    ]);
  },

  setCount: function(count) {
    this.refs.count.setContent(count + ' Photos');
  }
});

var AlbumListScene = exports.AlbumListScene = core.createClass({
  name: 'AlbumListScene',

  extend: Scene,

  declare: function() {
    return {
      boxOrientation: 'vertical',
      flex: 1,
      childViews:[
        {
          boxOrientation: 'horizontal',
          additionalClasses: 'bt-bar header',
          childViews: [
            {
              ref: 'title',
              content: 'Albums',
              additionalClasses: 'bt-bar-title',
              flex: 1
            }
          ]
        },
        {
          view: ScrollView,
          ref: 'scrollView',
          flex: 1,
          childViews: [
            {
              view: DataList,
              ref: 'dataList',
              animateChanges: true,
              createView: util.bind(this._dataListCreateView, this),
              updateView: util.bind(this._dataListUpdateView, this),
              doesEventTriggerRedraw: util.bind(this._dataListDoesEventTriggerRedraw, this)
            }
          ]
        },
        {
          view: Loader,
          ref: 'loader'
        }
      ]
    };
  },

  ready: function(options) {
    var deferredList = new DeferredList([
      photoClient.fetchPhotosByAlbumId(photos_constants.UNPUBLISHED_ALBUM_ID, null, 200),
      albumClient.fetchAlbumCollection()
    ]);
    deferredList.addCallback(this._fetchComplete, this);
  },

  destroy: function() {
    Scene.prototype.destroy.call(this);

    if (this._albums) {
      this._albums.removeListener('endUpdate', this._onAlbumEndUpdate, this);
    }
  },

  _fetchComplete: function(status, unpublishedPhotosResult, albumsResult) {
    this._unpublishedPhotos = unpublishedPhotosResult[1];
    this._albums = albumsResult[1];

    this._onAlbumEndUpdate();
    this._albums.listen('endUpdate', this._onAlbumEndUpdate, this);
    this.refs.dataList.setData(this._albums);
    this._albums.download(200);
  },

  // TODO: Let's do something smarter
  // startTransition: function(transition) {
  //   if (transition === 'in.reverse') {
  //     this._albums.download(200);
  //   }
  // },

  _onAlbumEndUpdate: function() {
    if (this._albums.length > 0) {
      this.refs.loader.hide();
    }
  },

  // DataList
  _dataListCreateView: function(model) {
    var albumListRow = new AlbumListRow({
      model: model
    });
    albumListRow.addListener('rowTouched', this._rowTouched, this);
    return albumListRow;
  },

  // DataList
  _dataListUpdateView: function(view, model) {
    view.setModel(model);
  },

  // DataList
  _dataListDoesEventTriggerRedraw: function(evt) {
    return evt.type === 'modelChanged';
  },

  _rowTouched: function(evt) {
    var album = evt.data.album;
    var type = album.get('type');

    var scene;
    if (type === 'unpublished') {
      if (!this._unpublishedPhotos) {
        return;
      }

      scene = {
        view: UnpublishedAlbumScene,
        photos: this._unpublishedPhotos,
        header: true,
        cameraButton: false
      };
    }
    else if (type === 'video') {
      scene = {
        view: VideoListScene
      };
    }
    else {
      scene = {
        view: AlbumScene,
        album: album
      };
    }

    this.getStack().push(scene, {
      transition: 'slide'
    });
  }
});
});

// module: audience_picker/audience_picker
// file:   ../../audience_picker/js/audience_picker.js
define("audience_picker/audience_picker", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var Collection             = require('bolt/collection').Collection;
var TableView              = require('bolt_touch/views/table_view').TableView;
var TableViewSectionHeader = require("bolt_touch/views/table_view").TableViewSectionHeader;
var AudienceCell           = require('./audience_cell').AudienceCell;
var AudienceConstants      = require('./audience_constants');
var core                   = require('bolt/core');
var Model                  = require('bolt/model').Model;
var util                   = require('bolt/util');
var Scene                  = require('bolt_touch/views/scene').Scene;
var View                   = require('bolt_touch/view').View;
var screen_dims            = require('shared/screen_constants').PHONE_DIMENSION;
var groupMemberStore =
  require('shared/data2/model/group/group_member_store').getInstance();
var session = require('shared/session');

var AudiencePicker = exports.AudiencePicker = core.createClass({
  name: 'AudiencePicker',

  extend: Scene,

  declare: function() {
    return {
      additionalClasses: 'bt-hidden',
      boxOrientation: 'vertical',
      height: '100%',
      childViews: [
        {
          additionalClasses: 'bt-bar',
          boxOrientation: 'horizontal',
          childViews: [
            {
              additionalClasses: 'bt-bar-button left bt-down-button',
              ontouchstart: '_goBack'
            },
            {
              additionalClasses: 'bt-bar-title',
              flex: 1,
              content: 'Audience'
            }
          ]
        },
        {
          flex: 1,
          view: TableView,
          additionalClasses: 'audience_picker_table',
          ref: 'table',
          stickySectionHeaders: true,
          bufferSize: 4
        }
      ]
    };
  },

  ready: function() {
    this._table = this.findRef('table');
    this._sections = [];
    this._sections.push({
      header: 'Audience',
      items: this._createPrivacyOptionCollection()
    });

    this.refreshHandler = util.bind(this._refresh, this);

    groupMemberStore.initialize()
      .then(groupMemberStore.fetchGroupMemberCollectionByUid,
        groupMemberStore,
        session.getUid())
      .addCallback(this._onGroupCollectionFetched, this);

    this._callback = null;
    this._selectedPrivacyId = null;
  },

  _onGroupCollectionFetched: function(collection) {
    this._sections.push({
      header: 'Groups',
      items: collection
    });
    this._tokens = [
      collection.listen('updated', this.refreshHandler),
      collection.listen('endUpdate', this.refreshHandler)
    ];
    collection.downloadHead(1000);
  },

  destroy: function() {
    if (this._tokens) {
      util.invoke(this._tokens, 'remove');
    }
    View.prototype.destroy.call(this);
  },

  show: function(cb, privacyId) {
    this._callback = cb;
    this._selectedPrivacyId = privacyId ? privacyId :
      AudienceConstants.PUBLIC_ID;

    // TODO: Make sure the picker gets the right height since we are using 100%
    // Another way of doing this is to set the height of the picker to
    // the correct screen dimensions in creation. That could be done after
    // exposing some API in java to get corret screen dimensions.
    // This should be coming soon.
    setTimeout(this.refreshHandler, 250);

    this.setStyle('webkitTransform', null);
  },

  hide: function() {
    // TODO: Once we can get exact screen dimension in windowmanager
    // instantiation. Remove the buffer.
    this.setStyle('webkitTransform',
      'translate3d(0,' + screen_dims.height + 'px,0)');
  },

  // Tableview Owner
  numberOfSections: function(tableView) {
    return this._sections.length;
  },

  heightForRowInSection: function(tableView, row, section) {
    return 63;
  },

  numberOfRowsInSection: function(tableView, section) {
    return this._sections[section].items.length;
  },

  cellForRowInSection: function(tableView, row, section) {
    var cell = tableView.dequeueReusableCellWithIdentifier('audience_cell');
    if (!cell) {
      cell = new AudienceCell({reuseIdentifier: 'audience_cell'});
    }

    var selected =
      this._sections[section].items.models[row].get('id') ==
        this._selectedPrivacyId;

    cell.setAudience(this._sections[section].items.models[row], selected);
    return cell;
  },

  viewForHeaderInSection: function(tableView, section, floatHeader) {
    var header = (
      floatHeader ?
      null :
      tableView.dequeueReusableCellWithIdentifier('header')
    );
    if (!header) {
      header = new TableViewSectionHeader({reuseIdentifier: 'header'});
    }
    header.setContent(this._sections[section].header);
    return header;
  },

  heightForSectionHeader: function(tableView, section) {
    return 24;
  },

  cellSelectedAtRowInSection: function(tableView, row, section, cell) {
    this._done(this._sections[section].items.models[row].get('id'));
  },

  _refresh: function() {
    this._table.refresh();
  },

  _createPrivacyOptionCollection: function() {
    if (this._privacyOptionCollection) {
      return this._privacyOptionCollection;
    }

    var privacyOptions = [
      {
        id: AudienceConstants.PUBLIC_ID,
        name: 'Public'
      },
      {
        id: AudienceConstants.FRIENDS_ID,
        name: 'Friends'
      },
      {
        id: AudienceConstants.SELF_ID,
        name: 'Only me'
      }
    ];

    var collection = new Collection();
    util.forEach(privacyOptions, function(privacyOption) {
      var model = new Model();
      model.setAll({
        id: privacyOption.id,
        name: privacyOption.name
      });
      collection.add(model);
    });

    // Cache this collection
    this._privacyOptionCollection = collection;

    return collection;
  },

  _goBack: function() {
    this._done(null);
  },

  _done: function(privacyId) {
    if (this._callback) {
      this._callback(privacyId ? privacyId : null);
    }
    this.hide();
  }
});

var audiencePicker = exports.audiencePicker = new AudiencePicker();
audiencePicker.hide();
audiencePicker.placeIn(document.body);
});

// module: photos/app/lib/view/grid_photo_viewer/index
// file:   ../../photos/app/lib/view/grid_photo_viewer/index.js
define("photos/app/lib/view/grid_photo_viewer/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core            = require('bolt/core');
var util            = require('bolt/util');
var builder         = require('bolt/builder');
var View            = require('bolt_touch/view').View;
var SpringAnimation = require('shared/springs').SpringAnimation;
var PhotoGrid       = require('../photo_grid').PhotoGrid;
var PhotoViewer     = require('../photo_viewer').PhotoViewer;

var SpringyScaleView = core.createClass({
  name: 'SpringyScaleView',

  extend: View,

  mixins: [SpringAnimation],

  properties: {
    scale: 1
  },

  springAnimation: {
    properties: ['scale'],
    ruleFunction: '_computeTransform'
  },

  ready: function() {
    this.springAnimation.animator._springs[0].updateProperties({
      tolerance: 0.0001
    });
  },

  shrink: function() {
    this.setScaleDirect(1);
    this.setScale(0.9);
    this.startSpringAnimationNow();
  },

  shrinkInstantly: function() {
    this.setScaleDirect(0.9);
  },

  expand: function() {
    this.setScaleDirect(0.9);
    this.setScale(1);
    this.startSpringAnimationNow();
  },

  expandInstantly: function() {
    this.setScaleDirect(1);
  },

  _computeTransform: function(values) {
    return {
      WebkitTransform:
        'scale3d(' + values.scale + ', ' + values.scale + ', 1)'
    };
  }
});

exports.GridPhotoViewer = core.createClass({
  name: 'GridPhotoViewer',

  extend: View,

  events: ['back', 'opened', 'photoSelected', 'tagSelected',
           'photoTouched', 'closing'],

  properties: {
    title: null,
    photos: null,
    selectable: false,
    startingIndex: null,
    header: true,
    showTags: false,
    closeOnTouch: true
  },

  declare: function() {
    return {
      boxOrientation: 'vertical',
      childViews: [
        {
          view: SpringyScaleView,
          ref: 'gridContainer',
          boxOrientation: 'vertical',
          flex: 1,
          childViews: [
            {
              ref: 'header',
              boxOrientation: 'horizontal',
              additionalClasses: 'bt-bar header',
              childViews: [
                {
                  additionalClasses: 'bt-bar-button left bt-back-button',
                  onclick: '_back'
                },
                {
                  ref: 'title',
                  additionalClasses: 'bt-bar-title',
                  flex: 1
                },
                {
                  className: 'bt-bar-button-placeholder'
                }
              ]
            },
            {
              view: PhotoGrid,
              ref: 'photoGrid',
              flex: 1,
              onthumbnailTouched: '_thumbnailTouched'
            }
          ]
        },
        {
          view: PhotoViewer,
          ref: 'photoViewer',
          getPhotoRect: util.bind(this._getPhotoRect, this),
          showPhoto: util.bind(this._showPhoto, this),
          hidePhoto: util.bind(this._hidePhoto, this),
          scrollToPhoto: util.bind(this._scrollToPhoto, this),

          onopened: '_photoViewerOpened',
          onphotoSelected: '_photoSelected',
          onphotoTouched: '_photoTouched',
          ontagTouched: '_tagTouched',
          onclosing: '_photoViewerClosing'
        }
      ]
    };
  },

  setTitle: function(title) {
    this.set('title', title);

    this.refs.title.setContent(title);
  },

  setHeader: function(header) {
    this.set('header', header);

    if (header) {
      this.refs.header.show();
      this.refs.photoGrid.addClass('header');
    }
    else {
      this.refs.header.hide();
      this.refs.photoGrid.removeClass('header');
    }
  },

  setShowTags: function(showTags) {
    this.set('showTags', showTags);

    if (showTags) {
      this.refs.photoViewer.showTags();
    }
    else {
      this.refs.photoViewer.hideTags();
    }
  },

  setCloseOnTouch: function(closeOnTouch) {
    this.set('closeOnTouch', closeOnTouch);
    this.refs.photoViewer.set('closeOnTouch', closeOnTouch);
  },

  load: function() {
    this.refs.photoGrid.set('photos', this.get('photos'));
    this.refs.photoGrid.load();

    if (this.get('startingIndex') !== null) {
      this.refs.photoViewer.openImmediately(
        this.get('photos'),
        this.get('startingIndex'),
        this.get('title'),
        this.get('selectable')
      );
    }
  },

  _back: function() {
    this.invoke('back');
  },

  _thumbnailTouched: function(evt) {
    // #EventCompatibilityHack
    if (typeof evt.data.index === 'undefined') {
      return;
    }

    this.refs.photoViewer.open(
      this.get('photos'),
      evt.data.index,
      this.get('title'),
      this.get('selectable')
    );
    this.refs.gridContainer.shrink();
  },

  _photoViewerOpened: function(evt) {
    this.refs.gridContainer.expandInstantly();

    // #EventCompatibilityHack
    if (!require('bolt/event_dispatcher').defaultEventDispatcher.getEnabled()) {
      this.invoke('opened', evt.data);
    }
  },

  _photoSelected: function(evt) {
    // #EventCompatibilityHack
    if (!require('bolt/event_dispatcher').defaultEventDispatcher.getEnabled()) {
      this.invoke('photoSelected', evt.data);
    }
  },

  _tagTouched: function(evt) {
    // #EventCompatibilityHack
    if (!require('bolt/event_dispatcher').defaultEventDispatcher.getEnabled()) {
      this.invoke(evt.type, evt.data);
    }
  },

  _photoTouched: function(evt) {
    // #EventCompatibilityHack
    if (!require('bolt/event_dispatcher').defaultEventDispatcher.getEnabled()) {
      this.invoke('photoTouched', evt.data);
    }
  },

  _photoViewerClosing: function(evt) {
    this.refs.gridContainer.expand();

    // #EventCompatibilityHack
    if (!require('bolt/event_dispatcher').defaultEventDispatcher.getEnabled()) {
      this.invoke('closing', evt.data);
    }
  },

  // PhotoViewer
  _getPhotoRect: function(index) {
    return this.refs.photoGrid.getPhotoRect(index);
  },

  // PhotoViewer
  _showPhoto: function(index) {
    this.refs.photoGrid.showPhoto(index);
  },

  // PhotoViewer
  _hidePhoto: function(index) {
    this.refs.photoGrid.hidePhoto(index);
  },

  // PhotoViewer
  _scrollToPhoto: function(index) {
    this.refs.photoGrid.scrollToPhoto(index);
  }
});
});

// module: mock/telephony_api
// file:   ../../mock/js/telephony_api.js
define("mock/telephony_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;

var DATA_CONNECTED = 2;
var NETWORK_TYPE_HSDPA = 8;

module.exports = {

  // State

  _line1PhoneNumber: '12345678900',
  _voiceMailNumber: '18887654321',
  _airplaneMode: false,
  _mobileData: true,
  _dataRoaming: false,
  _dataState: DATA_CONNECTED,
  _signalStrength: 19,
  _isRoaming: false,
  _networkName: 'Corona',
  _networkNameShort: 'Crna',
  _networkType: NETWORK_TYPE_HSDPA,
  _ttyMode: false,
  _callForwardingState: false,
  _umtsRscp: 72,
  _umtsEcno: 12,

  // Constants

  NETWORK_TYPE_UNKNOWN: 0,
  NETWORK_TYPE_GPRS: 1,
  NETWORK_TYPE_EDGE: 2,
  NETWORK_TYPE_EHRPD: 14,
  NETWORK_TYPE_UMTS: 3,
  NETWORK_TYPE_HSDPA: 8,
  NETWORK_TYPE_HSUPA: 9,
  NETWORK_TYPE_HSPA: 10,
  NETWORK_TYPE_CDMA: 4,
  NETWORK_TYPE_EVDO_0: 5,
  NETWORK_TYPE_EVDO_A: 6,
  NETWORK_TYPE_EVDO_B: 12,
  NETWORK_TYPE_1xRTT: 7,
  NETWORK_TYPE_IDEN: 11,
  NETWORK_TYPE_LTE: 13,

  SERVICE_STATE_IN_SERVICE: 0,
  SERVICE_STATE_OUT_OF_SERVICE: 1,
  SERVICE_STATE_EMERGENCY_ONLY: 2,
  SERVICE_STATE_POWER_OFF: 3,

  DATA_DISCONNECTED: 0,
  DATA_CONNECTING: 1,
  DATA_CONNECTED: 2,
  DATA_SUSPENDED: 3,

  // Methods

  _broadcastStateChange: function() {
    EventManager.broadcastEvent('telephony.STATE_CHANGED', {
      operatorName: this._networkName,
      operatorNameShort: this._networkNameShort,
      networkType: this.getNetworkType(),
      isRoaming: this.isRoaming(),
      state: this.getServiceState(),
      mmCauseCode: -1,
      number: this.getLine1PhoneNumber()
    });
  },

  isAirplaneModeEnabled: function() {
    return this._airplaneMode;
  },

  setIsAirplaneModeEnabled: function(enable) {
    var _this = this;
    this._airplaneMode = enable;
    setTimeout(
      function() {
        EventManager.broadcastEvent('telephony.AIRPLANE_MODE_CHANGED', {
          enabled: enable
        });
        _this._broadcastStateChange();
      },
      2 * 1000);
    return true;
  },

  toggleAirplaneMode: function() {
    return this.setIsAirplaneModeEnabled(!this._airplaneMode);
  },

  isMobileDataEnabled: function() {
    return this._mobileData;
  },

  setIsMobileDataEnabled: function(enable) {
    var _this = this;
    setTimeout(
      function() {
        _this._mobileData = enable;
        EventManager.broadcastEvent('telephony.MOBILE_DATA_SETTING_CHANGED', {
          enabled: enable
        });
      },
      2 * 1000);
    return true;
  },

  toggleMobileData: function() {
    return this.setIsMobileDataEnabled(!this._mobileData);
  },

  isDataRoamingEnabled: function() {
    return this._dataRoaming;
  },

  setIsDataRoamingEnabled: function(enable) {
    this._dataRoaming = enable;
    return true;
  },

  toggleDataRoaming: function() {
    return this.setIsDataRoamingEnabled(!this._dataRoaming);
  },

  isTtyActive: function() {
    // Note: For the purposes of the mock, active <=> enabled.
    return this._ttyMode;
  },

  isTtyEnabled: function() {
    return this._ttyMode;
  },

  setIsTtyEnabled: function(enable) {
    this._ttyMode = enable;
    setTimeout(function() {
      EventManager.broadcastEvent("telephony.TTY_CHANGED", {
        enabled: enable
      });
    }, 500);
    return true;
  },

  toggleTty: function() {
    return this.setIsTtyEnabled(!this._ttyMode);
  },

  getDataActivity: function() {
    return 0;
  },

  getDataState: function() {
    return this._dataState;
  },

  getGsmSignalStrength: function() {
    var signal = {
      networkType: this._networkType,
      signalStrength: this._signalStrength,
      umtsRscp: this._umtsRscp,
      umtsEcno: this._umtsEcno
    };
    return JSON.stringify(signal);
  },

  // Exists only in mock
  _setGsmSignalStrength: function(signalStrength) {
    this._signalStrength = signalStrength;
    this._umtsRscp = 120 - 2 * signalStrength;
    this._umtsEcno = 25 - signalStrength;

    EventManager.broadcastEvent("telephony.SIGNAL_CHANGED", {
      networkType: this._networkType,
      signalStrength: this._signalStrength,
      umtsRscp: this._umtsRscp,
      umtsEcno: this._umtsEcno
    });
  },

  getLine1PhoneNumber: function() {
    return this._line1PhoneNumber;
  },

  setLine1PhoneNumber: function(number) {
    this._line1PhoneNumber = number;
  },

  getNetworkCountry: function() {
    return 'us';
  },

  getNetworkName: function() {
    return this._networkName;
  },

  getNetworkNameShort: function() {
    return this._networkNameShort;
  },

  // Exists only in mock
  _setNetworkName: function(name) {
    this._networkName = name;
    this._broadcastStateChange();
  },

  getServiceState: function() {
    if (this._airplaneMode) {
      return 3; // SERVICE_STATE_POWER_OFF
    } else {
      return 0; // IN_SERVICE
    }
  },

  getGprsState: function() {
    if (this._airplaneMode) {
      return 3; // SERVICE_STATE_POWER_OFF
    } else {
      return 0; // IN_SERVICE
    }
  },

  _setCallForwardingState: function(enabled) {
    this._callForwardingState = enabled;
    EventManager.broadcastEvent('telephony.CALL_FORWARDING_STATE_CHANGED', {
      callForwardingState: enabled
    });
  },

  getCallForwardingState: function() {
    return this._callForwardingState;
  },

  getVoiceMailState: function() {
    return false;
  },

  getVoiceMailNumber: function() {
    return this._voiceMailNumber;
  },

  setVoiceMailNumber: function(number) {
    this._voiceMailNumber = number;
  },

  isRoaming: function() {
    return this._isRoaming;
  },

  getNetworkType: function() {
    return this._networkType;
  },

  _setNetworkType: function(networkType) {
    this._networkType = networkType;
    EventManager.broadcastEvent("telephony.STATE_CHANGED", {
      operatorName: this._networkName,
      operatorNameShort: this._networkNameShort,
      networkType: this.getNetworkType(),
      isRoaming: this.isRoaming(),
      state: this.getServiceState(),
      mmCauseCode: -1,
      number: this.getLine1PhoneNumber()
    });
  },

  getImei: function() {
    return '111222333444555';
  },

  getImeiSoftwareVersion: function() {
    return '01';
  },

  getBasebandVersion: function() {
    return '0.1133.03.00';
  }
};
});

// module: photos/app/lib/model/photo/photo_store
// file:   ../../photos/app/lib/model/photo/photo_store.js
define("photos/app/lib/model/photo/photo_store", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');

var Deferred           = require('shared/deferred').Deferred;
var StoreWithBroadcast =
  require('shared/data2/store/store_with_broadcast').StoreWithBroadcast;
var Schema             = require('shared/data2/store/schema').Schema;
var Filter             = require('shared/data2/store/filter').Filter;
var TypeInteger        = require('shared/data2/store/schema/type/integer').TypeInteger;

var Photo              = require('./photo').Photo;
var constants          = require('../../controller/constants');
var PHOTO_STATE        = constants.PHOTO_STATE;
var MEDIA_TYPE         = constants.MEDIA_TYPE;
var PhotoRemoteMapper  = require('./photo_remote_mapper').PhotoRemoteMapper;
var PhotoLocalMapper   = require('./photo_local_mapper').PhotoLocalMapper;

function createSchema() {
  return new Schema(
    {
      id: {
        localType: 'TEXT PRIMARY KEY',
        searchable: true,
        remote: false
      },
      fbid: {
        searchable: true,
        remote: 'object_id'
      },
      pid: {
        searchable: true,
        remote: 'pid'
      },
      owner: {
        remote: 'owner'
      },
      state: {
        searchable: true,
        remote: false
      },
      path: {
        searchable: true,
        remote: false
      },
      thumb: {
        searchable: true,
        remote: false
      },
      type: {
        searchable: true,
        remote: false
      },
      created_time: {
        remote: 'created'
      },
      updated_time: {
        remote: 'modified'
      },
      width: new TypeInteger({
        remote: 'src_big_width'
      }),
      height: new TypeInteger({
        remote: 'src_big_height'
      }),
      name: {
        remote: 'caption'
      },
      thumbnail_url: {
        remote: false
      },
      full_url: {
        remote: 'src_big'
      },
      position: {
        searchable: true,
        transformRemoteToModel: function(data) {
          return parseInt(data, 10);
        }
      },
      album_id: {
        searchable: true,
        remote: 'album_object_id'
      },
      likes: {
        remote: 'like_info',
        transformRemoteToModel: function(data) {
          return {
            can_like: data.can_like,
            user_likes: data.user_likes,
            count: parseInt(data.like_count, 10)
          };
        }
      },
      comments: {
        remote: 'comment_info',
        transformRemoteToModel: function(data) {
          return {
            can_post: data.can_comment,
            count: parseInt(data.comment_count, 10)
          };
        }
      },
      tags: {
        remote: false
      },
      // 'none' || 'thumbnail' || 'full'
      cacheState: {
        remote: false,
        local: false
      }
    },
    Photo
  );
}

function createLocalMapper(schema) {
  return new PhotoLocalMapper(schema);
}

function createRemoteMapper(schema, apiRequester) {
  return new PhotoRemoteMapper(schema, null, apiRequester);
}

var PhotoStore = exports.PhotoStore = core.createClass({
  name: 'PhotoStore',
  extend: StoreWithBroadcast,

  properties: {
    modelType: Photo
  },

  _downloaded: function(models) {
    return this._importDownloadedModels(models);
  },

  _importDownloadedModels: function(models) {
    if (!models || !models.length) {
      return (new Deferred()).succeed(models);
    } else {
      var fbids = models.map(function(model) {
        return model.get('fbid');
      });

      return this.fetchCollection({ fbid: fbids }, fbids.length)
        .then(this._mergeDownload, this, models);
    }
  },

  _mergeDownload: function(models, existingCollection) {
    models.forEach(function(model) {
      var existing = existingCollection.find(function(existingModel) {
        return existingModel.get('fbid') === model.get('fbid');
      });

      if (existing) {
        model.set('path', existing.get('path'));
        model.set('thumb', existing.get('thumb'));
        model.set('id', existing.get('id'));
        model.set('tags', existing.get('tags'));
        model.set('type', existing.get('type'));
      } else {
        model.set('type', MEDIA_TYPE.PHOTO);
      }

      model.set('state', PHOTO_STATE.SYNCED);

      // TODO: handle remotely-deleted photes
    });

    existingCollection.destroy();
    return this.store(models);
  },

  fetchPhotoByFbid: function(fbid) {
    return this.fetchCollection({ fbid: fbid }, 1);
  },

  /**
   * @param {string} pid The ID of the photo being queried.
   *   @see https://developers.facebook.com/docs/reference/fql/photo
   */
  fetchPhotoByPid: function(pid) {
    return this.fetchCollection({ pid: pid }, 1);
  },

  fetchPhotosByIds: function(ids) {
    return this.fetchCollection({ id: ids }, 200);
  },

  fetchPhotosByAlbumId: function(albumId, updatedTime, limit) {
    var order = (albumId === constants.UNPUBLISHED_ALBUM_ID ? 'position DESC' : 'position ASC');
    var filter = new Filter({album_id: albumId}, order);

    var query = 'album_object_id="' + albumId + '"';
    if (updatedTime) {
      query += ' AND modified>"' + updatedTime + '"';
    }

    filter.set('FQLQuery', query);

    return this.fetchCollection(filter, limit);
  },

  deletePhotosByAlbumId: function(albumId) {
    var deferred = new Deferred();

    this.fetchPhotosByAlbumId(albumId)
      .addCallback(function(photos) {
        var photoIds = photos.map(function(photo) {
          return photo.get('id');
        });

        this.remove(photoIds).then(function() {
          deferred.succeed();
        }, this);
      }, this);

    return deferred;
  },

  getPhotosByPath: function(path) {
    return this.fetchCollection({ path: path }, 1);
  }
});

var _instance = null;
exports.createLocalMapper = createLocalMapper;
exports.createRemoteMapper = createRemoteMapper;
exports.createSchema = createSchema;
exports.getInstance = function(remoteMapper, localMapper, schema) {
  if (!_instance) {
    schema = schema || createSchema();
    localMapper = localMapper || createLocalMapper(schema);
    remoteMapper = remoteMapper || createRemoteMapper(schema);
    _instance = new PhotoStore(remoteMapper, localMapper, schema);
  }
  return _instance;
};
});

// module: shared/data/store_meta
// file:   ../../shared/js/data/store_meta.js
define("shared/data/store_meta", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core           = require('bolt/core');
var util           = require('bolt/util');
var Deferred       = require('shared/deferred').Deferred;
var SqlTransaction = require('shared/data/sql_transaction').SqlTransaction;
var EventManager   = require('shared/event_manager').EventManager;

// Need to ensure that the EventManager is set up in advance, can't rely
// on the page to do it.
require('shared/init');

var _storeVersions = {};

var STORE_META_NAME = 'store_meta';
var STORE_SET_STORE_VERSION_EVENT = 'storeMetaSetStoreVersion';
var STORE_META_VERSION = 1.1;
var STORE_VERSION_UNDEFINED = -1;
var UNKNOWN_SEQ = -1;

function _insertStoreMeta(tx, name, version, result) {
  if (0 === result.rowsAffected) {
    return tx.executeSql(
      'INSERT INTO ' + STORE_META_NAME + ' (name,version) VALUES (?,?)',
      [name, version]
    );
  } else {
    return new Deferred().succeed();
  }
}

function _setStoreVersion(tx, name, version) {
  // Technically we should wait for the tx success but there would be a race
  // condition if we put this into tx.addSuccessCallback and the
  // _storeVersions is working as a cache only so setting it prematurely would
  // only lead to another revision mismatching in rare case (we changed the
  // revision and the tx fail) which can be recovered
  _storeVersions[name] = version;
  EventManager.broadcastEvent(
    STORE_SET_STORE_VERSION_EVENT,
    {
      name: name,
      version: version
    }
  );

  tx = tx || (new SqlTransaction());
  return tx.executeSql(
    'UPDATE ' + STORE_META_NAME + ' SET version=? WHERE name=?',
    [version, name]
  )
  .then(_insertStoreMeta, null, tx, name, version);
}

function _createStoreMeta(tx) {
  return tx.executeSql('CREATE TABLE IF NOT EXISTS ' + STORE_META_NAME +
    ' (name unique, version, head_seq DEFAULT "", tail_seq DEFAULT "")');
}

function _resetStoreMeta(tx) {
  return tx.executeSql('DROP TABLE IF EXISTS ' + STORE_META_NAME)
    .then(_createStoreMeta, null, tx)
    .then(_setStoreVersion, null, tx, STORE_META_NAME,
      STORE_META_VERSION);
}

function _checkStoreMetaVersion(tx) {
  return _createStoreMeta(tx)
    .then(function(tx) {
      return tx.executeSql('SELECT version, name FROM ' + STORE_META_NAME);
    }, null, tx)
    .then(function(tx, result) {
      if (result && result.rows) {
        var row;
        for (var i = 0, l = result.rows.length; i < l; ++i) {
          row = result.rows.item(i);
          _storeVersions[row.name] = row.version;
        }
        if (_storeVersions[STORE_META_NAME] === STORE_META_VERSION) {
          return new Deferred().succeed();
        } else {
          return _resetStoreMeta(tx);
        }
      } else {
        return _resetStoreMeta(tx);
      }
    }, null, tx);
}

function _getSingleRow(result) {
  return (
    result && result.rows && result.rows.length ?
    result.rows.item(0) :
    null
  );
}

function _parseSeq(value, syncerName) {
  try {
    var syncerSeqs = JSON.parse(value);
    var seq = JSON.parse(syncerSeqs[syncerName]);
    return (util.isBlank(seq) ? UNKNOWN_SEQ : seq);
  } catch (e) {
    return UNKNOWN_SEQ;
  }
}

function _setStoreVersionEventHandler(evt) {
  _storeVersions[evt.name] = evt.version;
}

/**
 * Store meta data (generally only used directly by StoreBase)
 */
var StoreMeta = exports.StoreMeta = new (core.createClass({
  name: 'StoreMeta',
  extend: Deferred,

  construct: function() {
    Deferred.apply(this, arguments);

    EventManager.listen(
      STORE_SET_STORE_VERSION_EVENT,
      _setStoreVersionEventHandler
    );

    // self-inspecting the store_meta table's version
    // and re-initiate the whole storage if the store_meta's revision
    // is changed.
    //
    // this approach has a race condition when running with mutliple webview
    // but it should be safe as the last transaction write to reset_store_meta
    // would always make the store_meta into the right revision
    //
    var tx = new SqlTransaction();
    tx.addTransactionCallback(util.bind(this.succeed, this))
      .addTransactionErrback(util.bind(this.fail, this));
    _checkStoreMetaVersion(tx);
  },

  getStoreVersion: function(name) {
    return _storeVersions[name] || STORE_VERSION_UNDEFINED;
  },

  setStoreVersion: function(tx, name, version) {
    return _setStoreVersion(tx, name, version);
  },

  resetStore: function(tx) {
    _resetStoreMeta(tx);
  },

  clearStoreSyncSequence: function(tx, storeName) {
    return tx.executeSql(
      'UPDATE ' + STORE_META_NAME +
        ' SET head_seq = "", tail_seq = "" WHERE name = ?',
      [storeName]
    );
  },

  getStoreSyncSequence: function(tx, storeName, syncerName) {
    return tx.executeSql(
      'SELECT head_seq, tail_seq FROM ' + STORE_META_NAME + ' WHERE name=?',
      [storeName]
    ).then(this._processSequence, this, syncerName);
  },

  _processSequence: function(syncerName, result) {
    var data = {
      head_seq: UNKNOWN_SEQ,
      tail_seq: UNKNOWN_SEQ
    };

    var row = _getSingleRow(result);
    if (row) {
      data.head_seq = _parseSeq(row.head_seq, syncerName);
      data.tail_seq = _parseSeq(row.tail_seq, syncerName);
    }

    return data;
  },

  setStoreSyncSequence: function(tx, storeName, syncerName, head, tail) {
    return tx.executeSql(
      'SELECT head_seq, tail_seq FROM ' + STORE_META_NAME + ' WHERE name=?',
      [storeName]
    ).then(this._storeSequence,
      this,
      tx,
      storeName,
      syncerName,
      JSON.stringify(head),
      JSON.stringify(tail));
  },

  _storeSequence: function(tx, storeName, syncerName, head, tail, result) {
    var syncerHeads, syncerTails;
    var row = _getSingleRow(result);
    if (row) {
      syncerHeads = row.head_seq ? JSON.parse(row.head_seq) : {};
      syncerTails = row.tail_seq ? JSON.parse(row.tail_seq) : {};
    } else {
      syncerHeads = {};
      syncerTails = {};
    }

    syncerHeads[syncerName] = head;
    syncerTails[syncerName] = tail;

    return tx.executeSql(
      'UPDATE ' + STORE_META_NAME + ' SET head_seq=?, tail_seq=? WHERE name=?',
      [JSON.stringify(syncerHeads), JSON.stringify(syncerTails), storeName]
    );
  }
}))();

exports.StoreMeta.STORE_VERSION_UNDEFINED = STORE_VERSION_UNDEFINED;
});

// module: view/threads_scene/threads_scene
// file:   view/threads_scene/threads_scene.js
define("view/threads_scene/threads_scene", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*global buffyChrome:false */

var util = require('bolt/util');
var core = require('bolt/core');

var Scene          = require('bolt_touch/views/scene').Scene;
var ActionableView = require('bolt_touch/views/actionable_view').ActionableView;
var Mailbox        = require('shared/model/mailbox').Mailbox;
var EventManager   = require('shared/event_manager').EventManager;
var ThreadList     = require('view/thread_list/thread_list').ThreadList;
var dialogUtil     = require('shared/dialogs');

var VISIBLE_ROWS = 7;
var MAX_THREAD_PRELOAD = 3;

var ThreadsScene = core.createClass({
  name: 'ThreadsScene',
  extend: Scene,

  properties: {
    controller: null,
    mailbox: null
  },

  delegateProperties: {
    'list': ['collection']
  },

  declare: function() {
    return {
      flex: 1,
      boxOrientation: 'vertical',
      className: 'talkThreadsScene',
      childViews: [
        {
          boxOrientation: 'horizontal',
          className: 'bt-bar',
          childViews: [
            {
              className: 'bt-bar-button left bt-filter-button',
              view: ActionableView,
              action: '_onMailboxFilter',
              ref: 'filterBtn',
              id: 'filterBtn'
            },
            {
              ref: 'title',
              className: 'bt-bar-title',
              content: 'Recents',
              flex: 1
            },
            {
              id: 'messageComposerBtn',
              className: 'bt-bar-button right bt-plus-button',
              owner: this,
              view: ActionableView,
              action: '_onMessageComposer'
            }
          ]
        },
        {
          view: ThreadList,
          onselection: '_onselection',
          ref: 'list'
        }
      ]
    };
  },

  ready: function() {
    EventManager.listen('dialog.RESULT_RECEIVED', this._changeMailbox, this);
  },

  activate: function() {
    this.findRef('list').refreshRemote();
    this.setSceneLink();
  },

  setSceneLink: function() {
    var mailbox = this.getMailbox();
    if (mailbox) {
      for (var i in Mailbox.MAILBOXES) {
        if (Mailbox.MAILBOXES[i] == mailbox) {
          this.getController().setSceneLink({scene: 'threads', mailbox: i});
          return;
        }
      }
    }
  },

  setMailbox: function(mailbox) {
    this.set('mailbox', mailbox);
    this.setSceneLink();

    if (mailbox.folder === 'inbox') {
      this.findRef('title').setContent('Recents');
    } else {
      this.findRef('title').setContent(mailbox.title);
    }

    this._preloadThreads = null;
    var threadClient = require('talk/client/thread_client').getInstance();

    threadClient
      .fetchLastThreads(mailbox.key, 30)
      .addCallback(function(collection) {
        // If the user makes another choice of mailbox while the original one
        // was loading, ignore the load
        if (mailbox !== this.getMailbox()) {
          return;
        }
        this._handleMailboxLoad(collection);
      }, this);
  },

  _handleMailboxLoad: function(collection) {
    this.findRef('list')
      .setMailbox(this.getMailbox())
      .setCollection(collection);

    // Pick a max of three threads to preload
    var preloadThreads = [];

    var thread;
    var i;

    // Only preload rows that are on screen, currently we fit 7 items on screen
    var lookAhead = Math.min(collection.length, VISIBLE_ROWS);

    for (i = 0; i < lookAhead &&
        preloadThreads.length < MAX_THREAD_PRELOAD; i++) {
      thread = collection.at(i);

      if (thread.isUnread()) {
        preloadThreads.push(thread);
      }
    }

    // If we have not found enough unread threads on screen, load from the top
    if (preloadThreads.length < MAX_THREAD_PRELOAD) {
      for (i = 0; i < lookAhead &&
          preloadThreads.length < MAX_THREAD_PRELOAD; i++) {
        thread = collection.at(i);

        if (!thread.isUnread()) {
          preloadThreads.push(thread);
        }
      }
    }

    this._preloadThreads = preloadThreads;

    // If we have any threads at all, preload the first.
    // The preloaded threads will be loaded in serial.
    this._loadNextThread();
  },

  /**
   * Load the next thread to be preloaded
   */
  _loadNextThread: function() {
    if (this._preloadThreads && this._preloadThreads.length > 0) {
      var thread = this._preloadThreads.splice(0, 1)[0];

      this.getController()
        .loadThread(thread).addCallback(this._loadNextThread, this);
    }
  },

  _onselection: function(e) {
    var thread = this.getCollection().at(e.data.index);
    if (thread.get('localData').voicemailAction) {
      var action = thread.get('localData').voicemailAction;
      if (action === 'call') {
        var sharedUtil = require('shared/util');
        sharedUtil.makeCall('voicemail');
      } else {
        var url = 'fbcf:///apps/settings/index.html' + action;
        window.openTab(url);
      }
    } else {
      // Cancel all further preloading of messages, in order to optimize
      // the data fetching of whatever the user selected.
      this._preloadThreads = null;

      this.getController().openMessages(thread);
    }
  },

  _onMailboxFilter: function() {
    this._mailboxDialogId = dialogUtil.createDialog();
    dialogUtil.appendText(this._mailboxDialogId, 'Select mailbox:',
      'font-weight: bold; font-size: 20pt; text-align: center; ' +
      'display: block; padding-top:25px; padding-bottom: 25px; ' +
      'background-color: #DDD');
    var actions = [];
    this._mailboxesData = util.values(Mailbox.MAILBOXES);

    // 0 is reservered for background cancelling in dialogs
    for (var i = 0; i < this._mailboxesData.length; i++) {
      actions.push({value: this._mailboxesData[i].title, result: i + 1});
    }

    dialogUtil.showModalDialog(this._mailboxDialogId, actions);
  },

  _changeMailbox: function(data) {
    if (data.id == this._mailboxDialogId &&
        data.result > 0 &&
        this.getMailbox() != this._mailboxesData[data.result - 1]) {
      this.setMailbox(this._mailboxesData[data.result - 1]);
    }
    delete this._mailboxDialogId;
  },

  _onMessageComposer: function(e) {
    this.getController().openMessageComposer();
  }

});

exports.ThreadsScene = ThreadsScene;
});

// module: views/picker/album_picker/picker_album_scene
// file:   ../../views/picker/album_picker/picker_album_scene.js
define("views/picker/album_picker/picker_album_scene", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core              = require('bolt/core');
var Scene             = require('bolt_touch/views/scene').Scene;
var ScrollView        = require('bolt_touch/views/scroll_view').ScrollView;
var util              = require('bolt/util');

var PickerSelectedThumbnailCollectionView =
  require('./picker_view').PickerSelectedThumbnailCollectionView;
var PickerAlbumThumbnailCollectionView =
  require('./picker_view').PickerAlbumThumbnailCollectionView;

var PickerAlbumScene = exports.PickerAlbumScene = core.createClass({
  name: 'PickerAlbumScene',

  extend: Scene,

  properties: {
    album: null
  },

  statics: {
    MAX_TITLE_LENGTH: 17
  },

  declare: function(options) {
    this.callback = options.callback;
    this.selectedPhotosCollection = options.photosCollection;
    this.photoTouchCallback = options.photoTouchCallback;
    return {

      additionalClasses: 'bt-album-scene',
      boxOrientation: 'vertical',
      flex: 1,

      childViews: [
        {
          boxOrientation: 'horizontal',
          additionalClasses: 'bt-bar',
          childViews: [
            {
              ref: 'backBtn',
              additionalClasses: 'bt-bar-button left bt-back-button'
            },
            {
              ref: 'title',
              additionalClasses: 'bt-bar-title',
              flex: 1
            },
            {
              ref: 'doneBtn',
              additionalClasses:
                'bt-bar-button right bt-text-button bt-done-button',
              content: 'DONE'
            }
          ]
        },
        {
          ref: 'photoCounter',
          content: 'Photos Selected (0)',
          additionalClasses: 'photo-counter'
        },
        {
          view: ScrollView,
          ref: 'selectedPhotosScroller',
          hScroll: true,
          vScroll: false,
          boxOrientation: 'horizontal',
          additionalClasses: 'selected-photos-collection',
          childViews: [
            {
              ref: 'selectedPhotosCollection',
              view: 'PickerSelectedThumbnailCollectionView',
              thumbnailTouchStart: util.bind(this._photoTouched, this)
            }
          ]
        },
        {
          view: ScrollView,
          ref: 'scroller',
          additionalClasses: 'album_scene_thumbnail_scroller',
          flex: 1,
          childViews: [

            {
              ref: 'thumbnailCollection',
              view: 'PickerAlbumThumbnailCollectionView',
              thumbnailTouchStart: util.bind(this._photoTouched, this)
            }
          ]
        }
      ]
    };
  },

  collectionViewDidInsertChildView: function() {
    //TODO: Figure out why this is necessary. It appears that refreshScrollView
    //runs before the view is actually placed in the collectionview, so refresh
    //has no effect. If we simply call this.refreshScrollView directly, the
    //scroll view is not refreshed on the phone.
    this.resizeElements();
    setTimeout(util.bind(this.refreshScrollViews, this), 500);
    this.selectedPhotosScroller.scrollTo(0, 0, 300);
  },

  collectionViewDidRemoveChildView: function() {
    this.resizeElements();
    setTimeout(util.bind(this.refreshScrollViews, this), 500);
  },

  ready: function() {

    this.scroller = this.findRef('scroller');
    this.selectedPhotosScroller = this.findRef('selectedPhotosScroller');

    this.thumbnailCollection = this.findRef('thumbnailCollection');
    this.title = this.findRef('title');

    this.setTitle();

    this.getAlbum().getPhotos()
      .addCallback(function(photos) {
        photos.listen('endUpdate', this._onPhotoEvent, this);
        this.thumbnailCollection.setCollection(photos);
        this._onPhotoEvent();

        photos.downloadHead(200);
      }, this);

    this.selectedPhotosCollectionView =
      this.findRef('selectedPhotosCollection');
    this.selectedPhotosCollectionView.setCollection(
      this.selectedPhotosCollection
    );
    this.photoCounter = this.findRef('photoCounter');
    this.refreshScrollViews();

    this.refreshCounter();
  },

  /**
   * Display the photo grid when the photos have been fetched.
   */
  _onPhotoEvent: function() {
    this.refreshScrollViews();
  },

  useHeader: function() {
    return false;
  },

  setTitle: function() {
    var albumTitle = this.getAlbum().get('name');

    // FIXME: this is a workaround until we figure out how to get the
    // PageHeader to support this natively
    if (albumTitle.length > this.klass.MAX_TITLE_LENGTH) {
      albumTitle = albumTitle.substr(0, this.klass.MAX_TITLE_LENGTH) +
        '&hellip;';
    }

    this.title.setContent(albumTitle);
  },

  _goBack: function() {
    this.getStack().pop();
  },

   /**
   * Perform callback with the tapped photo. The callback should be the
   * "togglePhotoSelected" function in picker_album_list_scene.js, which
   * changes whether the photo is selected
   */
  _photoTouched: function(view, evt) {

    var photo = view.getModel();

    //return true if photo is now selected; false otherwise
    var result = this.photoTouchCallback(photo);

    photo.set('selected', result);

    this.refreshCounter();
  },

  refreshCounter: function() {
    this.photoCounter.setContent(
      'Photos Selected (' +
      this.selectedPhotosCollection.length + ')'
    );
  },

  resizeElements: function() {
    if (this.selectedPhotosCollectionView) {

      //this adjusts the width of the collection view so that the photos will
      //fit horizontally inside of it the min-width of the view is 481 (one
      //bigger than the width of the scroll view), so that the scroll view
      //maintains its horizontal-scrolling (any smaller and it reverts to
      //vertical-scrolling)
      this.selectedPhotosCollectionView.setStyle('width', Math.max(
          this.selectedPhotosCollection.length * 105,
          window.innerWidth - 13
        ) + 'px');
    }
    if (this.selectedPhotosCollection.length > 0) {
      this.selectedPhotosScroller.addClass('open');
    } else {
      this.selectedPhotosScroller.removeClass('open');
    }
  },

  refreshScrollViews: function(photo) {
    this.selectedPhotosScroller.refresh();
    this.scroller.refresh();
  },

  backBtnClick: function(evt) {
    this._goBack(evt);
  },

  doneBtnClick: function(evt) {
    this.callback(evt);
  }
});
});

// module: mock/webview_api
// file:   ../../mock/js/webview_api.js
define("mock/webview_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var util            = require('bolt/util');
var KBD             = require('system/components/keyboard/keyboard_constants').KBD;
var debug           = require('system/util/logging').debug;
var PHONE_DIMENSION = require('shared/screen_constants').PHONE_DIMENSION;

module.exports = {
  _timeout: 1000,
  _webViewIdToReceiver: {},
  _activeElement: null,

  handleClick: function(evt) {
    debug('Got ', evt.event, ' from ', evt.webViewId);

    if (evt.event === 'focusin') {
      var elem = this._getActiveElement(evt.webViewId);
      if (elem.tagName === 'INPUT' || elem.tagName === 'input' ||
          elem.tagName === 'textarea' || elem.tagName === 'TEXTAREA') {
        this._webViewIdToReceiver[evt.webViewId]('show', elem.type);
      }
    } else if (evt.event === 'focusout') {
      this._webViewIdToReceiver[evt.webViewId]('hide');
    }
  },

  registerIME: function(webViewId, receiver) {
    debug("Registering IME in mock");
    if (receiver) {
      this._webViewIdToReceiver[webViewId] = receiver;
      var callToMock = util.bind(this._clientCommandReceiver, this, webViewId);
      receiver('setContext', callToMock);
    } else {
      delete this._webViewIdToReceiver[webViewId];
    }
  },

  _getActiveElement: function(webViewId) {
    return window.top.Angel.getWindow(webViewId).document.activeElement;
  },

  _clientCommandReceiver : function(webViewId, funcName) {
    this.init();
    debug("Client called " + funcName);

    this.actionater[funcName].apply(this,
        [webViewId].concat(Array.prototype.slice.call(arguments, 2)));
  },


  init : function() {
    if (!this.inited) {
      this.actionater =  {
        allowTextFeedback: function (webViewId, allowed) {
          this.fn("allowTextFeedback", allowed);
        },
        startSelection: function (webViewId) {
          this.fn("startSelection");
        },
        selectText: function (webViewId, start, end) {
          this.fn("selectText", start, end);
        },
        pressKey: function(webViewId, charCode, unicodeChar) {
          // DeleteBackward, and extra key code is getting sent to help webkit
          // send the correct onkeydown/onkeyup events
          if (charCode === KBD.keys.DELETE) {
            return;
          }
          debug("Mock key(): ", charCode, ' for webviewId ', webViewId);
          var elem = this._getActiveElement(webViewId);
          debug(elem);

          if (charCode === KBD.keys.DONE) {
            this._webViewIdToReceiver[webViewId]('hide');
            /*
              Something more like this would be preferable, but I don't think
              we can send key events, so this is out
              var eventObj = window.top.Angel.getWindow(webViewId).document.createEvent('TextEvent');
              eventObj.initTextEvent('textInput', true, true, null, '\u000D');
              elem.dispatchEvent(eventObj);
            */
          } else {
            this.addText(elem, String.fromCharCode(unicodeChar), webViewId);
          }
        },

        executeCommand: function(webViewId, command, value) {
          debug('Executing mock command: ' + command + ' with value: ' + value);
          var elem = this._getActiveElement(webViewId);
          var cursorPos;
          var receiver;
          if (command === 'DeleteBackward') {
            cursorPos = elem.selectionStart;
            debug('cursor pos: ', cursorPos);
            elem.value = elem.value.substring(0, cursorPos - 1) +
                         elem.value.substring(cursorPos, elem.value.length);

            // Weirdly, we decrease the position then send two selection change
            // events
            receiver = this._webViewIdToReceiver[webViewId];
            receiver('textSelectionDidChange', cursorPos - 1, cursorPos - 1);
            receiver('textContentDidChange', elem.value);
            receiver('textSelectionDidChange', cursorPos - 1, cursorPos - 1);
          } else if (command === 'DeleteWordBackward') {
            cursorPos = elem.selectionStart;
            debug('cursor pos: ', cursorPos);

            //find the word breaking character
            var currentStr = elem.value;
            var startPos = cursorPos;
            var ch = currentStr[startPos - 1];
            while (startPos > 0 && ch !== ' ' && ch !== '.' && ch !== '\n') {
              startPos--;
              ch = currentStr[startPos - 1];
            }

            elem.value = elem.value.substring(0, startPos) +
                         elem.value.substring(cursorPos, elem.value.length);

            // Weirdly, we decrease the position then send two selection change
            // events
            receiver = this._webViewIdToReceiver[webViewId];
            receiver('textSelectionDidChange', startPos, startPos);
            receiver('textContentDidChange', elem.value);
            receiver('textSelectionDidChange', startPos, startPos);
          } else if (command === 'InsertText') {
            this.addText(elem, value, webViewId);
          } else if (command === 'InsertNewline') {
            this.addText(elem, '\n', webViewId);
          }
        },

        keyboardHeightDidChange: function(webViewId, height) {
          debug('Keyboard height change to ' + height);
          window.top.Angel.getWindow(webViewId).frameElement.style.height =
              PHONE_DIMENSION.height - height;
        }
      };
    }
    this.inited = true;
  },

  /**
   * Add text to a given element, taking care to update the webview like
   * the device's webview does
   * @param elem
   * @param text
   * @param webViewId
   */
  addText: function(elem, text, webViewId) {
    var cursorPos = elem.selectionStart;
    elem.value = elem.value.substr(0, cursorPos) +
        text +
        elem.value.substr(cursorPos, elem.value.length);

    debug('new value', elem.value);
    var receiver = this._webViewIdToReceiver[webViewId];
    receiver('textSelectionDidChange', cursorPos - 1, cursorPos - 1);
    receiver('textContentDidChange', elem.value);
    receiver('textSelectionDidChange', elem.value.length, elem.value.length);
  },

  enableHistoryNavigation: function() {
  },

  setHistoryBroadcastSize: function() {
  },

  shouldOverrideUrlCallback: function() {
    return false;
  },

  deleteScreenshot: function() {
  },

  takeScreenshot: function() {
    return 'fbwebview:///stub-screenshot-id';
  },

  forwardTouchEvent: function() {
  }
};
});

// module: shared/text
// file:   ../../shared/js/text.js
define("shared/text", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var dom = require('bolt/dom');

var Text = exports;

// We have a bunch of innerHTML uses that are just "make this text
// class X"; this is just to make it easier to get rid of those.
Text.withClass = function(clazz, body) {
  return dom.createElement('span', {className:clazz}, body);
};

/**
 * Regex replace for typed markup:
 *   regexTextToContent(/foo=(\d+)/, spleen, 'foo=3 now')
 * returns the list
 *   ['and ', spleen('foo=3', '3'), ' now']
 *
 * If you decide to rewrite this to avoid the string copying in replace(),
 * beware of overlapping matches, zero-length matches, and the fact that the
 * callback function might clobber regex.lastIndex.
 */
Text.regexTextToContent = function(regex, callback, text) {
  text = '' + text;
  if (!text.length) return text; // Pretty common
  var result = [], last = 0;
  text.replace(regex, function(s) {
    var start = arguments[arguments.length - 2],
        end = start + s.length;
    if (last < start) {
      result.push(text.substring(last, start));
    }
    var v = callback.apply(this, arguments);
    result.push(v);
    last = end;
  });
  if (!result.length) {
    return text;
  }
  if (last < text.length) {
    result.push(text.substring(last));
  }
  return result;
};


Text.trustedLink = function(url, body) {
  return dom.createElement('a', {href: url}, body);
};

Text.externalLink = function(url, body) {
  if (/^https?:/i.test(url)) {
    // Should we linkshim?
    return dom.createElement('a', {href: url, target :'_blank'}, body);
  } else {
    if (__DEV__) {
      console.warn("Attempt to link to non-HTTP URL removed: ", url, body);
    }
    return body;
  }
};



// could probably move this somewhere and just leave the finished regex here. any suggestions?

function regulate(rex, map) {
  function f(rex) {
    return rex.source.replace(/<(\w+)>/g, function(_, id) {
        return '(?:' + f(map[id]) + ')';
      });
  }
  return new RegExp(f(rex), 'g');
}

var pieces = {
  // don't stop in the middle of a word
  tailassert: /(?!\w)/,

  // horizontal space
  hs: /[ \t]/,

  sep: /<hs>*(?:[-.]<hs>*)?/,
  intlphone: /\B\+\d(?:<sep>(?:\d|\(\d+\)))+/,
  area: /[2-9]\d\d/,
  parea: /\(<area>\)/,
  usphone: /(?:\b<area>|\B<parea>|\b1<sep><area>|\b1<sep><parea>)<sep>\d\d\d<sep>\d\d\d\d/,
  phone: /<intlphone>|<usphone>/,

  user: /[a-zA-Z0-9_.+]+/,
  subdomain: /[a-zA-Z0-9-]+\./,
  tld: /[a-zA-Z]{2,8}/,
  domain: /<subdomain>+<tld>/,
  email: /<user>@<domain>/,

  // Address regex; probably slow
  state: /(?=\w\w\b)(?:AL|AK|AS|AZ|AR|CA|CO|CT|DE|DC|FM|FL|GA|GU|HI|ID|IL|IN|IA|KS|KY|LA|ME|MH|MD|MA|MI|MN|MS|MO|MT|NE|NV|NH|NJ|NM|NY|NC|ND|MP|OH|OK|OR|PW|PA|PR|RI|SC|SD|TN|TX|UT|VT|VI|VA|WA|WV|WI|WY)/,
  zip: /\d{5}(?:-\d{4})?/,
  usaddress: /\d{1,5} [0-9a-zA-Z\-\'\s\.\,\n]{3,100} <state> <zip>/,

  // Carlos!!
  emoticon: /\[\[(\w+)\]\]/,

  // limited to http urls; we should probably use a smaller set of
  // characters when there is no scheme
  //
  // if modifying this, be very very careful so you don't allow arbitrary schemes
  urlchar: /[A-Za-z0-9-._~:\/?#\[\]@!$&\'()*+,;=%]/,
  url: /(https?:\/\/)?<domain>(?:[/?#]<urlchar>*)?/
};

var urlsRegex = regulate(/(<url>)<tailassert>/, pieces);
var dwimRegex = regulate(/(?:(<url>)|(<phone>)|(\b<email>)|(\b<usaddress>)|<emoticon>)<tailassert>/, pieces);

function replacer(all, url, scheme, phone, email, address, emoticon) {
  if (url) {
    return Text.externalLink(scheme ? url : 'http://' + url, url);
  } else if (phone) {
    return Text.trustedLink('tel:' + phone.replace(/[^0-9+]/g, ''), phone);
  } else if (email) {
    return Text.trustedLink('fbcf:///apps/talk/index.html#protocol=mailto&url=' + encodeURIComponent(email),
                            email);
  } else if (address) {
    return Text.externalLink('http://www.bing.com/maps/search?q=' + encodeURIComponent(address),
                             address);
  } else if (emoticon) {
    return dom.createElement(
      'img', {
        alt: emoticon, width: 20, height: 20,
        src: 'http://graph.facebook.com/' + encodeURIComponent(emoticon) + '/picture?type=square'
      });
  }
}
/** Find actual links in text */
Text.linkify = function(text) {
  return Text.regexTextToContent(urlsRegex, replacer, text);
};
/** Look for random stuff we can come up with a link for (phone numbers, email addresses, mail
 * addresses, emoticons) */
Text.linkifyAndDwim = function(text) {
  return Text.regexTextToContent(dwimRegex, replacer, text);
};


/** Backwards compat -- going away in the next diff */
Text.linkify_as_htmlstring__deprecated_____ick = function(s) {
  return dom.createElement('span', {}, Text.linkify(s)).innerHTML;
};


/**
 * Simple HTML whitelister
 *
 * Takes an HTML-string and a set of callbacks for input tags.
 *
 * return parseHTML('<p class=foo>hello <marquee>world</p>',
 *    { P : parseHTML.allowAttributes('class'),
 *      MARQUEE : parseHTML.FLATTEN,
 *      default : parseHTML.DROP });
 *
 * DROP is the default.
 */
Text.parseHTML = function(htmlstring, tags) {
  function clean(node) {
    if (node && node.nodeType == Node.ELEMENT_NODE) {
      var ctx = {
        attr: function(s) { return node.getAttribute(s); },
        content: function() { return [].slice.call(node.childNodes).map(clean); }
      };
      var tag = node.nodeName;
      if (tags.hasOwnProperty(tag)) {
        return tags[tag](ctx, tag);
      } else if (tags.default) {
        return tags.default(ctx);
      }
    }
    if (node && node.nodeType == Node.TEXT_NODE) {
      return node;
    }
    return null;
  }
  var wrapper = document.createElement('div');
  wrapper.innerHTML = htmlstring; // This should be safe as we are not
    //  exposing the resulting DOM node directly; worst case the
    //  browser might start prefetching content here, in which case we
    //  need to fix the browser.
  return [].slice.call(wrapper.childNodes).map(clean);
};
Text.parseHTML.DROP = function(_) { };
Text.parseHTML.FLATTEN = function(ctx) { return ctx.content(); };
Text.parseHTML.allowAttributes = function(list) {
  return function(ctx, nodeName) {
    var n = dom.createElement(nodeName, {}, ctx.content());
    list.map(function(name)  {
        n[name] = ctx.attr(name);
      });
    return n;
  };
};

// Hack for handling notifications (they arrive as unmarked
// html-strings from the server)
Text.hack__parseNotificationHTML = function(text) {
  return Text.parseHTML(
    text, {
      A: function(ctx) {
        return dom.createElement('span', {}, ctx.content());
      },
      default: Text.parseHTML.FLATTEN
    });
};
});

// module: bolt/util
// file:   ../../../frameworks/bolt/lib/util.js
define("bolt/util", function(require, exports, module) {
/**
 * Copyright (c) 2011-2012, Facebook, Inc.
 * All rights reserved.
 *
 * @option preserve-header
 *
 */

module.exports = exports = require('./vendor/_');

var _cid = 1;

var createTransformer = function(prefix) {
  var names = {};
  return function(name) {
    if (!names[name]) {
      names[name] = prefix + exports.capitalize(name);
    }
    return names[name];
  };
};

exports.setter = createTransformer('set');
exports.getter = createTransformer('get');
exports.eventHandler = createTransformer('on');

var slice = Array.prototype.slice;

/**
 * Generates a setter for a property that directly manipulates a CSS class.
 *
 * For a button consider the following properties declaration:
 *
 *   properties: {
 *     color: null,
 *     enabled: null,
 *   }
 *
 * Then to have those properties directly manipulate CSS classes the setters
 * should be overriden as follows:
 *
 *   setColor: util.modeSetter('color', ['green', 'red', 'blue']),
 *   setEnabled: util.modeSetter('enabled')
 *
 * @param mode - the property name
 * @param classes - If this is a boolean property (where truthy values will add
 *    <mode> to the className of the object and falsy values will remove <mode>
 *    from the className) then do not pass in a second argument. If this is a
 *    enumerated property with several mutually excluded options include an
 *    array of string options for what those properties may be. When one gets
 *    set the others get unset and a generated class is added to the classname
 *    of the form <mode>-<value>. If a value that isn't in the enumerated values
 *    is passed in, an exception is thrown.
 *
 * NOTE: Currently properties do not call their setter on construction so
 *  to set a default value, you'll need to call the setter in the ready
 *  function.
 */
exports.modeSetter = function(mode, classes, refName) {
  if (exports.isBlank(classes)) {
    // toggle mode
    return function(value) {
      var ref = this;
      if (refName) {
        ref = this.findRef(refName);
      }
      this.set(mode, !!value);
      return ref.toggleClass(mode, value);
    };
  } else {
    // enum mode
    var classesHash = {};
    for (var i = 0; i < classes.length; i++) {
      classesHash[classes[i]] = true;
    }
    return function(value) {
      var ref = this;
      if (refName) {
        ref = this.findRef(refName);
      }
      if (!(value in classesHash)) {
        throw this.getDeclaredClass() + ' does not support value "' +
          value + '" for mode "' + mode + '".';
      }
      this.set(mode, value);
      ref.setMode(mode, value);
    };
  }
};

exports.bind = function(func, obj) {
  var args = slice.call(arguments, 2);
  var nativeBind = Function.prototype.bind;

  if (typeof func === "string") {
    return function() {
      return obj[func].apply(obj, args.concat(slice.call(arguments)));
    };
  } else {
    if (func.bind === nativeBind && nativeBind) {
      return nativeBind.apply(func, slice.call(arguments, 1));
    }
    return function() {
      return func.apply(obj, args.concat(slice.call(arguments)));
    };
  }
};

var stringTransform = function(str, separator) {
  var UP = /[A-Z]/, SEP = /[^A-za-z0-9]/;
  for (var i = 0, l = str.length, out = [], cur, next, prior; i < l; i++) {
    cur = str[i];
    next = str[i + 1];
    prior = str[i - 1];
    if (SEP.test(cur)) {
      if (out[out.length - 1] !== separator) {
        out.push(separator);
      }
    } else {
      if (prior && next && UP.test(cur) && (!UP.test(next) || !UP.test(prior))) {
        out.push(separator);
      }
      out.push(cur.toLowerCase());
    }
  }
  return out.join('');
};

exports.hyphenate = function(str) {
  return stringTransform(str, '-');
};

exports.underscore = function(str) {
  return stringTransform(str, '_');
};

exports.trim = String.prototype.trim ?
  function(str){ return str.trim(); } :
  function(str){ return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');};

exports.capitalize = function(value) {
  if (!value || !value.length) {
    return value;
  }
  return value.charAt(0).toUpperCase() + value.slice(1);
};

/**
 * Call a method on multiple contexts.
 * This is similar to util.invoke, but is more lightweight. Whereas
 * util.invoke builds an object with the return values of all the
 * function calls, util.run simply executes the functions and returns
 * nothing. This uses less memory and has one less function call.
 *
 * @param obj An array of contexts, each of which contains the method
 * @param method Either a function, or the string name of a function
 * in the context
*/
exports.run = function(obj, method) {
  var args = arguments.length > 2 ? slice.call(arguments, 2) : [];
  var context;
  for (var i = 0; i < obj.length; i++) {
    context = obj[i];
    (method.call ? method || context : context[method]).apply(context, args);
  }
};

/**
 * Extend an object with the properties on one or more objects.
 * The first parameter is the destination object into which properties
 * are copied.  All subsequent parameters are iterated over and all their
 * properties copied into the first parameter.
 *
 * @param obj The destination object into which properties are placed.
 */
exports.extend = function(obj) {
  var len = arguments.length;
  var source;
  var prop;
  for (var i = 1; i < len; i++) {
    source = arguments[i];
    for (prop in source) {
      if (source[prop] !== void 0) {
        obj[prop] = source[prop];
      }
    }
  }
  return obj;
};

var CHARS =
  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');

exports.generateUUID = function() {
  var uuid = new Array(36),
      rnd = 0,
      r;
  for (var i = 0; i < 36; i++) {
    if (i == 8 || i == 13 || i == 18 || i == 23) {
      uuid[i] = '-';
    } else if (i == 14) {
      uuid[i] = '4';
    } else {
      if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
      r = rnd & 0xf;
      rnd = rnd >> 4;
      uuid[i] = CHARS[(i == 19) ? (r & 0x3) | 0x8 : r];
    }
  }
  return uuid.join('');
};

/**
 * Used to create an identifier that is intended to be unique per page load.
 * Do not persist this id and expect it to be unique in any offline system.
 */
exports.generateCID = function() {
  return _cid++;
};

exports.isBlank = function(obj) {
  return exports.isUndefined(obj) ||
    exports.isNull(obj) ||
    (!exports.isNumber(obj) && exports.isEmpty(obj));
};

exports.defineProperty = function(obj, key, descriptor) {
  if (!Object.defineProperty) {
    // herp derp, this should never have to be run amirite
    obj.key = descriptor.value;
  }

  Object.defineProperty(obj, key, descriptor);
};

require('./compat/util');
});

// module: talk/app/contacts/contact
// file:   contacts/contact.js
define("talk/app/contacts/contact", function(require, exports, module) {
module.exports = require("contacts/contact");});

// module: contacts/contact
// file:   contacts/contact.js
define("contacts/contact", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

//The following are not actually global, but local, defined underneath
//for readability

/*global ContactSnapshot: true */
/*global undefined: true */
/*global ReplaceSnapshotTransaction: true */
/*global Contact: true */

var core  = require('bolt/core');
var Model = require('bolt/model').Model;
var Announcer = require('./util/announcer').Announcer;

var Schema = require('shared/data2/store/schema').Schema;
var TypeBase = require('shared/data2/store/schema/type/base').TypeBase;
var TypeJSON = core.createClass({
  extend: TypeBase,
  name: 'TypeJSON',

  transformModelToLocal: function(value) {
    return JSON.stringify(value);
  },

  transformLocalToModel: function(value) {
    return JSON.parse(value);
  }
});


var contactsSchema = new Schema(
  {
    id: {searchable: true, localType: 'TEXT PRIMARY KEY', notAModelProperty: true},
    facebookId: {searchable: true, defaultValue: ''},
    firstName: {defaultValue: ''},
    lastName: {defaultValue: ''},
    fullName: {defaultValue: ''},
    profileUrl: {defaultValue: ''},
    coverPicUrl: {defaultValue: ''},
    company: {defaultValue : ''},
    email: {searchable: true, defaultValue: ''},
    coefficientOrder: {defualtValue: ''},
    phoneNumbers: new TypeJSON({searchable: true, defaultValue: []})
  }
);

var Contact = core.createClass({
  extend: Model,
  properties: contactsSchema.getPropertiesForModel(),

  construct: function() {
    this._announcer = new Announcer();
    Model.apply(this, arguments);
    this.addListener('changed', this._changed, this);
  },

  update: function(snapshot) {
    this.merge(snapshot);
  },

  _changed: function() {
    this._announcer.announce('contactStateChanged', this.snapshot());
  },

  addEventListener: function(listener) {
    this._announcer.addListener(listener);
  },

  destroy: function() {
    this._announcer.announce('contactDeleted', this.snapshot());
  },

  getName: function() {
    return this.getFirstName() + ' ' + this.getLastName();
  },

  snapshot: function() {
    return new ContactSnapshot({
      id: this.getId(),
      facebookId: this.getFacebookId(),
      firstName: this.getFirstName(),
      lastName: this.getLastName(),
      email: this.getEmail(),
      name: this.getName(),
      profileUrl: this.getProfileUrl(),
      coverPicUrl: this.getCoverPicUrl(),
      coefficientOrder: this.getCoefficientOrder(),
      company: this.getCompany(),
      phoneNumbers: this.getPhoneNumbers()
    });
  },

  equals: function(contact) {
    return this.getId() === contact.getId();
  }
});

contactsSchema.setModelType(Contact);

var ContactSnapshot = function(contactData) {
  for (var i in contactData) {
    this[i] = contactData[i];
  }
};

ContactSnapshot.prototype = {
  isForTheSameContact: function(snapshot) {
    return this.id === snapshot.id;
  },

  equals: function(snapshot) {
    for (var key in this) {
      if (typeof(this[key]) !== 'function' &&
         JSON.stringify(this[key]) !== JSON.stringify(snapshot[key])) {
        return false;
      }
    }
    return true;
  }
};

var ContactBuilder = function() {
  this._attributes = {
    profileUrl: '',
    phoneNumbers: []
  };
};

ContactBuilder.prototype = {
  withFirstName: function(firstName) {
    this._attributes.firstName = firstName;
    return this;
  },

  withLastName: function(lastName) {
    this._attributes.lastName = lastName;
    return this;
  },

  withName: function(name) {
    this._attributes.firstName = name.split(' ')[0];
    this._attributes.lastName = name.split(' ')[1];
    return this;
  },

  withProfileUrl: function(url) {
    this._attributes.profileUrl = url;
    return this;
  },

  withCoverPicUrl: function(url) {
    this._attributes.coverPicUrl = url;
    return this;
  },

  withCoefficientOrder: function(order) {
    this._attributes.coefficientOrder = order;
    return this;
  },

  withPhoneNumber: function(phoneNumber) {
    this._attributes.phoneNumbers.push(phoneNumber);
    return this;
  },

  withMobilePhoneNumber: function(number) {
    this._attributes.phoneNumbers.push({type: 'mobile', number: number});
    return this;
  },

  withId: function(id) {
    this._attributes.id = id;
    return this;
  },

  withFacebookId: function(facebookId) {
    this._attributes.facebookId = facebookId;
    return this;
  },

  withEmail: function(email) {
    this._attributes.email = email;
    return this;
  },

  build: function() {
    return new Contact(this._attributes);
  }
};

var ContactSnapshotBuilder = function() {
  this._builder = new ContactBuilder();
  this._id = null;
};

ContactSnapshotBuilder.prototype = {
  withFirstName: function(firstName) {
    this._builder.withFirstName(firstName);
    return this;
  },

  withLastName: function(lastName) {
    this._builder.withLastName(lastName);
    return this;
  },

  withName: function(name) {
    this._builder.withName(name);
    return this;
  },

  withId: function(id) {
    this._id = id;
    return this;
  },

  withFacebookId: function(facebookId) {
    this._builder.withFacebookId(facebookId);
    return this;
  },

  withPhoneNumber: function(phoneNumber) {
    this._builder.withPhoneNumber(phoneNumber);
    return this;
  },

  withPhoneNumbers: function(phoneNumbers) {
    var builder = this._builder;
    phoneNumbers.forEach(function(phoneNumber) {
      builder.withPhoneNumber(phoneNumber);
    });
    return this;
  },

  withMobileNumber: function(number) {
    this._builder.withMobilePhoneNumber(number);
    return this;
  },

  withEmail: function(email) {
    this._builder.withEmail(email);
    return this;
  },

  withProfileUrl: function(profileUrl) {
    this._builder.withProfileUrl(profileUrl);
    return this;
  },

  withCoverPicUrl: function(coverPicUrl) {
    this._builder.withCoverPicUrl(coverPicUrl);
    return this;
  },

  withCoefficientOrder: function(coefficientOrder) {
    this._builder.withCoefficientOrder(coefficientOrder);
    return this;
  },

  build: function() {
    var snapshot = this._builder.build().snapshot();
    snapshot.id = this._id;
    return snapshot;
  }
};

var PhoneNumberBuilder = function() {
};

PhoneNumberBuilder.prototype = {
  mobileNumber: function(number) {
    this._type = 'mobile';
    this._number = number;
    return this;
  },
  build: function() {
    return {type: this._type, number: this._number};
  }
};

exports.Contact = Contact;
exports.ContactSnapshot = ContactSnapshot;
exports.ContactBuilder = ContactBuilder;
exports.ContactSnapshotBuilder = ContactSnapshotBuilder;
exports.contactsSchema = contactsSchema;
exports.PhoneNumberBuilder = PhoneNumberBuilder;
});

// module: bolt_touch/util/image_queue
// file:   ../../../frameworks/bolt_touch/lib/util/image_queue.js
define("bolt_touch/util/image_queue", function(require, exports, module) {
// ImageQueue is an image queueing service which loads images
// in sequence.  The most newly added image is downloaded first, by default,
// but this can be configured by calling:
//
//   ImageQueue.setLoadOrder(ImageQueue.ACT_AS_QUEUE)
//
// which will then load the images in the order they were inserted.

// Call the add() function to add an image to be loaded.  This takes
// three parameters:
// - url: the url of the image to load
// - callback: a function to be called back.  This is passed the url that has
//             requested, and a boolean value stating whether or not it was
//             successfullly loaded.
// - scope: an optional parameter which defines the scope in which the
//          callback function is executed.  Defaults to window.

// To pause the image loading queue, call the pause() method.
// To resume the image loading queue, call the run() method.

var EventManager = require('./event_manager').EventManager;

// The number of images to load at one time
var threshold = 4;

var paused = false;
var hardPause = false;


/**
 * @const {Boolean} Whether this browser support the ability to listen to
 * offline and online events.
 */
var SUPPORTS_OFFLINE_EVENTS = window.navigator && 'onLine' in navigator;
if (SUPPORTS_OFFLINE_EVENTS) {
  var offline = !navigator.onLine;
}

var queue = [];
var retryQueue = [];
var inflight = [];
var cached = {};
var deferred = [];

var ACT_AS_QUEUE = exports.ACT_AS_QUEUE = 1;
var ACT_AS_STACK = exports.ACT_AS_STACK = 2;

/**
 * @const {Number} The number of times to try to load an image if fails to load.
 * After the first load attempt, only attempt to load the image when there's
 * connectivity.
 */
var RELOAD_ATTEMPTS = 2;

// default mode is stack
var imageRemovalMode = ACT_AS_STACK;

exports.setLoadOrder = function(mode) {
  if (mode !== ACT_AS_QUEUE && mode !== ACT_AS_STACK) {
    throw 'mode must be set to ACT_AS_QUEUE or ACT_AS_STACK';
  }
  imageRemovalMode = mode;
};

// Handle the loading of the image
function handleLoad(event) {

  // Find the matching callback
  var data;
  var success = event.type == 'load';

  for (var i = 0; i < inflight.length; i++) {
    data = inflight[i];
    if (data.img === event.target) {
      inflight.splice(i, 1);
      cached[data.url] = {width: data.img.width, height: data.img.height};
      doCallback(
        data.url,
        data.img.width,
        data.img.height,
        data.callback,
        data.scope,
        data.tag,
        success);
      break;
    }
  }

  next();
}

function retryOnError(event) {
  var data;
  for (var i = 0; i < inflight.length; i++) {
    data = inflight[i];
    if (data.img === event.target) {
      inflight.splice(i, 1);
      data.attempt++;
      retryQueue.push(data);
    }
  }
}

// Load the next image
function next() {
  if (paused) {
    return;
  }
  var data = (imageRemovalMode === ACT_AS_STACK) ? queue.pop() : queue.shift();
  if (!data) {
    data = retryQueue.shift();
    if (!data) {
      EventManager.invoke("imageQueue.EMPTY");
      return;
    }
    if (offline) {
      return;
    }
  }

  var img = document.createElement('img');
  img.onload = handleLoad;
  if (SUPPORTS_OFFLINE_EVENTS && data.attempt < RELOAD_ATTEMPTS) {
    img.onerror = retryOnError;
  } else {
    img.onerror = handleLoad;
  }
  data.img = img;
  inflight.push(data);
  img.src = data.url;
}

/**
* Execute the callback, unless a hard pause in in effect, or there is no
* connectivity in which case enqueue it for execution when the queue
* starts running again.
*/
function doCallback(url, width, height, callback, scope, tag, success) {
  if (paused && hardPause) {
    deferred.push({
      url: url,
      width: width,
      height: height,
      callback: callback,
      scope: scope,
      tag: tag,
      success: success
    });
    return;
  }
  callback.call(
    scope || window,
    url,
    width,
    height,
    success,
    tag);
}

// Filter an array, removing the matching url, callback, scope and tag
var filterArr = function(arr, url, callback, scope, tag) {
  var i;
  var data;
  for (i = arr.length - 1; i >= 0; i--) {
    data = arr[i];
    if (data.url == url &&
        data.callback === callback &&
        (!scope || scope === data.scope) &&
        (!tag || tag === data.tag)) {
      arr.splice(i, 1);
    }
  }
};

// Filter an array by tag
var filterArrByTag = function(arr, tag) {
  var i;
  var data;
  for (i = arr.length - 1; i >= 0; i--) {
    data = arr[i];
    if (tag === data.tag) {
      arr.splice(i, 1);
    }
  }
};

// Add a new image, specifying the url and callback.
exports.add = function(url, callback, scope, tag) {

  var imageSize = cached[url];
  if (imageSize) {
    // If the image is already loaded, call back immediately
    doCallback(url, imageSize.width, imageSize.height, callback, scope, tag, true);
    return;
  }

  queue.push({
    url: url,
    callback: callback,
    scope: scope,
    tag: tag,
    attempt: 0
  });

  if (inflight.length < threshold) {
    next();
  }
};

// Remove a previously requested image load from the queue
exports.remove = function(url, callback, scope, tag) {
  filterArr(queue, url, callback, scope, tag);
  filterArr(retryQueue, url, callback, scope, tag);
  filterArr(inflight, url, callback, scope, tag);
  filterArr(deferred, url, callback, scope, tag);
};

exports.removeByTag = function(tag) {
  filterArrByTag(queue, tag);
  filterArrByTag(retryQueue, tag);
  filterArrByTag(inflight, tag);
  filterArrByTag(deferred, tag);
};

/**
 *  Go through any deferred callbacks and execute them.
 */
_processQueue = function() {
  if (paused) {
    return;
  }
  var data;
  for (var i = 0; i < deferred.length; i++) {
    data = deferred[i];
    doCallback(
      data.url,
      data.width,
      data.height,
      data.callback,
      data.scope,
      data.tag,
      data.success);
  }
  deferred = [];

  while ((queue.length > 0 || retryQueue.length > 0)
    && inflight.length < threshold) {
    next();
  }
};

// Start the queue running again
exports.run = function() {
  paused = false;
  _processQueue();
};

// Pause the image loading.  If the isHard parameter is true, even cached
// images are not sent back to the callee.
exports.pause = function(isHard) {
  paused = true;
  hardPause = isHard;
};

exports.isPaused = function() {
  return paused;
};

// Clear all loading images.
exports.clear = function() {
  queue = [];
  retryQueue = [];
  inflight = [];
  deferred = [];
};

if (SUPPORTS_OFFLINE_EVENTS) {
  window.addEventListener('online', function() {
    offline = false;
    _processQueue();
  }, false);

  window.addEventListener('offline', function() {
    offline = true;
  }, false);
}
});

// module: contacts/shared/ui/contact_form_scene
// file:   contacts/shared/ui/contact_form_scene.js
define("contacts/shared/ui/contact_form_scene", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
//
//The following are not actually global, but local, defined underneath
//for readability

var core = require('bolt/core');
var Scene = require('bolt_touch/views/scene').Scene;
var Image = require('bolt_touch/views/image').Image;
var TextInput = require('bolt_touch/views/textinput').TextInput;
var ActionableView = require('bolt_touch/views/actionable_view').ActionableView;
var PhoneNumberBuilder = require('contacts/contact').PhoneNumberBuilder;
var Announcer = require('../../util/announcer').Announcer;
var RemoveContactInformationBuilder =
  require('../../values/remove_contact_information')
  .RemoveContactInformationBuilder;

var View = require('bolt_touch/view').View;
var PhoneNumberView = core.createClass({
  extend: View,

  declare: function(options) {
    return {
      tagName: 'li',
      className: 'phone-number',
      childViews: [
        {
          tagName: 'span',
          className: 'type',
          ref: 'type'
        },
        {
          view: TextInput,
          className: 'number',
          ref: 'number',
          placeholder: 'Phone'
        }
      ]
    };
  },

  setPhoneNumber: function(number) {
    this.findRef('type').setContent(number.type);
    this.findRef('number').setValue(number.number);
    this._number = number;
  },

  addPhoneNumberInformation: function(builder) {
    if (this.findRef('number').getNode().value !== '') {
      builder.withPhoneNumber({
        type: this._number.type,
        number: this.findRef('number').getNode().value
      });
    }
  }
});

var PhoneNumbersSection = core.createClass({
  extend: View,

  declare: function(options) {
    return {
      tagName: 'ul',
      className: 'phone-numbers-section'
    };
  },

  setPhoneNumbers: function(numbers) {
    var section = this;
    numbers.forEach(function(number) {
      var view = new PhoneNumberView();
      view.setPhoneNumber(number);
      section.appendChild(view);
    });
    var view = new PhoneNumberView();
    view.setPhoneNumber({type: 'mobile', number: ''});
    this.appendChild(view);
  },

  addPhoneNumbersInformation: function(builder) {
    this.getChildViews().forEach(function(phoneNumberView) {
      phoneNumberView.addPhoneNumberInformation(builder);
    });
  }
});

var ContactFormScene = core.createClass({
  extend: Scene,

  construct: function() {
    Scene.apply(this, arguments);
    this._announcer = new Announcer();
    this._cancelEvent = arguments[0].cancelEvent;
    this._saveEvent = arguments[0].saveEvent;
    this._builderType = arguments[0].builderType;
    if (arguments[0].contactInformation) {
      this._contactId = arguments[0].contactInformation.id;
      this._profileUrl = arguments[0].contactInformation.profileUrl;
    }
  },

  useHeader: function() {
    return false;
  },

  declare: function(options) {
    var allowsDelete = options.allowsDelete;
    return {
      flex: 1,
      id: options.id,
      className: 'contact-scene contact-form-scene create-contact-form',
      childViews: [
        {
          className: 'buttons-section',
          childViews: [
            {
              view: ActionableView,
              className: 'button left-button',
              content: 'Back',
              id: 'cancelContactForm',
              action: 'cancelPressed'
            },
            {
              view: ActionableView,
              className: 'button right-button',
              content: 'Done',
              id: 'saveContact',
              action: 'createPressed'
            }
          ]
        },
        {
          className: 'top-section',
          childViews: [
            {
              ref: 'image',
              className: 'picture-section',
              view: Image
            },
            {
              className: 'edit-tag',
              content: 'Edit'
            },
            {
              ref: 'name',
              className: 'name-section',
              childViews: [
                {
                  className: 'name text-field first-name',
                  ref: 'firstName',
                  placeholder: 'First Name',
                  view: TextInput
                },
                {
                  className: 'name text-field last-name',
                  ref: 'lastName',
                  view: TextInput,
                  placeholder: 'Last Name'
                }
              ]
            }
          ]
        },
        {
          ref: 'phoneNumbersSection',
          view: PhoneNumbersSection
        },
        {
          boxOrientation: 'vertical',
          className: 'delete-section',
          childViews: [
            {
              view: ActionableView,
              id: 'deleteContact',
              className: allowsDelete ? '' : 'hidden',
              action: 'deletePressed',
              childViews: [
                {
                  className: 'button-text',
                  content: 'Delete Contact'
                }
              ]
            }
          ]
        }
      ]
    };
  },

  setContact: function(contact) {
    this._snapshot = contact;
    this.findRef('firstName').setValue(contact.firstName);
    this.findRef('lastName').setValue(contact.lastName);
    this.findRef('image').setSrc(contact.profileUrl);
    this.findRef('phoneNumbersSection').setPhoneNumbers(contact.phoneNumbers);
  },

  createPressed: function(event) {
    var contactInformationBuilder = new this._builderType();
    if (this._getValueOf('firstName') !== '') {
      contactInformationBuilder.withFirstName(this._getValueOf('firstName'));
    }
    if (this._getValueOf('lastName') !== '') {
      contactInformationBuilder.withLastName(this._getValueOf('lastName'));
    }
    this.findRef('phoneNumbersSection').addPhoneNumbersInformation(
      contactInformationBuilder
    );
    if (this._snapshot && contactInformationBuilder.withId) {
      contactInformationBuilder.withId(this._snapshot.id);
      contactInformationBuilder.withProfileUrl(this._snapshot.profileUrl);
    }

    this._announcer.announce(this._saveEvent,
                             contactInformationBuilder.build());
  },

  deletePressed: function(event) {
    this._announcer.announce('deleteContact',
                             new RemoveContactInformationBuilder()
                                 .withId(this._snapshot.id)
                                 .build());
  },

  cancelPressed: function(event) {
    this._announcer.announce(this._cancelEvent);
  },

  addEventListener: function(listener) {
    this._announcer.addListener(listener);
  },

  _getValueOf: function(ref) {
    return this.findRef(ref).getNode().value;
  }
});

exports.ContactFormScene = ContactFormScene;
});

// module: mock/audio_api
// file:   ../../mock/js/audio_api.js
define("mock/audio_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;

module.exports = {

  VIBRATE_TYPE_RINGER: 0,
  VIBRATE_TYPE_NOTIFICATION: 1,
  TYPE_RINGTONE: 1,
  TYPE_NOTIFICATION: 2,

  RINGER_MODE_SILENT: 0,
  RINGER_MODE_VIBRATE: 1,
  RINGER_MODE_NORMAL: 2,

  VIBRATE_MODE_NEVER: 0,
  VIBRATE_MODE_ONLY_SILENT: 1,
  VIBRATE_MODE_ONLY_NOT_SILENT: 2,
  VIBRATE_MODE_ALWAYS: 3,

  WIRED_HEADSET_OFF: 0,
  WIRED_HEADSET_ON: 1,

  STREAM_VOICE_CALL: 0,
  STREAM_SYSTEM: 1,
  STREAM_RING: 2,
  STREAM_MUSIC: 3,
  STREAM_ALARM: 4,
  STREAM_NOTIFICATION: 5,
  STREAM_BLUETOOTH_SCO: 6,
  STREAM_SYSTEM_ENFORCED: 7,
  STREAM_DTMF: 8,
  STREAM_TTS: 9,

  VOLUME_CHANGED: 'audio.VOLUME_CHANGED',
  HEADSET_EVENT: 'audio.HEADSET_EVENT',
  RINGER_MODE_CHANGED: 'audio.RINGER_MODE_CHANGED',

  init: function() {
    if (!this.inited) {
      this.volume = 10;
      this.silent = true;
      this.headsetOn = 1;
      this.phoneRingtones = Array();
      this.notificationRingtones = Array();
      this.phoneRingtone = '';
      this.notificationRingtone = '';
      this.curVolumes = Array(Array(), Array());
      this.maxVolumes = Array();
      this.ringerVibrateMode = 0;
      this.notificationVibrateMode = 0;
      this.dtmfTones= false;
      this.prefs = {};
      this.currentState = 0;

      //Other streams defaults need to get added
      this.maxVolumes[this.STREAM_RING] = 7
      this.maxVolumes[this.STREAM_NOTIFICATION] = 15;
      this.maxVolumes[this.STREAM_MUSIC] = 15;
      this.maxVolumes[this.STREAM_BLUETOOTH_SCO] = 15;

      this.inited = true;
    }
  },

  getAudioProfile: function() {
    this.init();
    return (this.headsetOn() ? this.WIRED_HEADSET_ON : this.WIRED_HEADSET_OFF);
  },

  saveVolumeProfile: function(currentState)
  {
    this.init();
    prefs[currentState] = curVolumes;
  },

  restoreVolumeProfile: function(state)
  {
    this.init();
    curVolumes = prefs[state];
  },

  isVolumeProfileSaved: function(state)
  {
    this.init();
    return state in prefs;
  },

  shutdown: function(){
    this.init();
    return;
  },

  registerReceivers: function() {
    this.init();
  },

  unregisterReceivers: function() {
    this.init();
  },

  _broadcastRingerMode: function() {
    EventManager.broadcastEvent(this.RINGER_MODE_CHANGED, {
      mode: this.getRingerMode()
    });
  },

  isSilentModeEnabled: function() {
    this.init();
    return this.silent;
  },

  setIsSilentModeEnabled: function (s) {
    this.init();
    this.silent = s;
    this._broadcastRingerMode();
  },

  toggleSilentMode: function() {
    this.init();
    this.setIsSilentModeEnabled(!this.silent);
    return true;
  },

  getRingerMode: function() {
    var isVibrationOn = ((this.ringerVibrateMode === this.VIBRATE_MODE_ALWAYS) ||
      (this.ringerVibrateMode === this.VIBRATE_MODE_ONLY_SILENT));

    if (this.silent && isVibrationOn) {
      return this.RINGER_MODE_VIBRATE;
    } else if (this.silent) {
      return this.RINGER_MODE_SILENT;
    } else {
      return this.RINGER_MODE_NORMAL;
    }
  },

  getVolume: function(stream) {
    this.init();
    if (stream == undefined || stream == null) {
      stream = this.STREAM_RING;
    }
    if ( this.curVolumes[this.headsetOn][stream] && this.maxVolumes[stream]) {
      return Math.floor(100.0 *
        (this.curVolumes[this.headsetOn][stream] / this.maxVolumes[stream]));
    }
    return 0;
  },

  setVolume: function(stream, volume) {
    this.init();
    if (!this.maxVolumes[stream]) {
      this.maxVolumes[stream] = 15;
    }

    var prevVolume = this.curVolumes[this.headsetOn][stream];
    volume = Math.ceil(this.maxVolumes[stream] * (volume/100.0));
    this.curVolumes[this.headsetOn][stream] = volume;

    buffyGlitter._sendAndroidBroadcast('android.media.VOLUME_CHANGED_ACTION', {
      'android.media.EXTRA_VOLUME_STREAM_TYPE': stream,
      'android.media.EXTRA_PREV_VOLUME_STREAM_VALUE': prevVolume,
      'android.media.EXTRA_VOLUME_STREAM_VALUE': volume
    });
    EventManager.broadcastEvent(this.VOLUME_CHANGED, {
      stream: stream,
      value: volume
    });
  },

  setHeadsetMode: function(onOff) {
    this.init();
    this.headsetOn = onOff;
    EventManager.broadcastEvent(this.HEADSET_EVENT, onOff);
  },

  isDtmfTonesEnabled: function() {
    this.init();
    return this.dtmfTones;
  },

  setIsDtmfTonesEnabled: function(enable) {
    this.init();
    this.dtmfTones = enable;
    return true;
  },

  toggleDtmfTones: function() {
    this.init();
    this.dtmfTones = !(this.dtmfTones);
    return true;
  },

  startDtmfTone: function(tone) {
    this.init();
    // empty stub
  },

  stopDtmfTone: function(tone) {
    this.init();
    // empty stub
  },

  getRingerVibrateMode: function() {
    this.init();
    return this.ringerVibrateMode;
  },

  setRingerVibrateMode: function(vibrateMode) {
    this.init();
    this.ringerVibrateMode = vibrateMode;
    this._broadcastRingerMode();
  },

  getNotificationVibrateMode: function() {
    this.init();
    return this.notificationVibrateMode;
  },

  setNotificationVibrateMode: function(vibrateMode) {
    this.init();
    this.notificationVibrateMode = vibrateMode;
  },

  getAvailablePhoneRingtones: function() {
    this.init();
    return JSON.stringify(this.phoneRingtones);
  },

  getPhoneRingtone: function() {
    this.init();
    return this.phoneRingtone[2];
  },

  setPhoneRingtone: function(ringtone) {
    this.init();
    for (x in this.phoneRingtones)
      {
        if (this.phoneRingtones[x][2] == ringtone)
          {
            this.phoneRingtone = this.phoneRingtones[x];
            return true;
          }
      }
    return false;
  },

  togglePhoneRingtonePreview: function() {
    this.init();
    return false;
  },

  getAvailableNotificationRingtones: function() {
    this.init();
    return JSON.stringify(this.notificationRingtones);
  },

  getNotificationRingtone: function() {
    this.init();
    return this.notificationRingtone[2];
  },

  setNotificationRingtone: function(ringtone) {
    this.init();
    for (x in this.notificationRingtones)
      {
        if (this.notificationRingtones[x][2] == ringtone)
          {
            this.notificationRingtone = this.notificationRingtones[x];
            return true;
          }
      }
    return false;
  },

  playNotificationRingtone: function() {
    this.init();
  },

  stopNotificationRingtone: function() {
    this.init();
  },

  playNotificationByName: function(notificationName) {
    this.init();
    return true;
  },

  playRingtoneByName: function(ringtoneName) {
    this.init();
    return true;
  },

  toggleNotificationRingtonePreview: function() {
    this.init();
    return false;
  }
};
});

// module: views/composer/js/composer_textarea_container
// file:   ../../views/composer/js/composer_textarea_container.js
define("views/composer/js/composer_textarea_container", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core               = require('bolt/core');
var util               = require('bolt/util');
var View               = require('bolt_touch/view').View;
var AuthManager        = require('shared/auth_manager').AuthManager;
var ProfilePicture     = require('views/profile_picture').ProfilePicture;
var PhotoThumbnailView = require('./photo_thumbnail_view').PhotoThumbnailView;
var ComposerTextarea   = require('./composer_textarea').ComposerTextarea;
var ScrollView         = require('bolt_touch/views/scroll_view').ScrollView;

var ComposerTextareaContainer =
  exports.ComposerTextareaContainer =
  core.createClass({

  name: 'ComposerTextareaContainer',

  extend: View,

  properties: {
    inScene: false
  },

  declare: function(options) {
    return {
      boxOrientation: 'horizontal',
      flex: 10,
      childViews: [
        {
          view: ProfilePicture,
          ref: 'profilePicture',
          src: 'http://graph.facebook.com/' +
            AuthManager.getUserId() + '/picture?type=large'
        },
        {
          ref: 'implicitPlace',
          additionalClasses: 'place-picker composer-implicit-place'
        },
        {
          flex: 20,
          childViews: [
            {
              view: ComposerTextarea,
              ref: 'textarea'
            },
            {
              view: ScrollView,
              ref: 'photoScroller',
              additionalClasses: 'composer-photo-list',
              vScroll: false,
              childViews: [{
                tagName: 'div',
                ref: 'photo'
              }]
            }
          ]
        },
        {
          ref: 'cancelButton',
          flex: 1,
          additionalClasses: 'bt-composer-x-button'
        }
      ]
    };
  },

  ready: function() {

    this._textarea = this.findRef('textarea');
    this._photo = this.findRef('photo');
    this._cancelButton = this.findRef('cancelButton');
    this._implicitPlace = this.findRef('implicitPlace');
    this.photoScroller = this.findRef('photoScroller');

    var node = this._textarea.getInputNode();
    node.placeholder = '';
    node.disabled = false;

    this._textarea.setupTimer();
    this._implicitPlace.show();

    if (this.getInScene()) {
      this._cancelButton.hide();
    } else {
      this._cancelButton.show();
    }
  },

  focus: function() {
    this._textarea.getInputNode().focus();
  },

  blur: function() {
    this._textarea.getInputNode().blur();
  },

  getScrollerCoords: function() {
    return this.photoScroller.coords();
  },

  getScrollerOffsetPos: function() {
    return {
      top: this.photoScroller.getNode().offsetTop,
      left: this.photoScroller.getNode().offsetLeft
    };
  },

  setPhotos: function(photos) {
    if (photos) {
      var width = (PhotoThumbnailView.THUMBNAIL_DIM + 12) * photos.length;

      // There are three cases here:
      // 1) If the width of the photo list is less than
      //    the width of the container. Stay at the initial
      //    position.
      // 2) If the width of the photo list is greater than
      //    the container and this operation is a result of
      //    adding new photos, move to the right most of
      //    the list.
      // 3) If the width of the photo list is greater than
      //    the container and this operation is a result of
      //    removing photos, stay at the current scroll
      //    position.
      var diff = width - this.photoScroller.getNode().clientWidth;
      var endX = 0;

      if (diff > 0) {
        if (photos.length > this._photo.getChildViews().length) {
          endX = diff;
        }
      } else {
        this.photoScroller.scrollTo(0, 0, 0, false);
      }

      // Clear all the children
      this._photo.clearChildren();

      // Set the width of the container div so that
      // it could contain all the photos
      this._photo.setStyle('width', width + 'px');

      // Refresh the width of the photo scroller
      this.photoScroller.setContentWidth(width);

      // Insert the photos into the container div
      for (var i = 0; i < photos.length; i++) {
        this._photo.insertChild(this.build({
          view: PhotoThumbnailView,
          id: photos[i].get('id'),
          thumbnail: photos[i].get('thumbnail_url')
        }));
      }

      this.photoScroller.refresh();

      if (endX > 0) {
        this.photoScroller.scrollTo(-endX, 0, 100, false);
      }

      if (photos.length > 0) {
        this.photoScroller.addClass('border');
      } else {
        this.photoScroller.removeClass('border');
      }
    }
  },

  setContacts: function() {
    this._updateTextareaTags();
  },

  setPlace: function() {
    this._updateTextareaTags();
  },

  setStatus: function(status) {
    if (!util.isUndefined(status)) {
      this._textarea.setInputValue(status);
    }
  },

  getStatus: function() {
    return this._textarea.getInputValue();
  },

  _onCancelButtonTouched: function(e) {
    // Stop propagation so that the _onTextareaTouched on
    // composer does not get triggered in
    // expanded state.
    if (e) {
      e.stopPropagation();
    }

    if (this.getOwner().onTextareaCancelButtonTouched) {
      this.getOwner().onTextareaCancelButtonTouched();
    }
  },

  _updateTextareaTags: function() {
    var content = '';
    var contacts = this.getModel().get('contacts');
    var place = this.getModel().get('place');

    if (contacts && contacts.length > 0) {
      content += '<span class=\'composer-connector\'>with</span>';

      for (var i  = 0; i < contacts.length; i++) {
        content += this._createTextareaTags(
          contacts[i].get('name'),
          'contact-picker');

        if (i != contacts.length - 1) {
          content += '<span class=\'composer-connector\'>and</span>';
        }
      }
    }

    if (place) {
      if (place.implicit) {
        this._implicitPlace.setContent(place.name);
      } else {
        this._implicitPlace.setContent(null);
        content += '<span class=\'composer-connector\'>at</span>';
        content += this._createTextareaTags(place.name, 'place-picker');
      }
    } else {
      this._implicitPlace.setContent(null);
    }

    this._textarea.setStyledContent(content);
  },

  _createTextareaTags: function(str, additionalClass) {
    var tokens = str.split(/\s+/);
    // Need this <span> wrapper to create the
    // highlight effect on the entire word
    var content = '<span class=\'composer-param-wrapper\'>';
    for (var i = 0; i < tokens.length; i ++) {
      content += '<span class=\'composer-param ' + additionalClass + '\'>' +
        tokens[i] + '</span>';
    }
    content += '</span>';
    return content;
  },

  cancelButtonClick: function(evt) {
    this._onCancelButtonTouched(evt);
  }
});
});

// module: camera2/app/lib/view/preview/index
// file:   ../../camera2/app/lib/view/preview/index.js
define("camera2/app/lib/view/preview/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var View = require('bolt_touch/view').View;

var PHONE_DIMENSION = require('shared/screen_constants').PHONE_DIMENSION;
var logger          = require('shared/logger').logger;
var cameraConstants = require('../../controller/constants');

// default to full screen
var DEFAULT_HEIGHT = PHONE_DIMENSION.height;
var DEFAULT_WIDTH  = PHONE_DIMENSION.width;

var CAMERA_REAR = 0;
var CAMERA_FRONT = 1;

// the default area in which tap-to-focus operates on
var defaultFocusWidth = 50;
var defaultFocusHeight = 50;

// photo and video resolution
var resolution = [
    {x: 2592, y: 1944},
    {x: 640, y: 480}
];

exports.CameraPreview = core.createClass({
  name: 'CameraPreview',
  extend: View,

  properties: {
    cameraAdapter: null,
    height: null,
    width: null,
    autoFocus: false,
    tapToFocus: false,
    onError: null,
    onCaptureStart: null,
    onCaptureEnd: null,
    onRecordStart: null,
    onRecordEnd: null,
    onConverge: null
  },

  declare: function() {
    return {
      flex: 1,
      className: 'cameraContainer',
      id: 'camera-preview',

      childViews: [
        {
          ref: 'camPreview',
          tagName: 'video',
          onclick: '_previewTouched',

          childViews: [
            {
              ref: 'videoSource',
              tagName: 'source',
              src: this._getCameraPreviewSource(CAMERA_REAR),
              type: 'video/mp4'
            }
          ]
        }
      ]
    };
  },

  ready: function() {
    this.mode = CAMERA_REAR;
    document.addEventListener(
      'webkitvisibilitychange',
      util.bind(this.handleVisibilityStateChange, this),
      false);

    this.camPreview = this.findRef('camPreview');
    this.camNode = this.camPreview.getNode();

    this.get('cameraAdapter').addListener(this);

    var w = this.getWidth() ? this.getWidth() : DEFAULT_WIDTH;
    var h = this.getHeight() ? this.getHeight() : DEFAULT_HEIGHT;
    this.camNode.width = w;
    this.camNode.height = h;
  },

  onDocumentInsertion: function() {
    console.log('starting camera preview');
    this.play();

    // HACK: workaround for rendering bug
    //       tweak the DOM so that it causes a repaint
    setTimeout(util.bind(function() {
      console.log('showing camera preview');
      this.camPreview.hide();
      this.camPreview.show();

      this.get('cameraAdapter').replaceCamera(this.camNode.fbCameraController);

      if (this.getAutoFocus()) {
        this.enableAutoFocus();
      }
    }, this), 100);
  },

  _getCameraPreviewSource: function(mode) {
    return 'camera://omx:' + mode + '?mode=snapshot&x=' + resolution[mode].x +
      '&y=' + resolution[mode].y;
  },

  handleVisibilityStateChange: function() {
    if (!document.webkitHidden) {
      if (this.isHidden) {
        this.isHidden = false;
        this.play();
      }
    } else {
      this.isHidden = true;
      this.pause();
    }
  },

  play: function() {
    this.camNode.play();
  },

  pause: function() {
    this.camNode.pause();
  },

  setFlashMode: function(mode) {
    this.get('cameraAdapter').setFlashMode(mode);
  },

  setRotation: function(r) {
    this.get('cameraAdapter').setRotation(r);
  },

  /**
   * Focus on a particular box region of the preview.
   *
   * @param {int} x coordinate
   * @param {int} y coordinate
   * @param {int} width of focus area (optional)
   * @param {int} height of focus area (optional)
   */
  tapToFocus: function(x, y, width, height) {
    var w = width || defaultFocusWidth;
    var h = height || defaultFocusHeight;

    this.get('cameraAdapter').tapToFocus(x, y, w, h);
  },

  /**
   * Request that the camera perform various actions.
   *
   * @param {Object} focus, exposure, whiteBalance can be set to true or false
   */
  converge: function(options) {
    // you must wait for the previous converge to finish
    if (this.convergeCount > 0) {
      return;
    }

    var autoFocus      = options.focus || false,
      autoExposure     = options.exposure || false,
      autoWhiteBalance = options.whiteBalance || false;

    this.convergeCount = util.reduce(util.values(options), function(memo, num) {
      return (num ? 1 : 0) + memo;
    }, 0);

    this.get('cameraAdapter')
      .converge(autoFocus, autoExposure, autoWhiteBalance);
  },

  takePhoto: function() {
    // TODO: use a real shutter sound / make configurable

    //var audioApi = FBAPI.use('audio');
    //audioApi.playNotificationByName('F1_New_MMS.ogg');

    this.get('cameraAdapter').takeSnapshot();
  },

  startRecording: function() {
    this.get('cameraAdapter').startRecording();
  },

  stopRecording: function() {
    this.get('cameraAdapter').stopRecording();
  },

  enableAutoFocus: function() {
    this.get('cameraAdapter').enableContinuousFocus(true);
  },

  disableAutoFocus: function() {
    this.get('cameraAdapter').enableContinuousFocus(false);
  },

  onError: function(data) {
    var func = this.getOnError();
    func && func(data);
  },

  onCaptureStart: function(data) {
    var func = this.getOnCaptureStart();
    func && func(data);
  },

  onCaptureEnd: function(data) {
    var func = this.getOnCaptureEnd();
    func && func(data);
  },

  onRecordStart: function(data) {
    var func = this.getOnRecordStart();
    func && func(data);
  },

  onRecordEnd: function(data) {
    var func = this.getOnRecordEnd();
    func && func(data);
  },

  onFocus: function() {
    // TODO: owner might want onFocus callback
    this._converging();
  },

  onAutoExposure: function() {
    // TODO: owner might want onAutoExposure callback
    this._converging();
  },

  onAutoWhiteBalance: function() {
    // TODO: owner might want onAutoWhiteBalance callback
    this._converging();
  },

  onConverge: function() {
    var func = this.getOnConverge();
    func && func();
  },

  onPreviewStart: function() {
    if (logger.queryTimer(cameraConstants.LOG_PREVIEW_START) !== -1) {
      logger.endTimer(cameraConstants.LOG_PREVIEW_START, '');
    }
  },

  _converging: function() {
    this.convergeCount--;
    if (this.convergeCount === 0) {
      this.onConverge();
    }
  },

  _previewTouched: function(e, v) {
    var owner = this.getOwner();
    if (owner.onPreviewClick) {
      owner.onPreviewClick(e);
    }

    var x = e.offsetX;
    var y = e.offsetY;

    if (this.getTapToFocus()) {
      this.tapToFocus(x, y);
    }
  },

  flipCamera: function() {
    this.mode = this.mode === CAMERA_REAR ?
      CAMERA_FRONT :
      CAMERA_REAR;

    this.updateVideoSource(this.mode);
  },

  updateVideoSource: function(mode) {
    var src = this._getCameraPreviewSource(mode);
    this.findRef('videoSource').setAttributes({src: src});
    this.camNode.load();
  }
});
});

// module: incall/dtmf_keypad/index
// file:   ../../incall/lib/dtmf_keypad/index.js
define("incall/dtmf_keypad/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var View = require('bolt_touch/view').View;

var DtmfKey = core.createClass({
  name: 'DtmfKey',

  extend: View,

  delegateProperties: {
    keyName: [{ alias: 'keyName', name: 'content' }],
    subTitle: [{ alias: 'subTitle', name: 'content' }]
  },

  properties: {
    action: '',
    touchStart: '',
    touchEnd: ''
  },

  declare: function(options) {
    return {
      ontouchstart: 'touchStart',
      ontouchend: 'touchEnd',
      childViews: [{
        ref: 'keyName',
        additionalClasses: 'dtmf-key'
      }, {
        ref: 'subTitle',
        additionalClasses: 'dtmf-sub-title'
      }]
    };
  },

  touchStart: function(evt) {
    var func = this.getTouchStart();
    this.addClass('touched');
    if (func) {
      func(evt, this.getAction());
    }
  },

  touchEnd: function(evt) {
    var func = this.getTouchEnd();
    this.removeClass('touched');
    if (func) {
      func(evt, this.getAction());
    }
  }
});

var layoutMap = [
  [{ keyName: '1', subTitle: '', className: 'one' },
   { keyName: '2', subTitle: 'ABC' },
   { keyName: '3', subTitle: 'DEF' }],
  [{ keyName: '4', subTitle: 'GHI' },
   { keyName: '5', subTitle: 'JKL' },
   { keyName: '6', subTitle: 'MNO' }],
  [{ keyName: '7', subTitle: 'PQRS' },
   { keyName: '8', subTitle: 'TUV' },
   { keyName: '9', subTitle: 'WXYZ' }]
];

var purposeMap = {
  0: [ // PURPOSE_DIALER
    [ { keyName: '*',      subTitle: '', className: 'star'},
      { keyName: '0',      subTitle: '+'},
      { keyName: '#',      subTitle: '', className: 'one'}],
    [ { keyName: 'Call',   subTitle: '', className: 'call', action: 'call'}]
  ],
  1: [ // PURPOSE_FORWARDING
    [ { keyName: '*',      subTitle: '', className: 'star'},
      { keyName: '0',      subTitle: '+'},
      { keyName: '#',      subTitle: '', className: 'one'}],
    [ { keyName: ',' },
      { keyName: ';' },
      { keyName: '\u2190', subTitle: '', className: 'delete', action: 'delete'}]
  ],
  2: [ // PURPOSE_PINPAD
    [ { keyName: '',       subTitle: '', className: 'delete'},
      { keyName: '0',      subTitle: '', className: 'one'},
      {
        keyName: 'Emergency Call',
        subtitle: '',
        className: 'delete emergency',
        action: 'emergency'
      }]
  ],
  3: [ // PURPOSE_INCALL
    [ { keyName: '*',      subTitle: '', className: 'star'},
      { keyName: '0',      subTitle: '+'},
      { keyName: '#',      subTitle: '', className: 'one'}]
  ],
  4: [ // PURPOSE_TALK
    [ { keyName: '*',      subTitle: '', className: 'star'},
      { keyName: '0',      subTitle: '+'},
      { keyName: '#',      subTitle: '', className: 'one'}],
    [ { keyName: '',       subTitle: '', className: 'message',
        action: 'message', id: 'messageBtn'},
      { keyName: 'Call',   subTitle: '', className: 'call', action: 'call'},
      { keyName: '',       subTitle: '', className: 'delete',
        action: 'delete', id: 'deleteBtn'}]
  ]
};

var PURPOSE_DIALER = 0;
var PURPOSE_FORWARDING = 1;
var PURPOSE_PINPAD = 2;
var PURPOSE_INCALL = 3;
var PURPOSE_TALK = 4;

var DtmfKeypad = exports.DtmfKeypad = core.createClass({
  name: 'DtmfKeypad',

  extend: View,

  statics: {
    PURPOSE_DIALER: PURPOSE_DIALER,
    PURPOSE_FORWARDING: PURPOSE_FORWARDING,
    PURPOSE_PINPAD: PURPOSE_PINPAD,
    PURPOSE_INCALL: PURPOSE_INCALL,
    PURPOSE_TALK: PURPOSE_TALK
  },

  properties: {
    keyTouchStart: '',
    keyTouchEnd: '',
    purpose: PURPOSE_DIALER,
    showEmergencyButton: false
  },

  construct: function(options) {
    if (options.purpose) {
      this.setPurpose(options.purpose);
    }

    View.call(this, options);

    this._lastButtonPressed = '';
    this._buttonUnpressTimeoutId = null;

    this._setAudioApi();

    // Properly initialize the emergency button, if necessary
    this.setShowEmergencyButton(options.showEmergencyButton);

    // Initialize the button icons
    this._setupButtonIcons();
  },

  declare: function(options) {
    if (options.purpose) {
      this.setPurpose(options.purpose);
    }

    var rows = [];
    var lastRows = purposeMap[this.getPurpose()] ||
                   purposeMap[PURPOSE_DIALER];
    var layout = layoutMap.concat(lastRows);

    var touchStart  = util.bind(this.handleTouchStart, this);
    var touchEnd    = util.bind(this.handleTouchEnd, this);
    var touchCancel = util.bind(this.handleTouchCancel, this);

    for (var i = 0; i < layout.length; i++) {
      var row = layout[i];
      var rowView = { flex: 1, boxOrientation: 'horizontal', childViews: [] };

      for (var j = 0; j < row.length; j++) {
        row[j].action = row[j].action || row[j].keyName;
        var keyView = {
          flex: 1,
          ref: row[j].action,
          view: DtmfKey,
          keyName: row[j].keyName,
          subTitle: row[j].subTitle,
          additionalClasses: (row[j].className || ''),
          touchStart: touchStart,
          touchEnd: touchEnd,
          touchCancel: touchCancel,
          action: row[j].action
        };
        if (row[j].id) {
          keyView.id = row[j].id;
        }
        rowView.childViews.push(keyView);
      }

      rows.push(rowView);
    }

    return {
      boxOrientation: 'vertical',
      flex: 1,
      childViews: rows
    };
  },

  handleTouchStart: function(evt, action) {
    this.audioApi.startDtmfTone(action);

    var func = this.getKeyTouchStart();
    if (func) {
      func(evt, action);
    }
  },

  unmarkKeys: function() {
    var nodeList = document.querySelectorAll('.bt-dtmf-key.touched');
    for (var i = 0; i < nodeList.length; i++) {
      nodeList.item(i).classList.remove('touched');
    }
    this.audioApi.stopDtmfTone();
  },

  handleTouchEnd: function(evt, action) {
    this.unmarkKeys();

    var func = this.getKeyTouchEnd();
    if (func) {
      func(evt, action);
    }
  },

  handleTouchCancel: function(evt, action) {
    this.unmarkKeys();
  },

  setShowEmergencyButton: function(show) {
    var emergencyButton = this.refs.emergency;
    this.set('showEmergencyButton', show);
    if (emergencyButton) {
      if (show) {
        emergencyButton.setKeyName('Emergency Call');
        emergencyButton.addClass('emergency');
        emergencyButton.setAction('emergency');
      } else {
        emergencyButton.setKeyName('\u2190');
        emergencyButton.removeClass('emergency');
        emergencyButton.setAction('delete');
      }
    }
  },

  _setupButtonIcons: function() {
    if (this.refs.call) {
      var callButton = this.refs.call;
      callButton.setChildViews(
        [{
          additionalClasses: 'call-icon'
        }]
      );
    }
    if (this.getPurpose() === PURPOSE_TALK && this.refs.message) {
      var messageButton = this.refs.message;
      var deleteButton = this.refs.delete;
      messageButton.setChildViews(
        [{
          additionalClasses: 'message-icon'
        }]
      );
      deleteButton.setChildViews(
        [{
          additionalClasses: 'delete-icon'
        }]
      );
    }
  },

  _setAudioApi: function(api) {
    this.audioApi = api || FBAPI.use('audio');
  }
});
});

// module: views/picker/album_picker/picker_album_list_scene
// file:   ../../views/picker/album_picker/picker_album_list_scene.js
define("views/picker/album_picker/picker_album_list_scene", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core              = require('bolt/core');
var Scene             = require('bolt_touch/views/scene').Scene;
var ScrollView        = require('bolt_touch/views/scroll_view').ScrollView;
var TableView         = require("views/deprecated/table_view").TableView;
var TableViewCollectionSource =
  require('bolt_touch/mixins/table_view_collection_source')
    .TableViewCollectionSource;
var util              = require('bolt/util');

var AlbumListRow      = require('photos/app/lib/view/album_list_scene').AlbumListRow;
var PickerAlbumScene  = require('./picker_album_scene');
var SelectedPhotoCollection =
  require('./picker_model').SelectedPhotoCollection;

var albumStore        = require('photos/app/lib/model/album/album_store').getInstance();

var ROW_HEIGHT = 111;

var PickerAlbumListScene = exports.PickerAlbumListScene = core.createClass({
  name: 'PickerAlbumListScene',

  extend: Scene,

  mixins: [TableViewCollectionSource],

  declare: function(options) {
    this.callback = options.callback;

    return {

      additionalClasses: 'bt-album-list-scene',
      boxOrientation: 'vertical',
      flex: 1,

      childViews: [
        {
          boxOrientation: 'horizontal',
          additionalClasses: 'bt-bar',
          childViews: [
            {
              ref: 'title',
              content: 'Choose an Album...',
              additionalClasses: 'bt-bar-title',
              flex: 1
            },
            {
              ref: 'confirm',
              additionalClasses: 'bt-bar-button right bt-text-button',
              content: 'DONE'
            }
          ]
        },
        {
          ref: 'photoCounter',
          content: 'Photos Selected (0)',
          additionalClasses: 'photo-counter'
        },
        {
          view: ScrollView,
          ref: 'scroller',
          hScroll: true,
          vScroll: false,
          additionalClasses: 'selected-photos-collection',
          boxOrientation: 'horizontal',
          childViews: [
            {
              ref: 'selectedPhotosCollection',
              view: 'PickerSelectedThumbnailCollectionView',
              thumbnailTouchStart: util.bind(this._selectedPhotoTouched, this)
            }
          ]
        },
        {
          view: TableView,
          fixedRowHeight: ROW_HEIGHT,
          ref: 'albumListTable',
          sectioned: false,
          bufferSize: 2
        }
      ]
    };
  },

  ready: function() {
    this.refs.albumListTable.setLoading(true);

    this.selectedPhotosCollection = new SelectedPhotoCollection();
    this.refs.selectedPhotosCollection.setCollection(
      this.selectedPhotosCollection
    );

    this.setCellReuseIdentifier('album');
    this.setTableView(this.refs.albumListTable);

    this.refs.scroller.refresh();

    this.counter = 0;

    //this object will be shared between picker_album_list_scene and
    //picker_album_scene
    this.refreshCounter();

    albumStore.fetchAlbumCollection()
      .addCallback(function(albums) {
        this.albumList = albums;
        this.setCollection(this.albumList);
        // TODO: Why is this needed?
        this.refs.albumListTable.refresh();

        this.albumList.downloadHead(200)
          .addCallback(function() {
            this.refs.title.setContent('Choose an Album');
          }, this);
      }, this);
  },

  startTransition: function(transition) {
    if (transition === 'in.reverse') {
      this.refs.title.setContent('Choose an Album...');
      this.albumList.downloadHead(200)
        .addCallback(function() {
          this.refs.title.setContent('Choose an Album');
        }, this);
    }
  },

  collectionViewDidInsertChildView: function() {
    setTimeout(util.bind(this.refreshScrollViews, this), 500);
  },

  collectionViewDidRemoveChildView: function() {
    setTimeout(util.bind(this.refreshScrollViews, this), 500);
  },

  useHeader: function() {
    return false;
  },

  createTableViewCell: function(tableView, model, row, section) {
    if (this.refs.albumListTable.getLoading()) {
      this.refs.albumListTable.setLoading(false);
    }

    return new AlbumListRow();
  },

  cellSelectedAtRowInSection: function(tableView, row, section, cell) {
    tableView.deselectRowInSection(row, section);

    this.getStack().push({
      view: 'PickerAlbumScene',
      album: cell.getModel(),

      //method to call if photo is touched in picker_album_scene
      photoTouchCallback: util.bind(this.togglePhotoSelected, this),

      //method to call if user confirms photo selection in picker_album_scene
      callback: util.bind(this.onConfirm, this),

      photosCollection: this.selectedPhotosCollection
    }, {
      transition: 'slide'
    });
  },

  onConfirm: function() {
    var modelIds = this.selectedPhotosCollection.getIds();

    //backwards-compatibility: if only one photo, just return the photo, not an
    //array
    //
    ////unfortunately hackish. Remove Scene Stack (in the callback method) once
    //transition is complete wish there was a way to access the transition time
    //of scenes in the scene-stack

    var photos = [];
    if (modelIds.length == 1) {
      photos = this.selectedPhotosCollection.getById(modelIds[0]);
    } else {
      for (var i = 0; i < modelIds.length; i++) {
        photos.push(this.selectedPhotosCollection.getById(modelIds[i]));
      }
    }

    var _this = this;
    this.getStack().clearStack({}, {
      onComplete: function() {
        _this.callback(photos);
      }
    });
  },

  refreshCounter: function() {
    this.refs.photoCounter.setContent(
      'Photos Selected (' +
      this.selectedPhotosCollection.length + ')'
    );
  },

  togglePhotoSelected: function(photo) {
    if (photo.get('selected')) {
      this.selectedPhotosCollection.remove(photo);
    } else {
      var pickCounter = this.counter;
      //this ensures that photos are added to the end of the
      //selectedPhotoCollectionView photos are compared according to
      //pickPosition
      photo.set('pickPosition', pickCounter);
      this.counter += 1;
      this.selectedPhotosCollection.add(photo);

    }

    this.refreshCounter();
    return !photo.get('selected');
  },

  endTransition: function(direction) {
    this.refreshScrollViews();
  },

  refreshScrollViews: function(photo) {

    if (this.selectedPhotosCollection.length > 0) {
      this.refs.scroller.addClass('open');
    } else {
      this.refs.scroller.removeClass('open');
    }

    //this adjusts the width of the collection view so that the photos will fit
    //horizontally inside of it he min-width of the view is 481 (one bigger
    //than the width of the scroll view), so that the scroll view maintains its
    //horizontal-scrolling (any smaller and it reverts to vertical-scrolling)
    this.refs.selectedPhotosCollection.setStyle('width', Math.max(
        this.selectedPhotosCollection.length * 105,
        window.innerWidth - 13
      ) + 'px');
    this.refs.scroller.refresh();
  },

  //remove selected photo if touched
  _selectedPhotoTouched: function(view, evt) {
    var photo = view.getModel();
    photo.set('selected', false);
    this.selectedPhotosCollection.remove(photo);
    this.refreshCounter();
  },

  confirmClick: function(evt) {
    this.onConfirm(evt);
  }
});
});

// module: shared/data2/model/story/story_store
// file:   ../../shared/js/data2/model/story/story_store.js
define("shared/data2/model/story/story_store", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var Deferred = require('../../../deferred').Deferred;
var LocalMapper = require('../../local/local_mapper').LocalMapper;
var Store = require('../../store/store').Store;
var STATE = require('../../store/constants').STATE;
var Schema = require('../../store/schema').Schema;
var Filter = require('../../store/filter').Filter;
var Story = require('./story').Story;
var TypeTimestamp =
  require('../../store/schema/type/timestamp').TypeTimestamp;

var _sizeRegex = /[a-z]\.jpg/;

var assert = require('shared/util/assert').assert;

function createSchema() {
  var storyStoreVersions = require('./story_store_versions');
  return storyStoreVersions.getLatestSpec().getSchema();
}

function createLocalMapper(schema, database) {
  var storyStoreVersions = require('./story_store_versions');
  var migrations = storyStoreVersions.getMigrations();
  var migration = require('shared/data2/local/migration');
  if (!database) {
    database = require('shared/data2/local/init').getDatabase();
  }
  migration.migrate(database, 'story', migrations);
  return new LocalMapper(schema, 'story', database);
}

function createRemoteMapper(schema) {
  var StoryRemoteMapper = require('./story_remote_mapper').StoryRemoteMapper;
  return new StoryRemoteMapper(schema);
}

var StoryStore = core.createClass({

  name: 'StoryStore',

  extend: Store,

  properties: {
    modelType: Story
  },

  /**
   * @param {Number} limit of stories to load into colleciton
   */
  fetchStoryCollection: function(limit) {
    var filter = new Filter({filter_key: 'h'}, 'view_time_position DESC');
    return this.fetchCollection(filter, limit);
  },

  /**
   * Fetch a story by id
   * @param {number} id the story id
   * @return {Deferred}
   */
  fetchStory: function(id) {
    return this.fetchModel(id)
      .then(function(localModel) {
        var remoteDeferred = this.getRemoteMapper()
          .download(new Filter({id: id}), 1)
          .then(function(models) {
            var model = models && models[0];
            if (!model) {
              return {model: null, type: 'remote'};
            }
            if (localModel) {
              model.set('view_time_position',
                localModel.get('view_time_position'));
              model.set('is_highlight', localModel.get('is_highlight'));
              model.set('filter_key', localModel.get('filter_key'));
              model.set('fetched_time', localModel.get('fetched_time'));
            }
            // if the model that we fetched has a parent_post_id, we don't
            // want to store it because we already have its parent story
            // stored.
            if (!model.get('parent_post_id')) {
              this.store(models);
            }
            return {model: models[0], type: 'remote'};
          }, this);
        var result = {remote: remoteDeferred, type: 'local'};
        if (localModel) {
          result.model = localModel;
        }
        return result;
      }, this);
  },

  /**
   * Overrides Store's downloadCollectionHead to check and deal with gaps.
   * If none of the most recent stories downloaded are stored locally, then
   * there is most likely a gap in time between the oldest story downloaded
   * and the most recent story in local store. To deal with this gap, delete
   * all of the local stories.
   */
  downloadCollectionHead: function(collection, limit) {
    limit = (limit || 10) * 1;

    return this.getRemoteMapper().download(collection.getFilter(), limit)
      .then(function(models) {
        return this.getLocalMapper().findIDs(
          new Filter({id: util.invoke(models, 'getId')}), models.length)
            .then(function(ids) {
              if (ids.length > 0) {
                return this._downloadedHead(models);
              } else {
                return this.getLocalMapper().findIDs(new Filter({}), 9e9)
                  .then(function(ids) {
                    return this._downloadedHead(models)
                      .then(this.remove, this, ids);
                  }, this);
              }
            }, this);
      }, this);
  },

  /**
   * After downloading the most recent stories, we must set a fetched_time for
   * them so they can be sorted alongside ticker stories. Set the fetched_time
   * to the current time for all downloaded stories that are more recent than
   * the most recent local story, update all stories in local store with newly
   * downloaded data and discard all downloaded stories that are older than the
   * most recent story in local store.
   */
  _downloadedHead: function(models) {
    if (!models || !models.length) {
      return (new Deferred()).succeed(models);
    } else {
      var ids = util.invoke(models, 'getId');
      return this.fetchCollection({filter_key: 'h'},
        'view_time_position DESC', 1)
        .then(function(thresholdCollection) {
          var threshold = (thresholdCollection.first() &&
            thresholdCollection.first().get('view_time_position')) || 0;
          thresholdCollection.destroy();
          return this.fetchCollection({ id: ids }, ids.length)
          .then(function(existingCollection) {
            var timestamp = Date.now();
            var modelsToStore = [];
            models.forEach(function(model) {
              var existing = existingCollection.getById(model.getId());
              if (existing) {
                // Calls to the API don't set view_time_position for each
                // call. For any two stories X and Y, if X.fetched_time >=
                // Y.fetched_time, X.view_time_position >= Y.view_time_position
                // and vice versa.
                model.set('view_time_position',
                  existing.get('view_time_position'));
                model.set('fetched_time', existing.get('fetched_time'));
                modelsToStore.push(model);
              } else if (model.get('view_time_position') > threshold) {
                model.set('fetched_time', timestamp);
                modelsToStore.push(model);
              } else {
                console.warn('StoryStore fetched a story it should have.');
              }
            });
            existingCollection.destroy();
            return this.store(modelsToStore);
          }, this);
        }, this);
    }
  },

  /**
   * Called after stories downloaded after a certain view_time_position are
   * fetched. Set all of their fetched_time to 0, as fetched_time refers to the
   * fetched time of stories from the head of the feed and nowhere else. Sorting
   * for these stories should be done by view_time_position.
   */
  _downloaded: function(models) {
    models.forEach(function(model) {
      model.set('fetched_time', 0);
    });
    return this.store(models);
  }
});

exports.StoryStore = StoryStore;

var _instance = null;
exports.createLocalMapper = createLocalMapper;
exports.createRemoteMapper = createRemoteMapper;
exports.createSchema = createSchema;
exports.getInstance = function(remoteMapper, localMapper, schema) {
  if (!_instance) {
    schema = schema || createSchema();
    localMapper = localMapper || createLocalMapper(schema);
    remoteMapper = remoteMapper || createRemoteMapper(schema);
    _instance = new StoryStore(remoteMapper, localMapper);
  }
  return _instance;
};
});

// module: shared/data2/remote/remote_mapper
// file:   ../../shared/js/data2/remote/remote_mapper.js
define("shared/data2/remote/remote_mapper", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*globals undefined:false, __DEV__:false */
var LOG_FQL  = __DEV__ && !this.__PERF_TEST__;


var core = require('bolt/core');
var util = require('bolt/util');
var Deferred = require('shared/deferred').Deferred;

var FQL_ESCAPE_RE = /(["'\\])/g;

function fqlEscape(value) {
  if (typeof value == 'number' || typeof value == 'boolean') {
    return value;
  }
  return '"' + (value + '').replace(FQL_ESCAPE_RE, '\\$1') + '"';
}

/**
 * Remote mapper is responsible for reading/writing models to facebook API.
 */
exports.RemoteMapper = core.createClass({

  name: 'RemoteMapper',

  properties: {
    schema: null,
    tableName: 'dummy',
    /**
     * @property {Object} [migrationsOverride] an object specifying
     *  which fql migrations to override.
     */
    migrationsOverride: null,
    /**
     * @property {String} seqProperty the property to use when constructing
     *   the WHERE FQL clause. Default is timestamp.
     */
    seqProperty: 'timestamp'
  },

  /**
    @private

    The object responsible for executing requests against the Facebook API.
    It will default to the object defined in shared/js/api_xhr.js
  */
  _apiRequester: null,

  /**
   * @constructor
   * @param {Schema} schema
   * @param {String} tableName
   * @param {Object} [apiRequester] The object that executes the remote requests
   *   Defaults to apixhr which is defined in shared/js/api_xhr
   * @returns {RemoteMapper}
   */
  construct: function(schema, tableName, apiRequester) {
    this.setSchema(schema || this.getSchema());
    this.setTableName(tableName || this.getTableName());

    if (!apiRequester) {
      apiRequester = require('shared/api_xhr');
    }
    this._apiRequester = apiRequester;
  },

  remoteToModel: function(data) {
    var schema = this.getSchema();
    var object = {};
    schema.getPropertyNames().forEach(function(name) {
      var info = schema.getPropertyInfo(name);

      if (info.generatedRemote) {
        // Sometimes a local value needs to be created as the result of a
        // combination of two or more remote values.  In such a case they set
        // the 'generatedRemote' value.
        object[name] = info.transformRemoteToModel(null, data);
      } else if (info.remote) {
        if (typeof info.remote === 'string') {
          object[name] = info.transformRemoteToModel(data[info.remote], data);
        } else {
          var propertyData = {};
          var length = info.remote.length;
          for (var i = 0; i < length; i++) {
            propertyData[info.remote[i]] = data[info.remote[i]];
          }
          object[name] = info.transformRemoteToModel(propertyData, data);
        }
      }
    });
    var ModelType = schema.getModelType();
    return new ModelType(object);
  },

  getRemoteColumns: function() {
    var schema = this.getSchema();
    var result = [];

    // Allow multiple local fields to map to a single remote column.
    // Pre-populate the names hash with _composite_ so it can be ignored.
    var names = {};
    schema.getPropertyNames().forEach(function(name) {
      var info = schema.getPropertyInfo(name);
      if (info.remote) {
        if (typeof info.remote === 'string') {
          if (!names[info.remote]) {
            names[info.remote] = true;
            result.push(info.remote);
          }
        } else {
          for (var i = 0; i < info.remote.length; i++) {
            if (!names[info.remote[i]]) {
              names[info.remote[i]] = true;
              result.push(info.remote[i]);
            }
          }
        }
      }
    });
    return result;
  },

  getFQLQuery: function(filter) {
    if (filter.getFQLQuery()) {
      return filter.getFQLQuery();
    }

    var schema = this.getSchema();
    var properties = filter.getProperties();
    var result = [];
    util.forEach(properties, function(value, propertyName) {
      var info = schema.getPropertyInfo(propertyName);
      if (info.remote) {
        if (value && value.subquery) {
          result.push(info.remote + ' IN (' +
          value.subquery + ')');
        } else if (util.isArray(value)) {
          result.push(info.remote + ' IN (' +
            value
              .map(info.transformModelToRemote, info)
              .map(fqlEscape).join(',') + ')');
        } else {
          result.push(info.remote + '=' + fqlEscape(
            info.transformModelToRemote(value)));
        }
      }
    });
    return result.join(' AND ');
  },

  getFQLOrder: function(filter) {
    if (filter.getSQLOrder()) {
      return filter.getSQLOrder();
    }
    var order = filter.getOrder();
    if (!order) {
      return null;
    }
    var info = this.getSchema().getPropertyInfo(order[0]);
    if (info.remote) {
      return info.remote + ' ' + order[1];
    }
    return null;
  },

  // read/search
  downloadNext: function(model, filter, limit) {
    return this.download(
      filter,
      limit,
      this._modelToWhere(filter, model, false));
  },

  downloadPrevious: function(model, filter, limit) {
    return this.download(
      filter,
      limit,
      this._modelToWhere(filter, model, true));
  },

  download: function(filter, limit, _orderingWhere) {
    var params = {
      method: 'fql.query',
      query: this.getFqlQuery(filter, limit, _orderingWhere)
    };
    var migrationsOverride = this.getMigrationsOverride();
    if (migrationsOverride) {
      params.migrations_override = migrationsOverride;
    }
    if (LOG_FQL) {
      var t = Date.now();
    }
    return this._apiRequester.rest(params).then(function(data) {
      if (LOG_FQL) {
        console.info('fql', Date.now() - t, params.query);
      }
      if (!(data instanceof Array)) {
        if (data && data.error_msg && data.error_code) {
          console.error('Error downloading: ' + data.error_msg +
            'and error Code: ' + data.error_code + ' for request: ' +
            JSON.stringify(params));
        } else {
          console.error('Error downloading.');
        }
        return (new Deferred()).fail();
      }
      var models = [];
      for (var i = 0, l = data.length; i < l; i++) {
        models.push(this.remoteToModel(data[i]));
      }
      return (new Deferred()).succeed(models, models.length >= limit);
    }, this);
  },

  getFqlQuery: function(filter, limit, _orderingWhere) {
    var fql = 'SELECT ' + this.getRemoteColumns().join(',') +
      ' FROM ' + this.getTableName();

    var where = this.getFQLQuery(filter);
    var order = this.getFQLOrder(filter);
    if (_orderingWhere) {
      if (where) {
        where = '(' + where + ') AND (' + _orderingWhere + ')';
      } else {
        where = _orderingWhere;
      }
    }
    if (where) {
      fql += ' WHERE ' + where;
    }
    if (order) {
      fql += ' ORDER BY ' + order;
    }
    if (limit) {
      fql += ' LIMIT ' + limit;
    }
    return fql;
  },

  _modelToWhere: function(filter, model, isPrevious) {
    var schema = this.getSchema();
    var order = filter.getOrder();
    var name = order && order[0] || this.getSeqProperty();
    var info = schema.getPropertyInfo(name);
    var remoteName = info.remote;
    var value = info.transformModelToRemote(model.get(name));
    return remoteName + (isPrevious ? '<' : '>') + fqlEscape(value);
  },

  // create/update
  upload: function(models) {},

  // delete
  remove: function(model) {}
});
});

// module: bolt/core
// file:   ../../../frameworks/bolt/lib/core.js
define("bolt/core", function(require, exports, module) {
/**
 * Copyright (c) 2011-2012, Facebook, Inc.
 * All rights reserved.
 *
 * @option preserve-header
 *
 */

var util = require('./util');

// prefix for storing properties on the object. This is a holdover from Javelin.
var PROP_PREFIX = '__auto__';

// these keys are handled specially and are not
// automatically added to the protototype of the new Class
var SPECIAL_KEYS = {
  statics:            true,
  members:            true,
  mixins:             true,
  extend:             true,
  properties:         true,
  events :            true,
  name :              true,
  classExtended:      true
};

var seenDeprecations = {};
var deprecated = exports.deprecated = function(what, replacement) {
  var msg = what + ' is deprecated.';
  if (replacement) {
    msg += '\nUse ' + replacement + ' instead.';
  }
  if (!seenDeprecations[msg]) {
    seenDeprecations[msg] = true;
    console.warn(msg);
  }
};


// This is a hold over from JX. Sometimes folks are declaring classes
// with string values for extends. We need to track the classes that
// have been declared by name as a result.
var ClassRegistry = exports.ClassRegistry = {};

// Base object used in prototype chaining
var Base = function() {};

// setup the inheritance chain from parent to child
var inherit = exports.inherit = function(__super__, construct) {
  var klass;

  // if we have a constructor then use it otherwise provide a constructor
  // that automatically invokes the parent;
  if (construct) {
    klass = construct;
  } else {
    klass = function() {return __super__.apply(this, arguments);};
  }

  // setup the prototype chain without instantiating the superclass
  Base.prototype = __super__.prototype;
  klass.prototype = new Base();

  // set the constructor property of the klass
  klass.prototype.constructor = klass;

  return klass;
};

// createClass exported and also aliased as declare
var createClass = exports.createClass = exports.declare = function(config) {
  // setup the inheritance chain
  var __super__ = config.extend;
  var klass;
  if (__super__) {
    klass = inherit(__super__, config.construct);
  } else {
    klass = config.construct || function() {};
  }

  // set the klassName property
  ClassRegistry[config.name] = klass;
  klass.klassName = config.name || '';

  // Add the default implementation of getDeclaredClass
  klass.prototype.getDeclaredClass = getDeclaredClass;

  // setup classExtended
  klass.classExtended = config.classExtended ||
    bindCommonExtend(config.extend, config.mixins, 'classExtended');
  // setup mixinIncluded
  klass.mixinIncluded = config.mixinIncluded ||
    bindCommonExtend(config.extend, config.mixins, 'mixinIncluded');

  // setup mixins
  config.mixins && addMixins(klass, config.mixins);

  // add the instance methods
  addPrototypeMembers(klass, config);
  // add the static class methods
  config.statics && util.extend(klass, config.statics);

  // custom initialization for class
  klass.classExtended(klass, config);

  // custom extension
  config.mixins && includeMixins(klass, config.mixins);


  // the stuff should probably be removed. Keeping it for backwards compat
  // for now
  doClassHierarchyTracking(klass, __super__);

  return klass;
};

function bindCommonExtend(base, mixins, method) {
  var extensions = [];
  if (mixins) {
    for (var i = mixins.length - 1; i >= 0; i--) {
      if (mixins[i][method]) {
        extensions.push(mixins[i][method]);
      }
    }
  }
  if (base && base[method]) {
    extensions.push(base[method]);
  }
  if (extensions.length == 0) {
    return commonExtension;
  } else {
    return function(klass, config) {
      for (var i = 0; i < extensions.length; i++) {
        extensions[i](klass, config);
      }
      commonExtension(klass, config);
    };
  }
}

function commonExtension(klass, config) {
  // setup properties
  addProperties(klass, config);
}

exports.commonExtension = commonExtension;


function addPrototypeMembers(klass, config) {
  // JX had a convention of putting instance properties/methods into a members
  // key in the config. We are maintaining actively deprecated this
  // functionality.
  if (config.members) {
    console.warn('Member is deprecated, please fix ' + config.name + '.');
  }
  config.members = config.members || {};
  for (var key in config) {
    if (!SPECIAL_KEYS[key]) {
      config.members[key] = config[key];
    }
  }
  util.extend(klass.prototype, config.members);
}

function includeMixins(klass, mixins) {
  for (var i = 0; i < mixins.length; i++) {
    klass.mixinIncluded(klass, mixins[i]);
  }
}

// mixins are added to the prototype and optionally provide a mixinReady hook
// Must run AFTER inheriting from parent class but before declaring current
// class so that mixins can override parent class members but can be
// overwritten by current class members.
function addMixins(klass, mixins) {
  var mixinReadyFunctions = [];
  var proto = klass.prototype;
  for (var i = 0; i < mixins.length; i++) {
    var mixin = mixins[i];
    for (var key in mixin) {
      if (!proto.hasOwnProperty(key) && key !== 'mixinReady' && key !== 'properties') {
        proto[key] = mixin[key];
      }
    }
    mixin.mixinReady && mixinReadyFunctions.push(mixin.mixinReady);
  }

  if (mixinReadyFunctions.length > 0) {
    proto.mixinReadyFunctions = mixinReadyFunctions;
  }
}

// Cache the auto generated setters so as to minimize
// object creation
var cachedSetters = {};
var cachedGetters = {};

function generateSetter(key) {
  if (!cachedSetters[key]) {
    var propName = PROP_PREFIX + key;
    cachedSetters[key] = function(value) {
      this[propName] = value;
      return this;
    };
  }
  return cachedSetters[key];
}

function generateGetter(key) {
  if (!cachedGetters[key]) {
    var propName = PROP_PREFIX + key;
    cachedGetters[key] = function() {
      return this[propName];
    };
  }
  return cachedGetters[key];
}

// declared properties automatically create getters and setters
function addProperties(klass, config) {
  var getter, setter, proto = klass.prototype;
  proto.get || (proto.get = getProperty);
  proto.set || (proto.set = setProperty);

  if (!proto.setProperty) {
    proto.setProperty = function() {
      deprecated('setProperty', 'set');
      return setProperty.apply(this, arguments);
    };
  }
  if (!proto.getProperty) {
    proto.getProperty = function() {
      deprecated('getProperty', 'get');
      return getProperty.apply(this, arguments);
    };
  }

  if (!config.properties) {
    return;
  }
  var properties = config.properties;

  var defaultValue;
  for (var key in properties) {
    defaultValue = properties[key];
    setter = util.setter(key);
    getter = util.getter(key);

    if (!proto.hasOwnProperty(PROP_PREFIX + key)) {
      proto[PROP_PREFIX + key] = defaultValue;
    }
    if (!proto.hasOwnProperty(setter)) {
      proto[setter] = generateSetter(key);
    }
    if (!proto.hasOwnProperty(getter)) {
      proto[getter] = generateGetter(key);
    }
  }
}

// shared getProperty method
function getProperty(key) {
  return this[PROP_PREFIX + key];
}

// shared setProperty method
function setProperty(key, value) {
  this[PROP_PREFIX + key] = value;
  return this;
}

function doClassHierarchyTracking(klass, __super__) {
  klass.prototype.klass = klass;
  klass.superKlass = __super__;
  klass.inheritanceChain = __super__ ?
    [klass].concat(__super__.inheritanceChain) :
    [klass];
}

function getDeclaredClass() {
  return this.klass.klassName;
}
});

// module: photos/app/lib/view/photo_view/index
// file:   ../../photos/app/lib/view/photo_view/index.js
define("photos/app/lib/view/photo_view/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core                = require('bolt/core');
var View                = require('bolt_touch/view').View;
var ImageQueue          = require('bolt_touch/util/image_queue');
var Loader              = require('../loader').Loader;
var PhotoTags           = require('../photo_tags').PhotoTags;
var FeedbackBar         = require('views/feedback/bar').FeedbackBar;
var UfiFeedbackView     = require('views/feedback/flyout').UfiFeedbackView;
var ActionableView      = require('bolt_touch/views/actionable_view').ActionableView;

var PhotoView = exports.PhotoView = core.createClass({
  name: 'PhotoView',

  extend: View,

  events: ['photoTouched', 'photoTagTouched', 'photoTagDeleteTouched'],

  declare: function() {
    return {
      childViews: [
        {
          ref: 'photoWrapper',
          className: 'photo-wrapper',
          view: ActionableView,
          action: '_photoTouched',
          childViews: [
            {
              tagName: 'img',
              ref: 'photoImg',
              className: 'photoImg'
            },
            {
              ref: 'tags',
              view: PhotoTags
            }
          ]
        },
        {
          ref: 'footer',
          className: 'footer',
          childViews: [
            {
              ref: 'caption',
              className: 'caption'
            },
            {
              ref: 'separator',
              className: 'separator'
            },
            {
              view: FeedbackBar,
              ref: 'feedbackBar',
              overlay: true,
              onaction: '_feedbackBarTouched'
            },
            {
              ref: 'bottomGradient',
              className: 'bottom-gradient'
            }
          ]
        },
        {
          view: Loader,
          ref: 'loader'
        }
      ]
    };
  },

  ready: function() {
    this.findRef('tags').listen('photoTagTouched', this._forwardEvent, this);
    this.findRef('tags').listen('photoTagDeleteTouched', this._forwardEvent, this);
  },

  setModel: function(model) {
    this.set('model', model);

    if (model.get('cacheState') === 'thumbnail') {
      this._updateImage(model.get('thumbnail_url'));
    }
    else if (model.get('cacheState') === 'full') {
      this._updateImage(model.get('full_url'));
    }
    else {
      this._clearImage();
    }

    this._didShowPhoto = false;
  },

  showPhoto: function() {
    // PhotoCarousel may call this method multiple times for the
    // same photo. We just need to ignore the subsequent calls.
    if (!this._didShowPhoto) {
      this._didShowPhoto = true;
    }
    else {
      return;
    }

    // Only download the full photo if we don't already have it
    // cached.
    if (this.get('model').get('cacheState') !== 'full') {
      ImageQueue.add(
        this.get('model').get('full_url'),
        this._onImageLoad,
        this,
        'PhotoView'
      );
    }
  },

  showTags: function() {
    this.shouldShowTags = true;
    this.findRef('tags').showTags();
  },

  hideTags: function() {
    this.shouldShowTags = false;
    this.findRef('tags').hideTags();
  },

  setTags: function(tags, boundingBox) {
    this.findRef('tags').setTags(tags, boundingBox);
    if (this.shouldShowTags) {
      this.showTags();
    } else {
      this.hideTags();
    }
  },

  _photoTouched: function(view, evt) {
    // #EventCompatibilityHack
    if (evt.targetView && evt.targetView.getOwner().klass.klassName === 'PhotoTag') {
      return;
    }

    var node = this.findRef('photoWrapper').getNode();

    var touch = evt.changedTouches[0];
    this.invoke('photoTouched', {
      percentX: ((touch.pageX - node.offsetLeft)  / node.offsetWidth) * 100,
      percentY: ((touch.pageY - node.offsetTop) / node.offsetHeight) * 100
    });
  },

  _onImageLoad: function(src, w, h) {
    // Make sure that the image loaded is for this model
    // (and not an earlier one)
    if (src == this.get('model').get('full_url')) {
      this._updateImage(src);
      this.getModel().set('cacheState', 'full');
    }
  },

  _updateImage: function(src) {
    var photo = this.getModel();

    // Set the photo source
    this.refs.photoImg.setAttributes({ src: src });

    // Determine the size and position of the photo
    this._determineImageSizeAndPosition();

    // Set the size of the photo
    this.refs.photoImg.setStyle({
      width: this._width + 'px',
      height: this._height + 'px'
    });

    // Translate the wrapper to center the photo
    this.refs.photoWrapper.setStyle({
      webkitTransform: 'translate3d(' + this._translateX + 'px, ' + this._translateY + 'px, 0)'
    });

    // now we can show tags
    var tags = photo.getTags();
    var boundingBox = {
      top: 0,
      left: 0,
      width: this._width,
      height: this._height
    };
    this.setTags(tags, boundingBox);

    // Update the caption
    this.refs.caption.setContent(photo.get('name'));
    this.refs.caption.toggle(photo.get('name'));

    // Update the feedback bar
    this.findRef('feedbackBar').setBinding({
      model: photo,
      options: [{property: 'likes'}, {property: 'comments'}]
    });

    // Decide if we need the separator between the caption and the feedback bar
    this.refs.separator.toggle(photo.get('name') && this.refs.feedbackBar.getIsDisplayed());

    // Decide if we need the bottom gradient
    if (photo.get('name') || this.refs.feedbackBar.getIsDisplayed()) {
      var spread = this.refs.footer.getNode().offsetHeight + 20;
      this.refs.bottomGradient.setStyle({
        webkitBoxShadow: '0 0 100px ' + spread + 'px rgba(0, 0, 0, 0.3)'
      });
    }
    else {
      this.refs.bottomGradient.setStyle({
        webkitBoxShadow: 'none'
      });
    }

    this.refs.loader.hide();
  },

  _determineImageSizeAndPosition: function() {
    var photoWidth = this.getModel().get('width');
    var photoHeight = this.getModel().get('height');
    var containerWidth = this.getNode().offsetWidth;
    var containerHeight = this.getNode().offsetHeight;

    if (photoWidth > photoHeight) {
      var scale = containerWidth / photoWidth;
      this._width = photoWidth * scale;
      this._height = photoHeight * scale;
      this._translateX = 0;
      this._translateY = (containerHeight - this._height) / 2;
    }
    else {
      var scale = containerHeight / photoHeight;
      this._width = photoWidth * scale;
      this._height = photoHeight * scale;
      this._translateX = (containerWidth - this._width) / 2;
      this._translateY = 0;
    }
  },

  _feedbackBarTouched: function() {
    var photo = this.getModel();
    this._feedbackView = new UfiFeedbackView({
      model: photo,
      ufiYCoordinate: this._getUfiYCoordinate(),
      //onscrollTo: '_scrollTo',
      onclosed: '_feedbackViewClosed',
      owner: this
    });
    this._feedbackView.placeIn(document.body);
  },

  _getUfiYCoordinate: function() {
    var rect = this.findRef('feedbackBar').getRect();
    return rect.top + rect.height / 2;
  },

  _feedbackViewClosed: function() {
    this._feedbackView.destroy();
  },

  _clearImage: function() {
    this.refs.photoImg.setAttributes({ src: '' });
    this.refs.loader.show();
  },

  _forwardEvent: function(evt) {
    // #EventCompatibilityHack
    if (evt.targetView && evt.targetView.klass.klassName !== 'PhotoTags') {
      return;
    }

    evt.data.photo = this.get('model');
    this.invoke(evt.type, evt.data);
    evt.stopPropagation();
  }
});
});

// module: bolt_touch/views/scroll_view_lite
// file:   ../../../frameworks/bolt_touch/lib/views/scroll_view_lite.js
define("bolt_touch/views/scroll_view_lite", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var View = require('bolt_touch/view').View;

var _requestAnimationFrame = (
  window.requestAnimationFrame ||
  window.webkitRequestAnimationFrame ||
  window.mozRequestAnimationFrame ||
  window.oRequestAnimationFrame ||
  window.msRequestAnimationFrame ||
  function(callback, element) {
    setTimeout(callback, 1000 / 60);
  }
);

/**
 * A scroll view which uses native scrolling to scroll an area.
 * It offers much less functionality than the ScrollView class,
 * but works well for simple scrolling tasks.
 */
var ScrollView = core.createClass({

  name: 'ScrollView',

  extend: View,

  properties: {
    useScrollbar: true,
    vScroll: true,
    hScroll: false
  },

  flex: 1,

  createDom: function(options) {
    var node = View.prototype.createDom.call(this, options);
    node.style.position = 'relative';
    if (!this._scroller) {
      this._scroller = this.build({
        className: 'scroller',
        style: {
          position: 'relative'
        }
      });
      node.appendChild(this._scroller.getNode());
    }

    return node;
  },

  ready: function() {
    this.setVScroll(this.getVScroll());
    this.setHScroll(this.getHScroll());
    this._node = this.getNode();

    this.onTouchstart = util.bind(this.onTouchstart, this);
    this.onScroll = util.bind(this.onScroll, this);
    this.onScrollEnd = util.bind(this.onScrollEnd, this);
    this._node.addEventListener('scroll', this.onScroll, false);

    this.animLoop = util.bind(this.animLoop, this);
  },

  destroy: function() {
    View.prototype.destroy.call(this);
    this._node.removeEventListener('scroll', this.onScroll, false);
    this._node.removeEventListener('touchstart', this.onTouchstart, false);
    this._scroller.destroy();
    this.scrolling = false;
  },

  onScrollStart: function() {
    this.scrolling = true;
    var owner = this.getOwner();
    owner.didScrollStart && owner.didScrollStart(this);
  },

  onScroll: function(event) {
    if (this.isDestroyed) {
      return;
    }
    if (event) {
      event.stopPropagation();
      event.cancelBubble = true;  // Support IE, why not? ;-)
    }
    if (!this.scrolling) {
      this.scrolling = true;
      this.onScrollStart();
    }
    var node = this._node;
    if (node.scrollLeft > 1 || node.scrollTop > 1) {
      clearTimeout(this._scrollEndTimeout);

      this._scrollEndTimeout = setTimeout(this.onScrollEnd, 200);
      var owner = this.getOwner();

      if (owner.scrollViewDidScrollTo) {
        owner.scrollViewDidScrollTo(this, node.scrollLeft, node.scrollTop);
      }
    }
  },

  onScrollChange: function(newX, newY) {
    var owner = this.getOwner();
    if (owner && owner.willScrollToAnimated) {
      owner.willScrollToAnimated(newX, newY);
    }
  },

  onScrollEnd: function() {
    var owner = this.getOwner();
    if (owner && owner.didScrollTo) {
      owner.didScrollTo(this._node.scrollLeft, -this._node.scrollTop, this);
    }
    this.scrolling = false;
  },

  onTouchstart: function() {
    this._anim.canceled = true;
  },

  scrollTo: function(x, y, time, relative, timingFunction) {
    timingFunction = timingFunction || require('bolt_touch/util/easing').linear;

    if (relative) {
      x = this._node.scrollLeft + x;
      y = this._node.scrollTop + y;
    }

    this.onScrollChange(x,y);
    this.onScroll();

    if (time) {
      this.animateScroll(x, y, time, timingFunction);
    } else {
      this._node.scrollLeft = x;
      this._node.scrollTop = y;
    }
  },

  stopScrollAnimation: function() {
    if (this._anim) {
      this._anim.canceled = true;
    }
  },

  animateScroll: function(x, y, time, timingFunction) {
    var scrollLeft = this._node.scrollLeft;
    var scrollTop = this._node.scrollTop;
    this.animating = true;
    this._anim = {
      initialX: scrollLeft,
      initialY: -scrollTop,
      targetX: x,
      targetY: y,
      lastX: scrollLeft,
      lastY: -scrollTop,
      duration: time,
      timingFunction: timingFunction,
      start: Date.now(),
      canceled: false
    };
    this._node.addEventListener('touchstart', this.onTouchstart, false);
    _requestAnimationFrame(this.animLoop, this._node);
  },

  animLoop: function(timestamp) {
    var done;
    var anim = this._anim;
    var node = this._node;
    if (anim.canceled
        || node.scrollLeft !== anim.lastX
        || node.scrollTop !== -anim.lastY) {
      // if something other than animLoop scrolled _node, cancel the animation
      // this is necessary for mouse wheel and scrollbar scrolls
      done = true;
    } else {
      var initialX = anim.initialX;
      var initialY = anim.initialY;
      var targetX = anim.targetX;
      var targetY = anim.targetY;
      var duration = anim.duration;
      var timingFunction = anim.timingFunction;

      var x, y;
      var timeProgress = timestamp - anim.start;
      if (timeProgress < duration) {
        var scrollProgress = timingFunction(timeProgress / duration);
        x = (targetX - initialX) * scrollProgress + initialX;
        y = (targetY - initialY) * scrollProgress + initialY;
        done = false;
      } else {
        x = targetX;
        y = targetY;
        done = true;
      }
      x = Math.round(x);
      y = Math.round(y);
      anim.lastX = x;
      anim.lastY = y;
      node.scrollLeft = x;
      node.scrollTop = -y;
    }
    if (done) {
      node.removeEventListener('touchstart', this.onTouchstart, false);
    } else {
      _requestAnimationFrame(this.animLoop, node);
    }
  },

  setContentHeight: function(height) {
    this._scroller.setStyle({height: height + 'px'});
    this.refresh();
  },

  setContentWidth: function(width) {
    this._scroller.setStyle({width: width + 'px'});
    this.refresh();
  },

  setVScroll: function(vScroll) {
    this.set('vScroll', vScroll);
    this.setStyle({overflowY: vScroll ? 'auto' : 'hidden'});
  },

  setHScroll: function(hScroll) {
    this.set('hScroll', hScroll);
    this.setStyle({overflowX: hScroll ? 'auto' : 'hidden'});
  },

  /**
   * @return {number} the height of the scrollable area.
   */
  getScrollableAreaHeight: function() {
    return this._scroller.getNode().scrollHeight;
  },

  /**
   * @return {number} the width of the scrollable area.
   */
  getScrollableAreaWidth: function() {
    return this._scroller.getNode().scrollWidth;
  },

  appendChild: function(child) {
    this.getChildViews().push(child);
    this._scroller.getNode().appendChild(child.getNode());
    child.setParentView(this);
    this.refresh();
    return this;
  },

  insertChild: function(child, position) {
    View.prototype.insertChild.call(this, child, position);
    this.refresh();
    return this;
  },

  _insertNodeBefore: function(child, beforeChild) {
    this._scroller.getNode()
      .insertBefore(child.getNode(), beforeChild.getNode());
  },

  /**
   * Refresh should be called when the contents of a ScrollView change or change
   * size. This fires a resize event.
   */
  refresh: function() {
    this.invoke('resize');
  },

  clear: function() {
    util.invoke(this.getChildViews(), 'destroy');
    this.setContent('');
  },

  /**
   * @return {number} the height of the viewport.
   */
  getViewportHeight: function() {
    return this.getNode().clientHeight;
  },

  /**
   * @return {number} the width of the viewport.
   */
  getViewportWidth: function() {
    return this.getNode().clientWidth;
  },

  /**
   * get the current coordinates for the scroller
   */
  coords: function() {
    return [this._node.scrollLeft, this._node.scrollTop];
  }
});

exports.ScrollView = ScrollView;
});

// module: view/message_list/message_list
// file:   view/message_list/message_list.js
define("view/message_list/message_list", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core  = require('bolt/core');
var ScrollView = require('bolt_touch/views/scroll_view').ScrollView;

var BaseList = require('view/base_list/base_list').BaseList;
var AdminMessageRow =
  require('view/admin_message_row/admin_message_row').AdminMessageRow;
var MessageRow = require('view/message_row/message_row').MessageRow;
var DelimiterMessageRow =
  require('view/delimiter_message_row/delimiter_message_row')
    .DelimiterMessageRow;
var Loading = require('view/loading/loading').Loading;
var statusBar = require('view/status_bar/status_bar');

var ClientMessage =
  require('talk/client/model/message/client_message').ClientMessage;
var MESSAGE_TYPES =
  require('talk/client/model/message/message_types').MESSAGE_TYPES;

var DataList = require('bolt_touch/views/data_list').DataList;
var ClusteredCollection =
  require('lib/clustered_collection').ClusteredCollection;

if (window.__PERF_LOGGING__) {
  var realDataList = DataList;
  var DataList = core.createClass({
    name: 'DataListWithPerf',
    extend: realDataList,

    construct: function(options) {
      this._updateTimer = 0;
      realDataList.call(this, options);
    },

    update: function() {
      var start = Date.now();
      realDataList.prototype.update.call(this);
      this._updateTimer += (Date.now() - start);
    }
  });
}

exports.MessageList = core.createClass({
  name: 'MessageList',

  extend: BaseList,

  properties: {
    refreshMessage: 'Refreshing messages',
    thread: null,
    selectable: null
  },

  setSelectable: function(mode) {
    this.set('selectable', mode);
    this.findRef('dataList').reset();
  },

  construct: function() {
    this._viewConstructTimer = 0;
    this._viewUpdateTimer = 0;

    BaseList.apply(this, arguments);
  },

  declare: function() {
    var _this = this;
    return {
      className: 'talkMessageList',
      boxOrientation: 'vertical',

      childViews: [
        {
          view: ScrollView,
          ref: 'scrollView',

          flex: 1,

          childViews: [
            {
              view: Loading,
              ref: 'loading',
              style: 'display: none'
            },
            {
              view: DataList,
              ref: 'dataList',
              reverse: true,
              prerender: 0.5,

              // rendering
              // throttle: 10,

              // views
              getReusableType: function(message) {
                if (message instanceof ClientMessage) {
                  return message.get('type') == MESSAGE_TYPES.NORMAL ?
                      'MessageRow' : 'AdminMessageRow';
                } else {
                  return 'DelimiterMessageRow';
                }
              },

              createMessageRow: function(message) {
                var start = Date.now();
                var view = new MessageRow();
                _this._viewConstructTimer += (Date.now() - start);
                this.updateMessageRow(view, message);
                return view;
              },
              updateMessageRow: function(view, message) {
                var start = Date.now();
                view.setSelectable(_this.getSelectable());
                view.setModel(message);
                _this._viewUpdateTimer += (Date.now() - start);
                return view;
              },

              createAdminMessageRow: function(message) {
                var start = Date.now();
                var view = new AdminMessageRow();
                _this._viewConstructTimer += (Date.now() - start);
                this.updateAdminMessageRow(view, message);
                return view;
              },
              updateAdminMessageRow: function(view, message) {
                var start = Date.now();
                view.setModel(message);
                _this._viewUpdateTimer += (Date.now() - start);
                return view;
              },

              createDelimiterMessageRow: function(delimiter) {
                var start = Date.now();
                var view = new DelimiterMessageRow();
                _this._viewConstructTimer += (Date.now() - start);
                this.updateDelimiterMessageRow(view, delimiter);
                return view;
              },
              updateDelimiterMessageRow: function(view, delimiter) {
                var start = Date.now();
                view.setModel(delimiter);
                _this._viewUpdateTimer += (Date.now() - start);
                return view;
              },

              // updates
              doesEventTriggerResize: function(e) {
                var changedProperties = e.data.changedProperties;
                if (('remoteState' in changedProperties) ||
                    ('log_message' in changedProperties) ||
                    ('sending' in changedProperties) ||
                    ('delimiter' in changedProperties)) {
                  return true;
                }
                if (changedProperties.localData) {
                  return true;
                }
                return false;
              }
            }
          ]
        }
      ]

    };
  },

  getPerfTimers: function() {
    return {
      'view construction': this._viewConstructTimer,
      'view update': this._viewUpdateTimer,
      'datalist update': this.findRef('dataList')._updateTimer
    };
  },

  getScrollTop: function() {
    return this.refs.scrollView.getScrollTop();
  },

  getModelAt: function(idx) {
    return this.findRef('dataList').getData().at(idx);
  },

  _hasRemoteAfter: function() {
    return !this.getThread().isLocal() &&
      BaseList.prototype._hasRemoteAfter.call(this);
  },

  _lastDownloadTimeKey: function() {
    return 'last_download_time.' + this.getThread().getId();
  },

  _addRelationships: function(collection) {
    var RelationshipCollection =
      require('shared/data2/relationship/relationship_collection')
        .RelationshipCollection;
    var Relationship =
      require('shared/data2/relationship/relationship').Relationship;
    var Collection = require('bolt/collection').Collection;
    var contacts = require('talk/client/model/thread/contacts');
    var Deferred = require('shared/deferred').Deferred;
    var threadCollection = new Collection();
    threadCollection.add(this.getThread());

    var listCollection = new RelationshipCollection([
      new Relationship()
        .setQueryPropGetter(function(m) {
          return contacts.buildInfoIdent(m.get('sender'));
        })
        .setTargetProp('senderProfile')
        .setFetcher(contacts.fetchContacts)
        .setRelatedProp('ident'),

      new Relationship()
        .setQueryProp('thread_id')
        .setTargetProp('thread')
        .setRelatedProp('id')
        .setFetcher(function(ids) {
          return (new Deferred()).succeed(threadCollection);
        })
    ]);
    listCollection.setCollection(collection);

    return listCollection.waitForFetch().then(function() {
      var clusteredCollection = new ClusteredCollection(listCollection);
      return clusteredCollection;
    });
  },

  _refreshRemote: function() {
    if (this.getThread().isLocal()) {
      return;
    }
    this._downloading = true;
    if (!this.getCollection().length) {
      this.findRef('loading').show();
    }
    var message = statusBar.getInstance().addMessage(this.getRefreshMessage());
    var messageClient = require('talk/client/message_client').getInstance();
    messageClient.refreshThreadHead(this.getThread().getId(), 20)
      .addCompleteCallback(function() {
        statusBar.getInstance().removeMessage(message);
        this._afterDownload();
      }, this);
  },

  _dataIsDisplayed: function() {
    this.invoke('dataDisplayed');
  }
});
});

// module: shared/data2/relationship/relationship_collection
// file:   ../../shared/js/data2/relationship/relationship_collection.js
define("shared/data2/relationship/relationship_collection", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*global undefined:false*/
var core         = require('bolt/core');
var Collection   = require('bolt/collection').Collection;
var Deferred     = require('shared/deferred').Deferred;
var DeferredList = require('shared/deferred').DeferredList;
var util         = require('bolt/util');
var eventually   = require('bolt_touch/util/eventually').eventually;


/**
 * RelationshipCollection is a Collection wrapper that can load related
 * models/object. Exposes Collection api. When a model is added to a wrapped
 * collection, RC will not send an add event right away. It will instead load
 * all asociated relationships for the added model. When complete it will add
 * model to itself and trigger 'modelAdded'.
 *
 * Uses Relationship objects to describe each relationship. Can have unlimited
 * number of relationship per collection.
 *
 * Example scenario:
 * Setup: Each message has a thread associated. A colleciton of
 *        messages wrapped into a RelationshipCollection is provided.
 *
 * 1. New messages are added to the message collection. RemoteCollection will
 *    fetch all thread_ids from the new messages using queryProp/queryPropGetter
 * 2. RC will finda all the new thread_ids. new thread_ids = thread_ids that
 *    were not fetched before and are not being fetched now
 * 3. RC will issue a fetch using fetcher/store with the new thread_ids. Fetcher
 *    should return a colleciton of fetched threads.
 * 4. RC will extract thread_ids from fetched thread using
 *    relatedProp/relatedPropGetter. Then it will match messages from step 1 to
 *    the newly (or previosly) fetched threads. Each message will have a thread
 *    stored in targetProp
 * 5. New messages will be added to RC and coresponding events will be issued.
 *
 *
 * More complex (multiMatch) scenario:
 * Setup: You have a threads and contacts. Each thread can have many phone
 *        numbers associated. Each contact can have many phone numbers
 *        associated. One phone number can correspond to multiple threads and/or
 *        contacts. A thread collection wrapped into RC is provided.
 *        MultiMatch is true.
 *
 * 1-3. Same as in the previous scenario.
 * 4.   RC will extract all phones from contacts using relatedPropGetter.
 *      Then it will match contacts to threads. Each thread will cotain
 *      all the cobtacts that have at least one phone overlapping with the
 *      phones in a thread.
 * 5.   Same as in the previous scenario.
 *
 *
 * Example:
 *
 *   var col = new RelationshipCollection([
 *     new Relationship()
 *       .setQueryProp('parent_id') // find parent messages by message.parent_id
 *       .setRelatedProp('id')      // match parent messages by message.id
 *       .setTargetProp('parent')   // store in message.get('parent')
 *       .setStore(messageStore),   // fetch using message store
 *
 *     new Relationship()
 *       // find users by fetching all phones for participants
 *       .setQueryPropGetter(function(model) {
 *         return util.pluck(model.get('participants'), 'phone');
 *       })
 *       // match back by user phones
 *       .setRelatedPropGetter(function(model) {
 *         return model.phones || [model.phone];
 *       })
 *       // custom fetcher, should return a collection when phones are given
 *       .setFetcher(function(phones) {
 *         return contactFinder.findByPhones(phones);
 *       })
 *       // store in participantProfiles
 *       .setTargetProp('participantProfiles')
 *       // match many by many: user can have many phones and message can
 *       // have many participants with phones. In the end each message should
 *       // have all users where at least one phone matched to the ones in the
 *       // message
 *       .setMultiMatch(true)
 *   ]);
 *
 *   col.setCollection(messageCollection);
 *   col.waitForFetch().addCallback(continueWork);
 */
var RelationshipCollection = core.createClass({

  name: 'RelationshipCollection',

  extend: Collection,

  _collection: null,
  _pendingEvents: null,
  _relationships: null,
  _activeFetch: null,

  construct: function(relationships) {
    this._relationships = relationships;
    this._pendingEvents = [];
    this._pending = 0;
    Collection.call(this, true);
  },

  setCollection: function(collection) {
    this._collection = collection;
    this._collection.addListener('modelAdded', this._onadd, this);
    this._collection.addListener('modelRemoved', this._onremove, this);
    this._collection.addListener('updated', this._onupdate, this);
    this._collection.addListener('endUpdate', this._onendUpdate, this);
    this._onupdate();
  },

  _onadd: function(e) {
    this._pendingEvents.push(e);
    eventually(this._fetchRelationships, this);
  },

  _onremove: function(e) {
    if (this._pendingEvents.length) {
      this._pendingEvents.push(e);
    } else {
      this.remove(e.data.model);
    }
  },

  _onupdate: function() {
    this.clear();
    this._collection.forEach(function(model, i) {
      this._pendingEvents.push({
        type: 'modelAdded',
        data: {
          model: model,
          index: i
        }
      });
    }, this);
    this._fetchRelationships();
  },

  _onendUpdate: function() {
    this._fetchRelationships();
  },

  waitForFetch: function() {
    return this._fetchRelationships();
  },

  _fetchRelationships: function(recursion) {
    // if fetch is in progress wait for it to complete
    if (!recursion && this._activeFetch) {
      return this._activeFetch;
    }

    // if there's nothing more to load, just succeed
    if (!this._pendingEvents.length) {
      if (recursion) {
        this._activeFetch = false;
      }
      return (new Deferred()).succeed();
    }

    // extract newModels from events and clean up _pendingEvents
    var pendingEvents = this._pendingEvents;
    this._pendingEvents = [];
    var newModels = [];
    var i, l;
    for (i = 0, l = pendingEvents.length; i < l; i++) {
      if (pendingEvents[i].type === 'modelAdded') {
        newModels.push(pendingEvents[i].data.model);
      }
    }

    // fetch all relationships
    var dlist = new DeferredList();
    for (i = 0, l = this._relationships.length; i < l; i++) {
      dlist.waitFor(this._relationships[i].fetch(newModels));
    }
    dlist.startWaiting();
    dlist = dlist.then(this._fetchComplete, this, pendingEvents);
    if (!recursion && dlist.getStatus() === Deferred.STATUS_UNKNOWN) {
      this._activeFetch = dlist;
    }
    return dlist;
  },

  _fetchComplete: function(pendingEvents) {
    // apply pending events
    var i, l, data;
    for (i = 0, l = pendingEvents.length; i < l; i++) {
      data = pendingEvents[i].data;
      if (pendingEvents[i].type === 'modelAdded') {
        this.insert(data.index, data.model);
      } else {
        this.remove(data.model);
      }
    }

    return this._fetchRelationships(true);
  },

  destroy: function() {
    Collection.prototype.destroy.call(this);
    for (var i = 0, l = this._relationships.length; i < l; i++) {
      this._relationships[i].destroy();
    }
  },

  insert: function(idx, model) {
    if (!model) {
      return false;
    }
    if (!model.klass) {
      model = new this.modelType(model);
    }

    var cid = model.cid;
    var id = model.id;
    if (!this._byCid[cid] && (!id || !this._byId[id])) {
      this.models.splice(idx, 0, model);
      this._byCid[cid] = model;
      if (model.id !== null) {
        this._byId[id] = model;
      }
      this.length++;
      this._listeners[cid] = model.addListener('changed',
        this._onModelChanged, this);
      this.invoke('modelAdded', { model: model, index: idx });
      return model;
    }
    return false;
  }

});


exports.RelationshipCollection = RelationshipCollection;
});

// module: shared/post_manager
// file:   ../../shared/js/post_manager.js
define("shared/post_manager", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

/**
 *
 * WARNING
 *
 * WARNING

 * WARNING
 *
 * WARNING
 *
 * WARNING
 *
 * WARNING
 *
 * WARNING
 *
 * This file is all sorts of messed up. Al deleted all sorts of functionality
 * willy nilly to help get rid of old story syncer/store code. Deal with it.
 */
var core           = require('bolt/core');
var dom            = require('bolt/dom');
var util           = require('bolt/util');

var api_xhr            = require('shared/api_xhr');
var KeyValueMixin      = require('shared/data/key_value_mixin').KeyValueMixin;
var EventManager       = require('shared/event_manager').EventManager;
var PHOTO_STATE        = require('photos/app/lib/controller/constants').PHOTO_STATE;

var PostManager = core.createClass({
  name: 'PostManager',

  mixins: [KeyValueMixin],

  construct: function() {
    this.expirePendingStatusWithPhotoHandler =
      util.bind(this._expirePendingStatusWithPhoto, this);

    EventManager.listen('PostManager/deleteOfflineStory', this,
      this._onDeleteOfflineStories);
  },

  // Constants on the singleton
  DayInMilliSeconds: 24 * 60 * 60 * 1000,
  HourInMilliSeconds: 60 * 60 * 1000,

  PhotoKey: 'pending_photo_status',
  OfflineStoryKey: 'offline_story',

  getName: function() {
    return this.klass.klassName;
  },

  updateStatus: function(text, placeId, userIds, groupId, privacy, cb) {
    var params = this._createCommonParameters(text, placeId, userIds, privacy);
    var url = groupId ? '/' + groupId + '/feed' : '/me/feed';

    var reqParams = {
      id: this._createOfflineId(),
      cb: cb,
      reqTime: Date.now()
    };

    // Insert an offline story into the story store. This will show up
    // on the feed as a story that is being published which will give user
    // instant feedback.
    this._insertOfflineStory(reqParams.id, params);

    // Make a graph api call. Params is the api param. ReqParams is the
    // information related with this status update request.
    this._makeRequest(url, params, reqParams);
  },

  updateStatusWithPhotos:
    function(text, placeId, userIds, groupId, photos, privacy) {
    if (!photos || photos.length === 0) {
      return;
    }

    var reqParams = {
      id: this._createOfflineId(),
      reqTime: Date.now()
    };

    var params = this._createCommonParameters(text, placeId, userIds, privacy);

    if (groupId) {
      params.target = groupId;
    }

    this._insertOfflineStory(reqParams.id, params, []);

    var localPhotos = [];
    for (var i = 0; i < photos.length; i++) {
      var photo = photos[i];

      if (photo.get('state') === PHOTO_STATE.UPLOADING) {
        localPhotos.push(photo.get('id'));
      } else {
        this.updateStatusWithPhotoWhenUploadComplete(
          photo.get('fbid'), params, reqParams);
      }
    }

    if (localPhotos.length > 0) {
      this.getKeyValue(this.PhotoKey).then(
        this._addPendingStatusWithPhotoHandler,
          this, localPhotos, params, reqParams);
    }
  },

  updateStatusWithPhotoWhenUploadComplete:
    function(photoId, params, reqParams) {
    params.published = true;
    reqParams.photoId = photoId;
    var url = '/' + photoId;

    this._makeRequest(url, params, reqParams);
  },

  onPhotoUploadComplete: function(oid, fbid) {
    this.getKeyValue(this.PhotoKey).then(
      this._uploadPendingStatusWithPhotoHandler, this, oid, fbid);
  },

  // Expire photo requests
  _expirePendingStatusWithPhoto: function() {
    this.getKeyValue(this.PhotoKey).then(
      this._expirePendingStatusWithPhotoHandler, this);
  },

  _addPendingStatusWithPhotoHandler:
    function(photoIds, params, reqParams, value) {
    var obj = (value !== null) ? JSON.parse(value) : {};

    for (var i = 0; i < photoIds.length; i++) {
      obj[photoIds[i]] = {
        params: params,
        reqParams: reqParams
      };
    }

    this.updateOrCreateKeyValue(this.PhotoKey, JSON.stringify(obj));
  },

  _uploadPendingStatusWithPhotoHandler:
    function(oid, fbid, value) {
    var obj = (value !== null) ? JSON.parse(value) : {};
    if (!util.isUndefined(obj[oid])) {
      var params    = obj[oid].params;
      var reqParams = obj[oid].reqParams;

      this.updateStatusWithPhotoWhenUploadComplete(
        fbid, params, reqParams);

      delete obj[oid];
      this.updateOrCreateKeyValue(this.PhotoKey, JSON.stringify(obj));
    }
  },

  _expirePendingStatusWithPhotoHandler: function(value) {
    var obj = (value !== null) ? JSON.parse(value) : {};
    var now = Date.now();
    for (var photoId in obj) {
      var reqParams = obj[photoId].reqParams;
      if (!util.isUndefined(reqParams) &&
        (now - reqParams._timestamp > this.HourInMilliSeconds)) {
        delete obj[photoId];
      }
    }
    this.updateOrCreateKeyValue(this.PhotoKey, JSON.stringify(obj));
  },

  // Make a graph api call to publish the status.
  // params     - The api params
  // reqParams  - Information about this status update request
  _makeRequest: function(url, params, reqParams) {
    api_xhr.graph('POST', url, params)
      .addCallback(function(response) {
        if (reqParams.cb) {
          reqParams.cb(/* success */ true, response);
        }
        if (reqParams.photoId) {
          EventManager.broadcastEvent(
            'PostManager/PhotoPublished',
            {id: reqParams.photoId}
          );
        }
        if (response.id) {
          // Change the state of the offline story from Publishing to Published
          // to inform the user that the story has been successfully published.
          this.getKeyValue(this.OfflineStoryKey).then(
            this._publishOfflineStoryHandler,
            this,
            response.id,
            reqParams.id
          );
        }
      }, this)
      .addErrback(function(response) {
        if (reqParams.cb) {
          reqParams.cb(/* success */ false, response);
        }
        if (reqParams.photoId) {
          EventManager.broadcastEvent(
            'PostManager/PhotoFailed',
            {id: reqParams.photoId}
          );
        }
      });
  },

  _publishOfflineStoryHandler: function(serverId, id, value) {
  },

  _insertOfflineStory: function(id, params, photoIds) {
    console.warn('Inserting offline story no longer works.');
  },

  _getProfileHandler: function(id, params, photoIds, profile) {
  },

  _insertOfflineStoryHandler: function(id, story, value) {
    var offlineStories = (value !== null) ? JSON.parse(value) : {};
    offlineStories[id] = story;
    this.updateOrCreateKeyValue(this.OfflineStoryKey,
      JSON.stringify(offlineStories));
  },

  _onDeleteOfflineStories: function(id) {
    this.getKeyValue(this.OfflineStoryKey).then(
      this._deleteOfflineStoriesHandler, this, id);
  },

  _deleteOfflineStoriesHandler: function(id, value) {
    var offlineStories = (value !== null) ? JSON.parse(value) : {};

    var delIds = [];
    if (id) {
      if (!util.isUndefined(offlineStories[id])) {
        delIds = [id];
      }
    } else {
      // If id is not defined, delete all published stories
      delIds = util.keys(offlineStories);
    }

    this.updateOrCreateKeyValue(this.OfflineStoryKey,
      JSON.stringify(offlineStories));
  },

  _normalizeTagsParamFormat: function(arr) {
    return arr && util.isArray(arr) ? arr.join(',') : arr;
  },

  _createOfflineId: function() {
    return 'offline_' + this._createIntStoryTimeStamp();
  },

  _createIntStoryTimeStamp: function() {
    return parseInt(Date.now() / 1000, 10);
  },

  _createCommonParameters: function(text, placeId, userIds, privacy) {
    var params = {};
    params.message = text;
    params.name = text;
    params.tags = this._normalizeTagsParamFormat(userIds);
    params.place = placeId;
    params.privacy = privacy;

    return params;
  }
});

exports.PostManager = new PostManager();
});

// module: bolt/view
// file:   ../../../frameworks/bolt/lib/view.js
define("bolt/view", function(require, exports, module) {
/**
 * Copyright (c) 2011-2012, Facebook, Inc.
 * All rights reserved.
 *
 * @option preserve-header
 *
 */

var util     = require('./util');
var core     = require('./core');
var dom      = require('./dom');

var Container = require('./mixins/container').Container;

function setOwner(viewSpec) {
  viewSpec.owner = viewSpec.owner || this;
}

var View = exports.View = core.createClass({

  name: 'View',

  mixins: [Container],

  // Override declare in your subclasses to provide default options for your
  // specific View. This actually removes the need for a custom render
  // function, since childViews are just another part of setup. Views that
  // render in the old way will still work for backwards compatibility.
  //
  //   declaring a custom view can now be as simple as this:
  //   createClass({
  //     name: 'CustomView',
  //     extend: View,
  //     declare: {
  //       color: 'red'
  //       childViews: [
  //         {content: 'foo'}
  //       ]
  //     }
  //   }
  //
  // NOTE: wbailey 5-10-2011
  // The way we are do setLayout inside of render obscures what is
  // actually happening. The setChildViews setter at each level of the
  // hierarchy actually does the recursion. Thus a cleaner api is to just let
  // this happen during setup and provide a way to *declare* overridable default
  // options.
  declare: function() {},

  construct: function(options) {
    this._childViews = [];

    // the options for the view are now derived by extending a shallow copy
    // of the the *declared* options on the prototype. This allows you to
    // specify any property of the parent in the declare block and optionally
    // override it with options passed to the constructor.
    var declOptions = this.declare(options);

    // voloko: extremly hacky, and supports only childViews property. So
    // leftChildViews and rightChildViews will not work.
    // Set the owner of each of the childViews to default to this View
    if (declOptions && declOptions.childViews) {
      util.forEach(
        declOptions.childViews,
        setOwner,
        this);
    }

    // if both declOptions and options given => extend, otherwise use available
    var optionsToUse =
      declOptions && options ? util.extend(declOptions, options || {}) :
      declOptions || options || {};

    // should probably remove this guys to save some memory
    this.refs = {};

    this.createDom(optionsToUse);

    if (this.render) {
      require('./core').deprecated('View.render', 'View.setup');
      this.render(optionsToUse);
    }

    // if we haven't yet captured the cssClass for this view class use the
    // inheritance chain to create a list of css classes generated from the
    // js class name and cache it on the js class for future use.
    var klass = this.klass;
    if (!klass.cssClass) {
      var inheritanceChain = klass.inheritanceChain, classes = [];
      for (var i = 0, l = inheritanceChain.length; i < l; i++) {
        classes.unshift('bt-' + util.hyphenate(inheritanceChain[i].klassName));
      }
      klass.cssClass = classes.join(' ');
    }

    this.setup(optionsToUse);

    // the initial css class for a view should be its inherited class followed
    // by any passed in className or additionalClasses properties.
    // e.g. bt-view custom-class-foo
    var existingClass, classToSet, inheritedClass;
    existingClass = this.getClassName();
    classToSet = inheritedClass = klass.cssClass;

    if (existingClass) {
      classToSet = inheritedClass + ' ' + existingClass;
    }
    this.setClassName(classToSet);

    // call any mixinReady functions
    if (this.mixinReadyFunctions) {
      for (var i = 0; i < this.mixinReadyFunctions.length; i++) {
        this.mixinReadyFunctions[i].call(this);
      }
    }

    // hook to setup any post construct handlers
    this.ready && this.ready();
  },

  properties: {
    metadata: null
  },

  // Set up the delegated properties. A property that is just a string sets up
  // a setter and getter with that name on the parent widget, e.g. the property
  // of 'label' delegated to 'node' will set up a setLabel and getLabel function
  // that looks for either this.node or a referenced child widget in
  // this.refs['node'], then sets and gets the label on it.  A property that is
  // a JSON object, with both an 'alias' and 'name' member works slightly
  // differently.  A getter and setter for the alias are added to the parent
  // widget, but these functions look for the 'name' in the child property.
  // E.g. a property {alias: 'label', name: 'value '} delegated to 'node'
  // would create the functions 'getLabel' and 'setLabel' on the parent view,
  // but would get and set the 'value' property of 'node'.
  // By default, anything extending the View class will have these properties
  // delegated to the node returned from getNode().
  delegateProperties: {
    node: [
      'data-ref',
      'disabled',
      'id',
      'name',
      'tabIndex'
      /* We won't delegate tagName because it will be slow and redundant to set
       * it, if the creator doesn't know it's kind after creating it, then
       * they're not very organized.
       * We won't delegate innerHtml because you should create and remove
       * children in a way that doesn't leak memory removeChildViews().
       */
    ],
    style: [
      'height',
      'width'
    ]
  },


  /*
   * set the data attribute on the DOM node
   */
  setMetadata: function(obj) {
    this.set('metadata', obj);
    var node = this.getNode();
    for (var name in obj) {
      node.setAttribute('data-' + name, obj[name]);
    }
  },

  /**
   * create the dom node for this view to render within
   * options
   *   - tagName: specify a tag name to use when creating the dom node
   *              other than the default div
   */
  createDom: function(options) {
    var node = this.getNode();
    if (!node) {
      this.setNode(dom.createElement(options.tagName || 'div'));
      node = this.getNode();
    }
    return node;
  },

  /**
   * find the nearest ref for a given node
   * this is useful for event handling
   */
  findContainingRef: function(node) {
    var touchedButton = null;
    while (node !== this.getNode()) {
      var ref = node.getAttribute('data-ref');
      if (ref && this.refs && this.refs[ref]) {
        return this.refs[ref];
      }
      node = node.parentNode;
    }
    return false;
  },

  /**
   * add additional classes to the node for this view
   */
  setAdditionalClasses: function(classes) {
    if (util.isArray(classes)) { classes = classes.join(' '); }
    return this.addClass(classes);
  },

  /**
   * locates a ref-scoped handler for a specific event, e.g., if the
   * view has a ref called 'childView', and a method called
   * childViewClick, handlerForEvent(evt) where evt is a click event
   * will return the childViewClick method
   */
  sendEvent: function(evt) {
    var targetView = evt.targetView;
    var targetViewRef = targetView && targetView.getRef();
    var result = null;

    var eventName = evt.type;
    if (targetViewRef) {
      var handlerName = targetViewRef + eventName[0].toUpperCase() + eventName.substr(1);
    
      // three conditions to bail:
      // (1) the view handling the event doesn't have a ref by the correct name
      // (2) the view has the ref, but doesn't have the handler by the correct name
      // (3) the target view, although named with the same ref, isn't actually the right view
      if (this.findRef(targetViewRef) &&
          this[handlerName] &&
          this.findRef(targetViewRef) === targetView) {
        result = this[handlerName];
      }      
    }

    var handler = result || this[eventName] || this['on' + eventName];

    if (typeof handler === 'function') {
      handler.call(this, evt);
      return true;
    } else {
      return false;
    }
  }
});

});

// module: bolt/model
// file:   ../../../frameworks/bolt/lib/model.js
define("bolt/model", function(require, exports, module) {
/**
 * Copyright (c) 2011-2012, Facebook, Inc.
 * All rights reserved.
 *
 * @option preserve-header
 *
 */

var util = require('./util');
var core = require('./core');
var Events = require('./mixins/events').Events;

// Cache the auto generated setters so as to minimize
// object creation
var cachedSetters = {};
var cachedGetters = {};

/**
 * Models provide observable sets of properties that you can use to model
 * your domain logic.
 *
 * The Model class was inspired by and borrows heavily from backbone.js
 * http://documentcloud.github.com/backbone/
 */
var Model = exports.Model = core.createClass({
  name: 'Model',

  mixins: [Events],

  properties: {
    id: undefined
  },

  classExtended: function(klass, config) {
    addProperties(klass, config);
  },

  mixinIncluded: function(klass, config) {
    addProperties(klass, config);
  },

  /**
   * Create a new model
   * When unsafe init is set to true, construct expects an object in a formate
   * returned by toObject(). This object will be used directly without copying
   * so make sure to create a copy before creating model.
   * Using unsafeInit is signifcantly faster.
   */
  construct: function(data, unsafeInit) {
    data = data || {};
    if (!('id' in data) || data.id === null) { // we allow 0 as an id
      data.id = this.generateId();
    }
    this.cid = 'c' + util.generateCID();
    if (unsafeInit) {
      this._properties = data;
      this.id = data.id;
    } else {
      this._properties = {};
      this.merge(data, true);
    }
  },

  /**
   * Returns whether something is a base property
   */
  isBaseProperty: function(key) {
    return this._properties.hasOwnProperty(key);
  },

  /**
   * Wrapper to get property using getter if available or .get() if not
   */
  getSafe: function(key) {
    var getter = util.getter(key);
    return this[getter] ? this[getter]() : this.get(key);
  },

  /**
   * Wrapper to set property using setter if available or .set() if not
   */
  setSafe: function(key, value, quiet) {
    var setter = util.setter(key);
    return this[setter] ?
      this[setter](value, quiet) :
      this.set(key, value, quiet);
  },

  /**
   * Low-level api to get property directly bypassing getter function
   * get a property of the of model
   */
  get: function(key) {
    return this._properties[key];
  },

  /**
   * Low-level api to set property directly bypassing setter function
   *
   * set a property of the model
   * optionally pass quiet parameter to avoid
   * invoke changed event
   *
   * @return false if there is no change; or an object for changeset
   */
  set: function(key, value, quiet) {
    var prev = this._properties[key];
    if (!util.isEqual(prev, value)) {
      this._properties[key] = value;
      if (key === 'id') {
        // TODO:wbailey depending on how we decide to handle id changes
        //              we may want to fire an additional event here
        //              if we can always send the client id up when syncing
        //              then this is not necessary.
        this.id = value;
      }
      var change = this._changeQueue || {};
      change[key] = prev;
      if (!quiet && !this._changeQueue) { this._invokeChanged(change); }
      return change;
    }
    return false;
  },

  /**
   * Low-level api to clear property
   *
   * unset a property of the model
   * optionally pass quiet parameter to avoid
   * invoke changed event
   *
   * @return false if not changed, the change set object if changed.
   */
  unset: function(key, quiet) {
    var prev = this._properties[key];

    // The following block is similar to set(key, null), while the
    // key difference is that we are checking prev not defined and prev
    // not equal to null. see unittest of testModel with the case of
    // 'unset an undefined property'
    if (prev !== undefined && prev !== null) {
      this._properties[key] = null;
      var change = {};
      change[key] = prev;
      if (!quiet) { this._invokeChanged(change); }
      return change;
    }
    return false;
  },

  /**
   * Low-level api to set mutliple properties at once sending only 1 event
   *
   * set multiple properties in one call
   * takes an optional quiet flag avoid invoking
   * changed event
   */
  /** UNSET PROPERTIES that are not defined **/
  setAll: function(obj, quiet) {
    var changedProperties = this._changeQueue = {};
    // inline forEach for perf
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        this.set(key, obj[key], quiet);
      }
    }
    this._changeQueue = undefined;

    if (!util.isEmpty(changedProperties)) {
      if (!quiet) { this._invokeChanged(changedProperties); }
      return changedProperties;
    }
    return false;
  },

  _invokeChanged: function(changedProperties) {
    this.invoke('changed', {
      model: this,
      changedProperties: changedProperties
    });
  },

  /**
   * Merge a set of properties of the model -- this is similar to setAll,
   * but actually calls setters.
   *
   * @param {Model|Object} obj - the model or object to merge into this model.
   * @param {boolean} quiet - whether to send events during this or not.
   *
   * @return {boolean|Object} false if not changed, the change set object if
   *  changed.
   */
  merge: function(obj, quiet) {
    obj = obj instanceof Model ? obj._properties : obj;
    var changedProperties = this._changeQueue = {};
    // inline forEach for perf
    for (var key in obj) {
      if (typeof obj[key] !== 'function') {
        this.setSafe(key, obj[key], quiet);
      }
    }
    this._changeQueue = undefined;
    if (!util.isEmpty(changedProperties)) {
      if (!quiet) { this._invokeChanged(changedProperties); }
      return changedProperties;
    }
    return false;
  },

  /**
   * Function to be overridden to provide validity checks for
   * model values
   */
  isValid: function(key) {
    return true;
  },

  /**
   * iterate over each data property of the model
   */
  eachProperty: function(func, context) {
    util.forEach(this._properties, func, context);
  },

  /**
   * get the data properties of an object
   */
  toObject: function(unsafe) {
    if (unsafe) {
      return this._properties;
    } else {
      return util.extend({}, this._properties);
    }
  },

  /**
   * generate a unique ID for a model
   *
   * By default, this uses a built-in UUID generator, though subclasses
   * can override this behavior.
   */
  generateId: function() {
    return util.generateUUID();
  },

  listen: function(type, callback, contextOrNull) {
    function handleAll(event) {
      this.listener.apply(
        this.context,
        [event.type].concat(arguments));
    }

    function handleSingle() {
      this.listener.apply(this.context, arguments);
    }

    require('./core').deprecated('listen', 'addListener');
    var token = this.addListener(type, callback, contextOrNull || this);
    token.boundListener = type === 'all' ? handleAll : handleSingle;
    return token;
  },

  destroy: function() {
    this.removeListener();
  }
});

function generateSetter(key) {
  if (!cachedSetters[key]) {
    cachedSetters[key] = function(v, _extra) {
      return this.set(key, v, _extra);
    };
  }
  return cachedSetters[key];
}

function generateGetter(key, defaultValue) {
  if (!cachedGetters[key]) {
    cachedGetters[key] = function() {
      var value = this.get(key);
      return value === undefined ? defaultValue : value;
    };
  }
  return cachedGetters[key];
}


// declared properties automatically create getters and setters
function addProperties(klass, config) {
  if (!config.properties) {
    return;
  }
  var properties = config.properties;
  var proto = klass.prototype;

  var defaultValue;
  for (var key in properties) {
    defaultValue = properties[key];
    setter = util.setter(key);
    getter = util.getter(key);

    if (!proto.hasOwnProperty(setter)) {
      proto[setter] = generateSetter(key);
    }
    if (!proto.hasOwnProperty(getter)) {
      proto[getter] = generateGetter(key, defaultValue);
    }
  }
};

});

// module: photos/app/lib/model/photo/photo
// file:   ../../photos/app/lib/model/photo/photo.js
define("photos/app/lib/model/photo/photo", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core             = require('bolt/core');
var util             = require('bolt/util');
var Model            = require('bolt/model').Model;
var Collection       = require('bolt/collection').Collection;
var Model            = require('bolt/model').Model;

var api_xhr          = require('shared/api_xhr');
var Likeable         = require('shared/data2/model/mixin/likeable').Likeable;
var Commentable      = require('shared/data2/model/mixin/commentable').Commentable;
var Deferred         = require('shared/deferred').Deferred;
var Constants        = require('../../controller/constants');
var PHOTO_STATE      = Constants.PHOTO_STATE;
var MEDIA_TYPE       = Constants.MEDIA_TYPE;
var photoStore;
var albumStore;

var uploadManagerApi;
var mediaStorageApi;

function toObject(obj) {
  return obj.toObject();
}

function serializeCollection(collection) {
  return collection.map(toObject);
}

var Photo = exports.Photo = core.createClass({
  name: 'Photo',

  extend: Model,

  mixins: [Likeable, Commentable],

  construct: function(options) {
    Model.call(this, options);
    photoStore = require('./photo_store').getInstance();
    albumStore = require('../album/album_store').getInstance();
    uploadManagerApi =
      uploadManagerApi || window.FBAPI ? FBAPI.use('uploadmanager') : null;
    mediaStorageApi =
      mediaStorageApi || window.FBAPI ? FBAPI.use('mediastorage') : null;
    this.set('cacheState', 'none');
    this.set('selected', false);

    // we want to expose tags as a Collection to all clients even
    // thought they are stored in the db as an array
    this.tags = new Collection();
    if (options.tags) {
      for (var i = 0; i < options.tags.length; i++) {
        this.tags.add(new Model(options.tags[i]));
      }
    }
  },

  storeModel: function() {
    return this.save();
  },

  getFeedbackId: function() {
    return this.get('fbid');
  },

  getFeedbackIdType: function() {
    return Commentable.FEEDBACK_ID_OBJECT_TYPE;
  },

  /**
   * @return {Object} Collection of tag Models
   */
  getTags: function() {
    return this.tags;
  },

  save: function() {
    // serialize the tags collection into an array of objects
    var tagsArray = serializeCollection(this.tags);
    this.set('tags', tagsArray);

    return photoStore.store([this]);
  },

  remove: function() {
    return photoStore.remove([this.get('id')]);
  },

  canLikeAndComment: function() {
    return (this.get('album_id') !== Constants.UNPUBLISHED_ALBUM_ID);
  },

  delete: function() {
    var deferred = new Deferred();

    api_xhr.graph('DELETE', this.get('fbid'))
      .addCallback(function(response) {

        var mediaStorageApi = window.FBAPI ? FBAPI.use('mediastorage') : null;
        photoStore.remove([this.get('id')]);

        albumStore.fetchAlbumById(this.get('album_id'))
          .addCallback(function(album) {
            album.set('count', album.get('count') - 1);
            album.save();
          }, this);

        // Delete files
        var picturePath = this.get('path');
        mediaStorageApi.removeStoredByFilepath(picturePath);
        var thumbnailPath = this.get('thumb');
        mediaStorageApi.removeStoredByFilepath(thumbnailPath);

        deferred.succeed();
      }, this)
      .addErrback(function(response) {
        deferred.fail(response);
      });

    return deferred;
  },

  makeProfilePicture: function(x, y, width, height) {
    var deferred = new Deferred();

    if (this.get('state') !== PHOTO_STATE.LOCAL &&
        this.get('state') !== PHOTO_STATE.UPLOADING) {
      var params = {
        height: height,
        method: 'photos.cropProfilePic',
        pid: this.get('pid'),
        width: width,
        x: x,
        y: y
      };

      api_xhr.rest(params, /* readOnly */ false)
        .addCallback(function(response) {
          deferred.succeed();
        })
        .addErrback(function(response) {
          deferred.fail(response);
        });
    }

    return deferred;
  },

  setCaption: function(caption) {
    var deferred = new Deferred();

    if (this.get('state') !== PHOTO_STATE.LOCAL &&
        this.get('state') !== PHOTO_STATE.UPLOADING) {
      var oldCaption = this.get('name');
      this.set('name', caption);

      api_xhr.graph('POST', this.get('fbid'), {name: caption})
        .addCallback(function(response) {
          this.save();
          deferred.succeed();
        }, this)
        .addErrback(function(response) {
          this.set('name', oldCaption);
          deferred.fail(response);
        }, this);
    }

    return deferred;
  },

  /**
   * Add a tag to the model, does not upload.
   *
   * @param {Object}
   */
  addTag: function(tagToAdd) {
    this.tags.add(new Model(tagToAdd));
    this.save();
  },

  /**
   * Add an array of tags to the model, does not upload.
   *
   * @param {Array} An array of tag objects
   */
  addTags: function(tagsToAdd) {
    for (var i = 0; i < tagsToAdd.length; i++) {
      var tag = tagsToAdd[i];
      this.tags.add(new Model(tag));
    }
    this.save();
  },

  /**
   * Revome a tag from the model, does not upload.
   *
   * @param {Object}
   */
  removeTag: function(tagToRemove) {
    this.tags.remove(tagToRemove);
    this.save();
  }
});

var _uploadTagsHandler = function(resp) {
  // TODO: fire an event / retry?
};

/**
 * @param {int} the photo's FBID
 * @param {Array} an array of tag object
 */
exports.uploadTags = function(fbid, tags) {
  for (var i = 0; i < tags.length; i++) {
    var tag = tags[i];
    if (tag.id !== -1) {
      var data = {
        to : tag.id,
        x  : tag.xcoord,
        y  : tag.ycoord
      };

      api_xhr.graph('post', fbid + '/tags', data)
        .addCallback(this._uploadTagsHandler);
    }
  }
};

/**
 * @param {String} the local path of the photo
 * @param {int} the photo's FBID
 */
exports.onUploadComplete = function(path, fbid) {
  var store = require('./photo_store').getInstance();

  console.log('onUploadComplete()');
  store.getPhotosByPath(path).then(function(photos) {
    if (!photos || !photos.length) {
      console.log('no photos found with path: ' + path);
      return;
    }

    var photo = photos.at(0);

    photo.set('fbid', fbid);
    photo.set('state', PHOTO_STATE.SYNCED);
    photo.save();

    var PostManager = require('shared/post_manager').PostManager;
    PostManager.onPhotoUploadComplete(photo.get('id'), fbid);
  });
};

Photo.addPhoto = function(mediaPath, mediaUrl, thumbnailPath, thumbnailUrl, type, width, height) {
  var offline_id = Date.now().toString();
  var photo = new Photo({
    id           : offline_id,
    state        : PHOTO_STATE.UPLOADING,
    type         : type,
    path         : mediaPath,
    thumb        : thumbnailPath,
    album_id     : Constants.UNPUBLISHED_ALBUM_ID,
    picture      : thumbnailUrl,
    thumbnail_url: thumbnailUrl,
    source       : mediaUrl,
    full_url     : mediaUrl,
    created_time : Math.floor(offline_id / 1000),
    updated_time : Math.floor(offline_id / 1000),
    width        : width,
    height       : height,
    position     : offline_id,
    name         : '',
    likes        : {
      can_like   : false,
      user_likes : false,
      count      : 0
    },
    comments     : {
      can_post   : false,
      count      : 0
    }
  });
  photo.save();

  // increment the album count by one
  albumStore.fetchPrivateAlbum()
    .addCallback(function(album) {
      if (album) {
        var count = album.get('count');
        album.set('count', count + 1);
        album.save();
      }
    });

  console.info('starting to upload media ' + mediaPath + '...');
  if (type === MEDIA_TYPE.PHOTO) {
    uploadManagerApi.uploadImage(
      mediaPath,
      '',        /* caption */
      'me',      /* album */
      false,     /* require wifi */
      false,     /* publish */
      offline_id /* offline id */
    );
  } else {
    uploadManagerApi.uploadVideo(
      mediaPath,
      '',        /* caption */
      false,     /* require wifi */
      false,     /* publish */
      offline_id /* offline id */
    );
  }

  return offline_id;
};

});

// module: bolt_touch/views/action_sheet/index
// file:   ../../../frameworks/bolt_touch/lib/views/action_sheet/index.js
define("bolt_touch/views/action_sheet/index", function(require, exports, module) {
// ActionSheet is a view that pops up from the bottom of the screen, and offers
// the user a number of actions to choose from.  It can optionally have a 'title'
// and 'text' (or subtitle) which are displayed above the action buttons.
// By default all action buttons are displayed vertically.  Multiple vertical
// columns of action buttons can be created by passing a 'col' parameter with the
// action, e.g.
//
// actionSheet.addAction(
//   {value: 'Choice 1', col: 0, action: 'handleChoice1'}
// )
// actionSheet.addAction(
//   {value: 'Choice 2', col: 1, action: 'handleChoice2'}
// )
//
// An ActionSheet can also be constructed with a set of actions, e.g.
//
// builder.build({
//   view: 'ActionSheet',
//   title: 'Choose Wisely',
//   text: 'There are penalties for those who choose..... poorly',
//   actions: [
//     {
//       value: 'Big Golden Goblet',
//       action: function() {console.log('You chose poorly');}
//     },
//     {
//       value: 'Humble Wooden Cup',
//       action: function() {console.log('You chose wisely');}
//     },
//   ]
// }).show();

var util = require('bolt/util');

var View = require('bolt_touch/view').View;
var Scrim = require('../scrim').Scrim;
var Button = require('../button').Button;

var idCntr = 0;

var ActionSheet = require('bolt/core').createClass({

  name: 'ActionSheet',

  extend: View,

  properties: {
    destroyOnHide: false,

    actions: null,

    selectedAction: null,

    hasScrim: false
  },

  construct: function(options) {
    this.handleAction = util.bind(this.handleAction, this);
    View.call(this, options);
  },

  _title: null,
  _text: null,
  _visible: false,

  createDom: function() {
    View.prototype.createDom.apply(this, arguments);
    this.setLayout({
      ref: 'actionContainer',
      boxOrientation: 'horizontal'
    });
    this.setMode('state', 'sync_hidden');
  },

  // Add an action that can be selected.  This supports all the properties
  // of a Button, as well as
  // - col : The column in which to display the button.  Default is 0.
  // - actionId: The identifier for the action.
  // - selected: Whether or not the button is currently selected. This is more used
  //             with ActionScroller
  addAction: function(buttonProps) {
    var columnIdx = buttonProps.col || 0;
    var actionId = buttonProps.actionId || this.generateId();
    var selected = buttonProps.selected;
    var metadata = buttonProps.metadata || {};

    delete buttonProps.col;
    delete buttonProps.actionId;
    delete buttonProps.selected;
    delete buttonProps.metadata;

    var actionButton = this.build(util.extend({
        view: Button,
        metadata: util.extend(metadata, {
          column: columnIdx,
          actionId: actionId
        })
      }, buttonProps), this.getOwner() || this);

    this.appendButton(actionButton, columnIdx);
    this._refreshHeight();

    if (selected) {
      this.setSelectedAction(actionId);
    }
  },

  _refreshHeight: function() {
    var height = this.getDesiredHeight();
    this.updateHeight && this.updateHeight(height);
    this.setStyle({height: height, bottom: '-' + height + 'px'});
  },

  appendButton: function(button, columnIdx) {
    button.addAction(this.handleAction);

    this.getColumn(columnIdx).append(button);
  },

  generateId: function() {
    return 'actionId_' + (++idCntr);
  },

  // Gets the column at the specified position.
  // If one does not exist, it is created in the correct position.
  getColumn: function(columnIdx) {
    var columnView = this.findRef('col' + columnIdx);

    if (!columnView) {
      // If the column doesn't exist, find the right position for it
      // and insert it
      var actionContainer = this.findRef('actionContainer');
      var children = actionContainer.getChildViews();
      var insertPos = children.length;
      var metadata;
      for (var i = 0; i < children.length; i++) {
        metadata = children[i].getMetadata();
        if (!metadata) {
          continue;
        }
        if (metadata.column > columnIdx) {
          insertPos = i;
          break;
        }
      }

      columnView = this.build(this.createColumn(columnIdx));
      actionContainer.insertChild(columnView, insertPos);
    }
    return columnView;
  },

  createColumn: function(columnIdx) {
    return {
      view: View,
      boxOrientation: 'vertical',
      additionalClasses: 'bt-v-box',
      ref: 'col' + columnIdx,
      flex: 1,
      metadata: {column: columnIdx}
    };
  },

  hide: function() {
    this._visible = false;
    this.setMode('state', 'hidden');
    var style = this.getNode().style;
    var _this = this;
    this.scrim && this.scrim.hide();

    setTimeout(function() {
      style.display = 'none';
      if (_this.getDestroyOnHide()) {
        if (_this.parent) {
          _this.parent.removeChild(_this);
        } else {
          _this.destroy();
        }
      }
    }, 300);
  },

  setActions: function(actions) {
    if (actions) {
      util.forEach(actions, function(action) {
        this.addAction(action);
      }, this);
    }
  },

  setBody: function(body) {
    // create body wrapper or clear existing children within it
    if (this.refs.body) {
      this.findRef('body').clearChildren();
    } else {
      var bodyWrapper = this.build({
        className: 'bt-action-sheet--body',
        ref: 'body'
      }, this);
      this.insertChild(bodyWrapper, 1);
    }

    if (!body[0]) {
      this.appendBodyContent(body);
    } else {
      for (var i = 0; i < body.length; i++) {
        this.appendBodyContent(body[i]);
      }
    }
  },

  appendBodyContent: function(content) {
    var newContent;
    if ((typeof content) === 'string') {
      newContent = this.build({
        tagName: 'span',
        content: content
      }, this.getOwner());
    } else {
      newContent = this.build(content, this.getOwner());
    }
    this.findRef('body').appendChild(newContent);
  },

  _setContent: function(child, content, create) {
    if (content) {
      if (this[child]) {
        this[child].setContent(content);
      } else {
        create();
      }
    } else {
      this.removeChild(this[child]);
      this[child] = null;
    }
  },

  setText: function(text) {
    var _this = this;

    this._setContent('_text', text, function() {
      _this._text = _this.build({ tagName: 'h3', content: text });
      _this.insertChild(_this._text, (_this._title ? 1 : 0));
    });
  },

  setTitle: function(title) {
    var _this = this;
    this._setContent('_title', title, function() {
      _this._title = _this.build({ tagName: 'h2', content: title });
      _this.insertChild(_this._title, 0);
    });
  },

  handleAction: function() {
    this.hide();
  },

  show: function(parent) {
    var _this = this;
    if (this._visible) {
      return;
    }

    this._visible = true;
    var node = this.getNode(),
        style = node.style;

    style.cssText =
      'display: block; visibility: hidden; height: auto; width:' +
      this.getWidth();

    if (this.getHasScrim()) {
      this.scrim = this.build({
        view: Scrim,
        action: 'hide'
      });
      if (parent) {
        parent.appendChild(this.scrim);
      } else {
        this.scrim.placeIn(document.body);
      }
    }

    if (!node.parentNode) {
      if (parent) {
        parent.appendChild(this);
        this.parent = parent;
      } else {
        this.placeIn(document.body);
      }
    }

    var height = this.getDesiredHeight(); // measure
    this.updateHeight && this.updateHeight(height);

    this.setStyle({
      display: 'block',
      height: height,
      visibility: 'visible',
      bottom: '-' + height + 'px',
      width: this.getWidth() || '100%'
    });

    var isMultiCol = this.findRef('actionContainer').getChildViews().length > 1;

    this[isMultiCol ? 'addClass' : 'removeClass']('bolt-action-sheet-multi-col');

    setTimeout(function() {
      _this.setMode('state', 'visible');
    }, 0);
  },

  getDesiredHeight: function() {
    return this.getRect().height;
  },

  toggle: function() {
    this._visible ? this.hide() : this.show();
  }

});

exports.ActionSheet = ActionSheet;
});

// module: bolt/dom
// file:   ../../../frameworks/bolt/lib/dom.js
define("bolt/dom", function(require, exports, module) {
/**
 * Copyright (c) 2011-2012, Facebook, Inc.
 * All rights reserved.
 *
 * @option preserve-header
 *
 */

var util = require('./util');

var expando = 'bt' + (+new Date);

var oneOrMoreSpacesRegex = /\s+/;
var removeRegex1 = /^\s\s*/;
var removeRegex2 = /\s\s*$/;

/**
 * Dom convinience methods
 */
var dom = module.exports = {
  /**
   * Convenience wrapper around document.createElement
   * Creates dom element with given tagName, options and children
   *
   * @param {string} tagName
   * @param {object} options
   * @param {array} children
   * @returns {Element} created element
   */
  createElement: function(tagName, options, children) {
    var e = document.createElement(tagName);

    if (options) {
      var value;
      for (var name in options) {
        value = options[name];

        if (name === 'innerHTML') {
          dom.dangerouslyInjectHtml(e, value);
        } else if(name === 'content') {
          dom.replaceText(e, value);
        } else if (name === 'style') {
          e.style.cssText = value;
        } else {
          e[name] = value;
        }
      }
    }
    if (children !== undefined) {
      dom.appendContent(e, children);
    }
    return e;
  },

  removeElement: function(element) {
    if (element && element.parentNode) {
      element.parentNode.removeChild(element);
    }
  },

  /**
   * Convert an html-string into a DOM node; this is an unsafe operation.
   *
   * @param {htmlstring}
   * @returns {Node or DocumentFragment}
   */
  fromHTML: function(html) {
    if (__DEV__) {
      console.warn('Converting a raw HTML string: '+html);
    }
    var div = document.createElement('div');
    div.innerHTML = html;
    if (div.firstChild && !div.firstChild.nextSibling) {
      return div.firstChild;
    } else {
      var frag = document.createDocumentFragment();
      while (div.firstChild) {
        frag.appendChild(div.firstChild);
      }
      return frag;
    }
  },

  hasClass: function(elem, className) {
    return (' ' + elem.className + ' ').indexOf(' ' + className + ' ') > -1;
  },

  /**
   * Add one or more CSS classes to a DOM node
   * @param elem {DomNode} The element on which to change the className
   * @param classNames {String} One or more CSS classes, separated by spaces
   */
  addClass: function(elem, classNames) {
    var string = elem.className;
    var original = string;

    // Optimize for adding a single class, which is common
    if (classNames.indexOf(' ') > -1) {
      var names = classNames.split(oneOrMoreSpacesRegex);
      var length = names.length;
      for (var i = 0; i < length; i++) {
        if (!dom.hasClass(elem, names[i])) {
          string += (string ? ' ' : '') + names[i];
        }
      }
    } else {
      if (!dom.hasClass(elem, classNames)) {
        string += (string ? ' ' : '') + classNames;
      }
    }

    // Do not change the DOM element unless the class has actually changed
    if (string !== original) {
      elem.className = string;
    }
  },

  /**
   * Remove one or more CSS classes to a DOM node
   * @param elem {DomNode} The element on which to change the className
   * @param classNames {String} One or more CSS classes, separated by spaces
   */
  removeClass: function(elem, classNames) {
    var empty = ' ';
    var original = elem.className;
    var string = empty + original + empty;

    // Optimize for removing a single class, which is common
    if (classNames.indexOf(' ') > -1) {
      var names = classNames.split(oneOrMoreSpacesRegex);
      var length = names.length;
      for (var i = 0; i < length; i++) {
        string = string.replace(empty + names[i] + empty, empty);
      }
    } else {
      // Just change the string once, don't create an Array
      string = string.replace(empty + classNames + empty, empty);
    }

    string = string.replace(removeRegex1, '').replace(removeRegex2, '');

    // Do not change the DOM element unless the class has actually changed
    if (string !== original) {
      elem.className = string;
    }
  },

  /**
   * Adds or removes one or more class names.
   *
   * @param elem {DomNode} The elemen on which to change the className
   * @param className {String} A single CSS class to add or remove
   * @param condition {Boolean} If true, the CSS class is added.  If false
   *                    the CSS class is removed.  If not specified, the
   *                    CSS class is added or removed depending on whether
   *                    or not it already exists on the node.
   */
  toggleClass: function(elem, className, condition) {
    if (arguments.length < 3) {
      condition = !dom.hasClass(elem, className);
    }
    condition ? dom.addClass(elem, className) :
      dom.removeClass(elem, className);
  },

  alterClass: function(elem, className, condition) {
    require('./core').deprecated('alterClass', 'toggleClass');
    return this.toggleClass.apply(this, arguments);
  },

  /**
   * Converts a text string into an HTML representation of that text
   * by escaping HTML metacharacters. This is normally only necessary
   * if you intend to call dangerouslyInjectHtml with the result,
   * which should generally be avoided.
   *
   * @param {string} text
   * @returns {string} html-string
   */
  escapeHTML: function(html) {
    return (html + '')
      .replace(/&/g,'&amp;')
      .replace(/</g,'&lt;')
      .replace(/>/g,'&gt;')
      .replace(/\"/g,'&quot;')
      .replace(/\'/g,'&#x27;');
  },

  htmlize: function(html) {
    require('./core').deprecated('htmlize', 'escapeHTML');
    return this.escapeHTML(html);
  },

  identify: function(elem) {
    return elem[expando] = elem[expando] || util.generateCID();
  },

  clear: function(node) {
    node.innerHTML = '';
  },

  /**
   * This function is equivalent to eval(), with a slightly different
   * input encoding. Passing around raw HTML strings is the easiest
   * way to accidentally introduce XSS holes. When it cannot be
   * avoided, e.g. when you receive a trusted HTML string from outside
   * your program, the easiest way to limit the amount of code that
   * can potentially introduce an XSS hole is to exchange the string
   * for an actual DOM nodes as soon as possible (see DOM.fromHTML).
   */
  dangerouslyInjectHtml: function(node, html) {
    if (__DEV__) {
      console.warn('Injecting a raw HTML string: '+html);
    }
    node.innerHTML = html;
  },

  /**
   * Replace all the content of the DOM node with a text string.
   */
  replaceText: function(node, text) {
    this.replaceContent(node, text + '');
  },

  /**
   * Replace all the content of the DOM node with a list of dom nodes
   * and strings. This accepts nested lists so that any function that
   * wants to "append" markup can just put it in an array.
   */
  replaceContent: function(node, content) {
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
    dom.appendContent(node, content);
  },

  appendContent: function(node, data) {
    if (data instanceof Array) {
      for (var i=0; i<data.length; i++) {
        dom.appendContent(node, data[i]);
      }
    } else if (data !== null && data !== undefined) {
      if (!data.nodeType) {
        data = document.createTextNode(data + '');
      }
      node.appendChild(data);
    }
  },
  
  /**
   * get the bounding rect for the view
   */
  getRect: function(node) {
    var rect = node.getBoundingClientRect();
    rect = {
      // FF doesn't round the top/bottom coordinates.
      top:    Math.round(rect.top),
      bottom: Math.round(rect.bottom),
      left: rect.left,
      right: rect.right
    };
    // IE 8 doesn't give you width nor height
    rect.width = rect.right - rect.left;
    rect.height = rect.bottom - rect.top;
    return rect;
  },

  getScrollAdjustedRect: function(node) {
    var rect = dom.getRect(node);

    var body = document.body,
        docElem = document.documentElement,
        scrollTop = window.pageYOffset || body.scrollTop ||
          (docElem && docElem.scrollTop) || 0,
        scrollLeft = window.pageXOffset || body.scrollLeft ||
          (docElem && docElem.scrollLeft) || 0;

    rect.top += scrollTop;
    rect.bottom += scrollTop;
    rect.left += scrollLeft;
    rect.right += scrollLeft;

    return rect;
  }
};
});

// module: views/contact_menu_search_list/index
// file:   ../../views/contact_menu_search_list/index.js
define("views/contact_menu_search_list/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var Model = require('bolt/model').Model;
var Collection = require('bolt/collection').Collection;

var View = require('bolt_touch/view').View;
var Scrim = require('bolt_touch/views/scrim').Scrim;

var MenuSearchList = require('../menu_search_list').MenuSearchList;
var simpleContactFetcher = require('talk/app/contacts/simple_contact_fetcher');

function labelComparator(model) {
  return model.get('label');
}

/**
 * @classdesc A view that manages a MenuSearchList of contacts.  The menu is
 *   placed absolutelye on the screen, and contacts are loaded into it.  When
 *   a contact is selected by the user, the "select" event is fired.  If the
 *   user taps anywhere outside the menu, the entire view is destroyed.
 */
exports.ContactMenuSearchList = core.createClass({
  name: 'ContactMenuSearchList',

  extend: View,

  events: ['contactSelected'],

  properties: {
    /**
     * @param x {Number} The horizontal position of the menu, in percentage
     */
    x: 50,

    /**
     * @param y {Number} The vertical position of the menu, in percentage
     */
    y: 50,

    /**
     * @param existingTag {Model} The model for an existing tag that is being
     *   edited.  If this exists, when the search term is empty, any guesses
     *   will be used to populate the menu, with the current tag value
     *   appearing first
     */
    existingTag: null
  },

  declare: function() {

    this._focusMenu = util.bind(this._focusMenu, this);
    this._updateMenuPosition = util.bind(this._updateMenuPosition, this);

    return {

      childViews: [
        {
          view: Scrim,
          ref: 'scrim',
          action: 'hideAndDestroy'
        },
        {
          view: MenuSearchList,
          ref: 'menu',

          // Make the menu pop in
          className: 'shrunken-menu shrinkable-menu',

          onselect: 'handleSelect',
          owner: this,

          imageProperty: 'image',
          labelProperty: 'label',
          placeholder: 'Who is this?'
        }

      ]
    };
  },

  hideAndDestroy: function() {
    // Hide the menu, and when the animation has completed, destroy this view
    var menu = this.findRef('menu');

    // Keep the existing transform, if any
    var transform =
      'scale(0) ' + (this._scaleTransform || '');

    var menuNode = menu.getNode();
    menuNode.addEventListener(
      'webkitTransitionEnd', util.bind(this.destroy, this));

    menuNode.style.webkitTransform = transform;
  },

  handleSelect: function(event) {
    event.stopPropagation();
    this.invoke('contactSelected', util.extend({
      existingTag: this.getExistingTag()
    }, event.data));
  },

  /**
   * Delegate method called by the MenuSearchList when the search term changes
   */
  menuSearchListUpdate: function(listView, searchTerm) {
    var collection = this.findRef('menu').getCollection();

    collection.clear();

    searchTerm = util.trim(searchTerm || '');
    var i;

    if (searchTerm) {

      // If the search term is non-empty, filter the list of contacts
      // to contain just the contacts that match it.

      // Sort by name
      collection.comparator = labelComparator;

      var length = this._contactsCollection.length;
      searchTerm = searchTerm.toLowerCase();
      var model;
      var fullName;

      for (i = 0; i < length; i++) {
        model = this._contactsCollection.at(i);

        fullName = model.get('label').toLowerCase();

        if (fullName.indexOf(searchTerm) === 0) {
          collection.add(model);
        }
      }
      this._updateMenuPosition();
      this._positionWasUpdated = true;
    } else {
      // If the search term is empty, check if the photo has any
      // suggested tags, and populate the collection with those

      // TODO: handle showing default values based on face recognition guesses

      collection.comparator = null;

      var existingTag = this.getExistingTag();

      if (existingTag) {
        var userId = existingTag.get('id');
        var name = existingTag.get('text');

        if (userId !== -1) {

          var url =
            'https://graph.facebook.com/' + userId + '/picture?type=small';

          // If the user id is not a fake placeholder, add it to the model
          // as the first one to be seen
          collection.add(new Model({
            id: userId,

            label: name,

            image: url
          }));
        }

        var guesses = existingTag.get('guesses');

        if (guesses) {
          for (i = 0; i < guesses.length; i++) {
            collection.add(new Model({
              id: guesses[i].userId,

              label: guesses[i].name,

              image: guesses[i].profilePicUrl
            }));
          }
        }
      }

      if (this._positionWasUpdated) {
        this._updateMenuPosition();
      }
    }
  },

  onDocumentInsertion: function() {
   // Initialize the contacts data if it has not previously been loaded
    if (!this._contactsCollection) {
      var allContactsCollection = this._contactsCollection = new Collection();
      simpleContactFetcher.fetchContacts().addCallback(
        function(arrayOfContacts) {

          var contact;
          var length = arrayOfContacts ? arrayOfContacts.length : 0;

          // Build a Collection of simple models containing contact IDs
          for (var i = 0; i < length; i++) {
            contact = arrayOfContacts[i];
            allContactsCollection.add(new Model({
              id: contact.get('facebookId'),

              image: contact.get('profileUrl'),

              // Ugh, this is ugly.  TODO get the proper full name Task #1022441
              label: contact.get('firstName') + ' ' + contact.get('lastName')
            }, true));
          }
        }
      );
    }

    var menu = this.findRef('menu');

    // Create a new collection which will contain the filtered contacts
    var collection = menu.getCollection();

    var menuNode = menu.getNode();

    // Focus the menu when the scale animation finishes.
    // This produces a better effect, as the keyboard is not engaged until
    // after the animation completes
    menuNode.addEventListener('webkitTransitionEnd', this._focusMenu);

    // Calculate the initial position of the menu
    var menuWidth = menuNode.offsetWidth;
    var menuHeight = menuNode.offsetHeight;

    var wrapperNode = this.getNode(); // Maybe do more accurate measurements?
    var wrapperWidth = wrapperNode.offsetWidth;
    var percWidth = (menuWidth / wrapperWidth) * 100;
    var percHeight = (menuHeight / wrapperNode.offsetHeight) * 100;

    var x = this.getX();
    var y = this.getY();

    var leftPos = Math.min(100 - percWidth, Math.max(0, x - (percWidth / 2)));
    var topPos = Math.max(0, y - percHeight / 2);

    // Set the initial position of the menu
    menu.setStyle({
      top: topPos + '%',
      left: leftPos + '%'
    });

    menu.removeClass('shrunken-menu');
  },

  /**
   * Focus the input in the menu
   */
  _focusMenu: function(event) {
    var menu = this.findRef('menu');
    if (event.target === menu.getNode()) {
      menu.getNode().removeEventListener(
        'webkitTransitionEnd', this._focusMenu);

      // Delay the focus so the user can see the placeholder text
      setTimeout(function() {
        if (!menu.isDestroyed && menu.getNode().parentNode) {
          menu.focus();
        }
      }, 300);

      // Ensure that the menu is not off the screen
      setTimeout(this._updateMenuPosition, 800);
    }
  },

  /**
   * Ensure that the menu is on the screen by checking it's position and
   * dimensions
   */
  _updateMenuPosition: function() {
    var menu = this.findRef('menu');
    if (!menu) {
      // If the view has been destroyed, do nothing
      return;
    }
    var menuNode = menu.getNode();

    var height = menuNode.offsetHeight;
    var wrapperHeight = menuNode.parentNode.offsetHeight;
    var top = menuNode.offsetTop + 100;// Add a little buffer at the bottom

    var verticalTranslation = Math.min(0, wrapperHeight - (top + height));

    menuNode.style.webkitTransform = this._scaleTransform =
      'translate(0, ' + verticalTranslation + 'px)';
  }
});
});

// module: photos/app/lib/view/unpublished_album_scene/index
// file:   ../../photos/app/lib/view/unpublished_album_scene/index.js
define("photos/app/lib/view/unpublished_album_scene/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core               = require('bolt/core');
var util               = require('bolt/util');
var Model              = require('bolt/model').Model;
var Scene              = require('bolt_touch/views/scene').Scene;

var GridPhotoViewer    = require('../grid_photo_viewer').GridPhotoViewer;
var Toolbar            = require('../toolbar').Toolbar;
var photoClient        = require('../../client/photo_client').getInstance();
var Video              = require('photos/app/lib/model/video/video').Video;
var VideoPlayerScene   = require('photos/app/lib/view/video_player_scene').VideoPlayerScene;
var Constants          = require('../../controller/constants');

var PHOTO_STATE        = Constants.PHOTO_STATE;
var MEDIA_TYPE         = Constants.MEDIA_TYPE;

exports.UnpublishedAlbumScene = core.createClass({
  name: 'UnpublishedAlbumScene',

  extend: Scene,

  properties: {
    photos: null,
    header: false,
    cameraButton: false,
    startingIndex: null
  },

  declare: function() {
    return {
      boxOrientation: 'vertical',
      childViews: [
        {
          view: GridPhotoViewer,
          ref: 'gridPhotoViewer',
          flex: 1,
          showTags: true,
          selectable: true,
          onback: 'pop',
          onopened: '_photoViewerOpened',
          onphotoSelected: '_photoSelected',
          onphotoTouched: '_photoTouched',
          onclosing: '_photoViewerClosing',
          ontagTouched: '_tagTouched'
        },
        {
          ref: 'footer',
          view: Toolbar,
          type: Toolbar.TYPE.FOOTER,

          childViews: [
            {
              ref: 'cameraButton',
              className: 'go-back-button',
              onclick: 'pop'
            },
            {
              ref: 'photoStatus',
              className: 'photo-status'
            },
            {
              ref: 'tagButton',
              className: 'tag-button',
              onclick: 'tagPhoto'
            },
            {
              ref: 'shareButton',
              className: 'share-button',
              onclick: 'sharePhoto'
            }
          ]
        },
        {
          ref: 'tagFooter',
          view: Toolbar,
          type: Toolbar.TYPE.FOOTER,

          childViews: [
            {
              content: 'Tap a face to tag',
              className: 'tagging-text'
            },
            {
              className: 'done-button',
              onclick: 'doneTagging'
            }
          ]
        }
      ]
    };
  },

  ready: function() {
    this.refs.tagFooter.hide();
    this._photoViewerClosing();

    if (!this.get('cameraButton')) {
      this.refs.cameraButton.hide();
    }

    this.contactSelectedHandler = util.bind(this._contactSelectedHandler, this);

    // Prepare the grid photo viewer
    if (this.get('header')) {
      this.refs.gridPhotoViewer.setTitle(Constants.UNPUBLISHED_ALBUM_NAME);
    }
    this.refs.gridPhotoViewer.setPhotos(this.get('photos'));
    this.refs.gridPhotoViewer.setStartingIndex(this.get('startingIndex'));
    this.refs.gridPhotoViewer.setHeader(this.get('header'));
    this.refs.gridPhotoViewer.load();
  },

  destroy: function() {
    Scene.prototype.destroy.call(this);

    // TODO: Confirm intended behavior, but for now, clear the selection
    // whenever this view is destroyed.
    for (var i = 0; i < this.get('photos').length; i++) {
      this.get('photos').at(i).set('selected', false);
    }
  },

  _photoViewerOpened: function() {
    this.refs.photoStatus.show();
    this.refs.tagButton.show();
    this._gridView = false;
  },

  _photoSelected: function(evt) {
    this._currentPhoto = evt.data.photo;

    this.setBinding(this._currentPhoto, [
      { modelProperty: 'state', viewProperty: 'photoStatus' }
    ]);

    if (this._currentPhoto.get('type') === MEDIA_TYPE.VIDEO) {
      this.refs.tagButton.hide();
    }
    else {
      this.refs.tagButton.show();
    }
  },

  /**
   * Handles the selection of a tag for editing.  Show the tag menu if so
   */
  _tagTouched: function(evt) {

    var tagModel = evt.data.photo_tag;
    if (tagModel.get('id') === -1) {

      var x = Math.floor(tagModel.get('xcoord'));
      var y = Math.floor(tagModel.get('ycoord'));

      this._showTagMenu(x, y, tagModel);
    }
  },

  _photoTouched: function(evt) {
    // #EventCompatibilityHack
    if (typeof evt.data.index === 'undefined') {
      return;
    }

    var photo = this._currentPhoto;

    // TODO: If you click a video, it'll probably shrink to the Grid.
    // We need to update the photo viewer to support video better.
    if (photo.get('type') === MEDIA_TYPE.VIDEO) {
      // TODO: clean this up by using a more generic Media model
      var obj = util.extend(photo.toObject(), {
        source: 'file://' + photo.get('path')
      });
      var video = new Video(obj);

      this.getStack().pushModal({
        view  : VideoPlayerScene,
        video : video
      }, { transition: 'drawer' });

      return;
    }

    if (!this.isTagging) {
      return;
    }

    this.touchData = evt.data;
    this._showTagMenu(evt.data.percentX, evt.data.percentY, null);
  },

  /**
   * Show a tag menu at the position that the user clicked.
   */
  _showTagMenu: function(x, y, existingTag) {

    // Destroy any existing menu
    this._destroyMenu();

    // TODO: add support for editing an existing tag

    // Lazily require the menu code
    var ContactMenuSearchList =
      require('views/contact_menu_search_list').ContactMenuSearchList;

    this._tagMenu = new ContactMenuSearchList({
      x: x,
      y: y,

      existingTag: existingTag,

      oncontactSelected: 'contactSelectedHandler',
      owner: this
    });

    this.append(this._tagMenu);
  },

  _destroyMenu: function() {

    if (this._tagMenu && !this._tagMenu.isDestroyed) {
      this._tagMenu.hideAndDestroy();
    }
    this._tagMenu = null;
  },

  _contactSelectedHandler: function(event) {

    // Handle the selection of a contact from the ContactMenuSearchList
    var data = event.data;
    var model = data.model;
    var existingTag = data.existingTag;

    this._destroyMenu();

    if (existingTag) {
      existingTag.setAll({
        text   : model.get('label'),
        id     : model.get('id')
      });
      this._currentPhoto.save();
    } else {
      this._currentPhoto.addTag({
        text   : model.get('label'),
        id     : model.get('id'),
        xcoord : this.touchData.percentX,
        ycoord : this.touchData.percentY
      });
    }
    this.refs.gridPhotoViewer.setShowTags(true);

  },

  _photoViewerClosing: function() {
    this.refs.photoStatus.hide();
    this.refs.tagButton.hide();
    this._gridView = true;
  },

  setPhotoStatus: function(state) {
    var status;

    switch (this._currentPhoto.get('state')) {
      case PHOTO_STATE.LOCAL:
        status = 'local?';
        break;
      case PHOTO_STATE.UPLOADING:
        status = 'uploading...';
        break;
      case PHOTO_STATE.POSTING:
        status = 'posting';
        break;
      case PHOTO_STATE.POST_SUCCEEDED:
        status = 'now moving photo to Mobile Uploads';
        break;
      case PHOTO_STATE.POST_FAILED:
        status = 'post failed!';
        break;
      case PHOTO_STATE.SYNCED:
        status = 'synced';
        break;
      default:
        status = 'unknown status: ' + this._currentPhoto.get('state');
        break;
    }

    this.refs.photoStatus.setContent(status);
  },

  tagPhoto: function() {
    this._toggleTagState(true);
  },

  doneTagging: function() {
    this._toggleTagState(false);
  },

  _toggleTagState: function(enabled) {
    this.isTagging = enabled;

    this.refs.footer.toggle();
    this.refs.tagFooter.toggle();

    this.refs.gridPhotoViewer.setCloseOnTouch(!enabled);
  },

  sharePhoto: function() {
    var selectedPhotos = [];
    for (var i = 0; i < this.get('photos').length; i++) {
      var photo = this.get('photos').at(i);
      if (photo.get('selected')) {
        selectedPhotos.push(photo);
      }
    }

    this._composerScene = this._composerScene ||
      require('views/composer/js/composer_scene').ComposerScene;
    this.getStack().push({
      view: this._composerScene,
      composerModel: new Model({
        photos: selectedPhotos
      })
    });
  }
});
});

// module: shared/date_util
// file:   ../../shared/js/date_util.js
define("shared/date_util", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var util = require('bolt/util');

exports.parseISO8601DateString = function (date) {
  var timestamp = Date.parse(date), minutesOffset = 0, struct;
  if (isNaN(timestamp) && (struct = /^(\d{4}|[+\-]\d{6})-(\d{2})-(\d{2})(?:[T ](\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?))?/.exec(date))) {
    if (struct[8] !== 'Z') {
      minutesOffset = +struct[10] * 60 + (+struct[11]);

      if (struct[9] === '+') {
        minutesOffset = 0 - minutesOffset;
      }
    }

    struct = util.map(struct, function(part) {
      return part || '';
    });
    timestamp = Date.UTC(
      +struct[1],
      +struct[2] - 1,
      +struct[3],
      +struct[4],
      +struct[5] + minutesOffset,
      +struct[6],
      +struct[7].substr(0, 3));
  }
  return timestamp;
};


exports.getISOTime = function (syncSeq) {
  var nonZeroSyncSeq = syncSeq < 0 ? 0 : syncSeq;
  return new Date(nonZeroSyncSeq).toISOString();
};

/**
 * calculate the localized time by applying the current offset
 * to a number of miliseconds from the epoch in GMT.
 */
exports.localizedDateFromEpochMilliseconds = function(ms) {
  var offset = new Date(ms).getTimezoneOffset() * -60000;
  return new Date(ms + offset);
};

exports.formatDate = function(date) {
  return (date.getMonth() + 1) + "/" +
          date.getDate() + "/" +
          date.getFullYear();
};

/**
 * common method for generating a time string
 * ex: 13:47
 */
exports.getTime = function(dt) {
  var hours = dt.getHours();

  var minutes = dt.getMinutes();
  if (minutes < 10) {
    minutes = "0" + minutes;
  }

  if (localStorage['is24HourTimeFormat'] === '1') {
    return hours + ":" + minutes;
  } else {
    var meridiem;
    if (hours >= 12) {
      hours -= 12;
      meridiem = "pm";
    } else {
      meridiem = "am";
    }
    hours = hours || 12;

    return hours + ":" + minutes + meridiem;
  }
};

// constants and helper methods for getDate and shortTimestamp
var DAY_SECONDS = 86400;

var MONTHS = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];

var WEEKDAYS = [
  'Sunday',
  'Monday',
  'Tuesday',
  'Wednesday',
  'Thursday',
  'Friday',
  'Saturday'
];

var SHORT_MONTHS = [
  'Jan',
  'Feb',
  'Mar',
  'Apr',
  'May',
  'Jun',
  'Jul',
  'Aug',
  'Sep',
  'Oct',
  'Nov',
  'Dec'
];

var fullDate = exports.fullDate = function(date) {
  return MONTHS[date.getMonth()] + ' ' +
    date.getDate() + ', ' + date.getFullYear();
};

/**
 * Convert a Unix timestamp to a relative time ("about an hour ago", for
 * example).
 *
 * @param timestamp The Unix time in milliseconds to convert
 * @param framepoint An optional time off of which to base the relative time. By
 *  default this value is the current time.
 */
exports.relativeTimestamp = function(timestamp, framepoint) {
  framepoint = framepoint || new Date();
  var delta = framepoint.getTime() - timestamp.getTime();
  var minutes = Math.round(delta / (1000 * 60));
  var hours = Math.round(delta / (1000 * 60 * 60));
  var days = delta / (1000 * DAY_SECONDS);
  if (days > 1) {
    // no need to round anything under 24 hours up
    days = Math.round(days);
  }

  if (days > 7) {
    if (timestamp.getYear() < framepoint.getYear()) {
      return fullDate(timestamp);
    } else {
      return MONTHS[timestamp.getMonth()] + ' ' + timestamp.getDate();
    }
  } else if (days > 4) {
    return 'last ' + WEEKDAYS[timestamp.getDay()];
  } else if (days > 1) {
    return WEEKDAYS[timestamp.getDay()];
  } else if (days === 1) {
    return 'Yesterday';
  } else if (hours > 1) {
    return hours + ' hours ago';
  } else if (hours === 1) {
    return 'about an hour ago';
  } else if (minutes > 1) {
    return minutes + ' minutes ago';
  } else if (minutes === 1) {
    return 'about a minute ago';
  } else {
    return 'Just now';
  }
};

exports.getOrdinalSuffix = function(number) {
  if (number % 10 == 1 && number != 11) {
    return number + "st";
  } else if (number % 10 == 2 && number != 12) {
    return number + "nd";
  } else if (number % 10 == 3 && number != 13) {
    return number + "rd";
  } else {
    return number + "th";
  }
};

/**
 * common method for generating a date string
 * ex: Monday, February 7th
 */
exports.getDate = function(dt) {
  return WEEKDAYS[dt.getDay()] + ", " +
    MONTHS[dt.getMonth()] + " " +
    exports.getOrdinalSuffix(dt.getDate());
};

exports.shortTimestamp = function(dt) {

  var curDate = new Date();
  var diff = (curDate.getTime() - dt.getTime()) / 1000;
  var days = Math.floor(diff / DAY_SECONDS);
  var dayOfWeek = dt.getDay();
  var dayOfMonth = dt.getDate();
  var month = dt.getMonth();
  var hours = dt.getHours();
  var year = dt.getFullYear();
  var yearLastTwo = (year + '').substr(-2);
  var meridiem = hours >= 12 ? 'pm' : 'am';
  hours = (hours + 11) % 12 + 1;
  var minutes = dt.getMinutes();

  var formatted;
  if (days < 1) {
    minutes = minutes < 10 ? '0' + minutes : minutes;
    formatted = hours + ':' + minutes + ' ' + meridiem;
  } else if (days < 8) {
    formatted = WEEKDAYS[dayOfWeek];
  } else if (days < 365) {
    formatted = SHORT_MONTHS[month] + ' ' + dayOfMonth;
  } else {
    dayOfMonth = dayOfMonth < 10 ? '0' + dayOfMonth : dayOfMonth;
    month = month + 1;
    formatted = month + '/' + dayOfMonth + '/' + yearLastTwo;
  }
  return formatted;
};

exports.delimiterTimestamp = function(dt) {

  var curDate = new Date();
  var diff = (curDate.getTime() - dt.getTime()) / 1000;
  var days = Math.floor(diff / DAY_SECONDS);
  var dayOfWeek = dt.getDay();
  var dayOfMonth = dt.getDate();
  var month = dt.getMonth();
  var hours = dt.getHours();
  var year = dt.getFullYear();
  var yearLastTwo = (year + '').substr(-2);
  var meridiem = hours >= 12 ? 'pm' : 'am';
  hours = (hours + 11) % 12 + 1;
  var minutes = dt.getMinutes();
  var curDayOfMonth = curDate.getDate();
  minutes = minutes < 10 ? '0' + minutes : minutes;

  var formatted;
  if (days < 1) {
    formatted = hours + ':' + minutes + ' ' + meridiem;
    if (curDayOfMonth != dayOfMonth) {
      formatted = 'Yesterday, ' + formatted;
    }
  } else if (days < 7) {
    formatted = WEEKDAYS[dayOfWeek] + ', ' + hours +
      ':' + minutes + ' ' + meridiem;
  } else if (days < 365) {
    formatted = SHORT_MONTHS[month] + ' ' + dayOfMonth +
      ', ' + hours + ':' + minutes + ' ' + meridiem;
  } else {
    dayOfMonth = dayOfMonth < 10 ? '0' + dayOfMonth : dayOfMonth;
    month = month + 1;
    formatted = month + '/' + dayOfMonth + '/' + yearLastTwo +
      ' ' + hours + ':' + minutes + ' ' + meridiem;
  }
  return formatted;
};

exports.convertDateToTimestamp = function(time) {
  return exports.convertDateStringToDate(time).getTime();
};

exports.convertDateStringToDate = function(dateString) {

  if (!dateString) {
    console.error('convertDateStringToDate: argument cannot be empty');
    return null;
  }
  var regex = /(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})/;
  var result = regex.exec(dateString);

  var date = new Date();
  date.setYear(result[1]);
  date.setMonth(result[2] - 1);
  date.setDate(result[3]);
  date.setHours(result[4]);
  date.setMinutes(result[5]);
  date.setSeconds(result[6]);
  date.setMilliseconds(0);

  return exports.localizedDateFromEpochMilliseconds(date.getTime());
};

exports.convertDateToDateString = function(time) {
  var month = time.getMonth() + 1;
  month = month < 10 ? '0' + month : month;
  var date = time.getDate() < 10 ? '0' + time.getDate() : time.getDate();
  var hours = time.getHours() < 10 ? '0' + time.getHours() : time.getHours();
  var minutes = time.getMinutes() < 10 ? '0' + time.getMinutes() :
    time.getMinutes();
  var seconds = time.getSeconds() < 10 ? '0' + time.getSeconds() :
    time.getSeconds();
  return '' + time.getFullYear() + '-' +
         month + '-' +
         date + 'T' +
         hours + ':' +
         minutes + ':' +
         seconds + '+0000';
};

/**
 * Take a duration (in milliseconds) and turn it into something like 00:30.
 *
 * @param  int     Time, in milliseconds.
 * @return string  Prettified duration.
 */
exports.formatDuration = function(duration) {
  duration = Math.floor(duration / 1000); // convert to seconds

  var secs = duration % 60;
  var mins = Math.floor(duration / 60) % 60;
  var hours = Math.floor(duration / 60 / 60);

  secs = (secs < 10) ? ('0' + secs) : secs;
  mins = (mins < 10) ? ('0' + mins) : mins;

  if (hours > 0) {
    hours = (hours < 10) ? ('0' + hours) : hours;
    return hours + ':' + mins + ':' + secs;
  } else {
    return mins + ':' + secs;
  }
};
});

// module: bolt/event_dispatcher
// file:   ../../../frameworks/bolt/lib/event_dispatcher.js
define("bolt/event_dispatcher", function(require, exports, module) {
var util = require('./util');
var dom = require('./dom');
var core = require('./core');

var prefixedEvent = require('./feature_detect').prefixedEvent;

var getRawEvent = function() {return this};
var getTargetView = function() {return this.targetView};

/**
 * @class
 *
 * EventDispatcher manages the application-scoped event responding and
 * dispatching. It uses id-based delegation to find the proper view to
 * send the event to, and attaches/responds toevents listeners on the
 * root element.
 *
 * From a developer's perspective, the most interesting part of
 * EventDispatcher is the trigger() method, which allows you to trigger
 * an event to the system manually at runtime, and it will follow the
 * standard event-dispatching path.
 *
 * Event responders stopPropagation. When a truthy value is returned,
 * the event stops bubbling the view hierarchy. It defaults to false.
 */
var EventDispatcher = exports.EventDispatcher = core.createClass({
  name: 'eventDispatcher',

  _viewRegistry: null,
  _hasBeenSetUp: false,
  _listeners: null,

  properties: {
    compatibilityMode: true,
    enabled: false
  },

  _events: {
    'animationend': prefixedEvent('animation', 'animationEnd'),
    'animationiteration': prefixedEvent('animation', 'animationIteration'),
    'animationstart': prefixedEvent('animation', 'animationStart'),
    'blur': true,
    'change': true,
    'click': true,
    'dblclick': true,
    'drag': true,
    'dragend': true,
    'dragenter': true,
    'dragleave': true,
    'dragover': true,
    'dragstart': true,
    'drop': true,
    'focus': true,
    'focusin': true,
    'focusout': true,
    'input': true,
    'keydown': true,
    'keypress': true,
    'keyup': true,
    'mousedown': true,
    'mouseenter': true,
    'mouseleave': true,
    'mousemove': true,
    'mouseup': true,
    'resize': true,
    'scroll': true,
    'submit': true,
    'touchcancel': true,
    'touchend': true,
    'touchmove': true,
    'touchstart': true,
    'transitionend': prefixedEvent('transition', 'transitionEnd')
  },

  construct: function() {
    this._viewRegistry = {};
    this._listeners = {};
  },

  /**
   * Initiate listeners
   *
   * @public
   */
  setup: function(options) {
    if (this._hasBeenSetUp) return;
    var events = this._events;
    var handler = util.bind(this.trigger,this);

    for (var eventName in events) {
      if (events.hasOwnProperty(eventName)) {
        var domEventName;
        if (typeof(events[eventName]) === 'string') {
          // eventName is an alias
          domEventName = events[eventName];
        } else {
          domEventName = eventName;
        }
        document.addEventListener(domEventName, handler);
      }
    }

    this._hasBeenSetUp = true;
  },

  registerView: function(obj) {
    this._viewRegistry[dom.identify(obj.getNode())] = obj;
  },

  unregisterView: function(obj) {
    delete this._viewRegistry[dom.identify(obj.getNode())];
  },

  /**
   * Trigger events at runtime.
   *
   * @param source Event The browser event (raw or synthesized using createEvent()
   *                     and initEvent())
   *
   * @param source Object Specifies which event manager triggered this event.
   *                      This prevents multiple events from getting triggered
   *                      to the same event manager.
   *
   * @public
   */
  trigger: function(evt,source) {
    var eventName = evt.type;
    var node = evt.target;
    var view = this._viewRegistry[dom.identify(node)];

    // if you interact with a nested dom node that isn't a view,
    // start the event bubbling at the closest view.
    while (!view && node) {
      node = node.parentNode;
      if (node) view = this._viewRegistry[dom.identify(node)];
    }

    if (view) {
      evt.targetView = view;

      var manager = this._findNearestEventManager(view, eventName);

      if (manager && manager !== source) {
        this._dispatchEvent(manager, evt, eventName, view);
      } else if (view) {
        this._bubbleEvent(view, evt, eventName);
      }
    }

    return evt.propagationStopped;
  },

  /** @private */
  _dispatchEvent: function(object, evt, eventName, view) {
    var handler = object[eventName];

    if (typeof handler  === 'function') {
      var result = handler.call(object, evt, view);
      // Event manager events don't bubble.
      if (result) {
        evt.stopPropagation();
      }
    } else {
      this._bubbleEvent(view, evt, eventName);
    }
  },

  /** @private */
  _bubbleEvent: function(view, evt, eventName) {
    if (this.getCompatibilityMode()) {
      evt.getRawEvent = getRawEvent;
      evt.getTargetView = getTargetView;
    }

    while (view && !evt.propagationStopped) {
      view.sendEvent && view.sendEvent(evt);

      this._performInvoke(view, evt, eventName);
      view = view.getParentView();
    }

    return;
  },

  /** @private */
  _findNearestEventManager: function(view, eventName) {
    var manager = null;

    while (view) {
      if (view.getEventManager) {
        manager = view.getEventManager();
        if (manager && manager[eventName]) { break; }
      }

      view = view.getParentView();
    }

    return manager;
  },

  /**
   * view: Used to group events by view
   * eventName: Identify an event
   * listener: the callback function
   * contextOrNull: will usually point to the view itself, but could point
   *                to another object
   */
  addListener: function(view, eventName, listener, contextOrNull, args) {
    var element = view.getNode ? view.getNode() : view;
    var identifier =  dom.identify(element);
    var viewListeners = this._listeners[identifier];

    if (!viewListeners) {
      viewListeners = this._listeners[identifier] = {};
    }

    if (typeof eventName !== 'string') {
      // assume the listener was passed in without an event name
      args = contextOrNull;
      contextOrNull = listener;
      listener = eventName;
      eventName = '*';

      if (!contextOrNull) {
        contextOrNull = listener;
      }
    } else if (typeof(this._events[eventName]) === 'string') {
      eventName = this._events[eventName];
    }

    var registeredListeners = viewListeners[eventName];

    if (!registeredListeners) {
      registeredListeners = viewListeners[eventName] = [];
    }

    registeredListeners.push({
      listener: listener,
      context: contextOrNull,
      args: args
    });
  },

  removeListener: function(view, eventName, listener) {
    var element = view.getNode ? view.getNode() : view;
    var identifier = dom.identify(element);
    var viewListeners = this._listeners[identifier];

    if (!viewListeners) {
      return;
    }

    if (typeof eventName !== 'string') {
      // assume the listener was passed in without an event name
      listener = eventName;
      eventName = '*';
    }

    var registeredListeners = viewListeners[eventName];

    if (registeredListeners) {
      for (var i = 0; i < registeredListeners.length; i++) {
        if (listener === registeredListeners[i].listener) {
          registeredListeners.splice(i,1);
        }
      };
    }
  },

  invoke: function(object, eventObject) {
    // First, dispatch the event to the object itself
    var eventName = eventObject.type;
    var data = eventObject.data;

    if (object.getNode) {
      this._bubbleEvent(object, eventObject, eventName);
    }
    else {
      this._performInvoke(object, eventObject, eventName);
    }

    return !eventObject.defaultPrevented;
  },

  _performInvoke: function(object, eventObject, eventName) {
    // Now try to see if anyone else is listening...
    var element = object.getParentView ? object.getNode() : object;
    var identifier = dom.identify(element);
    var viewListeners = this._listeners[identifier];

    if (!viewListeners) {
      return !eventObject.defaultPrevented;
    }

    this._invokeEventForSubscribers(eventObject, viewListeners[eventName], eventName);
    this._invokeEventForSubscribers(eventObject, viewListeners['*'], eventName);
  },

  _invokeEventForSubscribers: function(eventObject, subscribers, eventName) {
    if (!subscribers || subscribers.length === 0) {
      return;
    }

    var idx;
    var subscriber;
    var listener;
    var len = subscribers.length;

    for (idx = 0; idx < len; idx++) {
      subscriber = subscribers[idx];
      listener = subscriber.listener;

      if (!listener.apply) {
        if (listener[eventName] && listener[eventName].apply) {
          listener = listener[eventName];
        } else {
          listener = null;
        }
      }

      if (listener) {
        listener.call(subscriber.context, eventObject);
      }
    }
  }

});

exports.defaultEventDispatcher = new EventDispatcher();
});

// module: place_picker/places_table
// file:   ../../place_picker/js/places_table.js
define("place_picker/places_table", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core  = require('bolt/core');
var util  = require('bolt/util');

var View = require('bolt_touch/view').View;
var TV            = require('bolt_touch/views/table_view');
var TableView     = TV.TableView;
var TableViewCell = TV.TableViewCell;
var LocationManager = require('./location_manager');
var api_xhr       = require('shared/api_xhr');

var FetchMoreCell = core.createClass({
  name: 'FetchMoreCell',

  extend: TableViewCell,

  LOADING_MORE: 'Loading...',
  FETCH_MORE: 'More nearby places...',
  NO_MORE: 'No more nearby places.',

  declare: function(options) {
    return {
      childViews: [
        {
          ref: 'text',
          additionalClasses: 'bt-fetch-more'
        }
      ]
    };
  },

  setLoading: function(loading) {
    var text = this.refs.text;
    if (loading) {
      text.setContent(this.LOADING_MORE);
      text.setMode('data', 'loading');
    } else {
      text.setMode('data', 'noloading');
    }
  },

  setMore: function(hasMore) {
    var text = this.refs.text;
    if (!text) {
      return;
    }
    text.setContent(hasMore ? this.FETCH_MORE : this.NO_MORE);
    if (!hasMore) {
      text.setMode('data', 'nomore');
    }
  }
});


var PlaceCell = core.createClass({
  name: 'PlaceCell',

  extend: TableViewCell,

  declare: function(options) {
    return {
      additionalClasses: 'bt-place-cell',
      boxOrientation: 'horizontal',
      childViews: [
        {
          ref: 'textWrapper',
          additionalClasses: 'bt-text-wrapper',
          childViews: [
            {
              ref: 'text',
              additionalClasses: 'bt-text',
              boxOrientation: 'vertical',
              childViews: [
                {
                  ref: 'name',
                  additionalClasses: 'bt-name'
                },
                {
                  ref: 'description',
                  additionalClasses: 'bt-description'
                }
              ]
            },
            { ref: 'overlay', additionalClasses: 'bt-row-overlay'}
          ]
        }
      ]
    };
  },

  setPlace: function(place) {
    this.place = place;

    var placeName = place.name.trim();
    this.refs.name.setContent(placeName);
    var placeDescription = place.description.trim();
    this.refs.description.setContent(placeDescription);
  }
});

var PlacesTable = exports.PlacesTable = core.createClass({
  name: 'PlacesTable',

  extend: View,

  properties: {
    customOverlayText: null,
    callback: null,
    filterRegex: null,
    placesPerPage: 20,
    searchRadiusMeters: 750,
    location: null,
    city: null,
    clearPlace: false
  },

  declare: function(options) {
    return {
      boxOrientation: 'vertical',
      childViews: [
        {
          view: 'TableView',
          ref: 'table',
          sectioned: false,
          flex: 1,
          bufferSize: 4
        },
        {
          ref: 'overlay',
          additionalClasses: 'bt-overlay',
          childViews: [
            {
              ref: 'overlayText',
              additionalClasses: 'bt-overlay-text'
            },
            {
              additionalClasses: 'bt-overlay-x',
              content: '', /* u+00d7 */
              onclick: 'hideOverlay'
            }
          ]
        }
      ]
    };
  },

  ready: function() {
    this.table = this.findRef('table');

    this.loading = false;
    this.hasMoreData = true;
    this.places = [];
    this.data = [];
    this.offset = 0;
    this.resetFilterRegex();

    this.locationManager = LocationManager.getLocationManager();
  },

  show: function(customOverlayText) {
    this.setClearPlace(false);

    if (customOverlayText) {
      this.showOverlay();
      this.setCustomOverlayText(customOverlayText);
    } else {
      this.hideOverlay();
    }
    if (customOverlayText) {
      this.refs.overlayText.setContent(customOverlayText);
    }

    this.locationManager.getLocation(util.bind(function(location) {
      if (location != this.getLocation()) {
        this.setLocation(location);
        this.refresh();
      } else if (this.places.length === 0 && this.hasMoreData) {
        // if table is empty we should fill it with stuff
        this.refresh();
      }
    }, this));
  },

  // refreshes the place picker, fetching new places from the current location
  // this usses the currently known location to refresh the table with
  refresh: function() {
    // reset data
    this.places = [];
    this.data = [];
    this.offset = 0;
    this.resetFilterRegex();

    // clear the table, then fill it with new data
    this.table.refresh();
    this.fetchMore();

    if (!this.getCustomOverlayText()) {
      this.locationManager.getCity(util.bind(function(city) {
        if (city) {
          this.refs.overlayText.setContent(city.name);
        }
      }, this));
    }

    return true;
  },

  fetchMore: function() {
    if (this.loading) return;
    if (!this.getLocation()) return;

    // preliminary UI stuff
    this.loading = true;
    this.fetchMoreCell.setLoading(true);

    // fetch coordinates and do stuff with it
    var coordinates = this.getLocation().coords;
    var lat = coordinates.latitude;
    var lon = coordinates.longitude;
    var accuracy = coordinates.accuracy;

    var limit = this.getPlacesPerPage();

    // TODO is accuracy being used properly?
    var distance = 'distance(latitude, longitude, "' +
      lat + '", "' + lon + '", "' + accuracy + '")';

    var radius = this.getSearchRadiusMeters();
    var query = 'SELECT page_id, name, description, latitude, longitude, ' +
      'checkin_count, display_subtext, ' + distance + ' FROM place' +
      ' WHERE ' + distance + ' < ' + radius +
      // ' ORDER BY ' + distance +
      ' LIMIT ' + limit + ' OFFSET ' + this.offset;

    api_xhr.fql(query).addCallback(function(response) {
      this.hasMoreData = !!response.length;
      this.loading = false;
      this.offset += response.length;
      this.places = this.places.concat(response);
      this.prepareData();
      this.table.refresh();
    }, this);
  },

  resetFilterRegex: function() {
    this.setFilterRegex(null);
  },

  setFilterRegex: function(regex) {
    this.set('filterRegex', regex);
    this.prepareData();
    this.table.refresh();
  },

  // generate this.data by running places through the regex filter
  prepareData: function() {
    var filter = this.getFilterRegex();
    if (!filter) {
      this.data = this.places;
    } else {
      this.data = [];
      util.each(this.places, function(place) {
        if (place && place.name) {
          var name = place.name.trim();
          if (filter.test(name)) {
            this.data.push(place);
          }
        }
      }, this);
    }
  },

  numberOfRowsInSection: function(tableView, section) {
    // 2 extra cells:
    //     FetchMoreCell that allows user to load more nearby places
    //     empty cell to fit underneath the city overlay
    return this.data.length + 2;
  },

  heightForRowInSection: function(tableView, row, section) {
    if (row === this.data.length + 1) {
      return 50;
    } else if (row === this.data.length) {
      return 88;
    } else {
      return 64;
    }
  },

  cellForRowInSection: function(tableView, row, section) {
    var cell;
    if (row === this.data.length + 1) {
      cell = tableView.dequeueReusableCellWithIdentifier('empty_cell');
      if (!cell) {
        cell = new TableViewCell({
          reuseIdentifier: 'empty_cell',
          additionalClasses: 'bt-empty-cell'
        });
      }
    } else if (row === this.data.length) {
      cell = tableView.dequeueReusableCellWithIdentifier('fetch_more_cell');
      if (!cell) {
        cell = new FetchMoreCell({reuseIdentifier: 'fetch_more_cell'});
      }
      cell.setMore(this.hasMoreData);
      cell.setLoading(this.loading);
      this.fetchMoreCell = cell;
    } else {
      cell = tableView.dequeueReusableCellWithIdentifier('place_cell');
      if (!cell) {
        cell = new PlaceCell({reuseIdentifier: 'place_cell'});
      }
      cell.setPlace(this.data[row]);
    }
    return cell;
  },

  cellSelectedAtRowInSection: function(tableView, row, section, cell) {
    if (row === this.data.length + 1) {
      // empty cell
    } else if (row === this.data.length) {
      if (this.hasMoreData && !this.loading) {
        this.fetchMore();
      } else {
        cell.setSelected(false);
      }
    } else {
      var callback = this.getCallback();
      if (callback) {
        callback(cell.place);
      } else {
        cell.setSelected(false);
      }
    }
  },

  hideOverlay: function() {
    this.setClearPlace(true);
    this.refs.overlay.hide();
  },

  showOverlay: function() {
    this.refs.overlay.show();
  }
});
});

// module: bolt_touch/vendor/jvelocity_estimator
// file:   ../../../frameworks/bolt_touch/lib/vendor/jvelocity_estimator.js
define("bolt_touch/vendor/jvelocity_estimator", function(require, exports, module) {
// Copyright 2011 Facebook, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.


/*
  JVelocityEstimator
  Author: Jonathan Kaldor (jmkaldor@fb.com)

  Given samples of positions at specific times, computes an estimate of the
  velocity at the requested time.  Uses a weighted filtered least squares
  solver
*/
function JVelocityEstimator(options) {
  this.options = {};

  // variables used for estimating velocity of flick from
  // a set of past samples.  Uses weighted least squares, so the
  // weights correspond to the importance of samples, from most
  // recent to least recent.
  this.options.sampleWeights = [1, 1, 1, 1, 1, 1, 1, 1];

  // Variables used to control the velocity estimator.  The times
  // that samples are recorded can be smoothed out (0: no smoothing ...
  // 1: times are evenly spaced through the interval), the velocity samples
  // can be smoothed (0: no smoothing ... 1: all samples are the average velocity)
  // and a maximum bound (in ms) can be set to exclude any samples which
  // occurred farther in the past than the bound
  this.options.timeSmoothingFilter = 0.3;
  this.options.posSmoothingFilter = 0.7;
  this.options.maxTimeInterval = 100;

  this.options.maxVelocity = 8000;

  for (var i in options) {
    this.options[i] = options[i];
  }

  this.posStartSamples = [];
  this.posEndSamples = [];
  this.timeStartSamples = [];
  this.timeEndSamples = [];

  for (var i = 0; i < this.options.sampleWeights.length; ++i) {
    this.posStartSamples[i] = 0;
    this.posEndSamples[i] = 0;
    this.timeStartSamples[i] = 0;
    this.timeEndSamples[i] = 0;
  }

  this.currentIndex = 0;
}

// Add a sample point to the velocity estimator.  This consists of a
// start and end position and the times they were recorded
JVelocityEstimator.prototype.addSample = function(posStart, timeStart, posEnd, timeEnd) {
  this.currentIndex = (this.currentIndex + 1) % this.options.sampleWeights.length;
  this.posStartSamples[this.currentIndex] = posStart;
  this.posEndSamples[this.currentIndex] = posEnd;
  this.timeStartSamples[this.currentIndex] = timeStart;
  this.timeEndSamples[this.currentIndex] = timeEnd;
}

// Set the first position for incremental sampling.  This allows
// position samples to be streamed in without having to track the deltas
JVelocityEstimator.prototype.setStartPositionSample = function(pos, time) {
  var nextIndex = (this.currentIndex + 1) % this.options.sampleWeights.length;
  this.posStartSamples[nextIndex] = pos;
  this.timeStartSamples[nextIndex] = time;
  // The end time is used to determine if this sample is valid.  Make sure to mark
  // it as invalid since it is not yet complete
  this.posEndSamples[nextIndex] = 0;
  this.timeEndSamples[nextIndex] = 0;
}

// Add a subsequent position for incremental sampling.  There must have
// been a previous call to setStartPositionSample or addPositionSample, the
// last of which will be used as the start position for the sample generated
// (the end position will be the position passed in to this function)
JVelocityEstimator.prototype.addPositionSample = function(pos, time) {
  this.currentIndex = (this.currentIndex + 1) % this.options.sampleWeights.length;
  this.posEndSamples[this.currentIndex] = pos;
  this.timeEndSamples[this.currentIndex] = time;
  this.setStartPositionSample(pos, time);
}

// Invalidate all samples added to the estimator.  Any samples added before
// this call will be ignored.  Time should be in milliseconds, pos can be
// in any units desired
JVelocityEstimator.prototype.invalidate = function(pos, time) {
  this.addSample(0, 0, 0, 0);
}

// Compute an estimate of the velocity at a specified time given the
// samples which have been added.  Only uses samples that are within
// a given range of the specified time 
JVelocityEstimator.prototype.estimate = function(time) {
  var totalSamples = this.options.sampleWeights.length;
  var timeStart = this.timeStartSamples;
  var timeEnd = this.timeEndSamples;
  var posStart = this.posStartSamples;
  var posEnd = this.posEndSamples;
  var weights = this.options.sampleWeights;
  var maxTimeInterval = this.options.maxTimeInterval;
  var timeSmoothingFilter = this.options.timeSmoothingFilter;
  var posSmoothingFilter = this.options.posSmoothingFilter;
  
  var numSamples = 0;
  // m21 == m12, since the matrix is symmetric
  var m11 = 0, m12 = 0, m22 = 0;
  var b1 = 0, b2 = 0;
  var vel = 0;
  // Store our first sample in case it's the only good sample -- it will
  // be our velocity estimate
  var firstSample;
  var currItem = this.currentIndex;

  if (timeStart[currItem] > 0 && timeEnd[currItem] - timeStart[currItem] > 0) {
    firstSample = (posEnd[currItem] - posStart[currItem]) * 1000 / (timeEnd[currItem] - timeStart[currItem]);
  }

  var maxTimeSample = 0;
  var avgVelSample = 0;
  // Figure out the time value of the maximum sample we're going to use, since
  // we're going to smooth over that range
  for (var i = 0; i < totalSamples; ++i) {
    var localItem = (currItem - i < 0 ? currItem - i + totalSamples : currItem - i);
    var localT = timeEnd[localItem] - time;

    if (timeEnd[localItem] <= 0 || Math.abs(localT) > maxTimeInterval || timeStart[localItem] <= 0) {
      // Only use velocity estimates recorded in the specified interval.
      // Since our times are in chronological order, we can break here
      break;
    }
    numSamples++;
    maxTimeSample = -localT;
    avgVelSample = avgVelSample + posEnd[localItem] - posStart[localItem];
  }
  avgVelSample = (numSamples > 0 ? avgVelSample / numSamples : 0);

  for (var i = 0; i < totalSamples; ++i) {
    if (i >= numSamples) {
      break;
    }
    var localItem = (currItem - i < 0 ? currItem - i + totalSamples : currItem - i);
    var localT = timeEnd[localItem] - time;
    var nextLocalT = timeStart[localItem] - time;
    var posDelta = posEnd[localItem] - posStart[localItem];
    var filteredT = (1 - timeSmoothingFilter)*localT + timeSmoothingFilter*(-i*maxTimeSample)/(numSamples-1);
    var filteredDeltaT = Math.max((1 - timeSmoothingFilter)*(localT - nextLocalT) + timeSmoothingFilter*maxTimeSample/(numSamples-1), 1);
    // times are in ms, so convert into seconds
    var filteredVel = (1 - posSmoothingFilter)*posDelta + posSmoothingFilter*avgVelSample;
    var velSample = 1000*filteredVel / filteredDeltaT;

    // Update the weighted least squares matrix
    m11 = m11 + weights[i]*filteredT*filteredT;
    m12 = m12 + weights[i]*filteredT;
    m22 = m22 + weights[i]*1;
    b1 = b1 + weights[i]*filteredT*velSample;
    b2 = b2 + weights[i]*velSample;
  }

  if (numSamples == 0) {
    // We have no usable velocity samples at all.  Either the user
    // hasn't moved their finger in some time, or they're quick like
    // a ninja and we missed everything.  In either case, set the
    // velocity to 0 so we can still animate if we're beyond the boundary --
    // only the ninjas will be disappointed
    vel = 0;
  } else if (numSamples == 1) {
    // We only got one velocity sample.  Just use that as the estimated
    // velocity (we're not liable to get anything better).
    // Note: this must be the first sample, since they're sorted by
    // time and inserted in the front, so if any sample is valid the
    // first must be valid
    vel = firstSample;
  } else {
    // We have enough samples to estimate a linear function to fit
    // and then compute the predicted velocity now when we've released
    // it.  Do that.

    // We've already constructed our weighted least squares problem.
    // Compute M^{-1} b
    var det = m11*m22 - m12*m12;
    if (det == 0) {
      // Our matrix isn't invertible.  Realistically, this shouldn't
      // happen by this point, unless we managed to record some rather
      // crazy velocities.  In any case, just set it to the last valid
      // sample
      vel = firstSample;
    } else {
      // Because we're computing the linear function around the current
      // time, the function evaluated at 0 is the estimated time we want.
      // This means we actually just need to compute the constant factor,
      // which is the second component of M^{-1} b

      vel = (1/det) * (-m12*b1 + m11*b2);
    }
  }
  vel = Math.max(Math.min(vel, this.options.maxVelocity), -this.options.maxVelocity);
  return vel;
}

if (typeof exports !== 'undefined') {
  exports.jVelocityEstimator = JVelocityEstimator;
}});

// module: bolt_touch/views/carousel/index
// file:   ../../../frameworks/bolt_touch/lib/views/carousel/index.js
define("bolt_touch/views/carousel/index", function(require, exports, module) {
var core        = require('bolt/core');
var util        = require('bolt/util');
var View        = require('bolt_touch/view').View;
var ScrollView  = require('bolt_touch/views/scroll_view_j').ScrollView;
var ViewManager = require('bolt_touch/views/data_list/view_manager').ViewManager;

/**
 * @classdesc Carousel component that can be used to display a collection of
 * views such that views are snapped into the viewport as you scroll through
 * the colleciton.
 *
 * Owner API:
 *  carouselCreateView(model)
 *    Creates a view for the given model.
 *    @param {object} model
 *
 *  carouselWillNavigateTo(page)
 *    Called as soon as it's known which page will be scrolled to.
 *    @param {number} page Current page
 *
 *  carouselDidNavigateTo(view, page)
 *    Called after the scroll change is complete.
 *    @param {object} view Current view
 *    @param {number} page Current page
 */
var Carousel = exports.Carousel = core.createClass({
  name: 'Carousel',

  extend: View,

  construct: function(options) {
    this._views = [];

    this._viewManager = new ViewManager({
      createView: util.bind(function(model) {
        var view = this.getOwner().carouselCreateView(model);

        this.refs.scrollView.appendChild(view);

        if (!this._scrollViewHeight) {
          this._scrollViewHeight = this.refs.scrollView.getNode().clientHeight;
        }

        this._widthOffset = (view.getNode().offsetWidth - view.getNode().clientWidth);
        this._heightOffset = (view.getNode().offsetHeight - view.getNode().clientHeight);

        view.setStyle({
          position: 'absolute',
          width: (this._scrollViewWidth - this._widthOffset) + 'px',
          height: (this._scrollViewHeight - this._heightOffset) + 'px'
        });

        this._views.push(view);

        return view;
      }, this),

      updateView: function(view, model) {
        return view.setModel(model);
      }
    });

    this._onResize = util.bind(this._onResize, this);
    window.addEventListener('resize', this._onResize);

    View.call(this, options);
  },

  declare: function(options) {
    return {
      className: 'bt-no-text-select',
      childViews: [
        {
          view: ScrollView,
          ref: 'scrollView',
          flex: 1,
          snap: true,
          vScroll: false,
          hScroll: true,
          useScrollbar: false
        }
      ]
    };
  },

  ready: function(options) {
    this.refs.scrollView.onDocumentInsertion = util.bind(function() {
      ScrollView.prototype.onDocumentInsertion.call(this.refs.scrollView);

      this._readyToLoad = true;
      this._scrollViewWidth = this.getNode().clientWidth;
      this._scrollViewHeight = this.getNode().clientHeight;

      if (this._collection) {
        this._refresh(this._startingPage);
      }
    }, this);
  },

  destroy: function() {
    if (this._collection) {
      this._collection.removeListener('all', this._onCollectionEvent, this);
    }
    this._collection = null;
    this._views = null;
    this._viewManager.destroy();
    window.removeEventListener('resize', this._onResize);
    View.prototype.destroy.call(this);
  },

  /**
   * Loads the carousel using the collection, showing the starting page.
   * If the carousel hasn't been added to the document yet, it will wait
   * until then to load.
   * @param {object} collection
   * @param {number} startingPage
   */
  load: function(collection, startingPage) {
    this._collection = collection;
    this._collection.addListener('all', this._onCollectionEvent, this);
    this._startingPage = startingPage || 0;

    if (this._readyToLoad) {
      this._refresh(this._startingPage);
    }
  },

  /**
   * Returns the current page.
   */
  getCurrentPage: function() {
    return this._currentPage;
  },

  /**
   * Returns the previous view (null if there isn't one)
   */
  getPreviousView: function() {
    return this._previousView;
  },

  /**
   * Returns the current view (null if there isn't one)
   */
  getCurrentView: function() {
    return this._currentView;
  },

  /**
   * Returns the next view (null if there isn't one)
   */
  getNextView: function() {
    return this._nextView;
  },

  /**
   * Navigate to the desired index, if possible.
   * @param {number} page
   */
  navigateTo: function(page) {
    if (this._isPageValid(page)) {
      this.refs.scrollView.scrollToPageX(page);
    }
  },

  /**
   * Navigate to the previous view, if possible.
   */
  navigateToPrevious: function() {
    this.navigateTo(this._currentPage - 1);
  },

  /**
   * Navigate to the next view, if possible.
   */
  navigateToNext: function() {
    this.navigateTo(this._currentPage + 1);
  },

  _refresh: function(page) {
    this._previousView = this._updateView(this._previousView, page - 1);
    this._currentView = this._updateView(this._currentView, page);
    this._nextView = this._updateView(this._nextView, page + 1);

    // Note: We set the width/height after we create the views because
    // the scrollViewHeight may get set during that process.
    this.refs.scrollView._scroller.setStyle({
      width: (this._scrollViewWidth * this._collection.length) + 'px',
      height: (this._scrollViewHeight) + 'px'
    });
    this.refs.scrollView.refresh();

    // Note: We want to "forget" the current page to force the scroll
    // callbacks to get fired.
    this._currentPage = null;
    this.navigateTo(page);
  },

  _onCollectionEvent: function(e) {
    if (this._readyToLoad && (e.type === 'modelAdded' || e.type === 'modelRemoved')) {
      var currentModel = this._currentView.get('model');
      for (var page = 0; page < this._collection.length; page++) {
        if (currentModel === this._collection.at(page)) {
          break;
        }
      }
      if (page == this._collection.length) {
        page = Math.min(this._currentPage, this._collection.length - 1);
      }

      this._refresh(page);
    }
  },

  _onResize: function() {
    if (this._collection && this._readyToLoad) {
      var w = this.getNode().clientWidth;
      var h = this.getNode().clientHeight;

      if (this._scrollViewWidth === w && this._scrollViewHeight === h) {
        // If the size hasn't changed, do nothing
        return;
      }
      this._scrollViewWidth = w;
      this._scrollViewHeight = h;

      if (this._scrollViewWidth !== 0 && this._scrollViewHeight !== 0) {
        for (var i = 0; i < this._views.length; i++) {
          var view = this._views[i];
          view.setStyle({
            width: (this._scrollViewWidth - this._widthOffset) + 'px',
            height: (this._scrollViewHeight - this._heightOffset) + 'px'
          });
        }

        this._refresh(this._currentPage);
      }
    }
  },

  _updateView: function(view, page) {
    var model = this._collection.at(page);

    if (model) {
      this._releaseView(view);
      return this._fetchView(page);
    }
    else {
      this._releaseView(view);
      return null;
    }
  },

  _fetchView: function(page) {
    var model = this._collection.at(page);

    if (model) {
      var view = this._viewManager.acquire(model);
      view.removeClass('hidden');
      view.setStyle({
        webkitTransform: 'translate3d(' + (page * this._scrollViewWidth) + 'px, 0px, 0px)'
      });

      return view;
    }
    else {
      return null;
    }
  },

  _releaseView: function(view) {
    if (view) {
      view.addClass('hidden');
      this._viewManager.release(view);
    }
  },

  _isPageValid: function(page) {
    return (page >= 0 && page < this._collection.length);
  },

  // ScrollView owner
  willScrollToAnimated: function(x, y, page) {
    if (page !== this._currentPage) {
      this.getOwner().carouselWillNavigateTo &&
        this.getOwner().carouselWillNavigateTo(page);
    }


    // TODO: The following code should go inside of didScrollTo
    // once jScroll fires the correct page for quick swipes.
    // --------------------------------------------------------

    //var page = this.refs.scrollView.getPageXNum();

    if (page !== this._currentPage) {
      if (this._currentPage !== null && page === this._currentPage - 1) { // Previous
        this._releaseView(this._nextView);

        this._nextView = this._currentView;
        this._currentView = this._previousView;
        this._previousView = this._fetchView(page - 1);;
      }
      else if (this._currentPage !== null && page === this._currentPage + 1) { // Next
        this._releaseView(this._previousView);

        this._previousView = this._currentView;
        this._currentView = this._nextView;
        this._nextView = this._fetchView(page + 1);
      }
      else {
        this._previousView = this._updateView(this._previousView, page - 1);
        this._currentView = this._updateView(this._currentView, page);
        this._nextView = this._updateView(this._nextView, page + 1);
      }

      this._currentPage = page;

      this.getOwner().carouselDidNavigateTo &&
        this.getOwner().carouselDidNavigateTo(this._currentView, page);
    }
  },

  // ScrollView owner
  didScrollTo: function() {

  }
});
});

// module: photos/app/lib/view/photo_carousel/index
// file:   ../../photos/app/lib/view/photo_carousel/index.js
define("photos/app/lib/view/photo_carousel/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core           = require('bolt/core');
var View           = require('bolt_touch/view').View;
var Carousel       = require('bolt_touch/views/carousel').Carousel;
var ImageQueue     = require('bolt_touch/util/image_queue');
var ActionSheet    = require('bolt_touch/views/action_sheet').ActionSheet;
var Actionable     = require('bolt_touch/mixins/actionable').Actionable;
var ActionableView = require('bolt_touch/views/actionable_view').ActionableView;
var PhotoView      = require('../photo_view').PhotoView;
var Checkbox       = require('../checkbox').Checkbox;

/**
 * A Carousel that shows images, using Photo models retrieved from Facebook
 * photo APIs.
 */
exports.PhotoCarousel = core.createClass({
  name: 'PhotoCarousel',

  extend: View,

  events: ['photoSelected', 'photoTouched', 'closed', 'tagSelected'],

  mixins: [Actionable],

  properties: {
    title: null,
    photos: null,
    showingTags: false,
    startingIndex: 0,
    selectable: false
  },

  declare: function() {
    return {
      boxOrientation: 'vertical',
      flex: 1,
      childViews: [
        {
          ref: 'header',
          className: 'header',
          childViews: [
            {
              className: 'top-gradient'
            },
            {
              view: ActionableView,
              ref: 'actionButton',
              className: 'action-button',
              action: '_showActions'
            },
            {
              className: 'title-group',
              boxOrientation: 'horizontal',
              childViews: [
                {
                  ref: 'title',
                  className: 'title'
                },
                {
                  ref: 'separator',
                  className: 'separator'
                },
                {
                  ref: 'pageCount',
                  className: 'pageCount'
                }
              ]
            },
            {
              view: Checkbox,
              ref: 'checkbox'
            }
          ]
        },
        {
          view: Carousel,
          ref: 'carousel'
        }
      ]
    };
  },

  ready: function() {
    // Note: setContent is not being used because it'll display the
    // string "&middot;"
    this.refs.separator.getNode().innerHTML = '&middot;';

    this.refs.checkbox.addListener(
      'selectionChanged',
      this._selectionChanged,
      this
    );

    this.refs.title.hide();
  },

  destroy: function() {
    View.prototype.destroy.call(this);

    if (this.get('photos')) {
      this.get('photos').removeListener('all', this._onPhotosUpdate, this);
    }
    this.set('photos', null);

    ImageQueue.removeByTag('PhotoView');
  },

  setTitle: function(title) {
    this.set('title', title);
    this.refs.title.setContent(title);
    this.refs.title.toggle(title);
    this._showSeparatorIfNeeded();
  },

  load: function() {
    // HACK: Temporary fix to jScroll bug
    if (this.refs.carousel.refs.scrollView._jScroll) {
      this.refs.carousel.refs.scrollView._jScroll.modelX.enabled(true);
    }

    // Only show the checkbox if we're selectable
    this.refs.checkbox.toggle(this.get('selectable'));

    this.refs.carousel.load(this.get('photos'), this.get('startingIndex'));
    this.get('photos').listen('all', this._onPhotosUpdate, this);
  },

  navigateTo: function(page) {
    // HACK: Temporary fix to jScroll bug
    if (this.refs.carousel.refs.scrollView._jScroll) {
      this.refs.carousel.refs.scrollView._jScroll.modelX.enabled(true);
    }

    this.refs.carousel.navigateTo(page);
  },

  show: function() {
    this.removeClass('hidden');
  },

  hide: function() {
    this.addClass('hidden');
  },

  // Carousel owner
  carouselCreateView: function(model) {
    var view = new PhotoView({model: model});
    view.addListener('photoTouched', this._photoTouched, this);
    view.addListener('photoTagTouched', this._onTagTouched, this);
    view.addListener('photoTagDeleteTouched', this._onDeleteTagTouched, this);

    return view;
  },

  // Carousel owner
  carouselWillNavigateTo: function(page) {
    this._currentIndex = page;
    var photo = this.get('photos').at(this._currentIndex);

    this._updatePageCount();

    if (this.get('selectable')) {
      this.refs.checkbox.setSelected(photo.get('selected'));
    }

    this.invoke('photoSelected', {
      photo: this.get('photos').at(page)
    });
  },

  // Carousel owner
  carouselDidNavigateTo: function() {
    var views = this._getCarouselViews();
    views.forEach(this._showPhoto);

    if (this.getShowingTags()) {
      this.showPhotoTags();
    } else {
      this.hidePhotoTags();
    }
  },

  _showPhoto: function(view) {
    view.showPhoto();
  },

  doAction: function() {
    // #EventCompatibilityHack
    // The one side effect here is that you won't be able to dismiss the
    // carousel by clicking the header. That's fine for now.
    //this._notifyTouched();
  },

  _selectionChanged: function(evt) {
    this.get('photos').at(this._currentIndex)
      .set('selected', evt.data.selected);
  },

  _photoTouched: function(evt) {
    this._notifyTouched(evt.data);
  },

  _notifyTouched: function(data) {
    this.invoke('photoTouched', {
      percentX: data.percentX,
      percentY: data.percentY,
      photo: this.get('photos').at(this._currentIndex),
      index: this._currentIndex
    });
  },

  _onTagTouched: function(evt) {
    var data = evt.data;
    var view = data.view;
    view.toggleDeleteButton();

    this.invoke('tagTouched', evt.data);
  },

  _onDeleteTagTouched: function(evt) {
    var tag = evt.data.photo_tag;
    var photo = evt.data.photo || this.get('photos').at(this._currentIndex);

    var guesses = tag.get('guesses');
    var view = evt.data.view;
    if (guesses && guesses.length > 0) {
      tag.set('id', -1);
      tag.set('text', 'Who is this?');
      photo.save();
      view.update();
    } else {
      photo.removeTag(tag);
      view.destroy();
    }

  },

  _onPhotosUpdate: function() {
    this._updatePageCount();

    // TODO: Can we do this in didNavigateTo?
    if (this.get('photos').length === 0) {
      this.invoke('closed');
    }
  },

  _updatePageCount: function() {
    if (this.get('photos').length > 1) {
      this.refs.pageCount.setContent(
        (this._currentIndex + 1) + ' of ' + this.get('photos').length);
      this.refs.pageCount.show();
    }
    else {
      this.refs.pageCount.hide();
    }

    this._showSeparatorIfNeeded();
  },

  _showSeparatorIfNeeded: function() {
    this.refs.separator.toggle(
      this.refs.title.getIsDisplayed() && this.refs.pageCount.getIsDisplayed());
  },

  _showActions: function() {
    var showMenu = true;
    if (this._actionSheet && this._actionSheet.getMode('state') === 'visible') {
      this._actionSheet.hide();
      showMenu = false;
    }
    if (this._deleteActionSheet &&
        this._deleteActionSheet.getMode('state') === 'visible') {
      this._deleteActionSheet.hide();
      showMenu = false;
    }
    if (!showMenu) {
      return;
    }

    var actions = [
      {
        value: 'Delete',
        additionalClasses: 'bt-destroy',
        action: '_showDeleteWarning'
      },
      {
        value: this.getShowingTags() ? 'Hide Tags' : 'Show Tags',
        action: '_toggleTags'
      },
      {
        value: 'Cancel',
        additionalClasses: 'bt-cancel'
      }
    ];

    this._actionSheet = this.build({
      view: ActionSheet,
      destroyOnHide: true,
      hasScrim: true,
      additionalClasses: 'fb-action-sheet',
      actions: actions
    });
    this._actionSheet.show();
  },

  _showDeleteWarning: function() {
    this._deleteActionSheet = this.build({
      view: ActionSheet,
      destroyOnHide: true,
      hasScrim: true,
      additionalClasses: 'fb-action-sheet',
      actions: [
        {
          value: 'Yes, delete this photo',
          additionalClasses: 'bt-destroy',
          action: 'confirmDeletePhoto'
        },
        {
          value: 'Cancel',
          additionalClasses: 'bt-cancel'
        }
      ]
    });
    this._deleteActionSheet.show();
  },

  showPhotoTags: function() {
    this.setShowingTags(true);
    var views = this._getCarouselViews();
    views.forEach(this._showTags);
  },

  _showTags: function(view) {
    view.showTags();
  },

  hidePhotoTags: function() {
    this.setShowingTags(false);
    var views = this._getCarouselViews();
    views.forEach(this._hideTags);
  },

  _hideTags: function(view) {
    view.hideTags();
  },

  _getCarouselViews: function() {
    var views = [];
    var carousel = this.refs.carousel;

    if (carousel.getPreviousView()) {
      views.push(carousel.getPreviousView());
    }
    if (carousel.getNextView()) {
      views.push(carousel.getNextView());
    }
    if (carousel.getCurrentView()) {
      views.push(carousel.getCurrentView());
    }

    return views;
  },

  _toggleTags: function() {
    if (!this.getShowingTags()) {
      this.showPhotoTags();
    } else {
      this.hidePhotoTags();
    }
  },

  confirmDeletePhoto: function() {
    this.get('photos').at(this._currentIndex).delete();
  }
});
});

// module: contacts/shared/ui/contacts_table_model
// file:   contacts/shared/ui/contacts_table_model.js
define("contacts/shared/ui/contacts_table_model", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

//The following are not actually global, but local, defined underneath
//for readability

/*global sortByName: true */
/*global undefined: true */
/*global ReplaceSnapshotTransaction: true */

var Announcer = require('../../util/announcer').Announcer;
var util = require('bolt/util');

var SECTION_HEADER_CHANGED    = 1;
var SNAPSHOT_SWITCHED_SECTION = 2;
var SNAPSHOT_DID_NOT_MOVE     = 3;

var ImageQueue = require('bolt_touch/util/image_queue');

var ContactsTableModel = function(headerFactory, cellFactory) {
  this._active = false;
  this._headerViewFactory = headerFactory;
  this._cellViewFactory = cellFactory;
  this._announcer = new Announcer();
  this._snapshots = [];
  this._cache = {};
};

ContactsTableModel.prototype = {
  setCellFactory: function(factory) {
    this._cellViewFactory = factory;
  },

  setHeaderFactory: function(factory) {
    this._headerViewFactory = factory;
  },

  numberOfSections: function() {
    return this._letters().length;
  },

  addTableModelListener: function(listener) {
    this._announcer.addListener(listener);
  },

  activate: function() {
    this._active = true;
    this._announce('refresh');
  },

  _announce: function() {
    if (this._active) {
      this._announcer.announce.apply(this._announcer, arguments);
    }
  },

  contactAdded: function(contact) {
    this._flushCache();
    contact.addEventListener(this);
    var snapshot = contact.snapshot();
    this._snapshots.push(snapshot);
    if (this._didAddNewSectionWith(snapshot)) {
      this._announce('refresh');
    } else {
      this._announce('insertRowInSection',
                       this._rowFor(snapshot),
                       this._sectionFor(snapshot));
    }
  },

  contactsAdded: function(contacts) {
    this._flushCache();
    for (var i = 0; i < contacts.length; i++) {
      var contact = contacts[i];
      contact.addEventListener(this);
      this._snapshots.push(contact.snapshot());
    }
    //This is nieve, and we can prolly do better
    this._announce('refresh');
  },

  contactDeleted: function(snapshot) {
    this._flushCache();
    this._removeSnapshot(snapshot);
    //this should prolly only notify the table view of the change of the single
    //contact, postponing doing this to get cert tasks done
    this._announce('refresh');
  },

  allContactsRemoved: function() {
    this._flushCache();
    this._snapshots = [];
    this._announce('refresh');
  },

  contactsLoaded: function(contacts) {
    this._flushCache();
    var self = this;
    contacts.forEach(function(contact) {
      contact.addEventListener(self);
      self._snapshots.push(contact.snapshot());
    });
    this._announce('refresh');
  },

  contactStateChanged: function(snapshot) {
    this._flushCache();
    var transaction = new ReplaceSnapshotTransaction(this);
    transaction.replaceSnapshot(snapshot);
    switch (transaction.getType()) {
      case SECTION_HEADER_CHANGED:
        //this is just refreshing for now because the table view can not handle
        //inserting or removing section headers manually
        this._announce('refresh');
        break;
      case SNAPSHOT_SWITCHED_SECTION:
        this._announce('removeRowInSection',
                         transaction.initialRow(),
                         transaction.initialSection());
        this._announce('insertRowInSection',
                         transaction.finalRow(),
                         transaction.finalSection());
        break;
      case SNAPSHOT_DID_NOT_MOVE:
        this._announce('reloadRowInSection',
                         transaction.finalRow(),
                         transaction.finalSection());
        break;
    }
  },

  filterByName: function(filterTerm) {
    this._flushCache();
    this._filter = function(snapshot) {
      var firstName = snapshot.firstName.toUpperCase();
      return firstName.indexOf(filterTerm.toUpperCase()) !== -1;
    };
    this._announce('refresh');
  },

  clearFilter: function() {
    this._flushCache();
    this._filter = undefined;
    this._announce('refresh');
  },

  numberOfRowsInSection: function(table, section) {
    return this._snapshotsInSectionNumber(section).length;
  },

  cellForRowInSection: function(table, row, section) {
    return this._cellViewFactory.buildViewFor(
      this._snapshotsInSectionNumber(section)[row]);
  },

  viewForHeaderInSection: function(table, section, header) {
    var letterForSection = this._letterForSection(section);
    return this._headerViewFactory.buildViewFor(letterForSection);
  },

  _flushCache: function() {
    this._cache = {};
  },

  _didAddNewSectionWith: function(snapshot) {
    var snapshots = this._snapshotsInSectionNumber(this._sectionFor(snapshot));
    return snapshots.length === 1;
  },

  _letters: function() {
    if (this._cache.letters) {
      return this._cache.letters;
    } else {
      var snapshots = this._filteredSnapshots();
      this._cache.letters = util.unique(snapshots.map(this._letterForSnapshot))
                                .sort();
      return this._cache.letters;
    }
  },

  _removeSnapshot: function(removedSnapshot) {
    this._snapshots = util.compact(this._snapshots.map(function(snapshot) {
      return snapshot.isForTheSameContact(removedSnapshot) ? null : snapshot;
    }));
  },

  _filteredSnapshots: function() {
    if (this._cache.filteredSnapshots) {
      return this._cache.filteredSnapshots;
    } else {
      var filter = this._filter;
      var snapshots = filter ? this._snapshots.filter(filter) : this._snapshots;
      this._cache.filteredSnapshots = snapshots;
      return snapshots;
    }
  },

  _snapshotsInSectionNumber: function(sectionNumber) {
    if (this._cache['snapshotsInSection' + sectionNumber]) {
      return this._cache['snapshotsInSection' + sectionNumber];
    } else {
      var letterForSection = this._letterForSection(sectionNumber);
      var snapshots = this._filteredSnapshots().filter(function(snapshot) {
        return snapshot.firstName[0].toUpperCase() === letterForSection;
      });
      var sortedSnapshots = snapshots.sort(sortByName);
      this._cache['snapshotsInsection' + sectionNumber] = sortedSnapshots;
      return sortedSnapshots;
    }
  },

  _letterForSnapshot: function(snapshot) {
    return snapshot.firstName[0].toUpperCase();
  },

  _letterForSection: function(sectionNumber) {
    return this._letters()[sectionNumber];
  },

  _sectionFor: function(snapshot) {
    return this._letters().indexOf(snapshot.firstName[0].toUpperCase());
  },

  _rowFor: function(snapshot) {
    var snapshots = this._snapshotsInSectionNumber(this._sectionFor(snapshot));
    for (var i = 0; i < snapshots.length; i++) {
      if (snapshots[i].isForTheSameContact(snapshot)) {
        return i;
      }
    }
    return -1;
  }
};

var sortByName = function(snapshot1, snapshot2) {
  var name1 = snapshot1.name.toLowerCase();
  var name2 = snapshot2.name.toLowerCase();
  if (name1 < name2) {
    return -1;
  }
  if (name1 > name2) {
    return 1;
  }
  return 0;
};

/*ReplaceSnapshotTransaction is a helper object that is used in calculating
  what happened when the state of an object changed. When the name changes
  it can either move sections, stay in the same section or have the section
  header change.
*/
var ReplaceSnapshotTransaction = function(tableModel) {
  this._tableModel = tableModel;
  this._initialSectionCount = tableModel.numberOfSections();
};

ReplaceSnapshotTransaction.prototype = {
  replaceSnapshot: function(snapshot) {
    //loop over the current snanpshots,record where the snapshot that is
    //being replaced was to begin with, and replace it with the new snapshot.
    for (var i = 0; i < this._tableModel._snapshots.length; i++) {
      if (this._tableModel._snapshots[i].isForTheSameContact(snapshot)) {
        this._initialSectionNumber =
          this._tableModel._sectionFor(this._tableModel._snapshots[i]);
        this._initialRowNumber =
          this._tableModel._rowFor(this._tableModel._snapshots[i]);
        this._tableModel._snapshots[i] = snapshot;
      }
    }
    this._tableModel._flushCache();
    //record where the snapshot now is, and how many sections there are
    this._finalSectionCount = this._tableModel.numberOfSections();
    this._finalSectionNumber = this._tableModel._sectionFor(snapshot);
    this._finalRowNumber = this._tableModel._rowFor(snapshot);
  },

  getType: function() {
    if (this.initialSectionCount() !== this.finalSectionCount()) {
      return SECTION_HEADER_CHANGED;
    } else if (this.initialSection() !== this.finalSection()) {
      return SNAPSHOT_SWITCHED_SECTION;
    } else {
      return SNAPSHOT_DID_NOT_MOVE;
    }
  },

  initialSectionCount: function() {
    return this._initialSectionCount;
  },

  initialSection: function() {
    return this._initialSectionNumber;
  },

  initialRow: function() {
    return this._initialRowNumber;
  },

  finalSectionCount: function() {
    return this._finalSectionCount;
  },

  finalSection: function() {
    return this._finalSectionNumber;
  },

  finalRow: function() {
    return this._finalRowNumber;
  }
};

exports.ContactsTableModel = ContactsTableModel;
});

// module: bolt/dom_event
// file:   ../../../frameworks/bolt/lib/dom_event.js
define("bolt/dom_event", function(require, exports, module) {
/**
 * Copyright (c) 2011-2012, Facebook, Inc.
 * All rights reserved.
 *
 * @option preserve-header
 *
 */

var util = require('./util');
var core = require('./core');
var dom  = require('./dom');

var TokenList = require('./token_list').TokenList;


function returnTrue() { return true; }
function returnFalse() { return false; }

var EventMethods = {
  getTargetView: function() {
    if (this._targetView === undefined) {
      this._targetView = require('./mixins/container').findClosest(this.target);
    }
    return this._targetView;
  },

  // simulateBubbling: false,

  preventDefault: function() {
    var e = this.baseEvent;
    if (e) {
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = false;
      }
    } else {
      if (this._preventDefault) {
        this._preventDefault();
      } else {
        this.returnValue = false;
      }
    }
    this.isDefaultPrevented = returnTrue;
  },

  stopPropagation: function() {
    var e = this.baseEvent;
    if (e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      } else {
        e.cancelBubble = true;
      }
    } else {
      if (this._stopPropagation) {
        this._stopPropagation();
      } else {
        this.cancelBubble = true;
      }
    }
    this.isPropagationStopped = returnTrue;
  },

  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,

  getRawEvent: function() {
    core.deprecated('event.getRawEvent', 'event');
    return this;
  },

  hasEventApi: true
};


function normalize(e) {
  // Fix target property, if necessary
  if (!e.target) {
    e.target = e.srcElement || document;
  }

  // check if target is a textnode (safari)
  if (e.target.nodeType === 3) {
    e.target = e.target.parentNode;
  }

  // Add relatedTarget, if necessary
  if (!e.relatedTarget && e.fromElement) {
    e.relatedTarget = e.fromElement === e.target ? e.toElement : e.fromElement;
  }

  // Calculate pageX/Y if missing and clientX/Y available
  if (e.pageX == null && e.clientX != null) {
    var doc = document;
    var body = doc.body;

    e.pageX = e.clientX +
      (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
      (doc && doc.clientLeft || body && body.clientLeft || 0);
    e.pageY = e.clientY +
      (doc && doc.scrollTop  || body && body.scrollTop  || 0) -
      (doc && doc.clientTop  || body && body.clientTop  || 0);
  }

  // Add which for key events
  if (e.which == null && (e.charCode != null || e.keyCode != null)) {
    e.which = e.charCode != null ? e.charCode : e.keyCode;
  }

  // Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
  if (e.metaKey === undefined) {
    e.metaKey = e.metaKey || e.ctrlKey;
  }

  // Add which for click: 1 === left; 2 === middle; 3 === right
  // Note: button is not normalized, so don't use it
  if (!e.which && e.button !== undefined) {
    e.which = (e.button & 1 ? 1 :
              (e.button & 2 ? 3 :
              (e.button & 4 ? 2 : 0 )));
  }

  return e;
};

/**
* Store all the handlers manually so we can override event behaviour
* {
*   node_id_1: {
*     click: [...],
*     change: [...],
*     selection: [...]
*   }
*   node_id_2: {
*     click: [...]
*   }
* }
*/
var tokenLists = {};

/**
* Need a connection between node on which addListener was called an it's
* listeners, so this is a hash of
* {
*   node_id_1: bound domHandler
*   node_id_2: bound domHandler
* }
*/
var domHandlers = {};

var eventProps = "altKey attrChange attrName bubbles button cancelable charCode clientX clientY clipboardData ctrlKey currentTarget data dataTransfer detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement type view wheelDelta which".split(" ");


/**
* Handle all listener calls. Should be called with dom element as this
*/
function domHandler(e) {
  e = e || window.event;
  e._preventDefault = e._preventDefault || e.preventDefault;
  e._stopPropagation = e._stopPropagation || e.stopPropagation;
  e = util.extend(e, EventMethods);
  if (!e.data) {
    e.data = {};
  }
  evt.invoke(this, normalize(e));
}


function EventWrapper () {}

/**
* Adds missing methods to custom events
*/
function wrapCustomEvent(baseEvent) {
  // Poor man Object.create() here.
  // It's generally cheaper to build a prototype chain for a
  // dynamicaly created event object than to copy all properties
  // from base event.
  EventWrapper.prototype = baseEvent;
  e = new EventWrapper();
  util.extend(e, EventMethods);
  e.baseEvent = baseEvent;
  return e;
}


function ExtEventWrapper() {}

util.extend(ExtEventWrapper.prototype, EventMethods);

/**
* More expensive version of wrapCustomEvent for dom events
*/
function wrapDomEvent(baseEvent) {
  e = new ExtEventWrapper();
  e.baseEvent = baseEvent;
  // This is expensive. I'd rather use much faster createEvent() here.
  // Unfortunately firefox uses read only properties on native events,
  // thus preventing modification even in descendants.
  // IE9 does not support prototype chain alltogehter throwing
  // 'Invalid calling object'.
  for (var i = eventProps.length, prop; i >= -1; i--) {
    prop = eventProps[i];
    e[prop] = baseEvent[prop];
  }
  return e;
}

function DomTokenList(element) {
  this.element = element;
}

DomTokenList.prototype = new TokenList();

DomTokenList.prototype.addListener = function(type, listener, context, args) {
  // if this is the first listener added to el for type
  // then create a handler
  if (!this.hasTokensForType(type)) {
    if (evt.special[type]) {
      evt.special[type].setup(this.element);
    } else {
      var id = dom.identify(this.element);
      domHandlers[id] = domHandlers[id] || util.bind(domHandler, this.element);
      this.element.addEventListener ?
        this.element.addEventListener(type, domHandlers[id], false) :
        this.element.attachEvent('on' + type, domHandlers[id]);
    }
  }
  return TokenList.prototype.addListener
    .call(this, type, listener, context, args);
};

DomTokenList.prototype.removeListener = function(type, listener, context) {
  TokenList.prototype.removeListener.call(this, type, listener, context);

  // when removing the last listener also remove listener from the dom
  if (!this.hasTokensForType(type)) {
    var id = dom.identify(this.element);
    if (evt.special[type]) {
      evt.special[type].teardown(this.element);
    } else {
      this.element.removeEventListener ?
        this.element.removeEventListener(type, domHandlers[id], false) :
        this.element.detachEvent('on' + type, domHandlers[id]);
      if (this.isEmpty()) {
        delete domHandlers[id];
      }
    }
    
    // it's not very cool that we're deleting the reference in here
    // however that's the only place we can reach when developer explictly
    // calls .remove() on a token (bypassing domEvent)
    if (this.isEmpty()) {
      delete tokenLists[id];
    }
  }
};


var evt = module.exports = {

  wrapDomEvent: wrapDomEvent,

  wrapCustomEvent: wrapCustomEvent,

  // public extension API. check mouseleave, mouseenter for an example
  special: {},

  // exposed for debugging, so we can find all the listeneres on a given node
  tokenLists: tokenLists,

  invoke: function(el, e/*, args*/) {
    if (!e.hasEventApi) { e = wrapCustomEvent(e); }
    if (!e.target) { e.target = el; }

    var tokenListForEl = tokenLists[dom.identify(el)];
    var args = util.toArray(arguments).slice(1);

    if (tokenListForEl) {
      var tokens = tokenListForEl.getTokensForType(e.type);
      for (var i = 0, l = tokens.length; i < l; i++) {
        var item = tokens[i];
        var listener = item.listener;
        listener.apply(item.context || this, item.args.concat(args));
      }
    }

    if (e.data && e.data.simulateBubbling && !e.isPropagationStopped() && el.parentNode) {
      evt.invoke.apply(evt, [el.parentNode].concat(args));
    }
    return !e.isDefaultPrevented();
  },

  addListener: function(el, type, listener, contextOrNull) {
    var id = dom.identify(el);

    tokenLists[id] = tokenLists[id] || new DomTokenList(el);
    var args = util.toArray(arguments).slice(4);
    return tokenLists[id].addListener(type, listener, contextOrNull, args);
  },

  removeListener: function(el, type, listener, contextOrNull) {
    var id = dom.identify(el);
    if (!id || !tokenLists[id]) return;
    tokenLists[id].removeListener(type, listener, contextOrNull);
  },

  preventDefaultHandler: function(e) {
    e && e.preventDefault();
    return false;
  }
};

util.forEach({
  mouseover: 'mouseenter',
  mouseout: 'mouseleave'
}, function(specialName, origName) {

  function handler(e) {
    var parent = e.relatedTarget;
    try {
      while (parent && parent !== this) {
        parent = parent.parentNode;
      }

      if (parent !== this) {
        var wrapped = wrapDomEvent(e, {
          type: specialName,
          simulateBubbling: true
        });
        evt.invoke(this, wrapped);
      }
    } catch(e) { }
  }

  evt.special[specialName] = {
    setup: function(el, listener) {
      evt.addListener(el, origName, handler);
    },
    teardown: function( el, listener ){
      evt.removeListener(el, origName, handler);
    }
  };
});
});

// module: views/feedback/flyout/index
// file:   ../../views/feedback/flyout/index.js
define("views/feedback/flyout/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var View = require('bolt_touch/view').View;
var Actionable = require('bolt_touch/mixins/actionable').Actionable;
var ActionableView = require('bolt_touch/views/actionable_view').ActionableView;
var ScrollView = require('bolt_touch/views/scroll_view_j').ScrollView;

var Deferred = require('shared/deferred').Deferred;
var SpringyTransformView =
  require('system/mixins/springy_transform').SpringyTransformView;
var UfiLikeRow = require('../ufi/like_row').UfiLikeRow;
var UfiCommentList = require('../ufi/comment_list').UfiCommentList;
var UfiComposer = require('../ufi/composer').UfiComposer;

/**
 * @class UfiFeedbackView
 * @classdesc UfiFeedbackView is a view that pops over a StoryRow to show
 * likes, comments, and a comment composer.
 */
var UfiFeedbackView = core.createClass({

  name: 'UfiFeedbackView',

  extend: View,


  statics: {
    // the minimum number of pixels between the top of the screen
    // and the top of the view.
    MINIMUM_TOP_VALUE: 75,
    // the minimum amount of space between the bottom of the view and the
    // keyboard after the window has been resized to accommodate the keyboard
    MINIMUM_BOTTOM_SPACE_AFTER_RESIZE: 20,
    // the factor by which the view is scaled before it expands
    // and after it shrinks
    SMALL_SCALE: 0.01,
    // the minimum height of the view. this provides a reasonable
    // size for the UfiLikeRow and the UfiComposer
    MINIMUM_HEIGHT: 140,
    // an estimate of the height of a single UfiCommentRow.
    EXPECTED_COMMENT_HEIGHT: 120,
    // the maximum number of comments of the expected height we
    // want to show in the view, beyond which the user must scroll
    // to see
    MAXIMUM_COMMENT_COUNT: 4
  },

  properties: {
    /**
     * @property {Story} the story for which we are providing a UFI
     */
    model: null,
    /**
     * @property {Number} the y coordinate of the FeedbackBar that this
     * view corresponds to. The bottom of this view matches the y coordinate
     * of the feedback bar.
     */
    ufiYCoordinate: null,
    /**
     * @property {Number} the height of this view, derived from the number
     * of comments that we are aware of upon construction of the view.
     */
    height: null,
    /**
     * @property {Number} the top value of the view, derived from the height and
     * the position of the feedback bar that this view came from.
     */
    top: null
  },

  construct: function(options) {
    this._ready = new Deferred();
    View.call(this, options);
  },

  declare: function() {
    return {
      childViews: [
        {
          view: ActionableView,
          ref: 'background',
          className: 'bt-ufi-feedback-view--background'
        },
        {
          view: SpringyTransformView,
          boxOrientation: 'vertical',
          className: 'bt-ufi-feedback-view--view',
          ref: 'ufiView',
          scale: 0.1,
          childViews: [
            {
              view: ScrollView,
              ref: 'scrollView',
              className: 'bt-ufi-feedback-view--scroll-view',
              flex: 1,
              childViews: [
                {
                  view: UfiLikeRow,
                  ref: 'ufiLikeRow'
                },
                {
                  view: UfiCommentList,
                  ref: 'ufiCommentList',
                  onaction: 'forwardAction',
                  className: 'bt-ufi-feedback-view--ufi-comment-list'
                }
              ]
            },
            {
              className: 'bt-ufi-feedback-view--hr'
            },
            {
              view: UfiComposer,
              ref: 'ufiComposer'
            }
          ]
        }
      ]
    };
  },

  ready: function() {
    this.findRef('ufiCommentList')
      .setScrollableParent(this.findRef('scrollView'));
    this._boundOnResize = util.bind(this._onResize, this);
    window.addEventListener('resize', this._boundOnResize, false);
    this._ready.succeed();
  },

  setModel: function(model) {
    if (model === this.getModel()) {
      return;
    }
    this.set('model', model);
    this._ready.addCallback(this._afterReady, this);
  },

  _afterReady: function() {
    var model = this.getModel();
    this.fetch(model);
    this._updateViews(model);
  },

  onDocumentInsertion: function() {
    var ufiView = this.findRef('ufiView');
    // UfiFeedbackView uses spring transformations in order to look cool.
    // First, we set the initial scale value to something very small.
    // Note: We need to provide noop values for translate rather than leaving
    // translate blank due to a bug in the spring transformation library.
    ufiView.setTransformDirect({
      opacity: 0,
      scale: UfiFeedbackView.SMALL_SCALE,
      translate: [0, 0]
    });
    // Next, we set the expanded values of the view. By calling setTransform
    // rather than setTransformDirect, the spring view knows to transition to
    // this new state smoothly.
    ufiView.setTransform({
      opacity: 1,
      scale: 1,
      translate: [0, 0]
    });
    // We need to override the default parameters of the spring to get just the
    // right amount of springiness. By increasing the tension, the spring snaps
    // back toward its equilibrium state faster.
    ufiView.springScale.updateProperties({
      tension: 250
    });
    // Start the spring animation NOW.
    ufiView.startSpringAnimationNow();

    var background = this.findRef('background');
    background.setAction('close');
    background.addClass('bt-ufi-feedback-view--background_dimmed');

    // if there isn't enough space to display the UfiFeedbackView such that the
    // bottom of it is on the story's feedback bar, we need to scroll the scene
    // down to make space.
    var overhang = this.getUfiYCoordinate() - this.getHeight();
    var minTopValue = UfiFeedbackView.MINIMUM_TOP_VALUE;
    if (overhang < minTopValue) {
      this.invoke('scrollTo', {y: -(minTopValue - overhang)});
    }
  },

  _onResize: function() {
    var windowHeight = window.innerHeight;
    var height = this.getHeight();
    var top = this.getTop();
    var minimumBottomSpace = UfiFeedbackView.MINIMUM_BOTTOM_SPACE_AFTER_RESIZE;
    // we are required to store the shrunk state because we don't get different
    // events for the keyboard appearing and for it disappearing.
    if (this._shrunk) {
      this.findRef('ufiView').setHeight(this.getHeight() + 'px');
      this.findRef('scrollView').refresh();
      this._shrunk = false;
    } else if (top + height > windowHeight - minimumBottomSpace) {
      var maxHeight =
        windowHeight - UfiFeedbackView.MINIMUM_TOP_VALUE - minimumBottomSpace;
      var ufiView = this.findRef('ufiView');
      if (maxHeight < height) {
        ufiView.setHeight(maxHeight + 'px');
        height = maxHeight;
      }
      ufiView
        .setStyle('top', (windowHeight - minimumBottomSpace - height) + 'px');
      this.findRef('scrollView').refresh();
      this._shrunk = true;
    }
  },

  fetch: function(model) {
    if (model) {
      var height = UfiFeedbackView.MINIMUM_HEIGHT +
        UfiFeedbackView.EXPECTED_COMMENT_HEIGHT *
        Math.min(model.get('comments').count,
          UfiFeedbackView.MAXIMUM_COMMENT_COUNT);
      this.setHeight(height);
      this.findRef('ufiView').setHeight(height + 'px');
      var top = Math.max(
        this.getUfiYCoordinate() - height, UfiFeedbackView.MINIMUM_TOP_VALUE);
      this.setTop(top);
      this.findRef('ufiView').setStyle('top', top + 'px');
    }

    var storyStore =
      require('shared/data2/model/story/story_store').getInstance();
    storyStore.fetchStory(model.getFeedbackId())
      .addCallback(this._onLoaded, this);
  },

  _onLoaded: function(result) {
    if (result.type === 'local') {
      result.remote.addCallback(this._onLoaded, this);
    }

    var model = result.model;
    if (!model || this.isDestroyed) {
      return;
    }
    this.set('model', model);
  },

  _updateViews: function(model) {
    this.findRef('ufiLikeRow').setModel(model);
    this.findRef('ufiCommentList')
      .setTarget(model);
    this.findRef('ufiComposer').setTarget(model);
  },

  forwardAction: function(evt) {
    evt.stopPropagation();
    this.invoke(evt.type, evt.data);
  },

  close: function() {
    window.removeEventListener('resize', this._boundOnResize, false);
    // Change background's action back to null so that close doesn't get called
    // twice.
    var background = this.findRef('background');
    background.setAction(null);
    background.removeClass('bt-ufi-feedback-view--background_dimmed');

    var ufiView = this.findRef('ufiView');
    ufiView.addListener('webkitAnimationEnd', this._closed, this);
    // Shrink the view back into the feedback bar.
    ufiView.setTransform({
      opacity: 0,
      scale: UfiFeedbackView.SMALL_SCALE,
      translate: [0, 0]
    });
    // We want a higher tolerance here so that the spring will stop bouncing
    // sooner.
    ufiView.springScale.updateProperties({
      tolerance: 0.1
    });
    ufiView.startSpringAnimationNow();
  },

  _closed: function(evt) {
    this.removeListener('webkitAnimationEnd', this._closed, this);
    this.invoke('closed');
  }
});

exports.UfiFeedbackView = UfiFeedbackView;
});

// module: bolt/collection
// file:   ../../../frameworks/bolt/lib/collection.js
define("bolt/collection", function(require, exports, module) {
/**
 *
 * Copyright (c) 2011-2012, Facebook, Inc.
 * All rights reserved.
 *
 * @option preserve-header
 *
 */

var util = require('./util');
var core = require('./core');
var Model = require('./model').Model;
var Events = require('./mixins/events').Events;

/**
 * Collections allow you to observe a set of models and receive notifications
 * when collection membership changes occur via adding and removing models.
 * Collections also proxy property change notifications on their models on to
 * the observer. This allows views to update the ui to reflect model state
 * within an observed collection.
 *
 * The Collection class was inspired by and borrows heavily from backbone.js
 * http://documentcloud.github.com/backbone/
 */
var Collection = core.createClass({
  name: 'Collection',

  /**
   * create a new collection
   */
  construct: function(options) {
    this.length = 0;
    this.models = [];
    this._byCid = {};
    this._byId = {};
    this._listeners = {};
    options = options || {};
    this.modelType = options.modelType || this.klass.modelType;
  },

  statics: {
    modelType: Model
  },

  mixins: [Events],

  /**
   * add a model or a hash to a collection and invoke the modelAdded event
   * if a hash is passed in, the collection's default type is used to
   * construct a model for it
   * if the quiet flag is passed the modelAdded event will not be invoked.
   * if a comparator is provided the collection will maintain sort order
   * as items are added
   */
  add: function(model, quiet) {
    if (!model) return false;
    if (!model.klass) {
      model = new this.modelType(model);
    } else {
      var chain = model.klass.inheritanceChain;
      if (!chain || chain[chain.length-1].klassName !== 'Model') {
        model = new this.modelType(model);
      }
    }
    var cid = model.cid;
    var id = model.id;
    if (!this._byCid[cid] && (!id || !this._byId[id])) {
      var idx = this.comparator ?
        this.sortedIndex(model, this.comparator) : this.length;
      this.models.splice(idx, 0, model);
      this._byCid[cid] = model;
      if (model.id !== null) {
        this._byId[id] = model;
      }
      this.length++;
      this._listeners[cid] = model.addListener('changed',
        this._onModelChanged, this);
      if (!quiet) {
        this.invoke('modelAdded', {model: model, index: idx});
      }
      return model;
    }
    return false;
  },

  /**
   * remove a model from the collection and invoke the modelRemoved event
   * if the quiet flag is passed the modelRemoved event will not be invoked
   */
  remove: function(model, quiet) {
    if (!model) return false;
    var cid = model.cid;
    var id = model.id;
    if (this._byCid[cid]) {
      delete this._byCid[cid];
      delete this._byId[id];
      var idx = this.indexOf(model);
      this.models.splice(idx, 1);
      this.length--;
      if (!quiet) {
        this.invoke('modelRemoved', {model: model, index: idx});
      }
      var listener = this._listeners[cid];
      listener && listener.remove();
      delete this._listeners[cid];
      return true;
    }
    return false;
  },

  /**
   * clear all models from the collection can be performed silently if the
   * quiet flag is passed in
   */
  clear: function(quiet, batchUpdateEvents) {
    var models = this.models;
    var _listeners = this._listeners;
    this._byCid = {};
    this._byId = {};
    this.models = [];
    this.length = 0;
    var i, len, model;
    for (i = 0, len = models.length; i < len; ++i) {
      model = models[i];
      var cid = model.cid;
      var listener = _listeners[cid];
      listener && listener.remove();
      delete _listeners[cid];
    }
    if (!quiet) {
      if (batchUpdateEvents) {
        this._beginBatchUpdate();
        for(i = 0, len = models.length; i < len; ++i) {
          this.invoke('modelRemoved', {model: models[i], index: i });
        }
        this._endBatchUpdate();
      } else {
        this.invoke('updated', {action: 'clear', collection: this});
      }
    }
  },

  /**
   * clears all models in the collection and replaces them
   * with the models passed in. The updated event is inovked upon
   * completion if the quiet flag is not passed in.
   */
  replace: function(models, quiet) {
    this.clear(true);
    this.merge(models, quiet);
  },

  /**
   * merge the passed in set of models into the collection by updating
   * or adding
   */
  merge: function(models, quiet, batchUpdateEvents) {
    var updated = false;
    if (!util.isArray(models)) {
      models = [models];
    }
    if (!quiet && batchUpdateEvents) {
      this._beginBatchUpdate();
    }
    var i, len, model;
    for (i = 0, len = models.length; i < len; ++i) {
      model = models[i];
      var existingModel = this.getById(model.id);
      // TODO: we have a weird case here where if a model is added without
      // an id it can appear to be a duplicate of any other models without
      // ids. Should we allow models without ids to be added? what use cases
      // does that break currently if we remove it.
      if (!existingModel) {
        var added = this.add(model, !batchUpdateEvents);
        if (added) {
          updated = true;
        }
      } else {
        var ret = existingModel.merge(model, !batchUpdateEvents);
        updated = updated || !!ret;
      }
    }
    if (batchUpdateEvents) {
      this._endBatchUpdate();
    } else if (updated && !quiet) {
      this.invoke('updated', {action: 'merge', collection: this});
    }
  },

  // helper function to see if we actually need to sort
  // basically, sort only if elements are out of order
  _shouldSort: function() {
    var comparator = this.comparator;
    if (!comparator) {
      return false;
    }
    var elem, nextElem;
    nextElem = this.at(0);
    for (var i = 1; i < this.length; i++) {
      elem = nextElem;
      nextElem = this.at(i);
      if (comparator(elem) > comparator(nextElem)) {
        return true;
      }
    }
    return false;
  },

  /**
   * sort the collection using the comparator
   */
  sort: function(quiet) {
    if (!this.comparator) {
      return false;
    }
    if (!this._shouldSort()) {
      // this is more to optimize the possibly high cost of the updated event
      // than the cost of the sort
      return false;
    }
    this.models = this.sortBy(this.comparator);
    if (!quiet) {
      this.invoke('updated', {action: 'sort', collection: this});
    }
    return this;
  },

  /**
   * get a model by id from the collection
   */
  getById: function(id) {
    return this._byId[id];
  },

  /**
   * get the ids of all the models
   */
  getIds: function() {
    return this.map(function(m) {
      return m.id;
    });
  },

  /**
   * get a model by client id from the collection
   */
  getByCid: function(cid) {
    return this._byCid[cid];
  },

  /**
   * get a model at a given index from the collection
   */
  at: function(idx) {
    return this.models[idx];
  },

  slice: function(a, b) {
    return this.models.slice(a, b);
  },

  /**
   * @return {Array} an array of object models
   */
  toJSONArray: function() {
    return this.map(modelToObject);
  },

  /**
   * proxy on a model change event
   */
  _onModelChanged: function(event) {
    var data = event.data;
    var model = data.model;
    var index = this.indexOf(model);

    if (index < 0) {
      // index can be undefined if model was removed before we get here, e.g.
      // if this is a filterable collection and the base collection removed
      // the model
      return;
    }
    this.invoke('modelChanged', util.defaults({index: index}, data));

    var comparator = this.comparator;
    var prevModel = (index > 0) && this.at(index - 1);
    var nextModel = (index < this.length - 1) && this.at(index + 1);
    var sortNeeded = (
      // comparator exists
      comparator &&
      // sortKey property was changed
      !util.isUndefined((data.changedProperties || {})[this.sortKey]) &&
      // model is not in the correct position
      (
        (prevModel && comparator(prevModel) > comparator(model)) ||
        (nextModel && comparator(model) > comparator(nextModel))
      )
    );
    if (sortNeeded) {
      this.sort();
    }
  },

  _beginBatchUpdate: function() {
    this.invoke('beginUpdate');
  },

  _endBatchUpdate: function() {
    this.invoke('endUpdate');
  },

  destroy: function() {
    this.removeListener();
    this.clear(true);
  },

  // COMPAT
  listen: function(type, callback, contextOrNull) {
    function handleAll(event) {
      this.listener.apply(
        this.context,
        [event.type].concat(arguments));
    }

    function handleSingle() {
      this.listener.apply(this.context, arguments);
    }

    require('./core').deprecated('listen', 'addListener');
    var token = this.addListener(type, callback, contextOrNull || this);
    token.boundListener = type === 'all' ? handleAll : handleSingle;
    return token;
  }

});

function modelToObject(model) {
  return model.toObject();
}

var methods = [
  'filter', 'forEach', 'each', 'map', 'include', 'without',
  'find', 'first', 'last', 'isEmpty', 'toArray', 'select',
  'reject', 'indexOf', 'sortBy', 'sortedIndex', 'max', 'min'
];

util.forEach(methods, function(method) {
  Collection.prototype[method] = function() {
    return util[method].apply(
      this,
      [this.models].concat(util.toArray(arguments)));
  };
});

exports.Collection = Collection;
});

// module: shared/data/sql_transaction
// file:   ../../shared/js/data/sql_transaction.js
define("shared/data/sql_transaction", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core     = require('bolt/core');
var db       = require('shared/data/db');
var util     = require('bolt/util');
var Deferred = require('shared/deferred').Deferred;
var timer    = require('shared/perf/timer');

var logger   = require('shared/logger').logger;

var RUNNING = 0,
    COMPLETE = 1,
    FAILED = 2;

// context is the SqlTransaction object that the transaction will be bound to
function beginTransaction(context) {
  timer.start(context);
  db.transaction(
    function(transaction) {
      context.setTransaction(transaction);
      context.ready.succeed(transaction);
    },
    function(error) {
      timer.stop(context);
      console.error('transaction creation error: ' + error.message);
      context.ready.fail(error);
    },
    function() {
      timer.stop(context);
      updateState(context, COMPLETE);
    }
  );
}

function runCallbacks(callbacks, context, args) {
  var callbackTimerId =
    logger.startTimer('webdb.transaction.callbacks', logger.ALLOW_OVERLAPPING);
  for (var i = 0, l = callbacks.length; i < l; i++) {
    callbacks[i].apply(context, args);
  }
  logger.endTimer(callbackTimerId);
}

function updateState(tx, state) {
  args = util.toArray(arguments).slice(2);
  if (RUNNING === tx.getState()) {
    tx.setState(state);
    var callbacks = null;
    switch (state) {
      case COMPLETE:
        callbacks = tx.callbacks.splice(0, tx.callbacks.length);
        break;
      case FAILED:
        callbacks = tx.errbacks.splice(0, tx.errbacks.length);
        break;
    }
    if (callbacks) {
      runCallbacks(callbacks, tx, args);
    }
  }
}

/**
 * This is returned from SqlTransaction.executeSql and represents a single
 * SQL statement.  We shouldn't create this class anywhere or use it outside
 * of SqlTransaction.
 */
var SqlStatement = core.createClass({
  name: 'SqlStatement',
  extend: Deferred,

  properties: {
    tx: null,           // SqlTransaction object
    statement: '',      // sql statement
    args: []            // array used to fill '?' in sql statement
  },

  construct: function(tx, statement, args) {
    Deferred.call(this);
    this.setTx(tx);
    this.setStatement(statement);
    this.setArgs(args);

    // bind _callback and _errback since we're only using them in executeSql
    this._callback = util.bind(this._callback, this);
    this._errback = util.bind(this._errback, this);

    this._logInfo = {
      url: window.location.toString(),
      statement: statement
      // we don't log args here for privacy reasons
    };
    // measures delay between object construction and when execute is called
    this._waitTimerId =
      logger.startTimer('webdb.statement.wait', logger.ALLOW_OVERLAPPING);
    // measures total time between construction and when the statement finishes
    this._durationTimerId =
      logger.startTimer('webdb.statement.duration', logger.ALLOW_OVERLAPPING);
  },

  execute: function() {
    logger.endTimer(this._waitTimerId, this._logInfo);

    var tx = this.getTx();
    var statement = this.getStatement();
    var args = this.getArgs();

    if (RUNNING !== tx.getState()) {
      var m = 'Attempting to call executeSql after closing the SqlTransaction';
      var error = { message: m };
      console.error(m);
      return this.fail(error);
    }

    var transaction = tx.getTransaction();  // native transaction

    timer.start(this);
    transaction.executeSql(
      statement,
      args,
      this._callback,
      this._errback
    );

    return this;
  },

  _callback: function(transaction, resultSet) {
    logger.endTimer(this._durationTimerId, this._logInfo);
    timer.stop(this);

    logger.logTimeDirect('webdb.statement.rows.length', 'count',
      resultSet.rows.length, this._logInfo);
    logger.logTimeDirect('webdb.statement.rowsAffected', 'count',
      resultSet.rowsAffected, this._logInfo);

    // measures how long callbacks take to run (synchronously)
    this._callbackTimerId =
      logger.startTimer('webdb.statement.callbacks', logger.ALLOW_OVERLAPPING);

    this.succeed(resultSet);

    logger.endTimer(this._callbackTimerId, this._logInfo);
  },

  _errback: function(transaction, error) {
    logger.endTimer(this._durationTimerId, this._logInfo);
    timer.stop(this);

    // measures how long errbacks take to run (synchronously)
    this._errbackTimerId =
      logger.startTimer('webdb.statement.errbacks', logger.ALLOW_OVERLAPPING);

    var sql = this.getStatement();
    var args = this.getArgs();
    var message = 'SQL Error: ' + (error ? error.message : '[Unknown]');
    console.error(message + ' (' + sql + ') ' + JSON.stringify(args));
    this.fail(error);

    logger.endTimer(this._errbackTimerId, this._logInfo);
  }
});

/**
 * Our wrapper arounda SQL Transaction.  Can execute SQL statements using
 * executeSql, and add callbacks/errbacks to the transaction with
 * addTransactionCallback and addTransactionErrback.
 */
exports.SqlTransaction = core.createClass({
  name: 'SqlTransaction',

  properties: {
    state: RUNNING,
    transaction: null
  },

  succeed: function() {
    console.error('Should not call succeed on SqlTransaction.');
    var d = new Deferred();
    return d.succeed.apply(d, arguments);
  },

  then: function() {
    console.error('Should not call then on SqlTransaction.');
    var d = new Deferred().succeed();
    return d.then.apply(d, arguments);
  },

  then: function() {
    console.error('Should not call then on SqlTransaction.');
    var d = new Deferred().succeed();
    return d.then.apply(d, arguments);
  },

  addCallback: function() {
    console.error('Should not call addCallback on SqlTransaction.');
    var d = new Deferred().succeed();
    return d.addCallback.apply(d, arguments);
  },

  /**
   * The constructor should be called with no arguments, or a deferred if we
   * want to delay creation of the transaction.
   */
  construct: function(deferred) {
    this.ready = new Deferred();
    this.batches = {};
    this.callbacks = [];
    this.errbacks = [];

    deferred = deferred || new Deferred().succeed();

    this._logInfo = {
      url: window.location.toString()
    };
    // measures time between construction and when deferred succeeds
    this._waitTimerId =
      logger.startTimer('webdb.transaction.wait', logger.ALLOW_OVERLAPPING);
    // measures total time between construction and when the transaction closes
    this._durationTimerId =
      logger.startTimer('webdb.transaction.duration', logger.ALLOW_OVERLAPPING);
    // measures the number of statements executed by this transaction
    this._statementCount = 0;

    deferred.addCallback(this._onDeferred, this);
    this.ready.addCallback(this._onReady, this);
    this.ready.addErrback(updateState, null, this, FAILED);
  },

  _onDeferred: function() {
    logger.endTimer(this._waitTimerId, this._logInfo);
    // measures how long it takes to create the transaction
    this._createTimerId =
      logger.startTimer('webdb.transaction.create', logger.ALLOW_OVERLAPPING);

    beginTransaction(this);
  },

  _onReady: function() {
    logger.endTimer(this._createTimerId, this._logInfo);
    // measures time between execution ready and transaction closes
    this._executeTimerId =
      logger.startTimer('webdb.transaction.execute', logger.ALLOW_OVERLAPPING);
  },

  setState: function(state) {
    this.set('state', state);
    if (state !== RUNNING) {
      // finish logging because we're done
      var executionTime = logger.queryTimer(this._executeTimerId);
      logger.endTimer(this._durationTimerId, this._logInfo);
      logger.endTimer(this._executeTimerId, this._logInfo);
      logger.logTimeDirect('webdb.transaction.statement_count', 'count',
        this._statementCount, this._logInfo);
      logger.logTimeDirect('webdb.transaction.average_statement_execute',
        'latency', executionTime / this._statementCount, this._logInfo);
    }
  },

  setBatch: function(storeName, batch) {
    this.batches[storeName] = batch;
    return batch;
  },

  getBatch: function(storeName) {
    return this.batches[storeName];
  },

  // transaction callbacks are called once the full transaction is complete
  addTransactionCallback: function(callback) {
    if (COMPLETE === this.getState()) {
      callback.apply(this);
    } else {
      this.callbacks.push(callback);
    }
    return this;
  },

  removeTransactionCallback: function(callback) {
    var index = this.callbacks.indexOf(callback);
    (-1 === index) || this.callbacks.splice(index, 1);
    return this;
  },

  // transaction errbacks are called when any error happens in the transaction
  addTransactionErrback: function(callback) {
    if (FAILED === this.getState()) {
      callback.apply(this);
    } else {
      this.errbacks.push(callback);
    }
    return this;
  },

  removeTransactionErrback: function(callback) {
    var index = this.errbacks.indexOf(callback);
    (-1 === index) || this.errbacks.splice(index, 1);
    return this;
  },

  clone: function() {
    console.error('clone');
    console.log(util.toArray(arguments));
    return this;
  },

  /**
   * Executes a SQL statement.  This returns a Deferred that succeeds with the
   * result set on success or fails with the error message on failure.
   *
   * @param sql {String} The SQL string you want to execute
   * @param args {Array} The args to bind to the SQL statement
   */
  executeSql: function(sql, args) {
    this._statementCount++;

    var statement = new SqlStatement(this, sql, args);
    statement.addErrback(updateState, null, this, FAILED);
    this.ready.then(statement.execute, statement);
    return statement;
  }
});
});

// module: shared/shadowbroker/broker/index
// file:   ../../shared/js/shadowbroker/broker/index.js
define("shared/shadowbroker/broker/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core = require('bolt/core');
var util = require('bolt/util');

var Deferred          = require('shared/deferred').Deferred;
var logger            = require('shared/logger').logger;
var ControllerFactory = require('./controller_factory').ControllerFactory;
var Channel           = require('./channel').Channel;
var transport         = require('./transport');

var emptyArray = [];
var slice      = emptyArray.slice;
var guid       = 1;
var global     = this;

/**
 * Broker that maintains communication between a client and a worker.
 *
 * Both client and a worker (dedicated or shared) have an instance of the
 * Broker object. Communication is symetrical. So all the APIs that are
 * available to the client are available to the worker as well.
 *
 * Broker provides APIs to
 * a) call remote methods
 * b) register controllers so that the other broker can call remote methods
 * b) send messages to open channels
 *
 *
 * Calling remote methods
 * To call a remote method invoke callMethod() on the broker passing
 * controller name, method name, and arbitrary number of arguments. callMethod()
 * always returns a Deferred object.
 *
 * @example
 *
 *   broker.callMethod('math', 'add', 2, 2)
 *    .addCallback(function(result) {
 *      console.log(result);
 *    })
 *
 *
 * Registring controllers
 * Controllers are registered on the broker directly or for SharedWorker on the
 * port manager. You can also pass a ControllerFactory object to a new Broker.
 * Controllers are just objects with methods. Each method accepts arbitrary
 * number of arguments and returns either a value or a Deferred.
 *
 * @example
 *   broker.registerController('echo', {
 *     echo: function(text) {
 *       return 'echo: ' + text;
 *     }
 *   });
 *
 *   // or
 *   var MathController = core.createClass({
 *     add: function(a, b) {
 *       return a + b;
 *     },
 *
 *     asyncMult: function(a, b) {
 *       var d = new Deferred();
 *       setTimeout(function() {
 *         d.succeed(a * b);
 *       });
 *       return d;
 *     }
 *   });
 *   broker.registerController('math', MathController);
 *
 *
 * Channels
 * When calling methods or returning parameters from controllers you can
 * either send serializable object
 * (see https://developer.mozilla.org/en/DOM/The_structured_clone_algorithm)
 * or Channel objects. Channel object will be automatically
 * serialized/deserialized by sending/receiving brokers.
 */
var Broker = core.createClass({

  name: 'Broker',

  _port: null,
  _name: 'Broker',
  _channels: null,
  _requests: null,
  _manager: null,
  _controllerFactory: null,


  // setup
  construct: function(port, controllerFactory, manager) {
    this._port = port;
    this._controllerFactory = controllerFactory || new ControllerFactory();
    this._manager = manager || null;
    this._channels = {};
    this._requests = {};

    this._successfulResponsesCount = 0;
    this._failedResponsesCount = 0;

    this._boundOnMessage = util.bind(this._onmessage, this);
    this._port.addEventListener('message', this._boundOnMessage, false);
    this._port.start();

    if (global.window && global.window.addEventListener) {
      this._boundDestroy = util.bind(this.destroy, this);
      window.addEventListener('beforeunload', this._boundDestroy, false);
    }
  },

  registerController: function(type, controller) {
    this._controllerFactory.registerController(type, controller);
  },

  setName: function(name) {
    this._name = name;
  },



  // Public API
  callMethod: function(objectName, methodName/*, args...*/) {
    var loggerId = logger.startTimer('shadowbroker.callMethod');

    var id = guid++;
    var args = arguments.length > 2 ? slice.call(arguments, 2) : emptyArray;
    var req = transport.encodeRequest(id, objectName, methodName, args);
    var deferred = new Deferred();
    deferred._shadobrokerLoggerId = loggerId;
    deferred._shadobrokerObjectName = objectName;
    deferred._shadobrokerMethodName = methodName;
    this._requests[id] = deferred;
    this._registerChannels(args);
    this._port.postMessage(req);
    this._openChannels(args);
    return deferred;
  },

  sendMessage: function(objectName, methodName/*, args */) {
    var args = arguments.length > 2 ? slice.call(arguments, 2) : emptyArray;
    var req = transport.encodeMessage(objectName, methodName, args);
    this._registerChannels(args);
    this._port.postMessage(req);
    this._openChannels(args);
  },

  // Channel API
  // use Channel object instead of calling this methods directly
  sendChannelMessage: function(channel, data) {
    this._port.postMessage(
      transport.encodeChannelMessage(channel.getId(), data));
  },

  closeChannel: function(channel) {
    var id = channel.getId();
    delete this._channels[id];
    this._serviceCall('closeChannel', id);
    channel.reactToClose();
  },


  // Misc
  destroy: function() {
    this._port.removeEventListener('message', this._boundOnMessage, false);
    if (global.window) {
      window.removeEventListener('beforeunload', this._boundDestroy, false);
    }

    if (this._manager) {
      this._manager.brokerDestroyed(this);
    }
    for (var i in this._channels) {
      this._channels[i].reactToClose();
    }
    this._serviceCall('destroy');
  },


  // Protected
  _onmessage: function(event) {
    var message = transport.decode(event.data);
    if (!message) {
      return;
    }

    if (message.messageType === transport.TYPE_RESPONSE) {
      this._processResponse(message);
    } else if (message.messageType === transport.TYPE_MESSAGE) {
      this._processMessage(message);
    } else if (message.messageType === transport.TYPE_REQUEST) {
      this._processRequest(message);
    } else if (message.messageType === transport.TYPE_CHANNEL_MESSAGE) {
      this._processChannelMessage(message);
    }
  },

  _processResponse: function(message) {
    var id = message.requestId;
    var deferred = this._requests[id];
    if (!deferred) {
      logger.logTimeDirect(
        'shadowbroker.failedResponses',
        'percent',
        ++this._failedResponsesCount / this._successfulResponsesCount,
        [this._name]);
      return;
    }
    this._successfulResponsesCount++;

    var loggerId = deferred._shadobrokerLoggerId;
    var objectName = deferred._shadobrokerObjectName;
    var methodName = deferred._shadobrokerMethodName;

    delete this._requests[id];
    this._registerChannels(message.args);
    this._openChannels(message.args);
    logger.endTimer(loggerId, [this._name, objectName, methodName]);
    deferred.setStatus.apply(deferred, [message.status].concat(message.args));
  },

  _processMessage: function(message) {
    var controller = this._controllerFactory.getController(message.object);
    this._registerChannels(message.args);
    this._openChannels(message.args);
    controller[message.method].apply(controller, message.args);
  },

  _processRequest: function(message) {
    var requestId = message.requestId;

    // method calls with empty objects are considered special and are used
    // to modifiy broker state
    if (!message.object) {
      this._processServiceRequest(message);
      return;
    }

    var controller = this._controllerFactory.getController(message.object);
    if (!controller) {
      this._respond(
        requestId,
        Deferred.STATUS_FAILED,
        ['No controller is registered for type: ' + message.object]);
      return;
    }

    if (!controller[message.method]) {
      this._respond(
        requestId,
        Deferred.STATUS_FAILED,
        ['Controller ' + message.object + ' does not have specified method: ' +
          message.method]);
      return;
    }

    this._registerChannels(message.args);
    this._openChannels(message.args);
    var result = controller[message.method].apply(controller, message.args);
    if (result instanceof Deferred) {
      result.addCompleteCallback(
        this._respondWithDeferred,
        this,
        result,
        requestId);
    } else {
      var args = [result];
      this._registerChannels(args);
      this._respond(requestId, Deferred.STATUS_SUCCEEDED, args);
      this._openChannels(args);
    }
  },

  _processServiceRequest: function(message) {
    if (message.method === 'destroy') {
      this.destroy();
    } else if (message.method === 'closeChannel') {
      var channelId = message.args;
      this._channels[channelId].reactToClose();
      delete this._channels[channelId];
    }
  },



  _processChannelMessage: function(message) {
    var channel = this._channels[message.channelId];
    if (!channel) {
      console.warn('[WorkerBroker] Trying to send message to a channel ' +
                   'that does not exist', message);
      return;
    }
    channel.reactToMessage(message.data);
  },



  _respond: function(requestId, status, args) {
    this._port.postMessage(
      transport.encodeResponse(requestId, status, args));
  },

  _respondWithDeferred: function(deferred, requestId) {
    var args = slice.call(arguments, 2);
    this._registerChannels(args);
    this._respond(requestId, deferred.getStatus(), args);
    this._openChannels(args);
  },

  _serviceCall: function(methodName, args) {
    this.callMethod('', methodName, args);
  },

  _registerChannels: function(args) {
    for (var i = 0, l = args.length; i < l; i++) {
      var channel = args[i];

      if (channel instanceof Channel) {
        this._channels[channel.getId()] = channel;
      }
    }
  },

  _openChannels: function(args) {
    for (var i = 0, l = args.length; i < l; i++) {
      var channel = args[i];

      if (channel instanceof Channel) {
        channel.reactToOpen(this);
      }
    }
  }

});

exports.Broker = Broker;
});

// module: shared/data2/relationship/relationship
// file:   ../../shared/js/data2/relationship/relationship.js
define("shared/data2/relationship/relationship", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core       = require('bolt/core');
var Collection = require('bolt/collection').Collection;
var Deferred   = require('shared/deferred').Deferred;
var util       = require('bolt/util');


var Relationship = core.createClass({

  name: 'Relationship',

  /**
   * Property/getter on the original models
   */
  _queryPropName: 'rel_id',
  _queryPropGetter: function(m) {
    return m.get('rel_id');
  },

  /**
   * Property/getter on the related models
   */
  _relatedPropName: 'id',
  _relatedPropGetter: function(m) {
    return m.id;
  },

  /**
   * Can a single original value correspond to a list of related models
   */
  _multiMatch: false,

  /**
   * Property on original model where result will be stored
   */
  _targetProp: 'relationship',

  /**
   * Fetcher function. Should return a collection
   */
  _fetcher: null,

  /**
   * Colleciton to cache fetched values
   */
  _collection: null,

  /**
   * Related values that were ever fetched
   */
  _inFlight: null,

  /**
   * Mapping between related values and coresponding model ids in _collection
   */
  _relatedValueToId: null,

  construct: function() {
    this._inFlight = {};
    this._relatedValueToId = {};
  },

  /**
   * Property name on original models that is used to query for relationship.
   * Example: 'thread_id' on message to fetch related threads.
   * @param {String} name
   */
  setQueryProp: function(name) {
    var getter = util.getter(name);
    this._queryPropName = name;
    this._queryPropGetter = function(model) {
      return model[getter] ? model[getter]() : model.get(name);
    };
    return this;
  },

  /**
   * Property getter for original models. Returned value(s) will be used to
   * query for relationship. Can return either single value or an array of
   * values.
   *
   * Example:
   *   function(m) {
   *     return m.getRelevantParticipants().map(contacts.buildIdent);
   *   });
   *   to fetch all participants for a thread
   *
   * @param {Function} fun
   */
  setQueryPropGetter: function(fun) {
    this._queryPropName = null;
    this._queryPropGetter = fun;
    return this;
  },


  /**
   * Whether one value from original model can correspond to a number of
   * values on a target model.
   *
   * Example:
   *
   *  new Relationship()
   *    .setQueryProp('parent_id') // many
   *    .setRelatedProp('id')      // one
   *    .setMultiMatch(false);
   *  original.get('relationship') => single model
   *
   *
   *  new Relationship()
   *    .setQueryProp('parent_ids') // many
   *    .setRelatedProp('id')       // one
   *    .setMultiMatch(false)
   *  original.get('relationship') => an array of models
   *
   *
   *  new Relationship()
   *    .setQueryProp('phone')     // many
   *    .setRelatedProp('phones')  // many
   *    .setFetcher(function(phones) {
   *      // several users can have the same phone
   *      return conctacts.findByAnyPhone(phones);
   *    })
   *    .setMultiMatch(true)
   *  original.get('relationship') => an array of models
   *
   */
  setMultiMatch: function(state) {
    this._multiMatch = state;
    return this;
  },


  /**
   * Property on original models that will be used to store the result of the
   * relationship fetch.
   *
   * Example: 'thread' on message to store fetched threads
   */
  setTargetProp: function(name) {
    this._targetProp = name;
    return this;
  },


  /**
   * Property on related models that will be used to query for the values from
   * original models. It will also be used to match related models back to
   * original ones.
   */
  setRelatedProp: function(name) {
    var getter = util.getter(name);
    this._relatedPropName = name;
    this._relatedPropGetter = function(model) {
      return model[getter] ? model[getter]() : model.get(name);
    };
    return this;
  },

  /**
   * Property getter on related models that will be used to match related models
   * back to original ones. You have to provide a custom fetcher if you intend
   * to use relatedPropGetter instead of relatedProp
   */
  setRelatedPropGetter: function(fun) {
    this._relatedPropName = null;
    this._relatedPropGetter = fun;
    return this;
  },


  /**
   * Related store to fetch related models from. You should setRelatedProp
   * to be able to query a store.
   */
  setStore: function(store) {
    this._collection = store.createCollection();
    var _this = this;

    this._fetcher = function(values) {
      var query = {};
      query[_this._relatedPropName] = values;
      return store.fetchCollection(query, values.length);
    };
    return this;
  },

  /**
   * Custom fetcher for the relationship
   */
  setFetcher: function(fetcher) {
    this._collection = new Collection();
    this._fetcher = fetcher;
    return this;
  },


  /**
   *             queryProp                  fetcher
   * newModels +------------------> props ------------> relatedModels
   *           |                                             |
   *           |                                             | map
   *            \-> modelsToValues   valuesToRelatedModel <-/
   *                       |                    |
   *                       |                    |
   *                        \--------+---------/
   *                                 |
   *                                 \-> newModels[i]
   *                                       .set(targetProp, relatedModels)
   *
   */
  fetch: function(newModels) {
    // 1. fetch query values
    var i, l, queryValues = [], value, model, id;
    for (i = 0, l = newModels.length; i < l; i++) {
      model = newModels[i];
      id = model.get('id');
      value = this._queryPropGetter(model);
      if (util.isArray(value)) {
        queryValues.push.apply(queryValues, value);
      } else {
        queryValues.push(value);
      }
    }

    // 2. filter out duplicated, empty values, or inFlight values
    var filteredValues = [];
    for (i = 0, l = queryValues.length; i < l; i++) {
      value = queryValues[i];
      if (value && !this._inFlight[value]) {
        this._inFlight[value] = true;
        filteredValues.push(value);
      }
    }

    if (filteredValues.length) {
      return this._fetcher(filteredValues)
        .then(this._fetchComplete, this, newModels);
    } else {
      this._mergeNewModels(newModels);
      return (new Deferred()).succeed();
    }
  },

  _fetchComplete: function(newModels, collection) {
    var i, l, j, n, model, value;

    for (i = 0, l = collection.length; i < l; i++) {
      model = collection.at(i);
      value = this._relatedPropGetter(model);
      this._collection.add(model);

      if (util.isArray(value)) {
        for (j = 0, n = value.length; j < n; j++) {
          this._addToValueToId(value[j], model.get('id'));
        }
      } else {
        this._addToValueToId(value, model.get('id'));
      }
    }
    this._mergeNewModels(newModels);
    // destroy original collection
    collection.destroy();
  },

  _mergeNewModels: function(newModels) {
    var valueToId = this._relatedValueToId;
    var i, l, j, n, model, value, related, used;

    for (i = 0, l = newModels.length; i < l; i++) {
      model = newModels[i];
      value = this._queryPropGetter(model);

      if (this._multiMatch) {
        related = [];
        used = {};

        // Case 1: multiple original values with multiple related values
        // Example: thread has many asociated phone numbers,
        //          user has many associated phone number
        //          find all users coresponding for a given thread
        if (util.isArray(value)) {
          for (j = 0, n = value.length; j < n; j++) {
            this._mergeMultiMatchValue(related, used, value[j]);
          }
        // Case 2: single original value with multiple related values
        // Example: message has one associated phone number,
        //          user has many associated phone number
        //          find all users coresponding for a given message
        } else {
          this._mergeMultiMatchValue(related, used, value);
        }
      } else {
        related = null;
        // Case 3: multiple original values with a single related values
        // Example: thread has many user ids
        //          user has only one id
        //          find all users coresponding for a given thread
        if (util.isArray(value)) {
          related = [];
          for (j = 0, n = value.length; j < n; j++) {
            if (valueToId[value[j]]) {
              related.push(this._collection.getById(valueToId[value[j]]));
            }
          }
        // Case 4: single original value with a single related values
        // Example: message has only one associated user id
        //          user has only one id
        //          find a coresponding user for the given message
        } else {
          if (valueToId[value]) {
            related = this._collection.getById(valueToId[value]);
          }
        }
      }
      model.setSafe(this._targetProp, related);
    }
  },

  _mergeMultiMatchValue: function(related, used, value) {
    if (value && this._relatedValueToId[value]) {
      var ids = this._relatedValueToId[value].ids;
      for (var i = 0, l = ids.length; i < l; i++) {
        if (!used[ids[i]]) {
          used[ids[i]] = true;
          related.push(this._collection.getById(ids[i]));
        }
      }
    }
  },

  _addToValueToId: function(value, id) {
    var valueToId = this._relatedValueToId;
    if (this._multiMatch) {
      if (!valueToId[value]) {
        valueToId[value] = { used: {}, ids: [] };
      }
      if (!valueToId[value].used[id]) {
        valueToId[value].ids.push(id);
        valueToId[value].used[id] = true;
      }
    } else {
      valueToId[value] = valueToId[value] || id;
    }
  }
});


exports.Relationship = Relationship;
});

// module: lib/clustered_collection
// file:   lib/clustered_collection.js
define("lib/clustered_collection", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var Store = require('shared/data2/store/store').Store;
var Model = require('bolt/model').Model;
var Collection = require('bolt/collection').Collection;

var SAME_CONVERSATION_THRESHOLD = 60 * 60 * 1000;
var Delimiter = core.createClass({ extend: Model });

var ClusteredCollection =  core.createClass({
  name: 'ClusteredCollection',
  extend: Collection,

  construct: function(baseCollection, options) {
    Collection.call(this, options);
    this.baseCollection = baseCollection;
    this.dlmt = [];
    if (this.baseCollection.models.length > 0) {
      this.baseKlassName = this.baseCollection.models[0].getDeclaredClass();
      this.baseCollection.at(0).set('_base_idx', 0, true);
      this.add(this.baseCollection.at(0), true);
      this.dlmt.push(0);
      var len = 1;
      var dlmtAdd = 0;
      for (var i = 1; i < this.baseCollection.models.length; i++) {
        var model = this.baseCollection.at(i);
        model.set('_base_idx', i, true);
        var timestamp = model.get('timestamp');
        if (!this.isSameCluster(
               this.models[len - 1].get('timestamp'),
               timestamp)) {
          dlmtAdd = 1;
          this.add(
            new Delimiter({
              delimiter: this.models[len - 1].get('timestamp')
            }),
            true
          );
          len++;
        }
        this.add(model, true);
        this.dlmt.push(this.dlmt[i - 1] + dlmtAdd);
        dlmtAdd = 0;
        len++;
      }

      this.add(
        new Delimiter({
          delimiter: this.models[len - 1].get('timestamp')
        }),
        true
      );
    }

    this.baseCollection.addListener('modelAdded',
      this.onBaseModelAdded, this);
    this.baseCollection.addListener('modelRemoved',
        this.onBaseModelRemoved, this);
  },

  onBaseModelAdded: function(evt) {
    var model = evt.data.model;
    if (!this.baseKlassName) {
      this.baseKlassName = model.getDeclaredClass();
    }
    var prevTimestamp, nextTimestamp, prevModel, nextModel;
    var timestamp = model.get('timestamp');

    // Possible cases are:
    // 1: New model at the position 0
    // 2: New model at the very end
    // 3: Surrounding models are both not delimiters
    // 4: Previous model is delimiter, next isn't

    var baseIdx = evt.data.index;
    model.set('_base_idx', baseIdx);

    if (baseIdx === 0) {
      // Case 1
      if (this.length > 0) {
        nextTimestamp = this.models[0].get('timestamp');
        if (!this.isSameCluster(timestamp, nextTimestamp)) {
          this.addModelWithDelimiterAt(model, 0);
        } else {
          this.addModelAt(model, 0);
        }
      } else {
        this.addModelWithDelimiterAt(model, 0);
      }
    } else if (baseIdx === (this.dlmt.length)) {
      // Case 2
      prevModel = this.models[this.length - 1];
      prevTimestamp = prevModel.get('delimiter');
      if (!this.isSameCluster(prevTimestamp, timestamp)) {
        // New cluster
        this.addModelWithDelimiterAt(model, this.length);
      } else {
        // Same cluster
        this.removeDelimiterAt(this.length - 1);
        this.addModelWithDelimiterAt(model, this.length);
      }
    } else {
      var ourIdx = baseIdx + this.dlmt[baseIdx];

      prevModel = this.models[ourIdx - 1];
      nextModel = this.models[ourIdx];
      var prevIsDelimiter = this.isDelimiter(prevModel);
      var nextIsDelimiter = this.isDelimiter(nextModel);
      if (!prevIsDelimiter && !nextIsDelimiter) {
        // Case 3
        this.addModelAt(model, ourIdx);
      } else if (prevIsDelimiter && !nextIsDelimiter) {
        // Case 4
        prevTimestamp = prevModel.get('delimiter');
        nextTimestamp = nextModel.get('timestamp');
        if (this.isSameCluster(timestamp, prevTimestamp) &&
              this.isSameCluster(timestamp, nextTimestamp)) {
          // This new model connects two clusters into one
          this.removeDelimiterAt(ourIdx - 1);
          this.addModelAt(model, ourIdx - 1);
        } else if (this.isSameCluster(timestamp, prevTimestamp) &&
                    !this.isSameCluster(timestamp, nextTimestamp)) {
          // This new model belongs to the previous cluster
          this.addModelAt(model, ourIdx - 1);
          prevModel.set('delimiter', timestamp);
        } else if (!this.isSameCluster(timestamp, prevTimestamp) &&
                      this.isSameCluster(timestamp, nextTimestamp)) {
          // This new model belongs to the next cluster
          this.addModelAt(model, ourIdx);
        } else if (!this.isSameCluster(timestamp, prevTimestamp) &&
                     !this.isSameCluster(timestamp, nextTimestamp)) {
          // This new model makes a new cluster
          this.addModelWithDelimiterAt(model, ourIdx);
        }
      }
    }
  },

  onBaseModelRemoved: function (evt) {
    var model = evt.data.model;
    var prevTimestamp, nextTimestamp, prevModel, nextModel;
    var timestamp = model.get('timestamp');
    var baseIdx = evt.data.index;

    if (baseIdx === 0) {
      nextModel = this.models[1];
      if (this.isDelimiter(nextModel)) {
        this.removeDelimiterAt(1);
      }
      this.removeModelAt(0);
    } else {
      var ourIdx = baseIdx + this.dlmt[baseIdx];
      prevModel = this.models[ourIdx - 1];
      nextModel = this.models[ourIdx + 1];
      var prevIsDelimiter = this.isDelimiter(prevModel);
      var nextIsDelimiter = this.isDelimiter(nextModel);
      if (prevIsDelimiter && nextIsDelimiter) {
        this.removeDelimiterAt(ourIdx + 1);
        this.removeModelAt(ourIdx);
      } else if (prevIsDelimiter && !nextIsDelimiter) {
        this.removeModelAt(ourIdx);
      } else if (!prevIsDelimiter && nextIsDelimiter) {
        this.removeModelAt(ourIdx);
        nextModel.set('delimiter', prevModel.get('timestamp'));
      } else if (!prevIsDelimiter && !nextIsDelimiter) {
        prevTimestamp = prevModel.get('timestamp');
        nextTimestamp = nextModel.get('timestamp');
        if (this.isSameCluster(prevTimestamp, nextTimestamp)) {
          this.removeModelAt(ourIdx);
        } else {
          this.removeModelAt(ourIdx);
          this.addDelimiterAfterModel(prevModel, ourIdx);
        }
      }
    }
  },

  isDelimiter: function(model) {
    return model instanceof Delimiter;
  },

  isSameCluster: function(timestamp1, timestamp2) {
    return Math.abs(timestamp1 - timestamp2) <= SAME_CONVERSATION_THRESHOLD;
  },

  addModelAt: function(model, idx) {
    var dlmtValue;
    if (idx === 0) {
      dlmtValue = 0;
    } else if (idx < this.length) {
      if (!this.isDelimiter(this.models[idx])) {
        dlmtValue = this.dlmt[this.models[idx].get('_base_idx')];
      } else {
        dlmtValue = this.dlmt[this.models[idx - 1].get('_base_idx')];
      }
    } else {
      if (!this.isDelimiter(this.models[idx - 1])) {
        dlmtValue = this.dlmt[this.models[idx - 1].get('_base_idx')];
      } else {
        dlmtValue = this.dlmt[this.models[idx - 2].get('_base_idx')] + 1;
      }
    }

    var cid = model.cid;
    var id = model.id;
    if (idx === 0) {
      this.models.unshift(model);
    } else {
      this.models.splice(idx, 0, model);
    }
    this._byCid[cid] = model;
    if (model.id !== null) {
      this._byId[id] = model;
    }
    this.length++;
    this._listeners[cid] =
      model.addListener('changed', this._onModelChanged, this);

    this.dlmt.splice(idx - dlmtValue, 0, dlmtValue);

    var value;

    for (var i = idx + 1; i < this.length; i++) {
      if (!this.isDelimiter(this.models[i])) {
        value = this.models[i].get('_base_idx');
        this.models[i].set('_base_idx',  value + 1, true);
      }
    }
    this.invoke('modelAdded', {model: model, index: idx});
  },

  addModelWithDelimiterAt: function(model, idx) {
    this.addModelAt(model, idx);
    var delimiter = new Delimiter({delimiter: model.get('timestamp')});

    var cid = delimiter.cid;
    var id = delimiter.id;

    this.models.splice(idx + 1, 0, delimiter);
    this._byCid[cid] = delimiter;
    if (delimiter.id !== null) {
      this._byId[id] = delimiter;
    }
    this.length++;
    this._listeners[cid] =
      delimiter.addListener('changed', this._onModelChanged, this);

    for (var i = model.get('_base_idx') + 1; i < this.dlmt.length; i++) {
      this.dlmt[i]++;
    }

    this.invoke('modelAdded', {model: delimiter, index: idx + 1});
  },

  addDelimiterAfterModel: function(model, idx) {
    var delimiter = new Delimiter({delimiter: model.get('timestamp')});

    var cid = delimiter.cid;
    var id = delimiter.id;

    this.models.splice(idx, 0, delimiter);
    this._byCid[cid] = delimiter;
    if (delimiter.id !== null) {
      this._byId[id] = delimiter;
    }
    this.length++;
    this._listeners[cid] =
      delimiter.addListener('changed', this._onModelChanged, this);

    for (var i = model.get('_base_idx') + 1; i < this.dlmt.length; i++) {
      this.dlmt[i]++;
    }

    this.invoke('modelAdded', {model: delimiter, index: idx});
  },

  removeModelAt: function(idx) {
    var model = this.models[idx];
    var baseIdx = model.get('_base_idx');
    var value;
    for (var i = idx + 1; i < this.length; i++) {
      if (!this.isDelimiter(this.models[i])) {
        value = this.models[i].get('_base_idx');
        this.models[i].set('_base_idx',  value - 1, true);
      }
    }
    this.dlmt.splice(baseIdx, 1);

    this.remove(model);
  },

  removeDelimiterAt: function(idx) {
    var model = this.models[idx];
    var prevModel = this.models[idx - 1];
    for (var i = prevModel.get('_base_idx') + 1; i < this.dlmt.length; i++) {
      this.dlmt[i]--;
    }

    this.remove(model);
  },

  getBaseCollection: function() {
    return this.baseCollection;
  }
});

exports.ClusteredCollection = ClusteredCollection;
});

// module: shared/dialogs
// file:   ../../shared/js/dialogs.js
define("shared/dialogs", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var util = require('bolt/util');
var EventManager = require('shared/event_manager').EventManager;

/**
 * Used to display modeless/modal dialogs.
 *
 * The dialog.RESULT_RECEIVED event
 * is broadcasted when a modal dialog returns, containing the dialog id and
 * result. Note that if no result is specified for an action, or if the dialog
 * is dismissed by the user tapping the background, or if dismiss() is called
 * on the dialog without specifying a result, 0 is returned. It then makes
 * sense that 0 should be the value of the default action for each dialog.
 * In most cases, this should be the Cancel action, but depending on the
 * situation, others might be more appropriate.
 *
 * Modal example:
 * var dialogUtil = require('shared/dialogs');
 *
 * // listen for results
 * var handleModalResult = function(data) {
 *   if (data.id == id) {
 *     if (data.result) {
 *       console.log('Time to snooze!');
 *       console.log('Reason: ' + data.formData.snoozeReason);
 *     } else {
 *       console.log('Waking up...');
 *     }
 *   }
 *   id = undefined;
 * };
 * EventManager.listen('dialog.RESULT_RECEIVED', handleModalResult);
 *
 * // create and display dialog
 * var id = dialogUtil.createDialog();
 * dialogUtil.appendText(id, 'Alarm Activated',
 *   'font-weight: bold; font-size: 20pt; text-align: center; display: block');
 * dialogUtil.appendText(id, 'It's time to wake up! Any reason to snooze?',
 *   'margin-left: 10px; display: block;');
 * dialogUtil.appendInput(id, 'snoozeReason', 'text', '5 more minutes...',
 *   'margin-left: 10px;');
 * var actions = [
 *   {
 *     value: 'Dismiss',
 *     result: 0
 *   },
 *   {
 *     value: 'Snooze',
 *     result: 1
 *   }
 * ];
 * dialogUtil.showModalDialog(id, actions);
 *
 * Modeless example:
 * var dialogUtil = require('shared/dialogs');
 *
 * var id = dialogUtil.createDialog();
 * dialogUtil.appendImage(id,
 *   'http://bit.ly/mu38z1', 'float: left; margin: 0 10px 0 0;');
 * dialogUtil.appendText(id,
 *   'Modeless test dialog title!', 'font-weight: bold; display: block;');
 * dialogUtil.appendText(id, 'Test message');
 * dialogUtil.showModelessDialog(id, 'http://www.example.com/');
 */

// dialog types used by showSpecialDialog()
exports.TYPE_BATTERY_LOW = 'battery-low';
exports.TYPE_CALL_MMI = 'call-mmi';
exports.TYPE_CALL_NUMBER = 'call-number';
exports.TYPE_DISABLE_AIRPLANE_MODE = 'disable-airplane-mode';
exports.TYPE_FILE_CHOOSER = 'file-chooser';
exports.TYPE_GLOBAL_ACTIONS = 'global-actions';
exports.TYPE_IMAGE_ACTIONS = 'image-actions';
exports.TYPE_INVALID_VOICEMAIL = 'invalid-voicemail';
exports.TYPE_JS_ALERT = 'js-alert';
exports.TYPE_JS_BEFORE_UNLOAD = 'js-before-unload';
exports.TYPE_JS_CONFIRM = 'js-confirm';
exports.TYPE_JS_PROMPT = 'js-prompt';
exports.TYPE_LINK_ACTIONS = 'link-actions';
exports.TYPE_PERM_GEOLOCATION = 'perm-geolocation';
exports.TYPE_PERM_STORAGE = 'perm-storage';
exports.TYPE_SHUTTING_DOWN = 'shutting-down';
exports.TYPE_SIM_LOCKED = 'sim-locked';
exports.TYPE_VOLUME_CHANGE = 'volume-change';
exports.TYPE_NO_CONNECTIVITY = 'no-connectivity';
exports.TYPE_DEV_CONSOLE = 'dev-console';
exports.TYPE_INSTALL_APP = 'install-app';
exports.TYPE_PLATFORM_AUTH = 'platform-auth';

var _showDialogScreen = function() {
  EventManager.broadcastEvent('dialog.SHOW_DIALOG_SCREEN', {});
};

var _hideDialogScreen = function() {
  EventManager.broadcastEvent('dialog.HIDE_DIALOG_SCREEN', {});
};

/**
 * Gets a unique ID number for a new dialog. IMPORTANT NOTE:
 * IDs are generated using Bolt's generateUUID(). There is an
 * approximate 4*10^36 chance of any two colliding. Given that
 * we expect a relatively low number of dialogs to be active at
 * any given time, this should not be an issue.
 */
var _getId = function() {
  return util.generateUUID();
};

/**
 * Retrieves the contents of a dialog and then deletes them. This means each
 * dialog can only be displayed once, preventing possible bugs from unintended
 * reuse of IDs.
 * @param id the ID of the dialog to retrieve contents for
 * @return the contents of the dialog
 */
var _getAndDeleteContents = function(id) {
  if ((typeof dialogContents[id]) === undefined) {
    throw ('Dialog ID is not registered:' + id);
  }

  var contents = dialogContents[id];
  delete dialogContents[id];
  return contents;
};

var dialogContents = {};

/**
 * Creates a new, blank dialog with a unique ID. This ID is used to
 * construct the contents of the dialog, then display it
 * @return the ID of the newly-created dialog
 */
exports.createDialog = function() {
  var id = _getId();
  dialogContents[id] = [];
  return id;
};

var _appendContent = function(id, content) {
  if ((typeof dialogContents[id]) === undefined) {
    console.error('Dialog ID is not registered', id);
    return;
  }
  if ((typeof content.style) === undefined) {
    delete content.style;
  }
  dialogContents[id].push(content);
};

exports.appendTitle = function(id, title) {
  _appendContent(id, {
    tagName: 'div',
    content: title,
    style:
      'padding: 10px; font-weight: bold; font-size: 30pt; ' +
      'text-align: center; white-space: normal; word-wrap: break-word;'
  });
};

/**
 * Appends a span of text to the dialog content
 * @param id the ID of the dialog to append to
 * @param text the text to append
 * @param css (optional) the CSS to style the element with
 */
exports.appendText = function(id, text, css) {
  _appendContent(id, {
    tagName: 'span',
    content: text,
    style: css
  });
};

/**
 * Appends an image to the dialog content
 * @param id the ID of the dialog to append to
 * @param src the URL of the image
 * @param css (optional) the CSS to style the element with
 */
exports.appendImage = function(id, src, css) {
  _appendContent(id, {
    tagName: 'img',
    src: src,
    style: css
  });
};

/**
 * Appends an input element to the dialog content
 * @param id the ID of the dialog to append to
 * @param name the name of the input element
 * @param type (optional) the type attribute passed to the input element
 * @param placeholder (optional) the placeholder text for text inputs
 * @param css (optional) the CSS to style the element with
 */
exports.appendInput = function(id, name, type, placeholder, css) {
  var options = {
      view: 'TextInput',
      name: name
  };
  if (type) {
    options.type = type;
  }
  if (placeholder) {
    options.placeholder = placeholder;
  }
  if (css) {
    options.style = css;
  }

  _appendContent(id, options);
};

// TODO add support for clearable text inputs

/**
 * Displays the dialog content associated with the specified ID as a modal
 * dialog. Once the dialog has been displayed, the ID should not be reused
 * to display another dialog.
 * @param id the ID of the dialog to display (from createDialog())
 * @param actions A JSON array of action buttons. Ex:
 * [
 *   {
 *     value: 'OK',
 *     result: 1
 *   },
 *   {
 *     value: 'Cancel',
 *     result: 0
 *   }
 * ]
 * If a result is not specified for an action, it will default to 0.
 * If no actions are specified, a single OK button will be displayed.
 * @param dismissible (optional) Allows the user to dismiss the dialog if they
 * touch outside of the dialog; essentially a cancel button.
 * Defaults to true.
 */
exports.showModalDialog = function(id, actions, dismissible) {
  var contents = _getAndDeleteContents(id);

  EventManager.broadcastEvent('dialog.SHOW_MODAL', {
    id: id,
    content: JSON.stringify(contents),
    actions: JSON.stringify(actions),
    dismissible: dismissible
  });
  _showDialogScreen();
};

/**
 * Displays the dialog content associated with the specified ID as a modeless
 * dialog. Once the dialog has been displayed, the ID should not be reused
 * to display another dialog.
 * @param id the ID of the dialog to display (from createDialog())
 * @param actionUrl the URL to launch if the user taps the dialog
 * @param dismissible (optional) Allows user to specify whether the modeless
 * dialog can be dismissed by the user by tapping out of the dialog
 * Set to true on default.
 * If this is set to false, the app that uses this dialog must be responsible
 * for dismissing the dialog because the user would not be able to.
 */
exports.showModelessDialog = function(id, actionUrl, dismissible) {
  var contents = _getAndDeleteContents(id);

  EventManager.broadcastEvent('dialog.SHOW_MODELESS', {
    id: id,
    content: JSON.stringify(contents),
    actions: actionUrl,
    dismissible: dismissible
  });
  _showDialogScreen();
};

/**
 * Used to show a specialized system dialog.
 * @param type one of the variables TYPE_*
 * @param options a JSON object of options for special dialogs
 * @param responder the DialogResponder for the system dialog
 * @return the id for the system dialog
 */
exports.showSpecialDialog = function(type, options) {
  var id = _getId();
  EventManager.broadcastEvent('dialog.SHOW_SPECIAL', {
    id: id,
    type: type,
    specialDlgOptions: options
  });
  _showDialogScreen();
  return id;
};

/**
 * Dismisses a dialog. This should not normally be called by your code,
 * as the dialog dismisses itself automatically. Examples to use it anyway:
 * - After displaying a dialog for a Bluetooth pairing request, the request
 *   is cancelled.
 * - After displaying a dialog for an alarm, the alarm plays for too long
 *   without user activity, so it automatically deactivated.
 * @param id the ID of the dialog to dismiss
 * @param result (optional) the result the dialog was dismissed with (default 0)
 * @param formData (optional) a JSON object containing the key/value pairs of
 *   any input elements (added with appendInput) included on the dialog
 */
exports.dismiss = function(id, result, formData) {
  var data = {
    id: id
  };
  if (result) {
    data.result = result;
  } else {
    data.result = 0;
  }
  if (formData) {
    data.formData = formData;
  }

  EventManager.broadcastEvent('dialog.RESULT_RECEIVED', data);
};
});

// module: bolt_touch/mixins/table_view_collection_source
// file:   ../../../frameworks/bolt_touch/lib/mixins/table_view_collection_source.js
define("bolt_touch/mixins/table_view_collection_source", function(require, exports, module) {
var imageQueue = require('../util/image_queue');
var util       = require('bolt/util');

var DEFAULT_REUSE_IDENTIFIER = 'cell';

/**
 * Mixin for a TableView owner implementation.  This will allow the owner to
 * support multiple TableViews (through sections), but also provides relatively easy
 * accessors to a "default" TableView.
 */
exports.TableViewCollectionSource = {

  /**
   * Returns the cell reuseIdentifier that will be used for the default
   * TableView
   */
  getCellReuseIdentifier: function() {
    return this.getCellReuseIdentifierForSection(0);
  },

  /**
   * Sets the cell reuseIdentifier that will be used for the default TableView
   */
  setCellReuseIdentifier: function(reuseIdentifier) {
    this.setCellReuseIdentifierForSection(0, reuseIdentifier);
  },

  /**
   * Gets the cell reuseIdentifier for a TableView section
   */
  getCellReuseIdentifierForSection: function(section) {
    return (this._sectionCellReuseIdentifiers &&
      this._sectionCellReuseIdentifiers[section]) || DEFAULT_REUSE_IDENTIFIER;
  },

  /**
   * Sets the cell reuseIdentifier that will be used for a TableView section
   */
  setCellReuseIdentifierForSection: function(section, reuseIdentifier) {
    this._sectionCellReuseIdentifiers =
      this._sectionCellReuseIdentifiers || {};
    this._sectionCellReuseIdentifiers[section] = reuseIdentifier;
  },

  /**
   * Gets the collection for the TableView
   */
  getCollection: function() {
    return this.getCollectionForSection(0);
  },

  /**
   * Specifies a collection which takes up all of an unsectioned TableView
   * Removes all old collection data and sets up the appropriate listeners to
   * update the TableView based on this collection.
   */
  setCollection: function(collection) {
    this.removeAllCollections();
    this._numSections = 1;
    this.setCollectionForSection(0, collection);
  },

  /**
   * Specifies a list of collections each of which get their own section in the
   * TableView to be displayed in. Removes all old collection data and sets up
   * the appropriate listeners to update the TableView based on these
   * collections.
   */
  setCollections: function(collections) {
    this.removeAllCollections();
    this._numSections = 0;
    for (var i = 0, l = collections.length; i < l; ++i) {
      this.setCollectionForSection(i, collections[i]);
      ++this._numSections;
    }
  },

  /**
   * Gets the collection for a TableView section
   */
  getCollectionForSection: function(section) {
    return this._collections ? this._collections[section] : null;
  },

  /**
   * Sets the collection for a TableView section
   */
  setCollectionForSection: function(section, collection) {
    this._collections = this._collections || [];
    var oldCollection = this._collections[section];
    if (oldCollection !== collection) {
      if (oldCollection) {
        this.removeCollectionEventListeners(section);
      }
      this._collections[section] = collection;
      collection._section = section;
      if (collection) this.addCollectionEventListeners(collection, section);
    }
  },

  /**
   * Gets the TableView section for a collection
   */
  getSectionForCollection: function(collection) {
    return collection._section;
  },

  /**
   * Sets the default TableView
   */
  setTableView: function(tableView) {
    this._tableView = tableView;
  },

  getTableView: function() {
    return this._tableView;
  },

  /**
   * Pause the imageQueue (keep track of whether we did anything)
   */
  didScrollStart: function(tableView) {
    if (!imageQueue.isPaused()) {
      this._shouldResumeImageQueue = true;
      imageQueue.pause();
    }
  },

  /**
   * Only turn imageQueue back on if we were responsible for pausing it
   */
  didScrollEnd: function(tableView) {
    if (this._shouldResumeImageQueue) {
      imageQueue.run();
    }
  },

  numberOfSections: function(tableView) {
    return this._numSections || 0;
  },

  numberOfRowsInSection: function(tableView, section) {
    var collection = this.getCollectionForSection(section);
    return (
      collection ?
      (
        this.numberOfExtraTopRowsInSection(tableView, section) +
        collection.length +
        this.numberOfExtraBottomRowsInSection(tableView, section)
      ) :
      0
    );
  },

  /**
  * Allows you to specify a number of static cells to include at the bottom of a
  * section
   */
  numberOfExtraBottomRowsInSection: function(tableView, section) {
    return 0;
  },

  /**
   * Allows you to specify a number of static cells to include at the top of a
   * section
   */
  numberOfExtraTopRowsInSection: function(tableView, section) {
    return 0;
  },

  /**
   * Default implementation of cellForRowInSection.  This will get the model
   * from the collection for the TableView and return cellForCollectionModel.
   */
  cellForRowInSection: function(tableView, row, section) {
    var collection = this.getCollectionForSection(section);
    var numberOfExtraTopRows =
      this.numberOfExtraTopRowsInSection(tableView, section);
    var model = (
      row < numberOfExtraTopRows ?
      null :
      collection && collection.at(row - numberOfExtraTopRows)
    );
    return (
      model ?
      this.cellForCollectionModel(tableView, model, row, section) :
      this.createExtraTableViewCell(tableView, row, section)
    );
  },

  /**
   * This method will follow the common patterns for creating a cell from a
   * collection model.  You can override here or at the sub-steps of this flow
   * (createTableViewCell, createExtraTableViewCell)
   */
  cellForCollectionModel: function(tableView, model, row, section) {
    var reuseIdentifier = this.getCellReuseIdentifierForSection(section);
    var cell = tableView.dequeueReusableCellWithIdentifier(reuseIdentifier);
    if (!cell) {
      cell = this.createTableViewCell(
        tableView,
        model,
        row,
        section
      );
      cell && cell.setReuseIdentifier(reuseIdentifier);
    }
    cell.setModel(model);
    return cell;
  },

  /**
   * Override this method to construct a cell
   */
  createTableViewCell: function(tableView, model, row, section) {
    return null;
  },

  /**
   * Override this method to add a cell for rows that do not have a matching
   * model (specifically if you override numberOfExtra[Top|Bottom]RowsInSection)
   */
  createExtraTableViewCell: function(tableView, row, section) {
    return null;
  },

  /**
   * Adds all collection event listeners for the section or collection
   */
  addCollectionEventListeners: function(collection, section) {
    collection._isHeaderHidden = collection.length === 0;
    var eventName, handler, i, l;
    this._collectionListeners = this._collectionListeners || [];
    var listeners = this._collectionListeners[section] = [];
    listeners.push(
      collection.addListener('all', util.bind(this.handleEvent, this, collection)));
  },

  handleEvent: function(collection, evt) {
    var data = evt.data;
    switch (evt.type) {
      case 'modelChanged':
        this.processModelChanged(collection, data);
        break;
      case 'modelRemoved':
        this.processModelRemoved(collection, data);
        break;
      case 'modelAdded':
        this.processModelAdded(collection, data);
        break;
      case 'beginUpdate':
        this.processBeginUpdate(collection);
        break;
      case 'endUpdate':
        this.processEndUpdate(collection);
        break;
      case 'updated':
        this.processUpdated(collection);
        break;
      default:
        break;
    }
  },

  /**
   * Removes all collection event listeners for the section
   */
  removeCollectionEventListeners: function(section) {
    this._collectionListeners = this._collectionListeners || [];
    var listeners = this._collectionListeners[section];
    if (listeners) {
      for (i = 0, l = listeners.length; i < l; ++i) {
        listeners[i].remove();
      }
      listeners.splice(0, listeners.length);
    }
    delete this._collectionListeners[section];
  },

  /**
   * Removes all event listeners for collections and all mapping between
   * sections and collections.
   */
  removeAllCollections: function() {
    for (var i = 0, l = this._numSections; i < l; ++i) {
      delete this._collections[i]._section;
      this.removeCollectionEventListeners(i);
    }
    this._collections = [];
  },

  checkAndUpdateHeader: function(section, collection) {
    if ((collection._isHeaderHidden && collection.length > 0) ||
        (!collection._isHeaderHidden && collection.length === 0)) {
      var tableView = this.getTableView();
      tableView && tableView.reloadRowInSection(undefined, section);
      collection._isHeaderHidden = collection.length === 0;
    }
  },

  processBeginUpdate: function(collection) {
    var tableView = this.getTableView();
    tableView && tableView.beginUpdates();
  },

  processEndUpdate: function(collection) {
    var tableView = this.getTableView();
    tableView && tableView.endUpdates();
  },

  processModelAdded: function(collection, data) {
    var tableView = this.getTableView();
    var section = this.getSectionForCollection(collection);
    var row = data.index +
      this.numberOfExtraTopRowsInSection(tableView, section);
    tableView && tableView.insertRowInSection(row, section);
    this.checkAndUpdateHeader(section, collection);
  },

  processModelRemoved: function(collection, data) {
    var tableView = this.getTableView();
    var section = this.getSectionForCollection(collection);
    var row = data.index +
      this.numberOfExtraTopRowsInSection(tableView, section);
    tableView && tableView.removeRowInSection(row, section);
    this.checkAndUpdateHeader(section, collection);
  },

  processModelChanged: function(collection, data) {
    var tableView = this.getTableView();
    var section = this.getSectionForCollection(collection);
    var row = data.index +
      this.numberOfExtraTopRowsInSection(tableView, section);
    tableView && tableView.reloadRowInSection(row, section);
  },

  processUpdated: function(collection) {
    var tableView = this.getTableView();
    tableView && tableView.refresh();
  }
};
});

// module: bolt/binding
// file:   ../../../frameworks/bolt/lib/binding.js
define("bolt/binding", function(require, exports, module) {
/**
 * Copyright (c) 2011-2012, Facebook, Inc.
 * All rights reserved.
 *
 * @option preserve-header
 *
 * The Binding class controls the connection between a Model and a View.
 *
 * When the specified property on the model is updated, the corresponding
 * property on the view is also updated.
 *
 * It is also possible to listen to events on the View, which when fired
 * retrieves the latest value from the View and updates the model.
 *
 * Usually this class is not created directly, and is instead constructed
 * by calling the setBinding function of a View.
 *
 * The Binding constructor takes the model and view as arguments as well as an
 * options object containing:
 * - modelProperty: the name of the property of the model
 * - viewProperty: the name of the property on the view
 * - property: If the name of the model and view property are equal, which
 *   is often the case, simply specify this value instead of modelProperty and
 *   viewProperty.
 * - viewEvent: the event on the View to listen to in order to update the
 *   model. Can be either a String or an array of Strings.
 * - sync: A Boolean. If false, the View is not immediately updated with
 * its corresponding model value. Otherwise it is.
 */
var util   = require('./util');
var core   = require('./core');
var getter = util.getter;
var setter = util.setter;

var Binding = exports.Binding = core.createClass({
  name: 'Binding',

  properties: {
    // the model to bind to
    model: null,

    // the model property to bind to
    modelProperty: 'value',

    // the view to bind to
    view: null,

    // the view event to listen for
    // note that the model event is `changed`
    // by default we don't listen to any view event
    viewEvent: null,

    // the view property to bind to
    viewProperty: 'value',

    // shortcut for setting both view and model property when they are the same
    property: 'value'
  },

  /**
   * Create a new Binding to synchronize state between a view and a model
   * @constructor
   *
   * @param {View} view The view to bind to
   * @param {Model} model The model to bind
   * @param {Object} options The options to use in binding
   * @param {String} options.modelProperty The model property to bind to
   * @param {String} options.viewProperty The view property to bind to
   * @param {String} options.property A shortcut for setting both the model
   *   and view property when they are the same
   * @param {String} options.viewEvent the event from the view that should
   *   trigger the binding to sync
   *
   * note that the model event is always `changed`
   */
  construct: function(view, model, options) {
    options = options || {};
    this.setView(view);
    this.setModel(model);

    // default the modelProperty and viewProperty to property if not specified
    if (options.property && !options.modelProperty && !options.viewProperty) {
      options.modelProperty = options.viewProperty = options.property;
    }

    this._modelPropertyIsFunction = util.isFunction(options.modelProperty);

    // if we don't specify a viewEvent but there's a setter on the
    // model property, set view event to 'change'.
    // TODO:wbailey - we need to discuss if we really want this default
    //                behavior. This is potentially pretty expensive and
    //                I don't understand fully why the presence of a model
    //                setter should trigger this default.
    if (!('viewEvent' in options) &&
      !this._modelPropertyIsFunction &&
      util.setter(options.modelProperty) in model) {
      options.viewEvent = 'change';
    }

    var sync = options.sync;
    delete options.sync;

    // setup the rest of the options
    for (var name in options) {
      if (typeof options[name] !== 'undefined') {
        this[util.setter(name)](options[name]);
      }
    }

    // TODO: wrap this and only include in development mode
    // check to make sure this is a valid binding before setting up listeners
    var validModelProperty = (this._modelPropertyGetter &&
      this._modelPropertySetter) || this._modelPropertyIsFunction;
    if (!this._model || !this._view || !this._viewPropertyGetter ||
      !validModelProperty) {
      this.destroy();
      throw 'invalid binding: require properties not specified';
    }

    // add listeners for view events
    var viewEvent = this.getViewEvent();

    if (viewEvent) {
      if (typeof viewEvent === 'string' || viewEvent instanceof String) {
        viewEvent = viewEvent.split(/\s+/);
      }

      this._viewBoundEventTypes = [];

      for (var i = 0, ev, len = viewEvent.length; i < len; i++) {
        ev = viewEvent[i];
        if (ev) {
          this._view.addListener(ev, this.updateModel, this);
          this._viewBoundEventTypes.push(ev);
        }
      }
    }

    // add a listener for the model event
    this._modelBound = this.getModel();
    this._modelBound.addListener('changed', this.updateView, this);

    // if the sync property is set then we should immediately synchronize
    // the model and the view.
    if (sync !== false) {
      this.setViewValue(this.getModelValue());
    }
  },

  /**
   * store the view and cache it for internal fast lookups
   * @param {View} view The view to bind the model to
   */
  setView: function(view) {
    if (this._view) {
      this._view.removeBinding();
    }
    this._view = view;
    this.set('view', view);
  },

  /**
   * store the model and cache it for internal fast lookups
   * @param {Model} model The model to bind the view to
   */
  setModel: function(model) {
    this.set('model', model);
    this._model = model;
  },

  /**
   * store the model property and cache it for internal fast lookups
   * @param {String} proeprty the model property to bind to
   */
  setModelProperty: function(property) {
    this.set('modelProperty', property);
    // bindings allow inline functions to serve as model properties for
    // transforming state before passing it to the view.
    this._modelPropertyIsFunction = util.isFunction(property);
    this._modelProperty = property;
    if (!this._modelPropertyIsFunction) {
      this._modelPropertyGetter = getter(property);
      this._modelPropertySetter = setter(property);
    }
  },

  /**
   * store the view property and cache it for internal fast lookups
   * @param {String} proeprty the view property to bind to
   */
  setViewProperty: function(property) {
    this.set('viewProperty', property);
    this._viewProperty = property;
    this._viewPropertyGetter = getter(property);
    this._viewPropertySetter = setter(property);
  },

  /**
   * destroy the binding and clean up its observers
   */
  destroy: function() {
    if (this.isDestroyed) {
      return;
    }
    this.isDestroyed = true;

    if (this._viewBoundEventTypes && this._view) {
      for (var i = 0, len = this._viewBoundEventTypes.length; i < len; i++) {
        this._view.removeListener(
          this._viewBoundEventTypes[i],
          this.updateModel,
          this
        );
      }
      this._viewBoundEventTypes = null;
    }

    this._modelBound.removeListener('changed', this.updateView, this);
    this._modelBound = null;

    this.setModel(null);
    this.setView(null);
    this.setModelProperty(null);
    this.setViewProperty(null);
  },

  /**
   * get the bound view value
   */
  getViewValue: function() {
    return this._view[this._viewPropertyGetter]();
  },

  /**
   * set the bound view value
   * @param value
   */
  setViewValue: function(value) {
    this._view[this._viewPropertySetter](value);
    return this;
  },

  /**
   * get the model value
   */
  getModelValue: function() {
    if (this._modelPropertyIsFunction) {
      // TODO: Replace context with the owner
      return this._modelProperty.call(null, this._model);
    }
    return this._model.getSafe(this._modelProperty);
  },

  /**
   * set the model value
   * @param value
   */
  setModelValue: function(value) {
    // inline model properties don't have setters yet
    if (!this._modelPropertyIsFunction) {
      this._model.setSafe(this._modelProperty, value);
    }
    return this;
  },

  /**
   * update the model state due to a change in view state
   * @param {Event} event the view event triggered by the state change
   */
  updateModel: function(event) {
    if (this.isDestroyed) {
      throw 'destroyed binding invoked';
    }
    // TODO: wbailey seems like we might want to be more strict about
    //       the api here. Right now bindings can silently fail due to a getter
    //       or setter not being implemented. I propose that we be explict and
    //       require a `one way` or `two way` property for each binding. Then
    //       if the appropriate getter/setter is not found we should throw.
    if (this._view[this._viewPropertyGetter]) {
      var viewValue = this.getViewValue();
      if (!util.isEqual(viewValue, this.getModelValue())) {
        this.setModelValue(viewValue);
      }
    }
  },

  /**
   * Update the view when a model state change is triggered
   * @param {Event} event the model event triggered by the state change
   */
  updateView: function(e) {
    var changedProperties = e.data.changedProperties;

    if (this.isDestroyed) {
      throw 'destroyed binding invoked';
    }
    if (changedProperties) {
      // this change is relevant if it directly changes the modelProperty that
      // we are bound to, or a derived property (which cannot be a base
      // property, and will always be evaluated on every model change)

      // TODO:wbailey we should try annotating our derived properties with the
      //              base properties they depend on so we can trigger bindings
      //              more selectively. Checkout how sproutcore does this.
      if (this._modelPropertyIsFunction ||
        changedProperties.hasOwnProperty(this._modelProperty) ||
        !this._model.isBaseProperty(this._modelProperty)) {

        var modelValue = this.getModelValue();
        if (this._view[this._viewPropertyGetter]) {
          if (!util.isEqual(this.getViewValue(), modelValue)) {
            this.setViewValue(modelValue);
          }
        } else {
          this.setViewValue(modelValue);
        }
      }
    }
  }

});
});

// module: bolt/mixins/filterable_collection
// file:   ../../../frameworks/bolt/lib/mixins/filterable_collection.js
define("bolt/mixins/filterable_collection", function(require, exports, module) {
/**
 * Copyright (c) 2011-2012, Facebook, Inc.
 * All rights reserved.
 *
 * @option preserve-header
 *
 */

var Collection = require('../collection').Collection;
var util       = require('../util');

// _fcid is an incrementing unique id for filteredCollections. The purpose of
// this is to allow filters to be easily added and removed.
var _fcid = 0;

// Mixing in filtered collection allows you to pull automatically maintained
// subcollections from the parent collection.
//
// Whenever an item is added/removed/modified in the parent collection, the
// parent will execute its filters on the model and determine if it needs to
// be added or removed from any sub collections.

var FilterableCollection = exports.FilterableCollection = {

  // destroy a filtered collection that is no longer in use
  destroyFilteredCollection: function(filteredCollection) {
    delete this._filtersById[filteredCollection._fcid];
    this._filters = util.values(this._filtersById);
  },

  // return a filtered collection containing models based on the passed in
  // filter function. If a collectionClass is passed as the second argument
  // then the resulting collection will be based on that class.
  //
  // filteredCollections are automatically updated as data is
  // added/removed/modified in the parent collection.
  getCollectionByFilter: function(filter, collectionClass) {
    return this._getCollection({
      filter: filter,
      collectionClass: collectionClass
    });
  },

  // return a filtered collection with a limit. The limit is the max number
  // of items that can be in the collection at a given time. This is
  // maintained when items are added and removed from the collection.
  getCollectionByFilterWithLimit: function(filter, limit, collectionClass) {
    return this._getCollection({
      filter: filter,
      collectionClass: collectionClass,
      limit: limit
    });
  },

  _getCollection: function(options) {
    var filter = options && options.filter;
    var collectionClass = options && options.collectionClass;
    var limit = options && options.limit;

    // lazily initialize the filteredCollection capabilities the first time
    // a filter is requested
    if (!this._filterableCollectionInitialized) {
      this._initializeFilterableCollection();
    }

    var filteredCollection = new (collectionClass || Collection)();
    // we give each filteredCollection a unique id so they can easily
    // be cleaned up.
    filteredCollection._fcid = _fcid++;
    var _this = this;
    filteredCollection.destroy = function() {
      _this.destroyFilteredCollection(filteredCollection);
    };

    // if the parent collection is sorted and the new child collection
    // does not declare a comparator, inherit the comparator from the
    // parent collection.
    if (this.comparator && !filteredCollection.comparator) {
      filteredCollection.comparator = this.comparator;
    }

    // execute the filter over the models and set the filteredCollection to
    // include the initial set
    var models = this.filter(filter);
    if (limit && models.length > limit) {
      models.splice(limit, models.length - limit);
    }
    filteredCollection.replace(models, true);

    // filters are maintained in a hash for random access while removing. The
    // filters are iterated by the processFilterEvent method to handle each
    // received event.
    this._filtersById[filteredCollection._fcid] = {
      filterFunction: filter,
      filteredCollection: filteredCollection,
      filterLimit: limit
    };
    this._filters = util.values(this._filtersById);

    return filteredCollection;
  },

  // getFilteredCollectionByProperty sugars the process of creating a filter
  // function so that you can think of it terms of getting all items with a
  // certain property value into a collection
  //
  // e.g.
  // pool.getCollectionByProperty('thread_id', 1234);
  //
  // returns an automatically maintained collection of all items with thread_id
  // 1234
  getCollectionByProperty: function(property, value, collectionClass) {
    var filter = this._getPropertyFilter(property, value);
    return this.getCollectionByFilter(filter, collectionClass);
  },

  // getCollectionByPropertyWithLimit is an enhanced getCollectionByProperty
  // with the choice of specifying the limit of the items that could be
  // put into the collection.
  getCollectionByPropertyWithLimit: function(property, value,
    limit, collectionClass) {
      var filter = this._getPropertyFilter(property, value);
      return this.getCollectionByFilterWithLimit(filter,
        limit, collectionClass);
  },

  // Create a filter that finds items with property = value
  _getPropertyFilter: function(property, value) {
    return function(model) {
      return model.get(property) === value;
    };
  },

  // processFilterEvent is the single listener that handles moving models
  // into and out of child filtered sets based on the return value of each
  // filter
  processFilterEvent: function(evt) {
    switch (evt.type) {
      case 'updated':
        this.processUpdateEvent(evt);
        break;
      case 'modelChanged':
        this.processModelChangedEvent(evt);
        break;
      case 'modelRemoved':
        this.processModelRemovedEvent(evt);
        break;
      case 'modelAdded':
        this.processModelAddedEvent(evt);
        break;
      case 'beginUpdate':
      case 'endUpdate':
        // forward these events from the base collection
        for ( var i = 0, l = this._filters.length; i < l; ++i) {
          this._filters[i].filteredCollection.invoke(evt.type, evt.data);
        }
        break;
      default: break;
    }
  },


  // handle an update event -- recreate all filteredCollections
  processUpdateEvent: function(evt) {
    var filter, filterFunction, filteredCollection, filterLimit;
    for (var i = 0, len = this._filters.length; i < len; i++) {
      filter = this._filters[i];
      filterFunction = filter.filterFunction;
      filteredCollection = filter.filteredCollection;
      filterLimit = filter.filterLimit;

      if (evt.data.action === 'sort' && !filterLimit) {
        // the models are already in the filtered collection, so just sort it
        if (filteredCollection.comparator) {
          filteredCollection.sort();
        } else {
          var oldComparator = filteredCollection.comparator;
          filteredCollection.comparator = this.comparator;
          filteredCollection.sort();
          filteredCollection.comparator = oldComparator;
        }
      } else {
        var models = this.filter(filterFunction);
        if (filterLimit && models.length > filterLimit) {
          models.splice(filterLimit, models.length - filterLimit);
        }
        filteredCollection.replace(models);
      }
    }
  },

  // handle a change event -- add the model to any matching collections
  //                       -- remove the model from any non matching collections
  processModelChangedEvent: function(evt) {
    var filter, filterFunction, filteredCollection, filterLimit,
        model = evt.data.model, matches;
    for (var i = 0, len = this._filters.length; i < len; i++) {
      filter = this._filters[i];
      filterFunction = filter.filterFunction;
      filteredCollection = filter.filteredCollection;
      filterLimit = filter.filterLimit;

      // does the model in question match this filter
      matches = filterFunction(model);

      // add the model if it matches: (noop if it's already there)
      if (matches) {
        this._addWithFilter(filter, model);
      } else {
        this._removeWithFilter(filter, model);
      }
    }
  },

  // handle a remove event -- remove the model from all filtered collections
  processModelRemovedEvent: function(evt) {
    var model = evt.data.model;

    for (var i = 0, len = this._filters.length; i < len; i++) {
      this._removeWithFilter(this._filters[i], model);
    }
  },

  // handle an add event -- add the model to any matching filtered collections
  processModelAddedEvent: function(evt) {
    var model = evt.data.model;
    var index = evt.data.index;

    for (var i = 0, len = this._filters.length; i < len; i++) {
      this._addWithFilter(this._filters[i], model, index);
    }
  },

  _removeWithFilter: function(filter, model) {
    var filterFunction, filteredCollection, filterLimit;
    filterFunction = filter.filterFunction;
    filteredCollection = filter.filteredCollection;
    filterLimit = filter.filterLimit;

    if (filteredCollection.indexOf(model) !== -1) {
      filteredCollection.remove(model);
      if (filterLimit) {
        // find the next match and add it
        var j, l, lastInd, last, nextModel;
        last = filteredCollection.at(filteredCollection.length - 1);
        lastInd = this.indexOf(last);
        for (j = lastInd + 1, l = this.length; j < l; j++) {
          nextModel = this.at(j);
          if (filterFunction(nextModel)) {
            filteredCollection.add(nextModel);
            break;
          }
        }
      }
    }
  },

  _addWithFilter: function(filter, model, index) {
    var filterFunction, filteredCollection, filterLimit, matches;
    filterFunction = filter.filterFunction;
    filteredCollection = filter.filteredCollection;
    filterLimit = filter.filterLimit;

    // does the model in question match this filter
    matches = filterFunction(model);

    // add the model if it matches: (noop if it's already there)
    if (matches) {
      if (filteredCollection.indexOf(model) === -1 &&
          (filterLimit && filteredCollection.length === filterLimit)) {
        var last, lastInd, nextInd;
        last = filteredCollection.at(filteredCollection.length - 1);
        nextInd = filteredCollection.sortedIndex(
            model, filteredCollection.comparator);
        if (nextInd < filterLimit) {
          filteredCollection.add(model);
          filteredCollection.remove(last);
        }
      } else {
        filteredCollection.add(model);
      }
    }
  },

  // set up the hash for storing filters and add a listener to the parent
  // collection to allow routing of events to the sub collections
  _initializeFilterableCollection: function() {
    this._filtersById = {};
    this._filters = [];
    this._filterableCollectionInitialized = true;
    this.addListener('all', this.processFilterEvent, this);
  }

};
});

// module: photos/app/lib/view/expandable_photo/index
// file:   ../../photos/app/lib/view/expandable_photo/index.js
define("photos/app/lib/view/expandable_photo/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core            = require('bolt/core');
var util            = require('bolt/util');
var View            = require('bolt_touch/view').View;
var SpringAnimation = require('shared/springs').SpringAnimation;

var SpringyOpacityView = core.createClass({
  name: 'SpringyOpacityView',

  extend: View,

  mixins: [SpringAnimation],

  properties: {
    opacity: 1
  },

  springAnimation: {
    properties: ['opacity'],
    ruleFunction: '_computeTransform'
  },

  ready: function() {
    this.springAnimation.animator._springs[0].updateProperties({
      tolerance: 0.0001
    });
  },

  setSize: function(width, height) {
    this.setStyle({
      width: width + 'px',
      height: height + 'px'
    });
  },

  changeOpacity: function(startingOpacity, endingOpacity) {
    this.setOpacityDirect(startingOpacity);
    this.setOpacity(endingOpacity);
    this.startSpringAnimationNow();
  },

  _computeTransform: function(values) {
    return {
      opacity: Math.max(0, Math.min(1, values.opacity))
    };
  }
});

var SpringyScaleTranslateView = core.createClass({
  name: 'SpringyScaleTranslateView',

  extend: View,

  mixins: [SpringAnimation],

  properties: {
    scaleX: 1,
    scaleY: 1,
    translateX: 0,
    translateY: 0
  },

  springAnimation: {
    properties: ['scaleX', 'scaleY', 'translateX', 'translateY'],
    ruleFunction: '_computeTransform'
  },

  ready: function() {
    this.springAnimation.animator._springs[0].updateProperties({
      tolerance: 0.01
    });

    this.springAnimation.animator._springs[1].updateProperties({
      tolerance: 0.01
    });
  },

  setSize: function(width, height) {
    this.setStyle({
      width: width + 'px',
      height: height + 'px'
    });
  },

  transform: function(startingScaleX, startingScaleY, startingTranslateX, startingTranslateY, endingScaleX, endingScaleY, endingTranslateX, endingTranslateY) {
    this.setScaleXDirect(startingScaleX);
    this.setScaleYDirect(startingScaleY);
    this.setTranslateXDirect(startingTranslateX);
    this.setTranslateYDirect(startingTranslateY);

    this.setScaleX(endingScaleX);
    this.setScaleY(endingScaleY);
    this.setTranslateX(endingTranslateX);
    this.setTranslateY(endingTranslateY);
    this.startSpringAnimationNow();
  },

  _computeTransform: function(values) {
    return {
      WebkitTransform:
        'translate3d(' + Math.round(values.translateX) + 'px, ' +
                         Math.round(values.translateY) + 'px, 0) ' +
        'scale3d(' + values.scaleX + ', ' + values.scaleY + ', 1)'
    };
  }
});

var SpringyPhoto = core.createClass({
  name: 'SpringyPhoto',

  extend: View,

  mixins: [SpringAnimation],

  properties: {
    scaleX: 1,
    scaleY: 1,
    translateX: 0,
    translateY: 0
  },

  springAnimation: {
    properties: ['scaleX', 'scaleY', 'translateX', 'translateY'],
    ruleFunction: '_computeTransform'
  },

  declare: function() {
    return {
      childViews: [
        {
          view: SpringyScaleTranslateView,
          ref: 'photoWrapper',
          className: 'photoWrapper',
          childViews: [
            {
              ref: 'photo',
              tagName: 'img',
              className: 'photo'
            }
          ]
        }
      ]
    };
  },

  ready: function() {
    this.springAnimation.animator._springs[0].updateProperties({
      tolerance: 0.0001
    });

    this.springAnimation.animator._springs[1].updateProperties({
      tolerance: 0.0001
    });

    this.addListener('webkitAnimationEnd', this._animationEnd, this);
  },

  expand: function(photoUrl, photoWidth, photoHeight, thumbnailRect, backgroundRect) {
    this._animationType = 'expand';

    var data = this._getTransformData(
      photoWidth,
      photoHeight,
      thumbnailRect,
      backgroundRect
    );

    this._performTransform({
      photoUrl: photoUrl,

      bigWidth: data.bigWidth,
      bigHeight: data.bigHeight,

      startingScaleX: data.smallScaleX,
      startingScaleY: data.smallScaleY,
      startingTranslateX: data.smallTranslateX,
      startingTranslateY: data.smallTranslateY,
      startingPhotoScaleX: data.smallPhotoScaleX,
      startingPhotoScaleY: data.smallPhotoScaleY,
      startingPhotoTranslateX: data.smallPhotoTranslateX,
      startingPhotoTranslateY: data.smallPhotoTranslateY,

      endingScaleX: 1,
      endingScaleY: 1,
      endingTranslateX: data.bigTranslateX,
      endingTranslateY: data.bigTranslateY,
      endingPhotoScaleX: 1,
      endingPhotoScaleY: 1,
      endingPhotoTranslateX: data.bigPhotoTranslateX,
      endingPhotoTranslateY: data.bigPhotoTranslateY
    });
  },

  shrink: function(photoUrl, photoWidth, photoHeight, thumbnailRect, backgroundRect) {
    this._animationType = 'shrink';

    var data = this._getTransformData(
      photoWidth,
      photoHeight,
      thumbnailRect,
      backgroundRect
    );

    this._performTransform({
      photoUrl: photoUrl,

      bigWidth: data.bigWidth,
      bigHeight: data.bigHeight,

      startingScaleX: 1,
      startingScaleY: 1,
      startingTranslateX: data.bigTranslateX,
      startingTranslateY: data.bigTranslateY,
      startingPhotoScaleX: 1,
      startingPhotoScaleY: 1,
      startingPhotoTranslateX: data.bigPhotoTranslateX,
      startingPhotoTranslateY: data.bigPhotoTranslateY,

      endingScaleX: data.smallScaleX,
      endingScaleY: data.smallScaleY,
      endingTranslateX: data.smallTranslateX,
      endingTranslateY: data.smallTranslateY,
      endingPhotoScaleX: data.smallPhotoScaleX,
      endingPhotoScaleY: data.smallPhotoScaleY,
      endingPhotoTranslateX: data.smallPhotoTranslateX,
      endingPhotoTranslateY: data.smallPhotoTranslateY
    });
  },

  _getTransformData: function(photoWidth, photoHeight, thumbnailRect, backgroundRect) {
    var data = {};

    var photoRatio = photoWidth / photoHeight;
    var smallRatio = thumbnailRect.width / thumbnailRect.height;

    // Big container
    if (photoRatio > 1) {
      var bigWidth = backgroundRect.width;
      var bigHeight = backgroundRect.width / photoRatio;
      data.bigTranslateX = 0;
      data.bigTranslateY = (backgroundRect.height - bigHeight) / 2;
    }
    else {
      var bigWidth = backgroundRect.height * photoRatio;
      var bigHeight = backgroundRect.height;
      data.bigTranslateX = (backgroundRect.width - bigWidth) / 2;
      data.bigTranslateY = 0;
    }

    // Big photo
    data.bigWidth = bigWidth;
    data.bigHeight = bigHeight;
    data.bigPhotoTranslateX = 0;
    data.bigPhotoTranslateY = 0;

    // Small container
    data.smallScaleX = thumbnailRect.width / bigWidth;
    data.smallScaleY = thumbnailRect.height / bigHeight;
    data.smallTranslateX = thumbnailRect.left - (data.bigWidth - (data.bigWidth * data.smallScaleX)) / 2;
    data.smallTranslateY = thumbnailRect.top - (data.bigHeight - (data.bigHeight * data.smallScaleY)) / 2;

    // Small photo
    if (smallRatio > photoRatio) {
      var smallPhotoWidth = thumbnailRect.width;
      var smallPhotoHeight = thumbnailRect.width / photoRatio;
    }
    else {
      var smallPhotoWidth = thumbnailRect.height * photoRatio;
      var smallPhotoHeight = thumbnailRect.height;

    }
    data.smallPhotoScaleX = smallPhotoWidth / thumbnailRect.width;
    data.smallPhotoScaleY = smallPhotoHeight / thumbnailRect.height;
    data.smallPhotoTranslateX = 0;
    data.smallPhotoTranslateY = 0;

    return data;
  },

  _performTransform: function(data) {
    this.setStyle({
      width: data.bigWidth + 'px',
      height: data.bigHeight + 'px'
    });

    this.refs.photo.setStyle({
      width: data.bigWidth + 'px',
      height: data.bigHeight + 'px'
    });

    // Initially set the source to a transparent png, otherwise the
    // image element will have a white border.
    this.refs.photo.setAttributes({ src: 'placeholder.png' });

    this.refs.photo.setAttributes({ src: data.photoUrl });

    this.setScaleXDirect(data.startingScaleX);
    this.setScaleYDirect(data.startingScaleY);
    this.setTranslateXDirect(data.startingTranslateX);
    this.setTranslateYDirect(data.startingTranslateY);
    this.setScaleX(data.endingScaleX);
    this.setScaleY(data.endingScaleY);
    this.setTranslateX(data.endingTranslateX);
    this.setTranslateY(data.endingTranslateY);
    this.startSpringAnimationNow();

    this.refs.photoWrapper.setSize(data.bigWidth, data.bigHeight);
    this.refs.photoWrapper.transform(data.startingPhotoScaleX, data.startingPhotoScaleY, data.startingPhotoTranslateX, data.startingPhotoTranslateY, data.endingPhotoScaleX, data.endingPhotoScaleY, data.endingPhotoTranslateX, data.endingPhotoTranslateY);
  },

  _computeTransform: function(values) {
    return {
      WebkitTransform:
        'translate3d(' + Math.round(values.translateX) + 'px, ' +
                         Math.round(values.translateY) + 'px, 0) ' +
        'scale3d(' + values.scaleX + ', ' + values.scaleY + ', 1)'
    };
  },

  _animationEnd: function() {
    this.invoke('animationEnd', {
      type: this._animationType
    });
  }
});

var ExpandablePhoto = exports.ExpandablePhoto = core.createClass({
  name: 'ExpandablePhoto',

  extend: View,

  declare: function() {
    return {
      childViews: [
        {
          view: SpringyOpacityView,
          ref: 'springyOpacityView'
        },
        {
          view: SpringyPhoto,
          ref: 'springyPhoto'
        }
      ]
    };
  },

  ready: function() {
    this.refs.springyPhoto.addListener('animationEnd', this._animationEnd, this);
    this.hide();
  },

  expand: function(photoUrl, photoWidth, photoHeight, thumbnailRect, backgroundRect) {
    this.show();

    this.refs.springyOpacityView.setSize(backgroundRect.width, backgroundRect.height);
    this.refs.springyOpacityView.changeOpacity(0, 1);

    this.refs.springyPhoto.expand(photoUrl, photoWidth, photoHeight, thumbnailRect, backgroundRect);
  },

  shrink: function(photoUrl, photoWidth, photoHeight, thumbnailRect, backgroundRect) {
    this.show();

    this.refs.springyOpacityView.setSize(backgroundRect.width, backgroundRect.height);
    this.refs.springyOpacityView.changeOpacity(1, 0);

    this.refs.springyPhoto.shrink(photoUrl, photoWidth, photoHeight, thumbnailRect, backgroundRect);
  },

  _animationEnd: function(evt) {
    this.hide();

    if (evt.data.type === 'expand') {
      this.invoke('photoExpanded');
    }
    else {
      this.invoke('photoShrinked');
    }
  }
});
});

// module: views/dialer/dialer_scene
// file:   ../../views/dialer/dialer_scene.js
define("views/dialer/dialer_scene", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core            = require('bolt/core');
var Scene           = require('bolt_touch/views/scene').Scene;
var View            = require('bolt_touch/view').View;
var util            = require('bolt/util');
var sharedUtil      = require('shared/util');
var dialogUtil      = require('shared/dialogs');
var EventManager    = require('shared/event_manager').EventManager;
var DtmfKeypad      = require('incall/dtmf_keypad').DtmfKeypad;
var EmergencyEntryDisplay =
  require('views/dialer/emergency_entry_display').EmergencyEntryDisplay;
var ContactEntryDisplay =
  require('views/dialer/contact_entry_display').ContactEntryDisplay;

var Dialog = require('shared/boltwidget/dialog').Dialog;

var phoneApi = FBAPI.use('phone');
var telephonyApi = FBAPI.use('telephony');

/**
 * This dialer should be configurable to the needs of
 * any app that needs to dial numbers. The configurations
 * should be passed in through the options hash. Currently
 * the configurable options are:
 *
 * - controller: The controller.
 * - title: The string in the title bar. Omit this is your
 *   scene doesn't need a title bar
 * - popFunction: If your scene does something fancy when
 *   it's popped, make it happen here. Just remember to
 *   actually pop at some point in the popFunction. Also,
 *   popping is only possible if you have a title bar. And
 *   the pop function is always called in the context of the
 *   dialer scene itself.
 * - entryDisplay: This is a view that shows the number that
 *   has been entered. It can also show other stuff, which is
 *   why this is configurable. Leave this out if you want the
 *   default display that shows people's pictures when a friend's
 *   number is dialed.
 * - purpose: The purpose of the keypad, which determines the
 *   button layout.  Currently there are three choices:
 *     PURPOSE_DIALER (default) for placing phone calls
 *     PURPOSE_FORWARDING for entering phone numbers without calling them
 *     PURPOSE_PINPAD for entering numeric codes
 */
var DialerScene = exports.DialerScene = core.createClass({
  name: 'DialerScene',
  extend: Scene,

  statics: {
    PURPOSE_DIALER: DtmfKeypad.PURPOSE_DIALER,
    PURPOSE_FORWARDING: DtmfKeypad.PURPOSE_FORWARDING,
    PURPOSE_PINPAD: DtmfKeypad.PURPOSE_PINPAD,
    PURPOSE_INCALL: DtmfKeypad.PURPOSE_INCALL,
    PURPOSE_TALK: DtmfKeypad.PURPOSE_TALK,
    LONG_PRESS_TIMEOUT:  500,
    TOUCH_END_TIMEOUT: 100,
    HOLD_DELETE_TIMEOUT: 50,
    VALID_ACTIONS: /[0-9*#+,;]/
  },

  properties: {
    controller: null,
    peerContext: null,
    purpose: DtmfKeypad.PURPOSE_DIALER,
    title: '',
    hasEmergencyCallButton: false,
    emergency: false,
    addCallScene: null, //for incall
    entryDisplay: null
  },

  construct: function(options) {
    this.phoneApi = window.FBAPI && FBAPI.use('phone');
    this.number = '';
    Scene.call(this, options);
  },

  ready: function() {
    this.entryDisplay = this.refs.entryDisplay;
    this.dtmfKeypad = this.refs.dtmfKeypad;
    this.lastNumber = null;
    this._isTouched = false;
    this._longPressTimeoutId = null;
    this._deleteTimeoutId = null;
    this._touchEndTimeoutId = null;
    this._lastTouchedAction = null;
    this.callee = this.findRef('callee');
  },

  declare: function(options) {
    var children = [];
    if (options.title) {
      var popFunction = 'pop';
      var submitFunction = sharedUtil.nop;
      if (options.popFunction) {
        popFunction = util.bind(options.popFunction, this);
      }
      if (options.submitFunction) {
        submitFunction = util.bind(options.submitFunction, this);
      }
      children.push({
        boxOrientation: 'horizontal',
        additionalClasses: 'nav-bar bt-bar',
        childViews: [{
          additionalClasses: 'bt-bar-button left bt-down-button',
          onclick: popFunction
        }, {
          content: options.title,
          additionalClasses: 'bt-bar-title'
            + (options.submitFunction ? '' : ' no-right'),
          ref: 'title',
          flex: 1
        }, {
          content: 'DONE',
          additionalClasses: 'bt-bar-button right bt-text-button',
          onclick: submitFunction,
          style: {display: options.submitFunction ? 'block' : 'none'}
        }]
      });
    }

    if (options.purpose) {
      this.setPurpose(options.purpose);
    }

    var entry = ContactEntryDisplay;
    if (options.entryDisplay) {
      entry = options.entryDisplay;
    }

    children.push({
      ref: 'entryArea',
      childViews: [
        {
          ref: 'entryDisplay',
          view: entry
        }
      ]
    });
    children.push({
      ref: 'dtmfKeypad',
      view: 'DtmfKeypad',
      keyTouchStart: util.bind(this.handleTouchStart, this),
      keyTouchEnd: util.bind(this.handleTouchEnd, this),
      purpose: this.getPurpose(),
      showEmergencyButton: options.hasEmergencyCallButton
    });
    if (options.emergency) {
      this.setEmergency(options.emergency);
    }
    return {
      boxOrientation: 'vertical',
      additionalClasses: this.getEmergency() ? 'emergency' : '',
      childViews: children
    };
  },

  setTitle: function(title) {
    this.set('title', title);
    if (this.refs.title) {
      this.refs.title.setContent(title);
    }
  },

  useHeader: function() {
    return false;
  },

  addDigit: function(value) {
    var number = this.number;
    number += value;
    this.entryDisplay.updateNumber(number);
    this.number = number;
    this.dtmfKeypad.setShowEmergencyButton(false);
  },

  deleteDigit: function() {
    var number = this.number;
    number = number.slice(0, number.length - 1);
    this.entryDisplay.updateNumber(number, true);
    this.number = number;
    if (!number && this.getHasEmergencyCallButton()) {
      this.dtmfKeypad.setShowEmergencyButton(true);
    }
  },

  handleLongPress: function(action) {
    if (this._isTouched) {
      switch (action) {
        // zero becomes plus
        case '0':
          if (this.getPurpose() !== DialerScene.PURPOSE_PINPAD) {
            this.deleteDigit();
            this.addDigit('+');
          }
          break;

        // call voicemail
        case '1':
          if (this.number === '1' &&
              this.getPurpose() === DialerScene.PURPOSE_TALK) {
            this.dial('voicemail');
          }
          break;

        case 'delete':
          this._deleteTimeoutId = setInterval(
            util.bind( this.deleteDigit, this),
            DialerScene.HOLD_DELETE_TIMEOUT);
          break;

        default:
          FBAPI.use('log').bumpKey('talk.dialer_scene', 'unhandled_action', 1);
          throw new Error('unhandled action: ' + action);
      }
    }
  },

  handleTouchStart: function(evt, action) {
    this._isTouched = true;

    if (this.klass.VALID_ACTIONS.test(action)) {
      this.addDigit(action);
    } else if (action === 'emergency') {
      this.pushEmergencyDialer();
    } else if (action === 'delete') {
      this.deleteDigit();
    }

    if (action === '0' || action === '1' || action === 'delete') {
      this._longPressTimeoutId = setTimeout(
        util.bind(this.handleLongPress, this, action),
        DialerScene.LONG_PRESS_TIMEOUT);
    }
  },

  handleTouchEnd: function(evt, action) {
    this._isTouched = false;
    if (this._longPressTimeoutId) {
      clearTimeout(this._longPressTimeoutId);
      this._longPressTimeoutId = null;
    }

    if (this._deleteTimeoutId) {
      clearInterval(this._deleteTimeoutId);
      this._deleteTimeoutId = null;
    }

    if (action === 'call') {
      this.callNumber();
    }

    if (action === 'message') {
      if (this.entryDisplay.getProfile()) {
        if (this.entryDisplay.getProfile().getFacebookId()) {
          this.getController().openThreadOrComposer(
            this.entryDisplay.getProfile().getFacebookId()
          );
        } else {
          this.getController().openThreadOrComposer(
            sharedUtil.getCanonicalPhoneNumber(this.number),
            'phone'
          );
        }
      } else {
        this.getController().openThreadOrComposer(
          sharedUtil.getCanonicalPhoneNumber(this.number),
          'phone'
        );
      }
    }
  },

  callNumber: function() {
    this.dial(this.number);
  },

  dial: function(number) {
    if (this.getPurpose() === DialerScene.PURPOSE_TALK &&
        number.length === 0 &&
        this.lastNumber) {
      //if there is no number, check if last dialed number exists
      //if last number exists, should populate the dialer area with
      //the last number
      this.number = this.lastNumber;
      this.entryDisplay.updateNumber(this.number, true);
    } else if (number.length > 0) {
      var def =
        sharedUtil.makeCall(number, this.getPeerContext(), this.getEmergency());
      if (this.getAddCallScene()) {
        this.getController().popScene();
      } else if (this.getPurpose() === DialerScene.PURPOSE_TALK) {
        def.then(this._callNumberSuccess, this);
      } else if (this.getEmergency()) {
        def.then(this._emergencyDialSuccess, this);
      }
    }
  },

  _callNumberSuccess: function(callStatus) {
    if ((callStatus !== phoneApi.CALL_DIALED) &&
               (callStatus !== phoneApi.CALL_SECRET_CODE)) {
      // Call failed...
      // error messages are now handled by sharedUtil.makeCall()
      return;
    }
    this.lastNumber = this.number;
    this.reset();
  },

  _emergencyDialSuccess: function(callStatus) {
    if (callStatus === phoneApi.CALL_FAILED_EMERGENCY_CALLS_ONLY) {
      this.reset();
    } else if (callStatus === phoneApi.CALL_FAILED_POWER_OFF) {
      if (this.entryDisplay.showAirplaneModeMessage) {
        this.entryDisplay.showAirplaneModeMessage();
      }

      this.airplaneModeHandle = EventManager.listen('telephony.AIRPLANE_MODE_CHANGED',
        this._makePostAirplaneModeCall, this);
      telephonyApi.setIsAirplaneModeEnabled(false);
    }
  },

  _makePostAirplaneModeCall: function(data) {
    if (!data.enabled) {
      sharedUtil.makeCall(
        this.number,
        this.getPeerContext(),
        this.getEmergency());
      this.airplaneModeHandle.remove();
    }
  },

  pushEmergencyDialer: function() {
    var emergencyDialer = new DialerScene({
      title: 'Emergency Call',
      controller: this.getController(),
      peerContext: this.getPeerContext(),
      emergency: true,
      entryDisplay: EmergencyEntryDisplay,
      modal: true
    });
    this.getStack().push(emergencyDialer, {transition: 'drawer'});
  },

  reset: function() {
    this.entryDisplay.updateNumber(this.number = '', true);
  },

  destroy: function() {
    if (this.mmiProgressSub) {
      this.mmiProgressSub.remove();
    }
  }
});
});

// module: shared/window_manager
// file:   ../../shared/js/window_manager.js
define("shared/window_manager", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var dom = require('bolt/dom');
var util = require('bolt/util');
var constants = require('shared/screen_constants');
var sharedUtil = require('shared/util');
var EventManager = require('shared/event_manager').EventManager;

var WindowManagerImpl= core.createClass({

  name: 'WindowManagerImpl',

  construct: function() {
    this._initMembers();
    this._initEvents();
    this._initDimensions();
    this._handleResize();
  },

  // Event constants
  EVENT_RESIZE: 'wm/resize',
  EVENT_ORIENTATION: 'wm/orientation',
  EVENT_KEYBOARD_APPEAR: 'wm/kbappear',
  EVENT_KEYBOARD_DISAPPEAR: 'wm/kbdisappear',

  // Resize mode  constants
  AUTO_RESIZE_TO_SCREEN: 0,
  AUTO_RESIZE_TO_VIEWPORT: 1,
  AUTO_RESIZE_NEVER: 2,

  // Orientation constatns
  PORTRAIT: 'portrait',
  LANDSCAPE: 'landscape',

  /**
   * PUBLIC METHODS
   */

  /**
   * get the width and height of the viewport
   * returns an object with width and height properties
   */
  getViewPortDimensions: function() {
    return {
      width:  window.innerWidth,
      height: window.innerHeight
    };
  },

  /**
   * get the width and height of the screen
   * returns an object with width and height properties
   */
  getScreenDimensions: function() {
    // TODO: this does not work correctly for full-screen apps
    // (like camera, etc)
    var orientation = this.getOrientation();
    if (orientation == this.PORTRAIT) {
      return {
        width: this.PORTRAIT_WIDTH,
        height: this.PORTRAIT_HEIGHT
      };
    } else {
      return {
        width: this.LANDSCAPE_WIDTH,
        height: this.LANDSCAPE_HEIGHT
      };
    }
  },

  /**
   * get the width and height of the real dimensions of
   * the root view.
   * returns an object with width and height properties
   */
  getDimensions: function() {
    return this._dimensions;
  },

  /**
   * get the width and height of the current orientation
   * returns the orientation constants
   */
  getOrientation: function() {
    var orientation = null;
    if (window.orientation) {
      switch (window.orientation) {
        case 0:
          orientation = this.PORTRAIT;
          break;
        case 90:
        case -90:
          orientation = this.LANDSCAPE;
          break;
        default:
          break;
      }
    }

    // TODO: Remove once orientation is checked in
    orientation = this.PORTRAIT;

    return orientation;
  },

  isKeyboardShown: function() {
    return this._keyboardShown;
  },

  /**
   * set the dimension of the body element to the screen size
   */
  setDimensionsToScreen: function() {
    this.setDimensions(this.getScreenDimensions());
  },

  /**
   * set the dimension of the body element to the view port
   */
  setDimensionsToViewPort: function() {
    this.setDimensions(this.getViewPortDimensions());
  },

  /**
   * set the dimension of the body element by custom value
   */
  setDimensions: function(dimensions) {
    if (dimensions && dimensions.width && dimensions.height) {
      if ((!this._dimensions) || (this._dimensions.width != dimensions.width) ||
        (this._dimensions.height != dimensions.height)) {
        this._dimensions = dimensions;
        document.body.style.width = this._dimensions.width + 'px';
        document.body.style.height = this._dimensions.height + 'px';
      }
    }
  },

  /**
   * set the resize mode.
   */
  setResizeMode: function(resizeMode) {
    this._resizeMode = resizeMode;
    this._handleResize();
  },

  /**
   * register a callback for the keyboard event triggered by
   * an input element. ALthought this could be done
   * by listening to window manager's keyboard event
   * directly and checking if the last touched input
   * element is of interest, this method provides
   * a convenient abstraction that handles a common
   * scenario.
   *
   *
   * trigger     The input element that will trigger
   *             associated callbacks.
   * appearCb    The callback when the input element
   *             got focus and keyboard appears
   * disappearCb The callback when the input element
   *             loses focus and keyboard disappears.
   */
  addKeyboardCallbacks: function(trigger, appearCb, disappearCb) {
    this.removeKeyboardCallbacks(trigger);
    this._keyboardCallbacks.push({
      trigger: trigger,
      appearCb: appearCb,
      // Default to the same cb if disappearCb is not provided
      disappearCb: disappearCb ? disappearCb : appearCb
    });
  },

  /*
   * remove the callbacks for one input trigger
   */
  removeKeyboardCallbacks: function(trigger) {
    this._keyboardCallbacks = util.filter(this._keyboardCallbacks,
      function(obj) {
        return obj.trigger != trigger;
      });
  },

  /**
   * cleanup the window manager
   */
  destroy: function() {
    window.removeEventListener('resize', this.resizeHandler);
    document.body.removeEventListener('touchmove', this.touchMoveHandler);
    util.forEach(this._eventTokens, function(token) {
      token.remove();
    });
  },

  /**
   * PRIVATE METHODS
   */
  _handleResize: function(e) {
    switch (this._resizeMode) {
      case this.AUTO_RESIZE_TO_SCREEN:
        this.setDimensionsToScreen();
        break;
      case this.AUTO_RESIZE_TO_VIEWPORT:
        this.setDimensionsToViewPort();
        break;
      case this.AUTO_RESIZE_NEVER:
        // Clear the body style
        document.body.style.width = null;
        document.body.style.height = null;
        break;
      default:
        break;
    }

    EventManager.invoke(this.EVENT_RESIZE);

    // Refresh the orientation
    this._refreshOrientation();
  },

  /**
   * fired when screen orientation changes
   * adds a css class corresponding to the new orientation
   */
  _refreshOrientation: function(e) {
    var orientation = this.getOrientation();
    if (!this._orientation || this._orientation != orientation) {
      EventManager.invoke(this.EVENT_ORIENTATION);
      this._orientation = orientation;
      this._setOrientationClass();
    }
  },

  /**
   * gets the last touchstart element
   * TODO: when we can get the last touched input from keyboard
   * event, this would deprecated.
   */
  _handleTouchStart: function(e) {
    var tagName = e.target.tagName;
    if (tagName === 'INPUT' || tagName == 'TEXTAREA') {
      this.lastTouchedInput = e.target;
    }
  },

  /**
   * handle keyboard will appear
   */
  _handleKeyboardWillAppear: function(e) {
    if (this._resizeMode == this.AUTO_RESIZE_TO_VIEWPORT) {
      this.setDimensions({height: e.newHeight, width: window.innerWidth});
    }

    var input = this.lastTouchedInput;
    EventManager.invoke(this.EVENT_KEYBOARD_APPEAR, e);
    util.forEach(this._keyboardCallbacks, function(obj) {
      if (obj.trigger === input && obj.appearCb) {
        obj.appearCb(e);
      }
    });

    this._setKeyboardShown(true, e.duration);
  },

  /**
   * handle keyboard will disappear
   */
  _handleKeyboardWillDisappear: function(e) {
    if (this._resizeMode == this.AUTO_RESIZE_TO_VIEWPORT) {
      this.setDimensions({height: e.newHeight, width: window.innerWidth});
    }

    EventManager.invoke(this.EVENT_KEYBOARD_DISAPPEAR, e);

    var input = this.lastTouchedInput;
    util.forEach(this._keyboardCallbacks, function(obj) {
      if (obj.trigger === input && obj.disappearCb) {
        obj.disappearCb(e);
      }
    });

    this._setKeyboardShown(false, e.duration);
  },

  /**
   * Initialize the member variables
   */
  _initMembers: function() {
    this._resizeMode = this.AUTO_RESIZE_TO_SCREEN;
    this._dimensions = null;
    this._orientation = null;
    this._keyboardShown = false;
    this._keyboardCallbacks = [];
    this.lastTouchedInput = null;
  },

  /**
   * Initializes the device dimensions
   */
  _initDimensions: function() {
   /*
    * Be aware that at this point, window.innerWidth may not be ready.
    */
    var infoAPI = window.FBAPI && FBAPI.use("info");
    var isNewDevice = infoAPI && infoAPI.getModelNumber() === 'Enterprise';
    var isStratton = infoAPI && infoAPI.getModelNumber() === 'stratton';

    this.PORTRAIT_HEIGHT = constants.PHONE_DIMENSION.height;
    this.PORTRAIT_WIDTH = constants.PHONE_DIMENSION.width;
    this.FULL_KEYBOARD_HEIGHT = constants.FULL_KEYBOARD_HEIGHT;

    // TODO: Need to expose some API to get these values reliably.
    // But currently since orientation is not supported, do not
    // need to handle it.
    this.LANDSCAPE_HEIGHT = 436;
    this.LANDSCAPE_WIDTH = 800;
  },

  /**
   * Initialize the event handlers
   */
  _initEvents: function() {
    this.resizeHandler = util.bind(this._handleResize, this);
    this.touchStartHandler = util.bind(this._handleTouchStart, this);
    this.keyboardWillAppearHandler =
      util.bind(this._handleKeyboardWillAppear, this);
    this.keyboardWillDisappearHandler =
      util.bind(this._handleKeyboardWillDisappear, this);

    this._eventTokens = [];
    window.addEventListener('resize', this.resizeHandler);
    window.addEventListener('mousewheel', this.mouseWheelHandler);
    window.addEventListener('scroll', this.scrollHandler);
    window.addEventListener('touchmove', this.touchMoveHandler);
    window.addEventListener('touchstart', this.touchStartHandler);
    this._eventTokens.push(EventManager.listen('keyboardWillAppear',
      this.keyboardWillAppearHandler));
    this._eventTokens.push(EventManager.listen('keyboardWillDisappear',
      this.keyboardWillDisappearHandler));
  },

  /**
   * set an orientation class on the window that can be used to switch
   * styles
   */
  _setOrientationClass: function() {
    if (this._orientation === this.Landscape) {
      dom.toggleClass(document.body, 'portrait');
      dom.toggleClass(document.body, 'landscape', true);
    } else {
      dom.toggleClass(document.body, 'landscape');
      dom.toggleClass(document.body, 'portrait', true);
    }
  },

  /**
   * set the keyboard shown value after a latency
   */
  _setKeyboardShown: function(value, duration) {
    var _this = this;
    setTimeout(function() {
      _this._keyboardShown = value;
    }, duration);
  }

});

/*
 * Some common util functions related with window manager
 */
var WindowManagerUtil = {
  /*
   * Handle a common scenario that there is a bottom composer
   * and a table view in the scene. When the keyboard appears,
   * need to move the table to end.
   */
  moveScrollableToEndOnKeyboard: function(scrollable) {
    scrollable.refresh();
    setTimeout(function() {
      if (scrollable.scrollToEnd) {
        // This inherits from a table view so move to end is available.
        scrollable.scrollToEnd(0);
      } else {
        var maxScrollY = scrollable.maxScrollY();
        scrollable.scrollTo(0, -maxScrollY, 0, false);
      }
    }, 10);
  }
};

exports.WindowManager = new WindowManagerImpl();
exports.WindowManagerUtil = WindowManagerUtil;

});

// module: talk/client/model/thread/contacts
// file:   ../client/model/thread/contacts.js
define("talk/client/model/thread/contacts", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

/*global contactsList: true */
/*global addToCollection: true */

var util = require('bolt/util');
var Collection = require('bolt/collection').Collection;
var Model = require('bolt/model').Model;
var userUtil          = require('shared/util/user');
var sharedUtil   = require('shared/util');
var session = require('shared/session');


//Contact - from Contacts app (facebookId, phoneNumbers, email, local id)
//Ident - 'fbid:4'
//Ident hash - pipe-separated list of idents
//Info - Titan "user" information (fbid, phone, email, name)

/**
 * All contact related functions should be stored here. Unfortuntately neither
 * server nor local AddressBook provide enough data to
 */

function buildContactIdent(c) {
  if (c) {
    return ((c.get('facebookId') * 1  ? 'fbid:' + c.get('facebookId') : null) ||
           (c.get('id') * 1 ? 'lid:' + c.get('id') : null) ||
           ((c.get('phoneNumbers') && (c.get('phoneNumbers').length > 0)) ?
               'phone:' + c.get('phoneNumbers')[0].number :
               null) ||
           (c.get('email') ? 'email:' + c.get('email') : null) || '');
  } else {
    return null;
  }
}
exports.buildContactIdent = buildContactIdent;

function buildInfoIdent(c) {
  if (c) {
    return ((c.user_id * 1  ? 'fbid:' + c.user_id : null) ||
            // Well, if the information is from titan it will never
            // have this field (phone),
            // but our intermediate data structures can still have it
           (c.phone ? 'phone:' + c.phone : null) ||
           (c.email ? 'email:' + c.email : null) || '');
  } else {
    return null;
  }
}
exports.buildInfoIdent = buildInfoIdent;

function _fetchInfoByIdents(idents, collection) {
  if (!collection) {
    collection = new Collection();
  }
  var Deferred = require('shared/deferred').Deferred;
  var deferred = new Deferred();
  if (!idents.length) {
    return deferred.succeed(collection);
  }
  var ident = idents.shift();
  var type = ident.substr(0, ident.indexOf(':'));
  var value = ident.substr(ident.indexOf(':') + 1);
  if (type == 'fbid') {
    findAnyoneByFacebookId(value, function(contact) {
      addInfoToCollection('user_id', value, collection, contact);
      deferred.succeed(collection);
    });
  } else if (type == 'phone') {
    if (value === 'voicemail') {
      addInfoToCollection('phone', 'voicemail', collection, new Model({
          phoneNumbers: [{number: 'voicemail'}],
          name: 'Voice Mail'
        }));
      deferred.succeed(collection);
    } else {
      contactsList().allContactsWithPhoneNumber(value).then(function(contacts) {
        addInfoToCollection('phone', value, collection, contacts[0]);
        deferred.succeed(collection);
      });
    }
  } else if (type == 'lid') {
    contactsList().findById(value).then(function(contact) {
      addInfoToCollection('lid', value, collection, contact);
      deferred.succeed(collection);
    });
  } else if (type == 'email') {
    contactsList().allContactsWithEmail(value).then(function(contacts) {
      addInfoToCollection('email', value, collection, contacts[0]);
      deferred.succeed(collection);
    });
  } else {
    deferred.succeed(collection);
  }

  return deferred.then(_fetchInfoByIdents, this, idents, collection);
}

exports.fetchInfoByIdents = function(idents, result) {
  return _fetchInfoByIdents([].concat(idents), result);
};

function _fetchInfoByPhonesOrEmails(entries, collection) {
  if (!collection) {
    collection = new Collection();
  }
  var Deferred = require('shared/deferred').Deferred;
  var deferred = new Deferred();
  if (!entries.length) {
    return deferred.succeed(collection);
  }
  var entry = entries.shift();
  if (sharedUtil.isEmail(entry)) {
    contactsList().allContactsWithEmail(entry).then(function(contacts) {
      addInfoToCollection('email', entry, collection, contacts[0]);
      deferred.succeed(collection);
    });
  } else {
    contactsList().allContactsWithPhoneNumber(entry).then(function(contacts) {
      addInfoToCollection('phone', entry, collection, contacts[0]);
      deferred.succeed(collection);
    });
  }
  return deferred.then(
    _fetchInfoByPhonesOrEmails, this, entries, collection);
}

exports.fetchInfoByPhonesOrEmails = function(entries, result) {
  return _fetchInfoByPhonesOrEmails([].concat(entries), result);
};

// returns contact (or fake contact)
function findAnyoneByFacebookId(fbId, callback) {
  var Deferred = require('shared/deferred').Deferred;
  var deferred = new Deferred();
  deferred.addCallback(callback);
  if (fbId == session.getUid()) {
    deferred.succeed(new Model({
      facebookId: session.getUid(),
      name: session.getName()
    }));
    return deferred;
  } else {
    contactsList().findByFacebookId(fbId).then(function(contact) {
      if (contact) {
        deferred.succeed(contact);
      } else {
        deferred.succeed(new Model({
          facebookId: fbId
        }));
      }
    });
  }
  return deferred;
}

function addInfoToCollection(defaultIdentName, defaultIdentValue,
                               collection, contact) {
  var info;
  if (contact) {
    info = new Model({
      name: contact.getName ? contact.getName() : contact.get('name'),
      user_id: contact.get('facebookId'),
      email: contact.get('email')
    });
    if (contact.get('phoneNumbers') && contact.get('phoneNumbers').length > 0) {
      info.set('phone', contact.get('phoneNumbers')[0].number);
    }
    collection.add(info);
  } else {
    info = new Model({});
    info.set(defaultIdentName, defaultIdentValue);
    info.set('name', defaultIdentValue);
    collection.add(info);
  }
}

function _infoContainsContactIDs(contacts) {
  return util.any(contacts, function(c) {
    return ((c.user_id * 1) && (!userUtil.isFacebookUserID(c.user_id)));
  });
}

exports.infoToIdents = function(infoArray) {
  if (_infoContainsContactIDs(infoArray)) {
    return [];
  } else {
    var idents = infoArray.map(buildInfoIdent);
    return util.uniq(idents);
  }
};

exports.splitParticipants = function(infoCollection, senderIdent) {
  var sender = {};
  var recipients = [];
  var info;

  if (infoCollection.length == 1) {
    sender = infoCollection.at(0).toObject();
    recipients.push(infoCollection.at(0).toObject());
  } else {
    for (var i = 0; i < infoCollection.length; i++) {
      info = infoCollection.at(i).toObject();
      if ((!senderIdent && info.user_id === session.getUid()) ||
          (senderIdent == buildInfoIdent(info))) {
        sender = info;
      } else {
        recipients.push(info);
      }
    }
  }
  return {
    sender: sender,
    recipients: recipients
  };
};

exports.infoToAPI = function(info) {
  var result = null;

  if (info.user_id) {
    result = info.user_id;
  } else if (info.email) {
    result = info.email;
  } else if (info.phone) {
    result = {
      type: 'phone',
      phone: info.phone,
      country: info.phoneCountry || 'US',
      name: info.name || info.phone
    };
  } else {
    console.warn('Invalid info: ' + JSON.stringify(info));
  }
  return result;
};


//=======================================================================
//=======================================================================
// Anything below this line should be refactored/deleted once we finish
// refactoring the delivery infrastructure
// And yes, there's a mess down from here
//=======================================================================
//=======================================================================

function infoToContacts(models) {
  return models.map(function(m) {
    var name = m.getName ? m.getName() : m.get('name');
    var id = m.get('facebookId');
    var phone = m.get('phoneNumbers') && m.get('phoneNumbers').length ?
      m.get('phoneNumbers').number :
      m.get('phone');
    var email = m.get('emails') && m.get('emails').length ?
      m.get('emails').at(0).get('value') :
      m.get('email');
    return {
      name: name || phone || email,
      user_id: id,
      local_id: m.get('local_id'),
      phone: phone,
      email: email
    };
  });
}

exports.modelsToContacts = modelsToContacts;

exports.modelToContact = function(model) {
  return exports.modelsToContacts([model])[0];
};



exports.fetchContacts = function(idents, collection) {
  if (!collection) {
    collection = new Collection();
  }
  var Deferred = require('shared/deferred').Deferred;
  var deferred = new Deferred();
  if (!idents.length) {
    return deferred.succeed(collection);
  }
  var ident = idents.pop();
  var type = ident.substr(0, ident.indexOf(':'));
  var value = ident.substr(ident.indexOf(':') + 1);
  if (type == 'fbid') {
    contactsList().findByFacebookId(value).then(function(contact) {
      addToCollection(ident, collection, contact);
      deferred.succeed(collection);
    });
  } else if (type == 'lid') {
    contactsList().findById(value).then(function(contact) {
      addToCollection(ident, collection, contact);
      deferred.succeed(collection);
    });
  } else if (type == 'phone') {
    contactsList().allContactsWithPhoneNumber(value).then(function(contacts) {
      addToCollection(ident, collection, contacts[0]);
      deferred.succeed(collection);
    });
  } else if (type == 'email') {
    contactsList().allContactsWithEmail(value).then(function(contacts) {
      addToCollection(ident, collection, contacts[0]);
      deferred.succeed(collection);
    });
  } else {
    deferred.succeed(collection);
  }

  return deferred.then(exports.fetchContacts, exports, idents, collection);
};

function addToCollection(ident, collection, contact) {
  if (contact) {
    contact.set('ident', ident);
    collection.add(contact);
  }
}

var localcontactsList;

function contactsList() {
  if (!localcontactsList) {
    var LocalContactsList =
      require('talk/app/contacts/local_contacts_list').LocalContactsList;
    localcontactsList = new LocalContactsList();
  }
  return localcontactsList;
}


/**
 * Participant Info is the extended version of FB messaging contact. It includes
 * all the known messaging related properties like phones or emails.
 */
function modelsToContacts(models) {
  return models.map(function(m) {
    var name = m.getName ? m.getName() : m.get('name');
    var id = m.get('facebookId');
    var phone = m.get('phoneNumbers') && m.get('phoneNumbers').length ?
      m.get('phoneNumbers').number :
      m.get('phone');
    var email = m.get('emails') && m.get('emails').length ?
      m.get('emails').at(0).get('value') :
      m.get('email');
    return {
      name: name || phone || email,
      user_id: id,
      local_id: m.get('local_id'),
      phone: phone,
      email: email
    };
  });
};

exports.modelsToContacts = modelsToContacts;

exports.modelToContact = function(model) {
  return exports.modelsToContacts([model])[0];
};

exports.profileURL = function(messagingContact, localContact) {
  // TODO: temporarily commenting out while waiting for hi-res
  // thumbnails from the photos team
  /*
  if (localContact && localContact.get('profileUrl')) {
    return localContact.get('profileUrl');
  }
  */
  if (messagingContact && messagingContact.user_id * 1) {
    return 'http://graph.facebook.com/' + messagingContact.user_id +
      '/picture?type=large';
  }
  return '';
};

});

// module: shared/incall
// file:   ../../shared/js/incall.js
define("shared/incall", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var sharedUtil = require('shared/util');
var apixhr = require('shared/api_xhr');
var util = require('bolt/util');

var Deferred = require('shared/deferred').Deferred;
var DeferredList = require('shared/deferred').DeferredList;
var EventManager = require('shared/event_manager').EventManager;
var LocalContactsList
  = require('talk/app/contacts/local_contacts_list').LocalContactsList;
var contactsList;
var PhoneNumberUtil;
var PhoneNumberFormat;

var phoneApi = exports.phoneApi = ((typeof FBAPI !== 'undefined') ?
  FBAPI.use("phone") : null);
var telephonyApi = FBAPI && FBAPI.use('telephony');

var callType = exports.callType = {
  NO_CALLS:  0,
  ONE_CALL:  1,
  TWO_CALLS: 2,
  CONF_CALL: 3
};

// this specific phone's geodata; used to determine the distance between
// this number and the incoming/outgoing number that we need the geodata
// from. This determines the level of zoom for the map.
// this is an object with properties:
//    - number (used to match current number so
//              we redo the search once we get a new sim card)
//    - latitude
//    - longitude
var phoneGeodata = exports.phoneGeodata;

exports.getPhoneGeodata = function() {
  return phoneGeodata;
};

// update geodata callback
var _setPhoneGeodata = function(geodata, data) {
  geodata.latitude = data.latitude;
  geodata.longitude = data.longitude;
  phoneGeodata = geodata;
};

// figure out the latitude/longitude matching the current
// phone number of this phone
var updateCurrentLocationData = exports.updateCurrentLocationData = function() {
  var number = telephonyApi.getLine1PhoneNumber();

  if (!phoneGeodata || phoneGeodata.number !== number) {
    phoneGeodata = {};
    phoneGeodata.number = number;

    // it'll error if the phone number is not a real number
    // we're not worrying about the geodata if it is not a real number
    try {
      PhoneNumberUtil = PhoneNumberUtil ||
        require('third-party/libphonenumber').PhoneNumberUtil;
      var phoneUtil = PhoneNumberUtil.getInstance();
      var parsedNumber = phoneUtil.parse(number, 'US');
    } catch (err) {
      console.warn(err);
      return;
    }

    _getLocationData(parsedNumber)
      .addCallback(_setPhoneGeodata, this, phoneGeodata);
  }
};

// ===== PHONE API wrappers =========================
// Note: Java returns strings so need to convert to json before use

exports.getPhoneCalls = function() {
  return phoneApi ? JSON.parse(phoneApi.getPhoneCalls()).calls : null;
};

exports.getDefaultCall = function() {
  var call = phoneApi ? phoneApi.getDefaultPhoneCall() : '{}';
  return call !== '{}' ? JSON.parse(call) : null;
};

exports.getPhoneProperties = function() {
  return phoneApi ? JSON.parse(phoneApi.getProperties()) : null;
};

exports.getPhoneLine = function() {
  return phoneApi ? JSON.parse(phoneApi.getPhoneLine()) : null;
};

// ===== Convenience methods ========================
var getDisplayNameForCallPeerType = exports.getDisplayNameForCallPeerType = function(type) {
  switch (type) {
  case 'PRIVATE':
    return 'Private caller';
  case 'UNKNOWN':
    return 'Unknown caller';
  case 'EMERGENCY':
    return 'Emergency services';
  case 'VOICEMAIL':
    return 'Voicemail';
  case 'NORMAL':
  default:
    return '';
  }
};

// number is a parsed number using PhoneNumberUtil
var formatNumber = exports.formatNumber = function(number) {
  PhoneNumberUtil = PhoneNumberUtil ||
    require('third-party/libphonenumber').PhoneNumberUtil;
  var phoneUtil = PhoneNumberUtil.getInstance();
  PhoneNumberFormat = PhoneNumberFormat ||
    require('third-party/libphonenumber').PhoneNumberFormat;
  // dialable string is not always a valid phone number
  return phoneUtil.format(number, PhoneNumberFormat.NATIONAL);
};

var getDisplayNameForPeer = exports.getDisplayNameForPeer = function(peer) {
  var displayName = getDisplayNameForCallPeerType(peer.type);
  if (!displayName) {
    PhoneNumberUtil = PhoneNumberUtil ||
      require('third-party/libphonenumber').PhoneNumberUtil;
    var phoneUtil = PhoneNumberUtil.getInstance();
    try {
      var parsedNumber = phoneUtil.parse(peer.displayName, 'US');
      displayName = formatNumber(parsedNumber);
    } catch (err) {
      displayName = peer.displayName;
    }
  }
  return displayName;
};

exports.getDisplayNameForCall = function(call) {
  // TODO: What if the call has multiple peers?
  var peer = call.peers[0];
  return getDisplayNameForPeer(peer);
};

exports.getDisplayDuration = function(call) {
  var start = call.connectTime;
  if (!start) {
    return '';
  }
  var end = call.disconnectTime || Date.now();
  return sharedUtil.formatDuration(end - start);
};

var getPhoneNumberForPeer = exports.getPhoneNumberForPeer = function(peer) {
  var number = '';
  if (peer.uri.indexOf('tel:') === 0) {
    number = peer.uri.substring('tel:'.length);
  }
  return number;
};

exports.getCallContext = function(call) {
  // TODO: fix to work with multiple peers
  var context = call.peers[0].context;
  if (!context) {
    return null;
  }

  // context is only a tel URL--normalize the format
  if (!context.match(/^\{.*\}$/)) {
    var displayName = context;
    if (context.indexOf('tel:') === 0) {
      displayName = context.substring(4);
    }
    return {
      displayName: displayName,
      uri: context
    };
  } else {
    return JSON.parse(context);
  }
};

// ===== Convenience methods ========================

exports.isCallHolding = function(call) {
  return call.state == 'HOLDING';
};

exports.isCallRinging = function(call) {
  return call.state == 'RINGING';
};

exports.getCallType = function(calls) {
  if (calls.length < 1) {
    return callType.NO_CALLS;
  } else if (calls.length > 1) {
    return callType.TWO_CALLS;
  } else if (calls[0].peers.length > 1) {
    return callType.CONF_CALL;
  } else {
    return callType.ONE_CALL;
  }
};

// data = plaintext string from the text file
// nxx = 3 digits given by the number
// we use binary search to find the corresponding location to the nxx
var _getLocationName = function(data, nxx) {
  // AreaCodeData = array of strings; each string is space separated into
  // nxx (3 digits after area code), latitude, longitude, state, city name
  var AreaCodeData = data.split('\n');
  var low = 0;
  var high = AreaCodeData.length - 1;
  var mid, val;

  while (high > low) {
    mid = Math.floor((high + low) / 2);
    val = AreaCodeData[mid].substr(0, 3);
    if (val > nxx) {
      high = mid - 1;
    } else if (val < nxx) {
      low = mid + 1;
    } else {
      low = mid;
      break;
    }
  }

  // NOTE: the nxx data used in these text files are not recent and we're only
  // looking at the closest lower value, which is most likely close but not 100%
  var ret = AreaCodeData[Math.min(AreaCodeData.length - 1, low)].split(' ', 5);
  // the input data file has a set number of characters
  // before a city name
  var city = AreaCodeData[low].substr(22);
  return {
    name: city + ', ' + ret[4],
    latitude: ret[1],
    longitude: ret[2]
  };
};

// looks for the array of area code data needed by the area code
// number is a parsed number using PhoneNumberUtil
var _getLocationData = function(number) {
  PhoneNumberUtil = PhoneNumberUtil ||
    require('third-party/libphonenumber').PhoneNumberUtil;
  var phoneUtil = PhoneNumberUtil.getInstance();
  var significantNum = phoneUtil.getNationalSignificantNumber(number);
  var areaCodeLength = phoneUtil.getLengthOfGeographicalAreaCode(number);
  var areaCode = significantNum.substring(0, areaCodeLength);
  var deferred = new Deferred();

  // update the current phone's location data in case it is not there
  updateCurrentLocationData();

  // to prevent xss hole, make sure areaCode is actually an area code
  if (areaCode >= 201 && areaCode <= 913) {
    //read area code data, pass in nxx
    apixhr.file("../../third-party/geolocation/data/" + areaCode + ".txt")
      .addCallback(function(data) {
        data = data.trim();
        // somehow we're getting callback for files that can't be found as well
        if (data == "404 Not Found") {
          deferred.succeed({ name: 'unknown location' });
        } else {
          var nxx = significantNum.substring(areaCodeLength,
                                             areaCodeLength + 3);
          deferred.succeed(_getLocationName(data, nxx));
        }
      }, this)
      .addErrback(function(data) {
        deferred.succeed({ name: 'unknown location' });
      }, this);
  } else {
    deferred.succeed({ name: 'unknown location' });
  }
  return deferred;
};

var _setContextHelper = function(callId, peerId, context) {
  if (phoneApi) {
    phoneApi.setPeerContext(callId, peerId, JSON.stringify(context));
    EventManager.invoke('incall.SET_CONTEXT');
  }
};

var _setContext = function(callId, peerId, profile) {
  // trim profile to a non-cyclic JSON-representable structure
  if (profile.toObject) {
    profile = profile.toObject();
  }

  var context = {
    profile: {
      id: profile.id,
      name: profile.name,
      pic_big: profile.pic_big
    }
  };

  PhoneNumberUtil = PhoneNumberUtil ||
    require('third-party/libphonenumber').PhoneNumberUtil;
  var phoneUtil = PhoneNumberUtil.getInstance();
  try {
    //check if the name is actually a number; otherwise it is just a name
    var parsedNumber = phoneUtil.parse(profile.name, 'US');
    // profile.name is thus a number
    context.profile.name = formatNumber(parsedNumber);
    // attempt to get location information
    _getLocationData(parsedNumber)
      .addCallback(function(data) {
        context.geodata = data;
        _setContextHelper(callId, peerId, context);
      }, this);
  } catch (err) {
    _setContextHelper(callId, peerId, context);
  }
};

/**
 * Get the profile information associated with a phone number, if it exists.
 * This will be stored with the phone number so the UI can show useful
 * info like name, profile pic, mutual friends, etc. in the in-call view.
 *
 * The context is stored as JSON.
 *
 * @param string callId A phone call identifier.
 * @param object peer A peer on the phone call whose phone number to lookup.
 */
exports.findContext = function(callId, peer) {
  // No lookup required for peer-types other than NORMAL.
  // These include PRIVATE, UNKNOWN, EMERGENCY, and VOICEMAIL.
  if (peer.type !== 'NORMAL') {
    return;
  }
  PhoneNumberUtil = PhoneNumberUtil ||
    require('third-party/libphonenumber').PhoneNumberUtil;

  var number = PhoneNumberUtil.normalize(getPhoneNumberForPeer(peer));
  if (!sharedUtil.isPhone(number)) {
    return;
  }

  //FIXME: if +1 is appended, the phone number doesn't normalize without the 1
  if (number.length == 11 && number.charAt(0) === '1') {
    number = number.substr(1);
  }
  //TODO: Use canonical phone number instead once it's implemented in contacts
  //number = sharedUtil.getCanonicalPhoneNumber(number);

  contactsList = contactsList || new LocalContactsList();
  //TODO: add in remote search if can't find in local
  contactsList.allContactsWithPhoneNumber(number).then(function(contacts) {
    if (contacts && contacts.length > 0) {
      _setContext(callId, peer.id, {
        id:      contacts[0].get('facebookId'),
        name:    contacts[0].getName(),
        pic_big: contacts[0].get('profileUrl')
      });
    } else {
      _setContext(callId, peer.id, {
        id: '',
        name: number
      });
    }
  });
};
});

// module: contact_picker/contact_picker_view
// file:   ../../contact_picker/js/contact_picker_view.js
define("contact_picker/contact_picker_view", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core              = require('bolt/core');
var util              = require('bolt/util');
var Scene             = require('bolt_touch/views/scene').Scene;
var EventManager      = require('shared/event_manager').EventManager;
var screen_dims       = require('shared/screen_constants').PHONE_DIMENSION;
var ContactsTable =
  require('views/contacts_table/contacts_table').ContactsTable;

var ContactPicker = exports.ContactPicker = core.createClass({
  name: 'ContactPicker',
  extend: Scene,

  declare: function(options) {
    options = options || {};
    return {
      additionalClasses: 'bt-hidden',
      boxOrientation: 'vertical',
      height: '100%',
      childViews: [
        {
          additionalClasses: 'bt-bar',
          boxOrientation: 'horizontal',
          ref: 'header',
          childViews: [
            {
              additionalClasses: 'bt-bar-title',
              flex: 1,
              content: options.title || 'Contacts',
              ontouchstart: 'scrollToTop'
            },
            {
              additionalClasses: 'bt-bar-button right bt-text-button',
              content: 'DONE',
              onclick: 'done'
            }
          ]
        },
        {
          additionalClasses: 'bt-picker-field-container',
          boxOrientation: 'horizontal',
          ref: 'container',
          childViews: [
            {
              flex: 1,
              content: 'With:',
              ref: 'withLabel',
              additionalClasses: 'bt-picker-label'
            },
            {
              additionalClasses: 'bt-picker-field',
              ref: 'contactField',
              flex: 20,
              ontouchstart: 'onPickerFieldTouched',
              onkeyup: 'onSearchKeyup',
              childViews: [
                {
                  ref: 'searchIcon',
                  additionalClasses: 'bt-search-button',
                  ontouchstart: 'search'
                },
                {

                  tagName: 'input',
                  ref: 'pickerInput',
                  type: 'text',
                  additionalClasses: 'bt-picker-input'
                }
              ]
            },
            {
              flex: 1,
              ref: 'cancelButton',
              additionalClasses: 'bt-composer-x-button',
              onclick: 'blur'
            }
          ]
        },
        {
          view: 'ContactsTable',
          ref: 'table',
          flex: 1
        }
      ]
    };
  },

  ready: function() {
    this.header = this.refs.header;
    this.table = this.findRef('table');
    this.table.setHeight(0);

    this.searchText = this.findRef('pickerInput');
    this.contactField = this.findRef('contactField');
    this.cancelButton = this.findRef('cancelButton');
    this.withLabel = this.findRef('withLabel');
    this.searchIcon = this.findRef('searchIcon');
    this.container = this.findRef('container');

    this.refreshHandler = util.bind(this.refresh, this);

    this._contactTokens = [];
    this._selectedContacts = [];

    this._tokens = [];
    this._tokens.push(EventManager.listen(WindowManager.EVENT_KEYBOARD_APPEAR, this.onKeyboard, this));
    this._tokens.push(EventManager.listen(WindowManager.EVENT_KEYBOARD_DISAPPEAR, this.onKeyboard, this));

    this._onHidden = util.bind(this._onHidden, this);

    this.isDevice = require('shared/util').isBuffyDevice();
    this.shown = false;
  },

  destroy: function() {
    util.invoke(this._tokens, 'remove');
    View.prototype.destroy.call(this);
  },

  setSelectedContacts: function(contacts) {
    this._deleteAllSelectedContacts();
    if (contacts && contacts.length > 0) {
      for (var i = 0; i < contacts.length; i ++) {
        this._insertSelectedContact(contacts[i]);
      }
    }
  },

  onSearchKeyup: function(e) {
    var text = this.searchText.getNode().value;
    if (text === '' && this._lastValue === '' && e.keyCode === 8) {
      // The highlighted contact is the one to be deleted
      if (this._highlightContactIndex === -1) {
        this._highlightContact(this._contactTokens.length - 1);
      } else {
        // Set to -1 would clear the highlighted contact
        this._highlightContact(-1);
        this._deleteLastSelectedContact();
      }
    }

    if (text.trim() === '') {
      if (this._contactTokens.length === 0) {
        this.blur();
      }
      this.table.resetFilter();
    } else {
      this._highlightContact(-1);

      this.table.setFilter(text);
    }

    this._lastValue = text;
  },

  onContactSelect: function(contact) {
    this._insertSelectedContact(contact);
    // Set the width of the input to one, so that
    // when the new token shows up in the search area,
    // it does not get pushed down.
    // The correct width would be calculated in 'refresh'
    this.searchText.setStyle('width', '1px');

    this.blur();
  },

  scrollToTop: function() {
    this.table.scrollToTop();
  },

  onPickerFieldTouched: function(e) {
    this.focus();
    e.preventDefault();
  },

  focus: function() {
    this.focused = true;
    this.hidePlaceHolder();
    this.searchText.getNode().focus();
    this.showInputAndCancelButton();

    // In simulator, keyboard is not supported,
    // so refresh immediately.
    // On device, need to refresh after keyboard
    // shows up to get the correct device dimensions.
    if (!this.isDevice) {
      this.refresh();
    }
  },

  blur: function() {
    this.focused = false;
    this._highlightContact(-1);

    if (!this._isSearchTextEmpty()) {
      this._clearPickerInput();
      this.table.resetFilter();
    }

    this.searchText.getNode().blur();

    if (this._contactTokens.length === 0)  {
      if (this._isSearchTextEmpty()) {
        this.showPlaceHolder();
      } else {
        this.hidePlaceHolder();
      }
      this.showOnlyInput();
    } else {
      this.showInputAndWithLabel();
    }

    if (!this.isDevice) {
      this.refresh();
    }
  },

  showInputAndWithLabel: function() {
    this.withLabel.show();
    this.cancelButton.hide();
    this.hidePlaceHolder();
  },

  showInputAndCancelButton: function() {
    this.withLabel.hide();
    this.cancelButton.show();
    this.hidePlaceHolder();
  },

  showOnlyInput: function() {
    this.withLabel.hide();
    this.cancelButton.hide();
  },

  showPlaceHolder: function() {
    // Leave some space for the search icon
    this.searchText.getNode().placeholder = '    Who are you with?';
    this.searchIcon.show();
  },

  hidePlaceHolder: function() {
    this.searchText.getNode().placeholder = '';
    this.searchIcon.hide();
  },

  done: function() {
    this.hide();
    this.callback && this.callback(this._selectedContacts);
  },

  fbFriendsFilter: function(model) {
    return model._profileModel && model._profileModel.get('is_friend');
  },

  show: function(options) {
    var callback = options && options.callback;
    var selectedContacts = options && options.selectedContacts;
    // TODO: add hidden contacts back in
    var hiddenContacts = options && options.hiddenContacts;
    var fbFriendsOnly = options && options.fbFriendsOnly;
    if (fbFriendsOnly) {
      this.table.setFilterFunction(this.fbFriendsFilter);
    } else {
      this.table.setFilterFunction(null);
    }
    this.shown = true;
    this._highlightContactIndex = -1;
    this.callback = callback;

    this.blur();

    this.setStyle('webkitTransform', null);
    if (selectedContacts) {
      this.setSelectedContacts(selectedContacts);
    }

    // TODO: get rid of this line and find a better fix
    util.delay(util.bind(this.refresh, this), 200);
  },

  hide: function() {
    this.shown = false;

    var node = this.getNode();
    if (node.parentNode) {
      node.addEventListener('webkitTransitionEnd', this._onHidden);
    }

    // TODO: Once we can get exact screen dimension in windowmanager
    // instantiation. Remove the buffer.
    this.setStyle('webkitTransform',
      'translate3d(0,' + screen_dims.height + 'px,0)');
  },

  _onHidden: function() {
    this.getNode().removeEventListener('webkitTransitionEnd', this._onHidden);

    this.invoke('hidden');
  },

  // Refresh the table on keyboard events
  // to make sure it is scrollable
  onKeyboard: function() {
    if (this.shown) {
      setTimeout(this.refreshHandler, 100);
    }
  },

  goBack: function() {
    if (this.callback) {
      this.callback(null);
    }
    this.hide();
  },

  refresh: function() {
    this.pickerHeight = WindowManager.getDimensions().height - this.header.getNode().offsetHeight;

    // If the available space for the input is too small, push it to a new line.
    // Otherwise, let it occupy the remaining space on the same line as the last contact token.
    var width;
    if (this._contactTokens && this._contactTokens.length > 0) {
      var lastContact = this._contactTokens[this._contactTokens.length - 1].getNode();
      var inputLeft = lastContact.offsetLeft + lastContact.offsetWidth;

      var containerWidth = this.contactField.getNode().offsetWidth;
      var inputWidth =  containerWidth - inputLeft - 30;

     // If it is focused, need to make sure
      // the input area is big enough.
      // If it is blurred, then input box should
      // be at the same line as the last contact
      // token.
      var threshold = (this.focused) ? 80 : 0;
      if (inputWidth < threshold) {
        width = containerWidth + 'px';
      } else {
        width = inputWidth + 'px';
      }
    } else {
      width = '100%';
    }

    this.searchText.setStyle('width', width);

    // Let the cancel button be at the same line
    // as the input text.
    this.cancelButton.setStyle('top', this.searchText.getNode().offsetTop + 'px');

    var height = ((this.pickerHeight - this.contactField.getNode().offsetHeight) + "px");
    this.table.setHeight(height);
  },

  _insertSelectedContact: function(contact) {
    if (this._selectedContacts.indexOf(contact) > -1) {
      return;
    }
    this._selectedContacts.push(contact);
    var token = this.build({
      additionalClasses: 'bt-recipient-token',
      content: contact.get('name')
    });

    this._contactTokens.push(token);
    this.contactField.insertChild(token,
      this._selectedContacts.length - 1);
  },

  _deleteAllSelectedContacts: function() {
    while (this._selectedContacts.length > 0) {
      this._deleteLastSelectedContact(false);
    }
  },

  _deleteLastSelectedContact: function(refresh) {
    refresh = refresh !== undefined ? refresh : true;

    this._selectedContacts.pop();
    var token = this._contactTokens.pop();
    if (token) {
      this.contactField.removeChild(token);
    }

    if (refresh) {
      this.refresh();
    }
  },

  _highlightContact: function(i) {
    if (this._highlightContactIndex !== -1) {
      this._contactTokens[this._highlightContactIndex].removeClass('highlight');
    }

    if (i !== -1) {
      this._contactTokens[i].addClass('highlight');
    }

    this._highlightContactIndex = i;
  },

  _isSearchTextEmpty: function() {
    var value = this.searchText.getNode().value;
    return value === null || value.trim() === '';
  },

  _clearPickerInput: function() {
    this.searchText.getNode().value = '';
    this._lastValue = '';
  }
});

// insert the contact picker in the document
// initially in a hidden state
var contactPicker = exports.contactPicker = new ContactPicker();
contactPicker.hide();
contactPicker.placeIn(document.body);
});

// module: shared/api_xhr
// file:   ../../shared/js/api_xhr.js
define("shared/api_xhr", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var session  = require('shared/session');
var uriUtil  = require('shared/uri_util');
var util     = require('bolt/util');
var api_key  = require('shared/config').api_key;
var Deferred = require('shared/deferred').Deferred;
var timer    = require('shared/perf/timer');

// give 30 seconds to connect
var XHR_TIMEOUT = exports.XHR_TIMEOUT = 30 * 1000;

/**
 * The total number of queries in a batch. The batch request now supports the
 * POST XHR request. Any batch size can be set.
 * TODO: analyze the optimal batch size to gain the best performance.
 */
var FQL_BATCH_LIMIT = exports.FQL_BATCH_LIMIT = 7;
// REST: hard limit of 20 (on the server), so <= 20
var REST_BATCH_LIMIT = exports.REST_BATCH_LIMIT = 5;
// graph batch requests are limited to 20 on the server
var GRAPH_BATCH_LIMIT = exports.GRAPH_BATCH_LIMIT = 20;

// this is the amount of time to wait for other requests to add to a batch; this
// makes the initial request delay by up to this timeout value, so don't make it
// too big
var BATCH_START_TIMEOUT = 500;

var _pendingFQLBatch = {
  queries: [],
  deferreds: []
};
var _fqlBatchTimer = 0;

var _pendingRestBatch = {
  methodFeed: [],
  deferreds: [],
  readOnly: true
};
var _restBatchTimer = 0;

var _pendingGraphBatch = {
  methods: [],
  endpoints: [],
  params: [],
  deferreds: []
};
var _graphBatchTimer = 0;

/**
 * Send a graph request.
 *
 * @param {String} the method type of request to send. GET, POST or DELETE.
 * @param {String} the endpoint to hit. For graph.facebook.com/me/feed,
 *                 this is me/feed.
 * @param {Dictionary} parameters to send in the request
 */
exports.graph = function(method, endpoint, params) {
  params = util.extend({
    access_token: session.getAccessToken(),
    format: 'json-strings'
  }, params);
  var url = 'https://graph.facebook.com/' + endpoint + '&' +
    uriUtil.encodeObj(uriUtil.flatten(params));

  return _fireXHR(
    method,
    url,
    true,
    params
  );
};

/**
 * Send a batched graph request.  You can use this method if you know you
 * are sending less than GRAPH_BATCH_LIMIT requests.  Otherwise, consider
 * using the addBatchGraph method.
 *
 * @param {Object} an array of JSON objects describing the request.  see
 *   https://developers.facebook.com/docs/reference/api/batch/ for more info
 */
var multigraph = exports.multigraph = function(requests, params) {
  params = util.extend({
    access_token: session.getAccessToken(),
    batch: requests,
    format: 'json-strings'
  }, params);

  return _fireXHR(
    'POST',
    'https://graph.facebook.com',
    true,
    params
  );
};

exports.addBatchGraph = function(method, endpoint, params) {
  var deferred = new Deferred();
  _pendingGraphBatch.methods.push(method);
  _pendingGraphBatch.endpoints.push(endpoint);
  _pendingGraphBatch.params.push(params);
  _pendingGraphBatch.deferreds.push(deferred);

  if (_pendingGraphBatch.methods.length >= GRAPH_BATCH_LIMIT) {
    _startGraphBatch();
  } else if (!_graphBatchTimer) {
    _graphBatchTimer = setTimeout(_startGraphBatch, BATCH_START_TIMEOUT);
  }
  return deferred;
};

var rest = exports.rest = function(params, readOnly) {
  params = util.extend({
      api_key: api_key,
      format: 'json-strings',
      access_token: session.getAccessToken()
    }, params);

  return _fireXHR(
    'POST',
    (
      readOnly ?
      'https://api-read.facebook.com/restserver.php' :
      'https://api.facebook.com/restserver.php'
    ),
    true,
    params
  );
};

/**
 * Send a fql query.
 *
 * @param {String} query the fpi query statement
 */
exports.fql = function (query) {
  console.info("calling fql with key " + api_key);
  return rest({method:'fql.query', query: query}, true);
};

/**
 * Call a https://api.facebook.com/method/ * method.
 *
 * @param {String} method Name of API method to call
 * @param {Array} params Arguments to pass to method
 * @param {Function} callback The call back function
 * @param {Function} errback The error back function
 */
exports.method = function (method, params, callback, errback) {
  params = util.extend({
    api_key: api_key,
    format: 'json',
    access_token: session.getAccessToken()
  }, params);

  return _fireXHR(
    'GET',
    'https://api.facebook.com/method/' + method + '?' +
      uriUtil.encodeObj(uriUtil.flatten(params)),
    true,
    null,
    callback,
    errback
  );
};

/**
 * Send a local file request. (read only)
 *
 * @param {String} the path to the file to read
 */
exports.file = function(path) {
  return _fireXHR('GET', path, true, null, false);
};

/**
 * Send multiple queries in a single batched FB.api request.
 *
 * Note: this is an enhanced version of multiquery, which uses POST XHR, and
 * can work around the 4000 bytes URL limit.
 *
 * @param {Array of String} query the JSON encoded array of query statements
 */
var multifql = exports.multifql = function(queries) {
  return rest({method: 'fql.multiquery', queries: queries}, true);
};

/**
 * Adds a query into the batch.
 * Note that the query won't be sent out immediately. Instead, it just puts
 * the input query in a queue. Whenever the length of queue reaches 5 or the
 * time duration is more than 300ms, a multiquery will be fired.
 *
 * Note that FB fql requires that the rating of querying any table should not
 * exceed the rate of 600 calls per 600 seconds. By using the batching, five
 * queries are  sent out in just one single FB.api.multiquery request, it
 * alleviates the risk of exceeds the rate limit.
 *
 * @param {String} query the query statement
 */
exports.addBatchQuery = function(query) {
  var deferred = new Deferred();
  _pendingFQLBatch.queries.push(query);
  _pendingFQLBatch.deferreds.push(deferred);

  if (_pendingFQLBatch.queries.length >= FQL_BATCH_LIMIT) {
    _startFQLBatch();
  } else if (!_fqlBatchTimer) {
    _fqlBatchTimer = setTimeout(_startFQLBatch, BATCH_START_TIMEOUT);
  }
  return deferred;
};

var multirest = exports.multirest =
function(methodFeed, serialOnly, readOnly) {
  var methodFeedStrings = [];
  var params;
  for (var i = 0, l = methodFeed.length; i < l; ++i) {
    params = uriUtil.encodeObj(uriUtil.flatten(methodFeed[i]));
    methodFeedStrings.push(params);
  }
  return rest({
    method: 'batch.run',
    method_feed: JSON.stringify(methodFeedStrings),
    serial_only: !!serialOnly
  }, readOnly);
};

exports.addBatchRest = function(params, readOnly) {
  var deferred = new Deferred();
  _pendingRestBatch.methodFeed.push(params);
  _pendingRestBatch.readOnly = _pendingRestBatch.readOnly && readOnly;
  _pendingRestBatch.deferreds.push(deferred);

  if (_pendingRestBatch.methodFeed.length >= REST_BATCH_LIMIT) {
    _startRestBatch();
  } else if (!_restBatchTimer) {
    _restBatchTimer = setTimeout(_startRestBatch, BATCH_START_TIMEOUT);
  }
  return deferred;
};

function _deferredCallback(deferred, method, result) {
  deferred[method](result);
}

function _batchHandler(deferreds, resultProperty, isFailed, results) {
  var result, cbMethod, deferred = null;
  for (var i = 0, l = deferreds.length; i < l; ++i) {
    if (!util.isBlank(results) && !util.isBlank(results[i])) {
      result = (
        resultProperty ?
        results[i][resultProperty] :
        JSON.parse(results[i])
      );
    }
    // Temporary hack for graph requests
    if (resultProperty === 'body') {
      result = JSON.parse(result);
    }

    // flip the context to relieve run loop pressure on handlers
    deferred = deferreds[i];
    cbMethod = isFailed ? 'fail' : 'succeed';
    setTimeout(_deferredCallback, 0, deferred, cbMethod, result);
  }
}

/**
 * Send telemetry data to logging endpoint
 *
 * @param {String} The report type to be logged in Nectar (or explicitly handled by /mobile/logs)
 * @param {Object} The data to be recorded in the log entry
 */
exports.logTelemetry = function(report_type, params) {
  var logdata = uriUtil.flatten(params);
  var url = 'https://www.facebook.com/mobile/logs?compressed=0' +
                 '&platform=buffy' +
                 '&report_type=' + encodeURIComponent(report_type) +
                 '&' + uriUtil.encodeObj(params);

  return _fireXHR(
    'GET',
    url,
    true,
    params,
    false
  );
};

function _failXHR(xhr, deferred, error_msg) {
  clearTimeout(xhr.timeoutHandler);
  delete xhr.timeoutHandler;
  xhr.abort();
  timer.stop('xhr', xhr);
  deferred.fail();
}

function _onreadyStateChange(xhr, deferred) {
  // on a network error it jumps to readyState 4 and sets status = 0
  if (xhr.DONE === xhr.readyState && 0 === xhr.status &&
      xhr.timeoutHandler) {
    _failXHR(xhr, deferred, 'XHR network unreachable, aborting!');
  }
}

function _onload(xhr, deferred, parseResponse) {
  clearTimeout(xhr.timeoutHandler);
  delete xhr.timeoutHandler;
  var data = null;
  timer.stop('xhr', xhr);
  try {
    data = (parseResponse === false) ? xhr.responseText :
      JSON.parse(xhr.responseText);
  } catch (e) {
    console.error('XHR ERROR: ' + e.toString() +
      '(' + xhr.responseText + ')');
    deferred.fail();
    return deferred;
  }
  deferred.succeed(data);
  return deferred;
}

function _timeoutAbort(xhr, deferred) {
  if (xhr.UNSENT === xhr.readyState) {
    _failXHR(xhr, deferred, 'XHR timeout, aborting!');
  }
}

function _fireXHR(method, path, async, params, parseResponse) {
  var deferred = new Deferred();

  var xhr = new XMLHttpRequest();
  xhr.open(method, path, async);
  if (method.toLowerCase() === 'post') {
    xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
  }

  xhr.onreadystatechange = util.bind(_onreadyStateChange, null, xhr, deferred);
  xhr.onload = util.bind(_onload, null, xhr, deferred, parseResponse);
  xhr.timeoutHandler = setTimeout(_timeoutAbort, XHR_TIMEOUT, xhr, deferred);

  timer.start('xhr', xhr);
  xhr.send(uriUtil.encodeObj(uriUtil.flatten(params)));

  return deferred;
}

// starts the batch request through multifql
function _startFQLBatch() {
  clearTimeout(_fqlBatchTimer);
  _fqlBatchTimer = 0;
  var batch = _pendingFQLBatch;
  _pendingFQLBatch = {
    queries: [],
    deferreds: []
  };

  var deferred = multifql(batch.queries)
    .addCallback(_batchHandler, this, batch.deferreds, 'fql_result_set', false)
    .addErrback(_batchHandler, this, batch.deferreds, null, true);

  return deferred;
}

// starts the batch request through rest
function _startRestBatch() {
  clearTimeout(_restBatchTimer);
  _restBatchTimer = 0;
  var batch = _pendingRestBatch;
  _pendingRestBatch = {
    methodFeed: [],
    deferreds: [],
    readOnly: true
  };

  var deferred = multirest(
    batch.methodFeed,
    true,
    batch.readOnly)
    .addCallback(_batchHandler, this, batch.deferreds, null, false)
    .addErrback(_batchHandler, this, batch.deferreds, null, true);

  return deferred;
}

// starts the batch request through graph
function _startGraphBatch() {
  clearTimeout(_graphBatchTimer);
  _graphBatchTimer = 0;
  var batch = _pendingGraphBatch;
  _pendingGraphBatch = {
    methods: [],
    endpoints: [],
    params: [],
    deferreds: []
  };

  var requests = [];
  // construct the array of requests to send to multigraph()
  for (var i = 0; i < batch.methods.length; i++) {
    var request = util.extend({
      method: batch.methods[i],
      relative_url: batch.endpoints[i]
    }, batch.params[i]);

    requests.push(request);
  }

  var deferred = multigraph(requests)
    .addCallback(_batchHandler, this, batch.deferreds, 'body', false)
    .addErrback(_batchHandler, this, batch.deferreds, 'body', true);

  return deferred;
}

});

// module: shared/deferred
// file:   ../../shared/js/deferred.js
define("shared/deferred", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');

var STATUS_UNKNOWN   = 0;
var STATUS_SUCCEEDED = 1;
var STATUS_FAILED    = 2;

var slice = Array.prototype.slice;
function toArray(array, offset) {
  return array ? slice.call(array, offset) : [];
}

/**
 * Basic Deferred implementation. Based on EventMachine API.
 *
 * The callback/errback registrations all take a context so you do not need to
 * call util.bind on the function before passing it in (is is built-in to
 * deferred).  Other args past the context will be curried into the callback
 * arguments.
 *
 * @example
 *   doSomethingAsync()
 *     .addCallback(function() { do stuff })
 *     .addErrback(function() { report error });
 *
 *   function doSomethingAsync() {
 *     var def = new Deferred();
 *     setTimeout(function() {
 *       try {
 *         var result = doSomeRendering();
 *         def.succeed(result);
 *       } catch (e) {
 *         def.fail();
 *       }
 *     });
 *     return def;
 *   }
 *
 * @class
 */
var Deferred = core.createClass({
  name: 'Deferred',

  construct: function() {
    this.callbacks = [];
    this.completeCallbacks = [];
    this.errbacks  = [];
  },

  properties: {
    status: STATUS_UNKNOWN
  },

  /**
   * Adds a callback that will be executed when this Deferred succeeds. If it
   * has already succeeded the callback will be executed immediately.
   *
   * @param {Function} callback The callback function to execute
   * @param {Object} contextOrNull The context to execute the function in
   * @returns {Object} This Deferred object
   */
  addCallback: function(callback, contextOrNull) {
    return this._addCallback(
      STATUS_SUCCEEDED,
      this.callbacks,
      callback,
      contextOrNull,
      toArray(arguments, 2)
    );
  },

  /**
   * Removes a callback.  If no context is passed, it will remove the all
   * instances of the function that are registered; otherwise both parameters
   * must match.
   *
   * @param {Function} callback The callback function to execute
   * @param {Object} contextOrNull The context to execute the function in
   */
  removeCallback: function(callback, contextOrNull) {
    return this._removeCallback(this.callbacks, callback, contextOrNull);
  },

  /**
   * Adds a callback that will be executed when this Deferred succeeds, after
   * regular callbacks. If it has already succeeded the callback will be
   * executed immediately.
   *
   * (It's undesireable that we have this, but it is needed to make sure that
   * the DeferredList callback is called last - the other option is to make a
   * full prioritization feature for the callbacks so that they can be ordered
   * outside of the order that they are added to the Deferred)
   *
   * @param {Function} callback The callback function to execute
   * @param {Object} contextOrNull The context to execute the function in
   * @returns {Object} This Deferred object
   */
  addCompleteCallback: function(callback, contextOrNull) {
    return this._addCallback(
      null,
      this.completeCallbacks,
      callback,
      contextOrNull,
      toArray(arguments, 2)
    );
  },

  /**
   * Removes a callback.  If no context is passed, it will remove the all
   * instances of the function that are registered; otherwise both parameters
   * must match.
   *
   * @param {Function} callback The callback function to execute
   * @param {Object} contextOrNull The context to execute the function in
   */
  removeCompleteCallback: function(callback, contextOrNull) {
    return this._removeCallback(
      this.completeCallbacks,
      callback,
      contextOrNull
    );
  },

  /**
   * Adds a errback that will be executed when this Deferred fails. If it
   * has already failed the callback will be executed immediately.
   *
   * @param {Function} callback The callback function to execute
   * @param {Object} contextOrNull The context to execute the function in
   * @returns {Object} This Deferred object
   */
  addErrback: function(callback, contextOrNull) {
    return this._addCallback(
      STATUS_FAILED,
      this.errbacks,
      callback,
      contextOrNull,
      toArray(arguments, 2)
    );
  },

  /**
   * Removes an errback.  If no context is passed, it will remove the all
   * instances of the function that are registered; otherwise both parameters
   * must match.
   *
   * @param {Function} callback The callback function to execute
   * @param {Object} contextOrNull The context to execute the function in
   */
  removeErrback: function(callback, contextOrNull) {
    return this._removeCallback(this.errbacks, callback, contextOrNull);
  },

  setStatus: function(status) {
    this.set('status', status);
    var args = toArray(arguments, 1);
    this.callbackArgs = args;
    if (status === STATUS_FAILED) {
      this._runCallbacks(this.errbacks, args);
    } else if (status === STATUS_SUCCEEDED) {
      this._runCallbacks(this.callbacks, args);
    }
    this._runCallbacks(this.completeCallbacks, args);
    return this;
  },

  /**
   * Fails after timeout milliseconds of delay.  If called multiple times only
   * the last set timeout applies.
   */
  setTimeout: function(timeout) {
    if (this.timeout) {
      this.clearTimeout();
    }
    this.timeout = setTimeout(this._fail, timeout, this);
  },

  /**
   * Clears the timeout created by setTimeout.
   */
  clearTimeout: function() {
    clearTimeout(this.timeout);
    delete this.timeout;
  },

  /**
   * Succeeds the Deferred.  Arguments passed to succeed will be passed to any
   * registered callbacks when they are run.
   */
  succeed: function() {
    var args = [STATUS_SUCCEEDED].concat(toArray(arguments, 0));
    return this.setStatus.apply(this, args);
  },

  /**
   * Fails the Deferred.  Arguments passed to fail will be passed to any
   * registered errbacks when they are run.
   */
  fail: function() {
    var args = [STATUS_FAILED].concat(toArray(arguments, 0));
    return this.setStatus.apply(this, args);
  },

  /**
   * Adds a callback that will be called after the Deferred succeeds, and
   * optionally an errback to be called when the Deferred fails.  This returns a
   * new Deferred that succeeds or fails with the result of the callback or
   * errback, respectively.
   */
  then: function(callback, errbackOrContext, contextOrNull) {
    var deferred = new Deferred();
    var args, errback, context;

    args = toArray(arguments, 0);
    args.shift();
    if (util.isFunction(args[0])) {
      errback = args.shift();
    }
    context = args.shift();

    if (util.isFunction(callback)) {
      var callbackArgs = [this._thenCallback, this,
        callback, context, deferred].concat(args);
      this.addCallback.apply(this, callbackArgs);
    } else {
      this.addCallback(deferred.succeed, deferred);
    }

    if (errback) {  // errback guaranteed to be a function by isFunction above
      var errbackArgs = [this._thenErrback, this,
        errback, context, deferred].concat(args);
      this.addErrback.apply(this, errbackArgs);
    } else {
      this.addErrback(deferred.fail, deferred);
    }

    return deferred;
  },

  _addCallback: function(status, callbacks, callback, contextOrNull, args) {
    var currentStatus = this.getStatus();
    if ((!status && currentStatus !== STATUS_UNKNOWN) ||
        currentStatus === status
    ) {
      callback.apply(contextOrNull || this, args.concat(this.callbackArgs));
    } else {
      callbacks.push({
        callback: callback,
        context: contextOrNull,
        args: args
      });
    }
    return this;
  },

  // this is a convenience function for failing a deferred through a timeout
  // without wrapping it in util.bind, just pass 'this' as an arg to
  // setTimeout
  _fail: function(deferred) {
    deferred.fail();
  },

  _removeCallback: function(callbacks, callback, context) {
    var item;
    for (var i = 0, l = callbacks.length; i < l; ++i) {
      item = callbacks[i];
      if (item.callback === callback &&
        (!context || item.context === context)) {
        callbacks.splice(i, 1);

        // remove all that match callback if no context is specified
        if (context) {
          break;
        }
      }
    }
    return this;
  },

  _runCallbacks: function(callbacks, args) {
    var item;
    while ((item = callbacks.shift())) {
      if (item.callback) {
        item.callback.apply(
          item.context || this,
          (item.args || []).concat(args)
        );
      }
    }
  },

  _thenCallback: function(callback, context, deferred) {
    var args = toArray(arguments, 3);

    var result = callback.apply(context, args);
    if (result instanceof Deferred) {
      // if return value is Deferred, wait for it to resolve
      result
        .addCallback(deferred.succeed, deferred)
        .addErrback(deferred.fail, deferred);
    } else {
      deferred.succeed(result);
    }
  },

  _thenErrback: function(errback, context, deferred) {
    var args = toArray(arguments, 3);

    var result = errback.apply(context, args);
    if (result instanceof Deferred) {
      // if return value is Deferred, wait for it to resolve
      result
        .addCallback(deferred.succeed, deferred)
        .addErrback(deferred.fail, deferred);
    } else {
      deferred.fail(result);
    }
  }
});

/**
* Group several deferreds into one. Will succeed when all
* deferreds succeed or fail when all are finished and at least
* one failed.
*
* Provides a hook for non deferred world, @see createWaitForCallback
*
* @example
*   var list = new DeferredList();
*   performRequest(list.createWaitForCallback());
*   list.waitFor(doSomethingAsync());
*   list
*     .addCallback(function() { all is good }).
*     .startWaiting();
*
* @example
*   performRequest
*
* @class
*/
var DeferredList = core.createClass({
  name: 'DeferredList',

  extend: Deferred,

  construct: function(list) {
    Deferred.call(this);

    this.completed = 0;

    this.list = [];
    if (list) {
      util.forEach(list, this.waitFor, this);
      this.startWaiting();
    }
  },

  startWaiting: function() {
    this.waiting = true;
    this.checkDeferreds();
    return this;
  },

  waitFor: function(deferred) {
    this.list.push(deferred);
    this.checkDeferreds();
    deferred.addCompleteCallback(this.deferredComplete, this);
    return this;
  },

  createWaitForDeferred: function() {
    var deferred = new Deferred();
    this.waitFor(deferred);
    return deferred;
  },

  createWaitForCallback: function() {
    var deferred = this.createWaitForDeferred();
    return util.bind(deferred.succeed, deferred);
  },

  deferredComplete: function() {
    this.completed++;
    if (this.completed === this.list.length) {
      this.checkDeferreds();
    }
  },

  checkDeferreds: function() {
    if (!this.waiting || this.completed !== this.list.length) {
      return;
    }
    var failed = false;
    var args = [failed ? STATUS_FAILED : STATUS_SUCCEEDED];
    for (var i = 0, l = this.list.length; i < l; i++) {
      var deferred = this.list[i];
      args.push([deferred].concat(deferred.callbackArgs));
      if (deferred.getStatus() === STATUS_FAILED) {
        failed = true;
      }
    }
    if (failed) {
      this.fail.apply(this, args);
    } else {
      this.succeed.apply(this, args);
    }
  }
});

exports.Deferred                  = Deferred;
exports.DeferredList              = DeferredList;
exports.Deferred.STATUS_UNKNOWN   = STATUS_UNKNOWN;
exports.Deferred.STATUS_SUCCEEDED = STATUS_SUCCEEDED;
exports.Deferred.STATUS_FAILED    = STATUS_FAILED;
});

// module: controller/app_controller
// file:   controller/app_controller.js
define("controller/app_controller", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*global undefined:false*/

var core = require('bolt/core');
var util = require('bolt/util');
var Model = require('bolt/model').Model;

var SceneStack    = require('bolt_touch/views/scene_stack').SceneStack;
var Mailbox       = require('shared/model/mailbox').Mailbox;

var DialerScene             =
  require('views/dialer/dialer_scene').DialerScene;
var HomeScene               =
  require('view/home_scene/home_scene').HomeScene;
var MessagesScene           =
  require('view/messages_scene/messages_scene').MessagesScene;
var MessageComposerScene    =
  require('view/message_composer_scene/message_composer_scene')
  .MessageComposerScene;
var AttachmentScene         =
  require('view/attachment_scene/attachment_scene').AttachmentScene;
var ThreadPhoneNumbersScene =
  require('view/thread_phone_numbers_scene/thread_phone_numbers_scene')
    .ThreadPhoneNumbersScene;
var EventManager            = require('shared/event_manager').EventManager;

var BrowseContactsSection =
  require('../contacts/browse_contacts_section').BrowseContactsSection;
var ContactsTransitionManager =
  require('../contacts/contacts_transition_manager').ContactsTransitionManager;
var ContactFiltersSection =
  require('../contacts/contact_filters_section').ContactFiltersSection;

var global = this;

var AppController = core.createClass({
  name: 'AppController',

  _homeScene: null,

  construct: function() {
    this._sceneStack = new SceneStack({disableHeaders: true});
    this._sceneStack.placeIn(document.body);
    this._expectedHash = undefined;

    this._threadDeferreds = {};

    window.addEventListener('hashchange',
      util.bind(this._openLinkedScene, this));
    document.addEventListener('webkitvisibilitychange',
      util.bind(this._handleVisibilityChange, this));
    this._setupContactsSections();
    this._openLinkedScene();
  },

  _initScenes: function() {
    this._sceneStack.clearStack({}, { noTransition: true });

    // voloko: Unfortnuatelly we have to manually push a mailboxes and threads
    // scenes into the stack to be able to return to them later
    this._homeScene = new HomeScene({ controller: this });
    var _this = this;
    this._homeScene.addListener('contactsSelected', function() {
      if (_this._contactsEventsManager.displayAllContacts) {
        _this._contactsEventsManager.displayAllContacts();
      }
    });
    this._sceneStack.push(this._homeScene, { noTransition: true });
  },

  _setupContactsSections: function() {
    this._contactsEventsManager = new ContactsTransitionManager(this);
    var transitionManager = this._contactsEventsManager;

    this._browseContactsSection = new BrowseContactsSection();
    this._browseContactsSection.addListener(transitionManager);

    this._contactFiltersSection = new ContactFiltersSection();
    this._contactFiltersSection.addListener(transitionManager);
  },

  openDefaultScene: function() {
    global.MEASURE_TALK_USABLE = true;
    this._initScenes();
    this._homeScene.setMailbox(Mailbox.MAILBOXES.inbox);
  },

  _decodeParams: function(query) {
    var params = {};
    var vars = (query || '').split('&');
    for (var i = 0; i < vars.length; i++) {
      var pair = vars[i].split('=');
      params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return params;
  },

  _encodeParams: function(params) {
    var pairs = [];
    for (var i in params) {
      pairs.push(encodeURIComponent(i) + '=' + encodeURIComponent(params[i]));
    }
    return pairs.join('&');
  },

  setSceneLink: function(params) {
    window.location.hash = this._expectedHash = this._encodeParams(params);
  },

  /**
   * Load a thread.
   *
   * @param thread {ClientThread} The thread to load.
   * @return A Deferred object
   */
  loadThread: function(thread) {
    var threadId = thread.getId();

    var deferred = this._threadDeferreds[threadId];
    if (!deferred) {
      var messageClient = require('talk/client/message_client').getInstance();
      this._threadDeferreds[threadId] = deferred =
        messageClient.fetchLastMessages(threadId, 50);
    } else {

      // The second time a thread is loaded, clean it up.
      // There is a strange behavior where, if a thread is loaded into a
      // messages_scene view, the collection goes to length zero, so force it
      // to load from the data base again.
      delete this._threadDeferreds[threadId];
    }
    return deferred;
  },

  _openLinkedScene: function() {
    var hash = (window.location.hash || '').replace(/^#/, '');
    if (hash === this._expectedHash) {
      return;
    }
    this._expectedHash = hash;
    var params = this._decodeParams(hash);
    var threadClient;

    if (params.dismissAfterAction && params.dismissAfterAction == 'true') {
      this.dismissAfterAction = true;
    }

    // try to open thread by id
    if (params.tid) {
      threadClient = require('talk/client/thread_client').getInstance();
      threadClient.fetchCollection({ id: params.tid })
        .addCallback(function(collection) {
          var thread = collection.first();
          collection.destroy();
          if (thread) {
            this._initScenes();
            this.openMessages(thread, { noTransition: true });
          } else {
            this.openDefaultScene();
          }
        }, this);
      return;
    }

    // try to open thread by uid
    if (params.uid) {
      this.openThreadOrComposer(params.uid, 'fbid', true);
      return;
    }

    // open message composer
    if (params.recipient) {
      this._initScenes();
      this.openMessageComposer(
        { recipient: params.recipient },
        { noTransition: true });
      return;
    }

    // parse mailto
    if (params.protocol && params.protocol == 'mailto') {
      var vars = params.url.split('?');
      var email = vars[0].replace('mailto:', '');
      var mailtoParams = this._decodeParams(vars[1]);
      var body = [];
      if (mailtoParams.subject) {
        body.push(mailtoParams.subject);
      }
      if (mailtoParams.body) {
        body.push(mailtoParams.body);
      }
      this._initScenes();
      this.openMessageComposer({
          recipient: email,
          body: body.join('\n')
        },
        { noTransition: true });
      return;
    }

    if (params.mailbox && Mailbox.MAILBOXES[params.mailbox]) {
      global.MEASURE_TALK_USABLE = true;
      this._initScenes();
      this.openThreads(
        Mailbox.MAILBOXES[params.mailbox],
        { noTransition: true });
      return;
    }

    if (params.scene && params.scene == 'composer') {
      this._initScenes();
      this.openMessageComposer({}, { noTransition: true });
      return;
    }

    // by default open inbox
    this.openDefaultScene({ noTransition: true });
  },

  openThreadOrComposer: function(recipient, type, noTransition) {
    var threadClient = require('talk/client/thread_client').getInstance();
    var recipientIdent = type + ':' + recipient;
    var session = require('shared/session');
    threadClient
      .fetchThreadByIdents(['fbid:' + session.getUid(), recipientIdent])
      .then(function(thread) {
        if (thread) {
          this._initScenes();
          this.openMessages(thread, { noTransition: noTransition });
        } else {
          this._initScenes();
          var options = {};
          if (type == 'fbid') {
            options = {recipientUid: recipient};
          } else {
            options = {recipient: recipient};
          }
          this.openMessageComposer(
            options,
            { noTransition: noTransition });
        }
      }, this);
  },

  _handleVisibilityChange: function() {
    if (document.webkitHidden) {
      this._clearDismissAfterAction();
    }
  },

  _clearDismissAfterAction: function() {
    delete this.dismissAfterAction;
    var params = this._decodeParams();
    if ('dismissAfterAction' in params) {
      delete params.dismissAfterAction;
      // clear param from URL as well (otherwise the next time talk is loaded
      // we might set this variable even if we don't want to dismiss after
      // the action
      this.setSceneLink(params);
    }
  },

  openDialer: function(header, transitionOptions) {
    var scene = new DialerScene({
      controller: this,
      title: 'Dialer'
    });
    this._sceneStack.push(scene, transitionOptions);
  },

  openThreads: function(mailbox, transitionOptions) {
    this._homeScene.setMailbox(mailbox);
    this._sceneStack.popTo('HomeScene');
  },

  openMessages: function(thread, transitionOptions) {
    var scene = new MessagesScene({
      controller: this
    });
    this._sceneStack.push(scene, transitionOptions);
    scene.setThread(thread);
    this._currentMessagesScene = scene;
  },

  openMessageComposer: function(options, transitionOptions) {
    options = options || {};
    transitionOptions = transitionOptions || {};
    var scene = new MessageComposerScene({
      forwardMessages: options.forwards,
      recipient: options.recipient,
      recipientUid: options.recipientUid,
      localId: options.localId,
      body: options.body,
      controller: this
    });
    if (!('onComplete' in transitionOptions)) {
      transitionOptions.onComplete = function() {
        scene.changeFocus(scene.klass.FOCUS_PICKER);
      };
    }
    this._sceneStack.push(scene, transitionOptions);
  },

  openThreadPhoneNumbersScene: function(numbers) {
    var scene = new ThreadPhoneNumbersScene({
      controller: this
    });
    scene.setNumbers(numbers);
    this._sceneStack.push(scene);
  },

  openAttachment: function(message, attachment) {
    var scene = new AttachmentScene();
    scene.setController(this);
    scene.setModel(message);
    scene.setAttachment(attachment);
    this._sceneStack.push(scene);
  },

  tryDismissAfterAction: function() {
    if (this.dismissAfterAction) {
      EventManager.notifyCore('goBack');
      delete this.dismissAfterAction;
    }
  },

  backToThread: function() {
    this._sceneStack.popTo('MessagesScene');
  },

  backToThreads: function(mailbox) {
    this._sceneStack.popTo('HomeScene');
    // if we're returning to a not yet rendered thread list, set mailbox on it
    var currentMailbox = this._homeScene.getMailbox();
    if (!currentMailbox ||
        (mailbox && (currentMailbox.folder !== mailbox.folder))) {
      this._homeScene.setMailbox(mailbox || Mailbox.MAILBOXES.inbox);
    }
    if (this._currentMessagesScene) {
      delete this._currentMessagesScene;
    }
  },

  back: function() {
    this._sceneStack.pop();
  },

  //Contacts Transitions Section

  displayScene: function(scene) {
    if (scene.getDeclaredClass() === 'ContactsListScene') {
      this._homeScene.showAllContactsScene(scene);
      this.backToThreads();
    } else {
      if (this._sceneStack.indexOf(scene.getDeclaredClass()) === -1) {
        this._sceneStack.push(scene);
      } else {
        this._sceneStack.popTo(scene.getDeclaredClass());
      }
    }
  },

  displayBrowseContactsWithGroupData: function(data) {
    this._homeScene.showBrowseContactsScene();
    this._browseContactsSection.displayContactsInGroup(data);
    this.backToThreads();
  },

  displayBrowseContactsWithListData: function(data) {
    this._homeScene.showBrowseContactsScene();
    this._browseContactsSection.displayContactsInList(data);
    this.backToThreads();
  },

  displayPickContactsFilter: function() {
    if (this._sceneStack.indexOf('ContactFiltersScene') === -1) {
      this._sceneStack.push(
        this._contactFiltersSection.getScene()
      );
    } else {
      this._sceneStack.popTo('ContactFiltersScene');
    }
  },

  displayProfile: function(snapshot) {
    //this is a hack and needs to be fixed
    window.openProfile(snapshot.facebookId);
  }
});

exports.AppController = AppController;
});

// module: third-party/md5
// file:   ../../third-party/md5.js
define("third-party/md5", function(require, exports, module) {
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = "";  /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
exports.b64_md5 = function(s)    { return rstr2b64(rstr_md5(str2rstr_utf8(s))); }

exports.hex_md5 = function(s)    { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }
exports.any_md5 = function(s, e) { return rstr2any(rstr_md5(str2rstr_utf8(s)), e); }
function hex_hmac_md5(k, d)
  { return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function b64_hmac_md5(k, d)
  { return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function any_hmac_md5(k, d, e)
  { return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc").toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of a raw string
 */
function rstr_md5(s)
{
  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
}

/*
 * Calculate the HMAC-MD5, of a key and some data (raw strings)
 */
function rstr_hmac_md5(key, data)
{
  var bkey = rstr2binl(key);
  if(bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
  try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input)
{
  try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for(var i = 0; i < len; i += 3)
  {
    var triplet = (input.charCodeAt(i) << 16)
                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > input.length * 8) output += b64pad;
      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding)
{
  var divisor = encoding.length;
  var i, j, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for(i = 0; i < dividend.length; i++)
  {
    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. All remainders are stored for later
   * use.
   */
  var full_length = Math.ceil(input.length * 8 /
                                    (Math.log(encoding.length) / Math.log(2)));
  var remainders = Array(full_length);
  for(j = 0; j < full_length; j++)
  {
    quotient = Array();
    x = 0;
    for(i = 0; i < dividend.length; i++)
    {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if(quotient.length > 0 || q > 0)
        quotient[quotient.length] = q;
    }
    remainders[j] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for(i = remainders.length - 1; i >= 0; i--)
    output += encoding.charAt(remainders[i]);

  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                  (input.charCodeAt(i) >>> 8) & 0xFF);
  return output;
}

function str2rstr_utf16be(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                   input.charCodeAt(i)        & 0xFF);
  return output;
}

/*
 * Convert a raw string to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binl(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(var i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32);
  return output;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function binl_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}
});

// module: bolt_touch/views/data_list/index
// file:   ../../../frameworks/bolt_touch/lib/views/data_list/index.js
define("bolt_touch/views/data_list/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core     = require('bolt/core');
var util     = require('bolt/util');
var dom      = require('bolt/dom');
var domEvent = require('bolt/dom_event');
var View     = require('bolt/view').View;

var eventually = require('../../util/eventually').eventually;
var CommandQueue = require('./command_queue').CommandQueue;
var ScrollViewAdapter = require('./scroll_view_adapter').ScrollViewAdapter;


/**
 * @class DataList
 * @classdesc DataList is a view that renders a collection or an array of data.
 *
 * Each item (row) in the collection is rendered a separate View object. When
 * placed into a ScrollView DataList utilizes progressive rendering. This means
 * that DataList will only render the rows that are visible at the given time.
 * It will try to reuse views while doing so. When a view goes off-screen
 * DataList will reclaim it and reuse to render new rows that are currently
 * visible.
 *
 * If provided with a Collection DataList will react to collection events and
 * update itself accordingly.
 *
 * DataList is supposed to be placed in a scrollable view, though it can live
 * without one. There can be other children in the scrollable container. In this
 * case you need to manually set scrollableParent property on the DataList.
 *
 * Options 'throttle', 'debounce', 'prerender' are available for performance
 * tuning. They all have sane defaults out of the box. Check the
 * RenderingStrategy for more info.
 *
 * @example
 *
 *   builder.build(
 *    { view: DataList, data: ['hello', 'world'] }
 *   );
 *
 *   // DataList support object pooling. If you provide both
 *   // createView and updateView DataList will try to avoid creating new
 *   // Views for rows and instead reuse already available. See ViewManager
 *   // and getReusableType if you have different types of views in the same
 *   // DataList
 *   builder.build({
 *     view: DataList,
 *     createView: function(model) {
 *       return new View({ content: model.get('name') });
 *     },
 *     updateView: function(view, model) {
 *       model.setContent(view);
 *     }
 *   });
 *
 *   // DataList can coexist with other views (including other DataLists)
 *   // within one scrollable container. It will do the right thing
 *   // automatically => only rendering data when it's visible
 *   builder.build({
 *     view: ScrollView,
 *     childViews: [
 *       { view: Header, content: 'Messages' },
 *       { view: DataList, data: messages },
 *       { view: Header, content: 'Posts' },
 *       { view: DataList, data: posts }
 *     ]
 *   });
 *
 *   builder.build({
 *     view: ScrollView,
 *     childViews: [
 *       { view: SearchBar },
 *       { view: DataList, data: threads }
 *     ]
 *   });
 */
var DataList = core.createClass({

  name: 'DataList',

  extend: View,

  properties: {

    /**
     * @property {Array|Collection} data to render
     */
    data: null,

    /**
     * @property {boolean} manageSelection - If true, initialize the selection
     * controller that will handle selection events for the views in the
     * DataList. Selection management can be expensive, so if this is not
     * necessary turn it off.
     */
    manageSelection: true,

    /**
     * @property {Number} manageSelection - when selection is enabled, this
     * should point to the currently selected element
     */
    selectedIndex: null,

    /**
     * @property {Number} throttle - Do not redraw more often then in value ms
     */
    throttle: 0,

    /**
     * @property {Number} debounce - Do redraw only after value ms after
     * last scroll or resize
     */
    debounce: 0,

    /**
     * @property {Number} prerender
     * Rendering and scrolling often happen on different threads. And event if
     * they don't throttle or debounce will lead to the same effect. This means
     * that we can potentially see a black yet-to-be-rendered area while
     * scrolling. To remedy this DataList will render more data than is
     * actually visible. Prerender controls this behavior.
     *
     * Prerender specifies how far should the visible range be extended.
     * 1 means that rendering range is extended before and after visible range
     * for the whole visible height => equaling to 3 vis heights to render.
     */
    prerender: 0.5,

    /**
     * @property {View|HTMLElement} If the direct parent of a DataList isn't a
     * scrollable view, one must be set. If the scrollable parent needs to be
     * updated when the DataList changes height, it should implement a method
     * called "refresh", which will be called on height change.
     */
    scrollableParent: null,

    /**
     * @property {Boolean} reverse - Renders the list upside down, with first
     * element being the bottommost
     */
    reverse: false
  },

  _viewManager: null,
  _renderingStrategy: null,
  _commandQueue: null,
  _scrollViewAdapter: null,


  /**
   * @param {Object} options - a hash with options (see properties) for the
   *   DataList and it's rendering strategy
   * @return DataList
   */
  construct: function(options) {
    if (options.viewManager) {
      this._viewManager = options.viewManager;
    } else {
      var ViewManager = require('./view_manager').ViewManager;
      this._viewManager = new ViewManager(options);
    }

    if (options.renderingStrategy) {
      this._renderingStrategy = options.renderingStrategy;
    } else {
      var VariableHeightRenderingStrategy =
        require('./rendering_strategy/variable_height')
          .VariableHeightRenderingStrategy;
      this._renderingStrategy = new VariableHeightRenderingStrategy(options);
    }

    if (options.doesEventTriggerRedraw) {
      this._doesEventTriggerRedraw = options.doesEventTriggerRedraw;
    }
    if (options.doesEventTriggerResize) {
      this._doesEventTriggerResize = options.doesEventTriggerResize;
    }

    if (this.getManageSelection()) {
      if (options.selectionController) {
        this._selectionController = options.selectionController;
      } else {
        var SelectionController =
          require('./selection_controller').SelectionController;
        this._selectionController = new SelectionController();
      }
    }

    this._commandQueue = new CommandQueue();
    this._originalUpdate = this.update;

    View.call(this, options);
  },

  /**
   * Data to render. When data is changed DataList is forced to fully redraw
   * itself. This is a relatively expensive operation.
   *
   * @param {Array|Collecton} data
   */
  setData: function(data) {
    var oldData = this.get('data');
    if (oldData && oldData.addListener) {
      oldData.removeListener('all', this._onCollectionEvent, this);
    }
    this.set('data', data);
    this._renderingStrategy.setData(data);
    this.setSelectedIndex(-1);
    if (data && data.addListener) {
      data.addListener('all', this._onCollectionEvent, this);
    }
    this.update();
    return this;
  },

  /**
   * Manually provide a ScrollableParent
   *
   * @param {ScrollView} parent
   */
  setScrollableParent: function(parent) {
    if (this._scrollViewAdapter) {
      this._scrollViewAdapter.destroy();
    }
    this.set('scrollableParent', parent);
    this._scrollViewAdapter = parent &&
      new ScrollViewAdapter(parent, this, this.getReverse());
    this.update();
  },

  setThrottle: function(time) {
    this.set('debounce', 0);
    this.set('throttle', time);
    this._wrapUpdate(time, 'throttle');
    return this;
  },

  setDebounce: function(time) {
    this.set('throttle', 0);
    this.set('debounce', time);
    this._wrapUpdate(time, 'debounce');
    return this;
  },

  /**
   * Update DataList when either the viewport or the pane dimensions change.
   * You need to manually call this method when you show a DataList after it
   * was hidden. This method can be throttled or debounced
   * (see corresponding properties).
   */
  update: function() {
    this._updateStrategy();
  },

  /**
   * Reset DataList internal state and do a full re-render. This is one of the
   * most expensive operations. It only makes sense if the data changes in a
   * way that DataList can not understand.
   */
  reset: function() {
    this._renderingStrategy.clear();
    this.setSelectedIndex(-1);
    this.update();
  },

  /**
   * Given a dom event within the DataList return an index of the corresponding
   * row.
   * @param {Event} event
   */
  getIndexForEvent: function(event) {
    return this._renderingStrategy.getIndexForEvent(event);
  },

  /**
   * Add or remove highlighting to/from a given row.
   * @param {Number} index
   * @param {Boolean} state
   */
  setHighlighted: function(index, state) {
    return this._renderingStrategy.setHighlighted(index, state);
  },

  // protected
  ready: function() {
    if (this._selectionController) {
      this._selectionController.init(this);
    }
    this._renderingStrategy.init(this._viewManager, this, this.getReverse());
  },

  declare: function() {
    return { };
  },

  onDocumentInsertion: function() {
    if (!this.getScrollableParent()) {
      this.setScrollableParent(this._findScrollableParent());
    }
    this.update();
  },

  getViewManager: function() {
    return this._viewManager;
  },

  destroy: function() {
    View.prototype.destroy.call(this);
    this.setScrollableParent(null);
    this.setData(null);
    if (this.getManageSelection()) {
      this._selectionController = null;
    }
    this._renderingStrategy.destroy();
    this._viewManager.destroy();
  },


  _readyToRender: function() {
    return this.getInDocument() && this.getData() &&
      this.getNode() && this.getNode().offsetWidth;
  },

  _updateHeight: function() {
    var height = this._renderingStrategy.getHeight();
    this._scrollViewAdapter.updateHeight(height);
  },

  _updateStrategy: function() {
    if (this._readyToRender()) {
      var changed = this._renderingStrategy.update(
        this._commandQueue,
        this._getRenderingRange(),
        this.getNode().offsetWidth);
      if (changed) {
        this._updateHeight();
      }
    }
  },

  _findScrollableParent: function() {
    return this.getParentView();
  },

  _getVisibleRange: function() {
    return this._scrollViewAdapter && this._scrollViewAdapter.getVisibleRange();
  },

  _getRenderingRange: function() {
    this._renderingRange = this._renderingRange || { from: 0, to: 0 };
    this._renderingHeight = this._renderingHeight || 0;
    var range = this._getVisibleRange();
    if (!range) {
      return this._renderingRange;
    }
    var h = (range.to - range.from) * this.getPrerender();
    h = this._renderingHeight = Math.max(this._renderingHeight, h);
    var from = range.from - h;

    this._renderingRange.from = Math.max(0, from);
    this._renderingRange.to   = range.to + h + (from < 0 ? -from : 0);
    return this._renderingRange;
  },

  _doesEventTriggerRedraw: function(event) {
    return false;
  },

  _doesEventTriggerResize: function(event) {
    return false;
  },

  _wrapUpdate: function(v, method) {
    if (v > 0) {
      this.update = util[method](this._originalUpdate, v);
    } else {
      this.update = this._originalUpdate;
    }
  },

  _insert: function(index, model) {
    this._commandQueue.push(CommandQueue.INSERT, index, model);
    eventually(this.update, this);
  },

  _remove: function(index) {
    this._commandQueue.push(CommandQueue.REMOVE, index, null);
    eventually(this.update, this);
  },

  _redraw: function(index, model) {
    this._commandQueue.push(CommandQueue.REDRAW, index, model);
    eventually(this.update, this);
  },

  _resize: function(index, model) {
    this._commandQueue.push(CommandQueue.RESIZE, index, model);
    eventually(this.update, this);
  },

  _onCollectionEvent: function(e) {
    if (e.type === 'modelAdded') {
      this._insert(e.data.index, e.data.model);
    } else if (e.type === 'modelRemoved') {
      this._remove(e.data.index);
    } else if (e.type === 'modelChanged') {
      if (this._doesEventTriggerResize(e)) {
        this._resize(e.data.index, e.data.model);
      } else if (this._doesEventTriggerRedraw(e)) {
        this._redraw(e.data.index, e.data.model);
      }
    } else if (e.type === 'updated') {
      this._commandQueue.clear();
      this._renderingStrategy.clear();
      this.update();
    } else if (e.type === 'endUpdate') {
      this.update();
    }
  }
});


exports.DataList = DataList;
});

// module: mock/wifi_api
// file:   ../../mock/js/wifi_api.js
define("mock/wifi_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;

module.exports = {
  SECURITY_NONE: 0,
  SECURITY_EAP: 1,
  SECURITY_PSK: 2,
  SECURITY_WEP: 3,

  STATE_AUTHENTICATING: 0,
  STATE_CHECKING_CONNECTIVITY: 1,
  STATE_CONNECTED: 2,
  STATE_CONNECTING: 3,
  STATE_DISCONNECTED: 4,
  STATE_DISCONNECTING: 5,
  STATE_FAILED: 6,
  STATE_IDLE: 7,
  STATE_OBTAINING_IPADDR: 8,
  STATE_SCANNING: 9,
  STATE_SUSPENDED: 10,

  WIFI_DISABLING: 0,
  WIFI_DISABLED: 1,
  WIFI_ENABLING: 2,
  WIFI_ENABLED: 3,
  WIFI_UNKNOWN: 4,

  MAX_WIFI_LEVEL: 5,

  NETWORK_ID_UNKNOWN: -1,

  _mixin: function(a, b) {
    for (var key in b) {
      a[key] = b[key];
    }
    return a;
  },

  // This is a snapshot of the network wireless hotspots while I was working on
  // this...
  _wifiNetworks: [{
    "isDisabled": false,
    "isRemembered": false,
    "id": -1,
    "level": 0,
    "SSID": "bluebook",
    "isAdhoc": false,
    "security": 1,
    "capabilities": "[WPA2-EAP-CCMP]",
    "BSSID": "00:0b:86:02:2b:e1",
    "priority": -1
  }, {
    "isDisabled": false,
    "isRemembered": false,
    "id": -1,
    "level": 1,
    "SSID": "lighthouse",
    "isAdhoc": false,
    "security": 1,
    "capabilities": "[WPA2-EAP-CCMP]",
    "BSSID": "00:0b:86:fa:e1:00",
    "priority": -1
  }, {
    "isDisabled": false,
    "isRemembered": false,
    "id": -1,
    "level": 5,
    "SSID": "fbguest",
    "isAdhoc": false,
    "security": 0,
    "capabilities": "",
    "BSSID": "00:0b:86:fa:e2:e3",
    "priority": -1
  }, {
    "isDisabled": false,
    "isRemembered": false,
    "id": -1,
    "level": 4,
    "SSID": "jzhouMBP15",
    "isAdhoc": true,
    "security": 0,
    "capabilities": "[IBSS]",
    "BSSID": "4a:69:92:fa:e5:60",
    "priority": -1
  }, {
    "isDisabled": false,
    "isRemembered": false,
    "id": -1,
    "level": 3,
    "SSID": "Lombard1770",
    "isAdhoc": false,
    "security": 3,
    "capabilities": "[WEP][WPS]",
    "BSSID": "4a:69:92:fa:ce:60",
    "priority": -1
  }, {
    "isDisabled": false,
    "isRemembered": false,
    "id": -1,
    "level": 2,
    "SSID": "fbguest",
    "isAdhoc": false,
    "security": 0,
    "capabilities": "",
    "BSSID": "00:0b:86:fa:df:43",
    "priority": -1
  }, {
    "isDisabled": false,
    "isRemembered": false,
    "id": -1,
    "level": 4,
    "SSID": "mansion600112",
    "isAdhoc": false,
    "security": 2,
    "capabilities": "[WPA-PSK-TKIP][WPS]",
    "BSSID": "e0:91:f5:b4:7c:4e",
    "password": "synergy1",
    "priority": -1
  }],

  _wifiState: 1, // DISABLED
  _networkState: 7, // IDLE
  _scanResult: [],
  _connection: null,
  _lastPriority: -1,
  _openNetworkNotification: true,
  _autoDetectCaptivePortal: true,

  _retagNetworks: function() {
    var id = 0;
    for (var i = 0; i < this._wifiNetworks.length; ++i) {
      if (this._wifiNetworks[i].isRemembered) {
        this._wifiNetworks[i].id = id++;
      } else {
        this._wifiNetworks[i].id = -1;
      }
    }
  },

  _changeIds: function() {
    EventManager.broadcastEvent('wifi.NETWORK_IDS_CHANGED', {});
  },

  _getNetwork: function(networkId) {
    if (networkId >= 0) {
      for (var i = 0; i < this._wifiNetworks.length; ++i) {
        if (this._wifiNetworks[i].id === networkId) {
          return this._wifiNetworks[i];
        }
      }
    }

    return null;
  },

  _setAllNetworksDisabled: function(disabled) {
    for (var i = 0; i < this._wifiNetworks.length; ++i) {
      this._wifiNetworks[i].isDisabled = disabled;
    }
  },

  _enableAllNetworks: function() {
    this._setAllNetworksDisabled(false);
  },

  _disableAllNetworks: function() {
    this._setAllNetworksDisabled(true);
  },

  _changeNetworkState: function(state) {
    if (this._networkState === state) {
      return;
    }

    this._networkState = state;

    // Find the corresponding coarse state. The corresponding mapping can be found at
    // android.net.NetworkInfo
    var coarseState;
    switch (state) {
    case this.STATE_IDLE:
    case this.STATE_SCANNING:
    case this.STATE_DISCONNECTED:
    case this.STATE_FAILED:
      coarseState = this.STATE_DISCONNECTED;
      break;
    case this.STATE_CONNECTING:
    case this.STATE_AUTHENTICATING:
    case this.STATE_OBTAINING_IPADDR:
    case this.STATE_CHECKING_CONNECTIVITY:
      coarseState = this.STATE_CONNECTING;
      break;
    case this.STATE_CONNECTED:
    case this.STATE_DISCONNECTING:
    case this.STATE_SUSPENDED:
      coarseState = state;
      break;
    default:
      break;
    }

    EventManager.broadcastEvent("wifi.NETWORK_STATE_CHANGED", {
      "state": state,
      "coarseState": coarseState
    });
  },

  isWifiEnabled: function() {
    return this._wifiState === this.WIFI_ENABLED;
  },

  getState: function() {
    return this._wifiState;
  },

  setIsWifiEnabled: function(enable) {
    if (this._wifiState === this.WIFI_UNKNOWN) {
      return false;
    }

    var _this = this;

    if (enable) {
      if (this._wifiState === this.WIFI_ENABLED ||
          this._wifiState === this.WIFI_ENABLING) {
        // Do not enable again when Wifi is already enabled
        return true;
      }

      this._wifiState = this.WIFI_ENABLING;
      this._enableAllNetworks();
    } else {
      if (this._wifiState === this.WIFI_DISABLED ||
          this._wifiState === this.WIFI_DISABLING) {
        // Do not disable again when Wifi is already disabled
        return true;
      }
      this._wifiState = this.WIFI_DISABLING;
      this._connection = null;
      this._changeNetworkState(this.STATE_DISCONNECTED);
    }

    EventManager.broadcastEvent("wifi.STATE_CHANGED", {
      "state": this._wifiState
    });

    setTimeout(function() {
      if (_this._wifiState === _this.WIFI_ENABLING ||
          _this._wifiState === _this.WIFI_DISABLING) {

        if (_this._wifiState === _this.WIFI_ENABLING) {
          _this._wifiState = _this.WIFI_ENABLED;
          setTimeout(function() {
            _this.startScan();
          }, 100);
        } else { // WIFI_DISABLING
          _this._wifiState = _this.WIFI_DISABLED;
        }

        EventManager.broadcastEvent("wifi.STATE_CHANGED", {
          "state": _this._wifiState
        });
      }
    }, 1000);

    return true;
  },

  toggleWifi: function() {
    return this.setIsWifiEnabled(!this.isWifiEnabled());
  },

  setIsOpenNetworkNotificationEnabled: function(enable) {
    this._openNetworkNotification = enable;
    return true;
  },

  isOpenNetworkNotificationEnabled: function() {
    return this._openNetworkNotification;
  },

  toggleOpenNetworkNotification: function() {
    this._openNetworkNotification = !this._openNetworkNotification;
    return true;
  },

  setIsAutoDetectCaptivePortalEnabled: function(enable) {
    this._autoDetectCaptivePortal = enable;
    return true;
  },

  isAutoDetectCaptivePortalEnabled: function() {
     return this._autoDetectCaptivePortal;
  },

  toggleAutoDetectCaptivePortal: function() {
     this._autoDetectCaptivePortal = !this._autoDetectCaptivePortal;
     return true;
  },

  getConnectionInfo: function() {
    if (!this._connection) {
      return "{}";
    }

    return JSON.stringify(this._mixin({
      "state": this._networkState
    }, this._connection));
  },

  startScan: function() {
    if (this._wifiState !== this.WIFI_ENABLED) {
      return false;
    }

    var _this = this;
    this._changeNetworkState(this.STATE_SCANNING);

    setTimeout(function() {
      // For those remembered networks, their ID should not be -1.
      _this._retagNetworks();
      EventManager.broadcastEvent("wifi.SCAN_RESULTS_AVAILABLE");
    }, 1000);
    return true;
  },

  getScanResults: function() {
    return JSON.stringify(this._wifiNetworks);
  },

  // TODO: Build a state machine for connection
  //       Watch out for race conditions.
  _authenticate: function(wifiIndex, security, password) {
    if (security === this.SECURITY_NONE) {
      this._establishConnection();
      return;
    }

    this._changeNetworkState(this.STATE_AUTHENTICATING);
    var _this = this;

    setTimeout(function() {
      if (password !== _this._wifiNetworks[wifiIndex].password) {
        _this._changeNetworkState(_this.STATE_DISCONNECTED);
        _this._changeNetworkState(_this.STATE_FAILED);
        _this._connection = null;
        return;
      }
      _this._establishConnection();
    }, 1000);
  },

  _establishConnection: function() {
    this._changeNetworkState(this.STATE_OBTAINING_IPADDR);

    var _this = this;

    setTimeout(function() {
      // Copy an entry of _wifiNetworks to _connection, and assign ipAddress
      _this._connection.ipAddress = "192.168.1.2";
      _this._connection.linkSpeed = "54Mbps";
      _this._changeNetworkState(_this.STATE_CONNECTED);
    }, 1000);
  },

  connect: function(data) {
    var config = JSON.parse(data);
    var SSID = config.SSID;
    var security = config.security || this.SECURITY_NONE;
    var password = config.password || null;

    for (var i = 0; i < this._wifiNetworks.length; ++i) {
      if (SSID === this._wifiNetworks[i].SSID &&
          security === this._wifiNetworks[i].security) {
        // If connection exists, disconnect first
        if (!this._connection) {
          this._changeNetworkState(this.STATE_DISCONNECTED);
          this._connection = null;
        }

        this._changeNetworkState(this.STATE_IDLE);
        this._disableAllNetworks();

        // Remember network
        this._wifiNetworks[i].isRemembered = true;
        if (this._wifiNetworks[i].hasOwnProperty("rememberedPassword") &&
            password === null) {
          password = this._wifiNetworks[i].rememberedPassword;
        }
        if (password !== null) {
          this._wifiNetworks[i].rememberedPassword = password;
        }

        this._wifiNetworks[i].isDisabled = false;

        if (this._wifiNetworks[i].priority !== this._lastPriority) {
          this._wifiNetworks[i].priority = ++this._lastPriority;
        }

        this._retagNetworks();
        this._connection = this._mixin({
          "_index": i
        }, this._wifiNetworks[i]);

        this._changeNetworkState(this.STATE_CONNECTING);

        var _this = this;

        setTimeout(function() {
          _this._authenticate(i, security, password);
        }, 1000);

        _this._enableAllNetworks();

        return true;
      }
    }

    return false;
  },

  disconnect: function() {
    this._changeNetworkState(this.STATE_DISCONNECTING);
    this._changeIds();

    var _this = this;
    setTimeout(function() {
      _this._wifiNetworks[_this._connection._index].isDisabled = true;
      _this._connection = null;
      _this._changeNetworkState(this.STATE_DISCONNECTED);
      this._changeIds();
    }, 1000);

    return true;
  },

  forget: function(networkId) {
    var network = this._getNetwork(networkId);

    if (network) {
      network.id = -1;
      network.isRemembered = false;
      network.isDisabled = false;
      delete network.rememberedPassword;
      network.priority = -1;
      this._changeIds();
      return true;
    }

    return false;
  },

  checkConnectivity: function(networkId) {
    var network = this._getNetwork(networkId);

    if (network) {
      var result = {
        "ssid": network.ssid,
        "networkId": networkId,
        "internetConnected": network.ssid === "fbguest"
      };

      setTimeout(function() {
        EventManager.broadcastEvent("wifi.INTERNET_CONNECTIVITY_CHECK", result);
      }, 1000);

      return true;
    }

    return false;
  },

  cancelConnectivityChecks: function(networkId) {
    if (networkId >= 0) {
      return true;
    }
    return false;
  },

  getMacAddress: function() {
    return "fa:ce:b0:0c:ba:fe";
  },

  getConfiguredNetworks: function() {
    var result = [];
    for (var i = 0; i < this._wifiNetworks.length; ++i) {
      if (this._wifiNetworks[i].isRemembered) {
        result.push(this._wifiNetworks[i]);
      }
    }

    return JSON.stringify(result);
  },

  createConfiguredNetwork: function(data) {
    var network = {
      "isDisabled": false,
      "isRemembered": true,
      "id": -1,
      "level": 5,
      "isAdhoc": false,
      "capabilities": "[WPA2-EAP-CCMP]",
      "BSSID": "00:0b:86:02:2b:e1",
      "priority": -1
    };

    data = JSON.parse(data);
    network.SSID = data.SSID;
    network.security = data.security;
    network.username = data.username || null;
    network.password = data.password || null;
    network.isHidden = data.isHidden || false;

    this._wifiNetworks.push(network);

    return true;
  }
};
});

// module: shared/data2/local/local_mapper
// file:   ../../shared/js/data2/local/local_mapper.js
define("shared/data2/local/local_mapper", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*global __DEV__:false*/
var LOG_DATA = false;
var LOG_SQL  = __DEV__ && !this.__PERF_TEST__;

var core = require('bolt/core');
var util = require('bolt/util');
var WithAnnotation = require('../with_annotation').WithAnnotation;


function question_mark() {
  return '?';
}

function logTiming(annotation, sql, data, resultSet) {
  if (resultSet && resultSet.rows) {
    console.info(
      'sql',
      this.getTime(),
      resultSet.rows.length + ' rows',
      sql,
      annotation);
  } else if (resultSet && resultSet.rowsAffected) {
    console.info(
      'sql',
      this.getTime(),
      resultSet.rowsAffected + ' rows affected',
      sql,
      annotation);
  } else {
    console.info('sql', this.getTime(), sql, annotation);
  }
  if (LOG_DATA) {
    console.info(data);
  }
}

/**
 * Local mapper is responsible for reading/writing models to local db
 * (only WebSql now, possibly IndexdDB in the future).
 */
exports.LocalMapper = core.createClass({

  name: 'LocalMapper',

  properties: {
    schema: null,
    tableName: 'dummy',
    localDataColumnName: 'data',
    db: null
  },

  mixins: [WithAnnotation],

  _db: null,
  _transaction: null,
  _annotation: null,

  /**
   * @constructor
   * @param {Schema} schema
   * @param {String} tableName
   * @param {Database} db (optional)
   * @returns {LocalMapper}
   */
  construct: function(schema, tableName, db) {
    this.setSchema(schema || this.getSchema());
    this.setTableName(tableName || this.getTableName());

    if (!db) {
      var dbModule = require('shared/data/db');
      var Database = require('shared/data2/local/db').Database;
      db = new Database(dbModule.getDB());
    }
    this.setDb(db);
  },

  /**
   * Creates a table to store models
   * @return {Deferred}
   */
  init: function() {
    var tx = this._wantsTransaction();
    var columnsWithTypes = this.getLocalColumns(true);
    var sql = 'CREATE TABLE IF NOT EXISTS ' + this.getTableName() +
      '  (' + columnsWithTypes.join(',') + ')';

    if (LOG_SQL) {
      if (tx.addCallback) {
        var annotation = this.getAndClearAnnotation('init');
        tx.addCallback(logTiming, tx, annotation, sql);
      }
    }
    tx.executeSql(sql);
    this.createIndexes(tx);
    return tx;
  },

  /**
   * @override
   */
  createIndexes: function(tx) {},


  /**
   * Drops a table
   * @return {Deferred}
   */
  drop: function() {
    var tx = this._wantsTransaction();
    var sql = 'DROP TABLE IF EXISTS ' + this.getTableName();
    if (LOG_SQL) {
      if (tx.addCallback) {
        var annotation = this.getAndClearAnnotation('drop');
        tx.addCallback(logTiming, tx, annotation, sql);
      }
    }
    tx.executeSql(sql);
    return tx;
  },

  /**
   * Converts local row data to a model form.
   *
   * @param {Object} data
   * @return {Model}
   */
  localToModel: function(data) {
    var object = {};
    var schema = this.getSchema();
    var localData = JSON.parse(data[this.getLocalDataColumnName()]);

    var propertyNames = schema.getPropertyNames();

    var name, value, info;
    for (var i = 0, length = propertyNames.length; i < length; i++) {
      name = propertyNames[i];
      info = schema.getPropertyInfo(name);
      if (info.local) {
        value = info.searchable ? data[info.local] : localData[info.local];
        object[name] = info.transformLocalToModel(value, data);
      }
    }
    return object;
  },

  /**
   * Converts model data form to local storage form.
   *
   * @param {Object} data
   * @return {Model}
   */
  modelToLocalArgs: function(model) {
    var schema = this.getSchema();
    var args = [];
    var dataColumn = {};

    var propertyNames = schema.getPropertyNames();

    var name,
      value,
      info;
    for (var i = 0, length = propertyNames.length; i < length; i++) {
      name = propertyNames[i];
      info = schema.getPropertyInfo(name);
      value = model[name];
      if (info.searchable) {
        args.push(info.transformModelToLocal(value));
      } else if (info.local) {
        dataColumn[info.local] = info.transformModelToLocal(value, model);
      }
    }

    args.push(JSON.stringify(dataColumn));
    return args;
  },

  /**
   * Returns a list of local columns to use in SELECT and CREATE TABLE
   * statements. Can return optional types.
   *
   * @param {Boolean} withType defaults to false
   * @return {Array}
   */
  getLocalColumns: function(withType) {
    var schema = this.getSchema();
    var result = [];

    var propertyNames = schema.getPropertyNames();

    var name,
      value,
      info,
      localName;
    for (var i = 0, length = propertyNames.length; i < length; i++) {
      name = propertyNames[i];
      info = schema.getPropertyInfo(name);
      if (info.searchable) {
        localName = info.local;
        if (withType && info.localType) {
          localName += ' ' + info.localType;
        }
        result.push(localName);
      }
    }

    result.push(this.getLocalDataColumnName() + (withType ? ' TEXT' : ''));
    return result;
  },

  getSQLWhere: function(filter) {
    if (filter.getSQLWhere()) {
      return filter.getSQLWhere();
    }
    var schema = this.getSchema();
    var properties = filter.getProperties();
    var result = [];
    var value;
    var info;

    for (var propertyName in properties) {
      if (!properties.hasOwnProperty(propertyName)) {
        continue;
      }
      value = properties[propertyName];

      info = schema.getPropertyInfo(propertyName);
      if (info.searchable) {
        if (util.isArray(value)) {
          result.push(
              info.local + ' IN (' +
              value.map(question_mark).join(',') + ')');
        } else {
          result.push(info.local + '=?');
        }
      }
    }

    return result.join(' AND ');
  },

  getSQLArgs: function(filter) {
    if (filter.getSQLArgs()) {
      return filter.getSQLArgs();
    }
    var schema = this.getSchema();
    var properties = filter.getProperties();
    var result = [];
    var value;
    var info;

    for (var propertyName in properties) {
      if (!properties.hasOwnProperty(propertyName)) {
        continue;
      }
      value = properties[propertyName];
      info = schema.getPropertyInfo(propertyName);
      if (info.searchable) {
        if (util.isArray(value)) {
          result.push.apply(
              result,
              value.map(info.transformModelToLocal, info));
        } else {
          result.push(info.transformModelToLocal(value));
        }
      }
    }

    return result;
  },

  getSQLOrder: function(filter) {
    if (filter.getSQLOrder()) {
      return filter.getSQLOrder();
    }
    var order = filter.getOrder();
    if (!order) {
      return null;
    }
    var info = this.getSchema().getPropertyInfo(order[0]);
    if (info.searchable) {
      return info.local + ' ' + order[1];
    }
    return null;
  },

  /**
   * Finds ids for the given filter
   *
   * @param {Filter} filter
   * @param {Integer} limit
   * @return {Deferred}
   */
  findIDs: function(filter, limit, offset) {
    var tx = this._wantsReadTransaction();
    var sql = 'SELECT id FROM ' + this.getTableName();
    sql += this._getSQLWhereOrderAndLimit(filter, limit, offset);

    var args = this.getSQLArgs(filter);
    var result = tx.executeSql(sql, args);
    if (LOG_SQL) {
      var annotation = this.getAndClearAnnotation('findIDs');
      result.addCallback(logTiming, result, annotation, sql, args);
    }
    return result.then(this._findIDsResultCallback, this);
  },

  _findIDsResultCallback: function(results) {
    var rows = results.rows || [];
    var ids = [];
    for (var i = 0, l = rows.length; i < l; i++) {
      ids.push(rows.item(i).id);
    }
    return ids;
  },

  /**
   * Fetches model information by ids
   *
   * @param {Array} ids
   * @return {Deferred}
   */
  fetchInformationForIds: function(ids, getFromCache) {
    var tx = this._wantsReadTransaction();
    var sql =
      'SELECT ' + this.getLocalColumns().join(',') +
      ' FROM ' + this.getTableName() +
      ' WHERE id IN (' + ids.map(question_mark).join(',') + ')';

    var result = tx.executeSql(sql, ids);
    if (LOG_SQL) {
      var annotation = this.getAndClearAnnotation('fetchModels');
      result.addCallback(logTiming, result, annotation, sql, ids);
    }
    return result.then(this._fetchInformationResultCallback, this, getFromCache);
  },

  /**
   * Fetches information for the given filter
   *
   * @param {Filter} filter
   * @param {Integer} limit
   * @param {Integer} offset
   * @param {function|null} getFromCache an optional function that should return
   *                                     a cached version of model by id
   * @return {Deferred}
   */
  fetchInformationForFilter: function(filter, limit, offset, getFromCache) {
    var tx = this._wantsReadTransaction();
    var sql = 'SELECT ' + this.getLocalColumns().join(',') +
              ' FROM ' + this.getTableName();

    sql += this._getSQLWhereOrderAndLimit(filter, limit, offset);

    var args = this.getSQLArgs(filter);
    var result = tx.executeSql(sql, args);
    if (LOG_SQL) {
      var annotation = this.getAndClearAnnotation('fetchModelsByFilter');
      result.addCallback(logTiming, result, annotation, sql, args);
    }
    return result.then(this._fetchInformationResultCallback, this, getFromCache);
  },

  _getSQLWhereOrderAndLimit: function(filter, limit, offset) {
    var where = this.getSQLWhere(filter);
    var order = this.getSQLOrder(filter);
    var sql = '';
    if (where) {
      sql += ' WHERE ' + where;
    }
    if (order) {
      sql += ' ORDER BY ' + order;
    }
    if (limit) {
      sql += ' LIMIT ' + limit;
    }
    if (offset) {
      sql += ' OFFSET ' + offset;
    }
    return sql;
  },

  _fetchInformationResultCallback: function(getFromCache, results) {
    var rows = results.rows || [];
    var models = [];
    var row, idInfo, id;
    if (getFromCache) {
      idInfo = this.getSchema().getPropertyInfo('id');
    }
    for (var i = 0, l = rows.length; i < l; i++) {
      row = rows.item(i);
      if (getFromCache) {
        id = idInfo.transformLocalToModel(row.id);
        models.push(getFromCache(id) || this.localToModel(row));
      } else {
        models.push(this.localToModel(row));
      }
    }
    return models;
  },


  /**
   * Stores an array of model data
   *
   * @param {Array} modelsData
   * @return {Deferred}
   */
  store: function(modelsData) {
    var tx = this._wantsTransaction();
    var columns = this.getLocalColumns();
    var sql =
      'INSERT OR REPLACE INTO ' + this.getTableName() +
      ' (' + columns.join(',') + ')' +
      ' VALUES(' + columns.map(question_mark).join(',') + ')';

    var args, allArgs;
    if (LOG_DATA) {
      allArgs = [];
    }
    for (var i = 0, length = modelsData.length; i < length; i++) {
      args = this.modelToLocalArgs(modelsData[i]);
      tx.executeSql(sql, args);
      if (LOG_DATA) {
        allArgs.push(args);
      }

    }
    if (LOG_SQL) {
      var annotation = this.getAndClearAnnotation('store');
      tx.addCallback(
        logTiming,
        tx,
        annotation,
        modelsData.length + 'x: ' +  sql,
        allArgs);
    }
    return tx;
  },


  /**
   * Deletes records with the given ids from the db
   *
   * @param {Array} ids
   * @return {Deferred}
   */
  remove: function(ids) {
    var tx = this._wantsTransaction();
    var sql =
      'DELETE FROM ' + this.getTableName() +
      ' WHERE id IN (' + ids.map(question_mark).join(',') + ')';

    var result = tx.executeSql(sql, ids);
    if (LOG_SQL) {
      var annotation = this.getAndClearAnnotation('remove');
      result.addCallback(logTiming, result, annotation, sql, ids);
    }
    return result;
  },


  /**
   * Execute all statemets within a given transaction
   *
   * @example
   *   // create all the tables in one transaction
   *   db.transaction(function(tx) {
   *     messageStore.withTransaction(tx, function() {
   *       messageStore.init();
   *     });
   *     threadStore.withTransaction(tx, function() {
   *       threadStore.init();
   *     });
   *   });
   *
   *
   * @param {Transaction} tx
   * @param {Function} callback
   * @return {Deferred}
   */
  withTransaction: function(tx, callback) {
    this._transaction = tx;
    callback.call(this, tx);
    this._transaction = null;
    return this;
  },

  /**
   * @private
   */
  _wantsTransaction: function() {
    return this._transaction ? this._transaction : this.getDb().transaction();
  },

  /**
   * @private
   */
  _wantsReadTransaction: function() {
    return this._transaction ? this._transaction :
      this.getDb().readTransaction();
  },

  _defaultErrorCallback: function(deferred, e) {
    console.error(e);
    deferred.fail();
  }
});
});

// module: view/message_row/message_row
// file:   view/message_row/message_row.js
define("view/message_row/message_row", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var util = require('bolt/util');
var View = require('bolt_touch/view').View;
var Text = require('shared/text');

var imageQueue     = require('bolt_touch/util/image_queue');
var Image          = require('bolt_touch/views/image').Image;
var Button         = require('bolt_touch/views/button').Button;
var ActionableView = require('bolt_touch/views/actionable_view').ActionableView;
var STATE          = require('shared/data2/store/constants').STATE;
var ClientMessage =
  require('talk/client/model/message/client_message').ClientMessage;
var attachmentUtil = require('talk/client/model/message/attachment_util');
var changesClient  = require('talk/client/thread_changes_client');

var MessageRow = exports.MessageRow = core.createClass({
  name: 'MessageRow',

  extend: View,

  properties: {
    model: null,
    selectable: null
  },

  declare: function(options) {
    return {
      className: '',
      childViews: [
        {
          className: 'bt-message--avatar',
          ref: 'avatar'
        },
        {
          className: 'bt-message--box',
          ref: 'msgBox',
          childViews: [
            {
              className: 'bt-message--text',
              ref: 'text'
            },
            {
              className: 'bt-message--attachments',
              ref: 'attachments'
            },
            {
              className: 'bt-message--share',
              ref: 'shares'
            },
            {
              className: 'bt-message--forwards',
              ref: 'forwards'
            }
          ]
        }
      ]
    };
  },

  setModel: function(model) {

    if (model === this.getModel()) {
      return;
    }

    this.set('model', model);

    this.toggleClass('bt-message-row_selectable', this.getSelectable());

    // Avatar
    var avatar = this.findRef('avatar');
    if (!model.getThread().is1to1() && !model.isFromMe()) {
      var contacts = require('talk/client/model/thread/contacts');
      avatar.show();
      var url =
        contacts.profileURL(model.get('sender'), model.getSenderProfile());
      avatar.getNode().style.backgroundImage = '';
      if (url) {
        avatar.url = url;
        imageQueue.add(url, function(url) {
          if (url !== this.url) {
            return;
          }
          this.getNode().style.backgroundImage = 'url(' + url + ')';
        }, avatar);
      }
      this.hasAvatar = true;
    } else {
      avatar.hide();
      this.hasAvatar = false;
    }

    this.setMetadata({'message-id': model.id});

    // Body
    var bodyText = model.getText().trim();

    var formattedBody = Text.linkifyAndDwim(bodyText);

    this.refs.text.setContent(formattedBody);

    // // Timestamp
/*    if (model.isSending()) {
      this.refs.timestamp.setContent('...');
    } else if (model.hasError()) {
      this.refs.timestamp.setContent('Error, tap to retry');
    }*/

    if (bodyText.length < 100) {
      this.isShort = true;
    } else {
      this.isShort = false;
    }

    // Gap
    var isGap = model.get('remoteState') == STATE.GAP;
    this.toggleClass('bt-message-row_with-gap', isGap);
    if (isGap) {
      if (!this.refs.loadGap) {
        var button = this.build(
          {
            view: View,
            className: 'bt-message-row--load-more',
            ref: 'loadGap',
            childViews: [
              {
                view: Button,
                className: 'bt-message-row--load-more--button',
                content: 'Load missing messages',
                action: '_onLoadGapClick',
                ref: 'loadGapButton'
              }
            ]
          }
        );
        this.insertChild(button, 0);
      }
    } else {
      if (this.refs.loadGap) {
        this.removeChild(this.refs.loadGap);
      }
    }

    // Unread status
    if (model.get('unread')) {
      model.set('unread', false);
      var thread = model.getThread();
      var controller = changesClient.getInstance();
      controller.markAsRead(thread.getId(), true);
      controller.uploadChanges(thread.getId());
    }

    this.renderAttachments();
    this.renderShares();

    this.renderForwardedMessages();

    this
      .toggleClass('bt-message-row_right', model.isFromMe())
      .toggleClass('bt-message-row_short', this.isShort)
      .toggleClass('bt-message-row_with-avatar', this.hasAvatar);
  },

  _onLoadGapClick: function() {
    var model = this.get('model');
    this.refs.loadGapButton.setContent('Loading...');
    this.refs.loadGapButton.removeListener('click', this._onLoadGapClick);
    require('talk/client/message_client')
      .getInstance()
      .eliminateGap(model.getThread().getId(), model.getId(), 10);
  },

  renderAttachments: function() {
    var attachmentsContainer = this.refs.attachments;
    attachmentsContainer.setChildViews([]);
    var message = this.getModel();
    var attachments = message.get('attachments');
    var attachment_map = message.get('attachment_map');
    var attachmentsToRender = [];
    var attachment;
    var i, len;
    for (i = 0, len = attachments.length; i < len; i++) {
      attachment = attachment_map[attachments[i]];
      if (attachment) {
        attachmentsToRender.push(attachment);
      }
    }
    for (i = 0, len = attachmentsToRender.length; i < len; i++) {
      this.addAttachment(attachmentsToRender[i]);
    }
  },

  addAttachment: function(attachment) {
    var attachmentsContainer = this.refs.attachments;
    var message = this.getModel();
    var mime_type = attachment.mime_type;
    var type = mime_type.split('/', 1)[0];
    if (type === 'image') {
      this.isShort = false;

      var localData = message.get('localData');
      var localAttachmentData =
        localData.storedAttachments ?
          (attachment.id in localData.storedAttachments ?
            localData.storedAttachments[attachment.id] : {})
         : {};

      var attachmentImagePreview = this.build({
        className: 'bt-message--attachment--image-preview',
        childViews: [{
          ref: 'label',
          className: 'bt-message--attachment--label',
          content: attachment.filename
        }],
        view: ActionableView,
        action: util.bind(this.openAttachment, this, attachment)
      });

      if (attachment.local_url || attachment.local_link) {
        attachmentImagePreview.setStyle('backgroundImage', 'url(' +
            (attachment.local_url || attachment.local_link) + ')');
        attachmentsContainer.append(attachmentImagePreview);
      } else if (localAttachmentData.thumbnailData) {
        attachmentImagePreview.setStyle({
          backgroundImage:
            'url(' + localAttachmentData.thumbnailData.dataURI + ')',
          width: localAttachmentData.thumbnailData.width + 'px',
          height: localAttachmentData.thumbnailData.height + 'px'
        });
        attachmentImagePreview.getChildViews()[0]
          .setStyle('top', (localAttachmentData.thumbnailData.height + 5) + 'px');
        attachmentsContainer.append(attachmentImagePreview);
      } else {
        var hasDimensions = false;
        if (attachment.image_data && attachment.image_data.width &&
            attachment.image_data.height) {
          // Set container dimensions even before downloading it
          hasDimensions = true;
          var constraints = message.getThumbnailConstraints();
          var resizeDimensions = attachmentUtil.calculateResizeDimensions(
            {
              height: constraints.height,
              maxWidth: constraints.width,
              preserveHeight: constraints.preserveHeight
            },
            {
              height: attachment.image_data.height,
              width: attachment.image_data.width
            }
          );
          attachmentImagePreview.setStyle({
            width: resizeDimensions.thumbnailWidth + 'px',
            height: resizeDimensions.imageHeight + 'px'
          });
          attachmentImagePreview.getChildViews()[0]
            .setStyle('top', (resizeDimensions.imageHeight + 5) + 'px');
        }

        message.getAttachmentData(attachment, {thumbnail: true})
          .addCallback(util.bind(function(thumbnailData) {
            if (message.get('id') !== this.get('id')) {
              return;
            }
            attachmentImagePreview.setStyle('backgroundImage', 'url(' + thumbnailData.dataURI + ')');
            if (!hasDimensions) {
              attachmentImagePreview.setStyle({
                width: thumbnailData.width + 'px',
                height: thumbnailData.height + 'px'
              });
              attachmentImagePreview.getChildViews()[0]
                .setStyle('top', (thumbnailData.height + 5) + 'px');
            }
            var localData = util.clone(this.get('localData')) || {};
            if (!localData.storedAttachments) {
              localData.storedAttachments = {};
            }
            var storedAttachments = localData.storedAttachments;
            if (!storedAttachments[attachment.id]) {
              storedAttachments[attachment.id] = {};
            }
            storedAttachments[attachment.id].thumbnailData = thumbnailData;
            this.set('localData', localData);
            var messageClient = require('talk/client/message_client');
            messageClient.getInstance()
              .update(this.getId(), { localData: localData });
          }, message));
        attachmentsContainer.append(attachmentImagePreview);
      }
    } else if (type === 'audio') {
      // TODO: support media playback
      this.addAttachmentToken(attachment, attachmentsContainer);
    } else {
      this.addAttachmentToken(attachment, attachmentsContainer);
    }
  },

  addAttachmentToken: function(attachment, attachmentsContainer) {
    var attachmentToken = this.build({
      className: 'bt-message--attachment--token',
      content: attachment.filename,
      view: ActionableView,
      action: util.bind(this.openAttachment, this, attachment)
    });
    attachmentsContainer.append(attachmentToken);
  },

  openAttachment: function(attachment) {
    var eventData = {
        simulateBubbling: true,
        attachment: attachment,
        message: this.getModel()
      };
    this.invoke('attachment', eventData);
  },

  renderShares: function() {
    var sharesContainer = this.refs.shares;
    util.invoke(sharesContainer.getChildViews(), 'destroy');
    var message = this.getModel();
    var shares = message.get('shares');
    if (!shares) {
      return;
    }
    if (shares.length > 0) {
      this.isShort = false;
    }
    var share_map = message.get('share_map');
    var sharesToRender = [];
    var share;
    for (var i = 0, len = shares.length; i < len; i++) {
      share = share_map[shares[i]];
      if (share) {
        sharesToRender.push(share);
      }
    }
    for (var j = 0, ll = sharesToRender.length; j < ll; j++) {
      this.addShare(sharesToRender[j], sharesContainer);
    }
  },

  addShare: function(share, sharesContainer) {
    var thumbnails = util.map(share.media, this.renderShareThumbnail);

    var textView = {
      childViews: [
        {
          tagName: 'a',
          target: '_blank',
          href: share.href,
          content: share.name,
          className: 'bt-message--share--link'
        },
        {
          tagName: "br"
        },
        {
          tagName: 'span',
          content: share.caption
        },
        {
          tag: 'span',
          content: share.description
        }
      ]
    };

    var shareView = this.build({
      className: "bt-message--text ",
      childViews: thumbnails.concat([textView])
    });

    sharesContainer.append(shareView);
  },

  renderShareThumbnail: function(media) {
    return {
      tagName: 'a',
      target: '_blank',
      href: media.href,
      alt: media.alt,
      className: "bt-message--share--link bt-message--share--thumbnail",
      childViews: [{
        view: Image,
        src: media.src,
        height: 67
      }]
    };
  },

  renderForwardedMessages: function() {
    var forwardsContainer = this.refs.forwards;
    util.invoke(forwardsContainer.getChildViews(), 'destroy');
    var message = this.getModel();
    var fids = message.get('forwarded_messages') || [];
    var forwardMap = message.get('forwarded_messages_map') || {};

    // hide forwards container if there are no forwarded messages
    if (fids.length > 0) {
      forwardsContainer.setChildViews([]);
      forwardsContainer.show();
      this.isShort = false;
    } else {
      forwardsContainer.hide();
    }

    // Commenting out until we have design for this
    /*
    for (var i = 0, fid = null, forwardedMessage = null; i < fids.length; i++) {
      fid = fids[i];
      forwardedMessage = forwardMap[fid];
      if (forwardedMessage) {
        this.addForwardedMessage(forwardedMessage);
      }
    }
    */
  },

  addForwardedMessage: function(forwardedMessage) {
    var fwd = new ClientMessage(forwardedMessage);
    var row = new MessageRow({ model: fwd });
    var forwardsContainer = this.refs.forwards;
    forwardsContainer.append(row);
  }

});
});

// module: bolt_touch/views/scroll_view_j/index
// file:   ../../../frameworks/bolt_touch/lib/views/scroll_view_j/index.js
define("bolt_touch/views/scroll_view_j/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core = require('bolt/core');
var dom = require('bolt/dom');
var util = require('bolt/util');
var build = require('bolt/builder').build;

var View = require('bolt_touch/view').View;
var jScroll = require('../../vendor/jscroll').jScroll;
var jVelocityEstimator = require('../../vendor/jvelocity_estimator').jVelocityEstimator;
var jInertialModel = require('../../vendor/jinertial_model').jInertialModel;

var _requestAnimationFrame = (
  window.requestAnimationFrame ||
  window.webkitRequestAnimationFrame ||
  window.mozRequestAnimationFrame ||
  window.oRequestAnimationFrame ||
  window.msRequestAnimationFrame ||
  function(callback, element) {
    setTimeout(callback, 1000 / 60);
  }
);

var scrollId = 1;

/**
 * @classdesc A scrolling view that uses the jScroll library.
 */
var ScrollView = core.createClass({

  name: 'ScrollView',

  extend: View,

  statics: {
    /**
     * @constant Number of milliseconds before that refresh will be debounced
     *   when calling _debouncedRefresh
     */
    REFRESH_DEBOUNCE: 100
  },

  properties: {
    /**
     * @property {boolean} useScrollbar If true, then a scrollbar is displayed
     *   when scrolling, if false, no scrollbar is displayed
     */
    useScrollbar: true,

    /**
     * @property {boolean} vScroll If true, scroll vertically, if false
     *   do not scroll vertically
     */
    vScroll: true,

    /**
     * @property {boolean} hScroll If true, scroll horizontally, if false
     *   do not scroll horizontally
     */
    hScroll: false,

    /**
     * @property {boolean} snap If true, paging will be enabled, if false
     *   scroll smoothly
     */
    snap: false
  },

  flex: 1,

  construct: function() {
    this._debouncedRefresh =
      util.debounce(util.bind(this.refresh, this), ScrollView.REFRESH_DEBOUNCE);
    this.onResize = util.bind(this.onResize, this);

    View.apply(this, arguments);
  },

  createDom: function(options) {
    var node = View.prototype.createDom.call(this, options);
    this.addClass('wrapper');
    if (!this._scroller) {
      // By default the scroller should be the width of the encomapssing
      // ScrollView so block element can declare their width as a percentage of
      // the ScrollView width. It should also grow to contain children elements.
      // So that simply appending an element that's wider than the ScrollView
      // will cause horizontal scrollbars to appear.
      this._scroller = this.build({
        className: 'scroller',
        style: {
          display: 'inline-block',
          minWidth: '100%'
        }
      });
      node.appendChild(this._scroller.getNode());
    }
    return node;
  },

  destroy: function() {
    View.prototype.destroy.call(this);
    this.scrolling = false;
    window.removeEventListener('resize', this.onResize);
    this._jScroll && this._jScroll.destroy();
  },

  onDocumentInsertion: function() {
    if (this._inserted) {
      return;
    }
    this._inserted = true;

    var id = scrollId++;

    var options = {};
    options.velocityEstimatorX = new jVelocityEstimator();
    options.velocityEstimatorY = new jVelocityEstimator();
    options.scrollStartListener = util.bind(this.onScrollStart, this);
    options.scrollEndListener = util.bind(this.onScrollEnd, this);
    options.scrollMoveListener = util.bind(this.onScroll, this);
    options.scrollToListener = util.bind(this.onScrollTo, this);
    options.inertialScrollInterruptedListener =
      util.bind(this.onInertialScrollInterrupted, this);

    options.scrollbarEnabled = this.getUseScrollbar();

    var scrollModelOptions = (this.get('snap') ?
                              jInertialModel.getDefaultPaginatedOptions() :
                              jInertialModel.getDefaultOptions());
    options.scrollModel = {
      x: this.getHScroll() ? new jInertialModel(scrollModelOptions) : null,
      y: this.getVScroll() ? new jInertialModel(scrollModelOptions) : null
    };

    options.scrollEnabled = {
      x: this.getHScroll(),
      y: this.getVScroll()
    };

    this._jScroll = new jScroll(
      this._scroller.getNode(), this.getNode(), 'scroller' + id, options);

    window.addEventListener('resize', this.onResize);
  },

  onScrollStart: function() {
    this.scrolling = true;
    var owner = this.getOwner();
    owner.didScrollStart && owner.didScrollStart(this);
  },

  onScroll: function(x, y) {
    if (this.isDestroyed) {
      return;
    }
    x = Math.round(x);
    y = Math.round(y);

    if (x !== this._lastX || y !== this._lastY) {
      this._lastX = x;
      this._lastY = y;

      var owner = this.getOwner();
      owner.scrollViewDidScrollTo && owner.scrollViewDidScrollTo(this, x, y);
      this.invoke('scroll');
    }
  },

  onScrollEnd: function(x, y) {
    var owner = this.getOwner();
    if (owner && owner.didScrollTo) {
      owner.didScrollTo(x, y, this);
    }
    this._lastX = this._lastY = null;
    this.scrolling = false;
  },

  onScrollTo: function(x, y) {
    var owner = this.getOwner();
    if (owner && owner.willScrollToAnimated) {
      var pageX = this.get('hScroll') ?
        Math.floor(x / this._jScroll.modelX.getViewportSize()) :
        0;

      var pageY = this.get('vScroll') ?
        Math.floor(y / this._jScroll.modelY.getViewportSize()) :
        0;

      owner.willScrollToAnimated(x, y, pageX, pageY);
    }
  },

  onInertialScrollInterrupted: function(x, y) {
    var owner = this.getOwner();
    if (owner && owner.scrollAnimationInterrupted) {
      owner.scrollAnimationInterrupted(x, y);
    }
  },

  onResize: function() {
    this.refresh();
  },

  setHeight: function(height) {
    View.prototype.setHeight.call(this, height);
    this.refresh();
  },

  scrollTo: function(x, y, time, relative) {
    if (!this._jScroll) {
      return;
    }
    var viewportSize = this._jScroll.viewportSize;
    var now = Date.now();
    var currentX = this._jScroll.getCurrentPositionX(now);
    var currentY = this._jScroll.getCurrentPositionY(now);
    var baselineX = 0, baselineY = 0;
    // if relative, we offset the baseline coordinates by the current position
    if (relative) {
      baselineX = currentX;
      baselineY = currentY;
    }
    x = Math.max(x, -baselineX);
    x = Math.min(
      x,
      this._jScroll.scrollbarScrollWidth - viewportSize.width - baselineX);
    y = Math.max(y, -baselineY);
    y = Math.min(
      y,
      this._jScroll.scrollbarScrollHeight - viewportSize.height - baselineY);

    // If x is relative, absolute position is w/r/t baseline.  If x
    // is absolute, baselineX is 0 and so x is the absolute position
    // we want to scroll to
    this.onScrollTo(x + baselineX, y + baselineY);
    this.onScrollStart();

    // TODO: make this animated
    // updatePosition takes relative values as input, so we want to provide
    // absolute values if we aren't scrolling to a relative position. Since
    // currentX - baselineX is 0 when relative is true, we know that
    // x - (currentX - baselineX) is the correct value that we want. When
    // relative is false, we know baselineX is 0, so we are providing
    // x - currentX, which is the correct scrolling offset that we need. Same
    // holds for y values, so QED.
    this._jScroll.
      updatePosition(x - (currentX - baselineX), y - (currentY - baselineY));
  },

  scrollToPageX: function(pageNum, time) {
    if (this._jScroll && this._jScroll.modelX) {
      this.scrollTo(pageNum * this._jScroll.modelX.getViewportSize(), 0, time);
    }
  },

  getPageXNum: function() {
    return this._jScroll.modelX.getPage();
  },

  setContentHeight: function(height) {
    if (!this._jScroll) {
      return;
    }
    var top = this._jScroll.scrollableAreaSize.top;
    this._jScroll.setVerticalScrollRegion(top, top + height);
    this.invoke('resize');
  },

  setContentWidth: function(width) {
    if (!this._jScroll) {
      return;
    }
    var left = this._jScroll.scrollableAreaSize.left;
    this._jScroll.setHorizontalScrollRegion(left, left + width);
    this.invoke('resize');
  },

  /**
   * Sets the scroll region (aka content). This allows for changing the vertical
   * boundaries of the scroll region without manipulating the viewport directly.
   *
   * @property {number} the top of the vertical scroll region.
   * @property {number} the bottom of the vertical scroll region.
   */
  setVerticalScrollableAreaRegion: function(top, bottom) {
    if (!this._jScroll) {
      return;
    }
    this._jScroll.setVerticalScrollRegion(top, bottom);
    this.invoke('resize');
  },

  /**
   * Sets the scroll region (aka content). This allows for changing the vertical
   * boundaries of the scroll region without manipulating the viewport directly.
   *
   * @property {number} the top of the vertical scroll region.
   * @property {number} the bottom of the vertical scroll region.
   */
  setHorizontalScrollableAreaRegion: function(left, right) {
    if (!this._jScroll) {
      return;
    }
    this._jScroll.setHorizontalScrollRegion(left, right);
    this.invoke('resize');
  },

  /**
   * Note: the returned object is a reference from jScroll and should not be
   * modified.
   *
   * @return {object} the scrollable region
   * @config {number} [left] the start of the horizontal scroll region
   * @config {number} [right] the end of the horizontal scroll region
   * @config {number} [top] the start of the vertical scroll region
   * @config {number} [bottom] the end of the vertical scroll region
   */
  getScrollableAreaRegion: function() {
    if (!this._jScroll) {
      return null;
    }
    return this._jScroll.scrollableAreaSize;
  },

  setUseScrollbar: function(useScrollbar) {
    this.set('useScrollbar', useScrollbar);

    if (this._jScroll) {
      this._jScroll.enableScrollbars(this.getUseScrollbar());
    }
  },

  setVScroll: function(vScroll) {
    this.set('vScroll', vScroll);
    if (this._jScroll) {
      this._jScroll.enableVScroll(vScroll);
    }
  },

  setHScroll: function(hScroll) {
    this.set('hScroll', hScroll);
    if (this._jScroll) {
      this._jScroll.enableHScroll(hScroll);
    }
  },

  /**
   * @return {number} the height of the scrollable area.
   */
  getScrollableAreaHeight: function() {
    if (this._jScroll) {
      return this._jScroll.scrollbarScrollHeight;
    } else {
      return 0;
    }
  },

  /**
   * @return {number} the width of the scrollable area.
   */
  getScrollableAreaWidth: function() {
    if (this._jScroll) {
      return this._jScroll.scrollbarScrollWidth;
    } else {
      return 0;
    }
  },

  appendChild: function(child) {
    View.prototype.appendChild.call(this, child);
    this._debouncedRefresh();
    return this;
  },

  _appendChildNode: function(child) {
    this._scroller.getNode().appendChild(child.getNode());
  },

  insertChild: function(child, position) {
    View.prototype.insertChild.call(this, child, position);
    this._debouncedRefresh();
    return this;
  },

  _insertNodeBefore: function(child, beforeChild) {
    this._scroller.getNode()
      .insertBefore(child.getNode(), beforeChild.getNode());
  },

  // notify jScroll of changes
  refresh: function() {
    var scrollerNode = this._scroller.getNode();
    this.setContentHeight(scrollerNode.offsetHeight);
    this.setContentWidth(scrollerNode.offsetWidth);
  },

  clear: function() {
    util.run(this.getChildViews(), 'destroy');
    this._scroller.getNode().innerHTML = '';
  },

  /**
   * @return {number} the height of the viewport.
   */
  getViewportHeight: function() {
    if (this._jScroll && this._jScroll.viewportSize) {
      return this._jScroll.viewportSize.height;
    } else {
      return 0;
    }
  },

  /**
   * @return {number} the width of the viewport.
   */
  getViewportWidth: function() {
    if (this._jScroll && this._jScroll.viewportSize) {
      return this._jScroll.viewportSize.width;
    } else {
      return 0;
    }
  },

  getScrollTop: function() {
    if (this._jScroll && this._jScroll.modelY) {
      return this.scrolling ?
        this._lastY : this._jScroll.getCurrentPositionY(Date.now());
    } else {
      return 0;
    }
  },

  setScrollTop: function(value) {
    if (this._jScroll && this._jScroll.modelX) {
      this.scrollTo(this._jScroll.modelX.getPosition(), value, 0, false);
    } else {
      this.scrollTo(0, value, 0, false);
    }
  },

  getScrollLeft: function() {
    if (this._jScroll && this._jScroll.modelX) {
      return this.scrolling ?
        this._lastX : this._jScroll.getCurrentPositionX(Date.now());
    } else {
      return 0;
    }
  },

  setScrollLeft: function(value) {
    if (this._jScroll && this._jScroll.modelY) {
      this.scrollTo(value, this._jScroll.modelY.getPosition(), 0, false);
    } else {
      this.scrollTo(value, 0, 0, false);
    }
  },

  /**
   * get the current coordinates for the scroller
   */
  coords: function() {
    if (!this._jScroll) {
      return [0, 0];
    }

    var x = this._jScroll.modelX ? this._jScroll.modelX.getPosition() : 0,
        y = this._jScroll.modelY ? this._jScroll.modelY.getPosition() : 0;

    return [x, y];
  }
});

exports.ScrollView = ScrollView;
});

// module: shared/data2/store/store
// file:   ../../shared/js/data2/store/store.js
define("shared/data2/store/store", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*global undefined:false*/

// ACHTUNG !!!
// If this file is more then 500 lines we have an architectural problem

var core   = require('bolt/core');
var util   = require('bolt/util');
var Model  = require('bolt/model').Model;
var Events = require('bolt/mixins/events').Events;

var Deferred = require('shared/deferred').Deferred;

var MemoryCache       = require('./memory_cache').MemoryCache;
var ManagedCollection = require('./managed_collection').ManagedCollection;
var Filter            = require('./filter').Filter;
var SEQUENCE_STATE    = require('./constants').SEQUENCE_STATE;
var STATE             = require('./constants').STATE;
var WithAnnotation    = require('../with_annotation').WithAnnotation;


/**
 * Store is responsible for syncronizing efforts between LocalMapper and
 * RemoteMapper. It also ensures uniqueness of models in memory using
 * MemoryCache.
 */
exports.Store = core.createClass({

  name: 'Store',

  mixins: [Events, WithAnnotation],

  properties: {
    modelType: Model
  },

  /**
   * @constructor
   * @param {Object} [remoteMapper] The object used to load remote data
   * @param {Object} [localMapper] The object used to load local data
   */
  construct: function(remoteMapper, localMapper) {
    this._localMapper = localMapper;
    this._remoteMapper = remoteMapper;
    this._memoryCache = new MemoryCache();
    this._boundGetFromCache = util.bind(function(id) {
      var model = this._memoryCache.get(id);
      return model && model.toObject();
    }, this);
  },

  getLocalMapper: function() {
    return this._localMapper;
  },

  getRemoteMapper: function() {
    return this._remoteMapper;
  },

  // Local DB API
  //______________________________________________________|
  //__________________[oo_H_oo]___________________________|
  //                      |                               |
  //                      |                               |
  //                   +++++++                            |
  //                 //       \\                          |
  //                || _-----_ ||                         |
  //                 \|-_____-|/                          |
  //   _-----_        |-_____-|   _-----_  _-----_        |
  //  |-__ _-----_    |-_____-|  |-_____-||-__ _-----_    |
  //  |-__|-_____-|    -_____-   |-_____-||-__|-_____-|   |
  //_ |-__|-_____-|_____________ |-_____-||-__|-_____-| __|
  //   -__|-_____-|               -_____-  -__|-_____-|    \
  //       -_____-                             -_____-      \
  //
  /**
   * Asyncronously returns a collection populated with data from the local
   * database. Collection will be automatically updated when
   * new data arrives from server or from different threads.
   *
   * See data/store/collection for the api available on a store collection
   *
   * @param {Filter|Object} filter
   * @param {Integer|String} limit or order
   * @return {Deferred}
   *
   * @example
   *   store
   *    .fetchCollection(new Filter({ thread_id: 12 }, 'timestamp desc'), 10)
   *    .addCallback(view.setCollection, view);
   *
   *   // same as (syntax sugar)
   *
   *   store
   *    .fetchCollection({ thread_id: 12 }, 'timestamp desc', 10)
   *    .addCallback(view.setCollection, view);
   *
   *   // same as (default limit)
   *
   *   store
   *    .fetchCollection({ thread_id: 12 }, 'timestamp desc')
   *    .addCallback(view.setCollection, view);
   */
  fetchCollection: function(filter, limit) {
    if (!(filter instanceof Filter)) {
      if (arguments.length > 2 || typeof arguments[1] == 'string') {
        filter = new Filter(filter, arguments[1]);
        limit = arguments[2];
      } else {
        filter = new Filter(filter);
      }
    }
    limit = (limit || 10) * 1;
    var collection = this.createCollection();
    collection.setFilter(filter);
    return this.fetchMoreIntoCollection(collection, limit);
  },

  /**
   * _ _ _ ____ ____ _  _ _ _  _ ____
   * | | | |__| |__/ |\ | | |\ | | __
   * |_|_| |  | |  \ | \| | | \| |__|
   * You need to manually release the model after you no longer need it.
   * If you don't it will cause memory leaks.
   *
   * Asyncronously fetch a single model from the store by id. v1 aka 'naive'
   *
   * @param model id
   * @return model
   *
   * @example
   *   store.fetchModel(123).addCallback(function(model) {
   *     // do something with model
   *     store.release(model);
   *   })
   */
  fetchModel: function(id) {
    var model = this._memoryCache.get(id);
    if (model) {
      this.hold(model);
      return (new Deferred()).succeed(model);
    }
    var filter = new Filter({ id: id });
    return this._localMapper
      .annotate(this.getAndClearAnnotation('fetchModel'))
      .fetchInformationForFilter(filter, 1, 0, this._boundGetFromCache)
      .then(this._fetchModelFound, this);
  },

  _fetchModelFound: function(models) {
    var modelAttributes = models[0];
    var model;
    if (modelAttributes) {
      model = this.createModel(modelAttributes);
      this.hold(model);
    }
    return model;
  },

  /**
   * _ _ _ ____ ____ _  _ _ _  _ ____
   * | | | |__| |__/ |\ | | |\ | | __
   * |_|_| |  | |  \ | \| | | \| |__|
   * You need to manually release the models after you no longer need them.
   * If you don't it will cause memory leaks.
   *
   * Asyncronously fetch several models from the store by id.
   *
   * @param {Array} model ids
   * @return {Object} models indexed by id
   *
   * @example
   *   store.fetchModels([123,456]).addCallback(function(models) {
   *     // do something with models
   *     util.forEach(models, store.release, store)
   *   })
   */
  fetchModels: function(ids) {
    var result = {};
    var toFetch = [];
    for (var i = 0; i < ids.length; i++) {
      var model = this._memoryCache.get(ids[i]);
      if (model) {
        this.hold(model);
        result[ids[i]] = model;
      } else {
        result[ids[i]] = null;
        toFetch.push(ids[i]);
      }
    }
    var filter = new Filter({ id: toFetch });
    return this._localMapper
      .annotate(this.getAndClearAnnotation('fetchModels'))
      .fetchInformationForFilter(filter, toFetch.length,
                                  0, this._boundGetFromCache)
      .then(this._fetchModelsFound, this, result);
  },

  _fetchModelsFound: function(result, models) {
    for (var i = 0; i < models.length; i++) {
      var modelAttributes = models[i];
      var model = this.createModel(modelAttributes);
      this.hold(model);
      result[model.getId()] = model;
    }
    return result;
  },

  /**
   * Asyncronously fetches more data into given collection
   *
   * @param {Filter} filter
   * @param {Integer} limit
   * @return {Deferred}
   */
  fetchMoreIntoCollection: function(collection, limit) {
    limit = (limit || 10) * 1;

    var filter = collection.getFilter();
    var offset = collection.length;
    return this._localMapper
      .annotate(this.getAndClearAnnotation('fetchMoreIntoCollection'))
      .fetchInformationForFilter(filter, limit, offset, this._boundGetFromCache)
      .then(this._modelsFound, this, collection, limit);
  },

  _modelsFound: function(collection, limit, models) {
    var ModelType = this.getModelType();
    var createdModels = [];
    for (var i = 0, length = models.length; i < length; i++) {
      var modelAttributes = models[i];
      var model = this.createModel(modelAttributes);
      createdModels.push(model);
    }
    collection.setHasMore(createdModels.length == limit);
    collection.merge(createdModels, false, true);
    return collection;
  },

  /**
   * Creates a model from the data hash returned by the local mapper
   *
   * @protected
   * @param {Array} models
   * @return {ModelInstance}
   */
  createModel: function(modelAttributes) {
    var model = this._memoryCache.get(modelAttributes.id);
    if (model) {
      return model;
    } else {
      var ModelType = this.getModelType();
      return new ModelType(modelAttributes, true);
    }
  },

  /**
   * Stores a set of models to local databases. Updates all collections
   * including collections in other threads
   *
   * @param {Array} models
   * @return {Deferred}
   */
  store: function(models) {
    var dataHashes = [];
    for (var i = 0, length = models.length; i < length; i++) {
      dataHashes.push(models[i].toObject());
    }
    var result = this._localMapper
     .annotate(this.getAndClearAnnotation('store'))
     .store(dataHashes);
    this._triggerStoreEvent(models);
    return result;
  },

  _triggerStoreEvent: function(models) {
    if (models.length) {
      this.invoke('modelsAdded', { models: models });
    }
  },

  /**
   * Removes models from local database by id. Updates all collections
   * including collections in other threads
   *
   * @param {Array} ids
   * @return {Deferred}
   */
  remove: function(ids) {
    var result = this._localMapper
      .annotate(this.getAndClearAnnotation('remove'))
      .remove(ids);
    this._triggerRemoveEvent(ids);
    return result;
  },

  _triggerRemoveEvent: function(ids) {
    this.invoke('modelsRemoved', { ids: ids });
  },


  // Memory cache API
  //
  //         ______________________________________________
  //         |   =####=    =####=     =####=    =####=    |
  //          )  =####=    =####=     =####=    =####=   (
  //    ______________________________________________    |
  //    |   =####=    =####=     =####=    =####=    |    |
  //     )  =####=    =####=     =####=    =####=   (    o|
  //    |   =####=    =####=     =####=    =####=    | WW_|
  //    |   =####=    =####=  G  =####=    =####=    |
  //    |o                    G                     o|
  //    |_WWWWWWW WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW_|
  //
  /**
   * Release fetched model. If all users released a model it will be destroyed
   */
  release: function(model) {
    this._memoryCache.release(model);
  },

  /**
   * Hold fetched model. If model was never hold before it will be cached in
   * memory and next calls to getCollection() will hit memory instead of db.
   */
  hold: function(model) {
    this._memoryCache.hold(model);
  },



  // Remote API        ________
  //                ddGG??????GGbb
  //            dGGGb            dGGGb
  //           dGG                  GGb
  //         GGG         ____         GGG
  //        GG        dGG????GGb        GG
  //       dGG      dG          Gb      GGb
  //        GG     G              G     GG
  //        GG     G      ()      G     GG
  //         dG     d     /\     b     Gb
  //          GG         /  \         GG
  //             G      /    \      G
  //                   /      \
  //
  downloadIntoCollection: function(collection, limit) {
    limit = (limit || 10) * 1;
    return this.getRemoteMapper()
      .download(collection.getFilter(), limit)
      .then(this._checkHasMore, this, collection)
      .then(this._downloaded, this);
  },

  downloadCollectionAfter: function(collection, limit) {
    return this._downloadCollectionPart(collection, limit, true);
  },

  downloadCollectionBefore: function(collection, limit) {
    return this._downloadCollectionPart(collection, limit, false);
  },

  downloadCollectionHead: function(collection, limit) {
    limit = (limit || 10) * 1;
    return this.getRemoteMapper()
      .download(collection.getFilter(), limit)
      .then(this._checkHasMore, this, collection)
      .then(this._downloaded, this);
  },

  upload: function(models) {
    util.invoke(models, 'set', 'remoteState', STATE.LOCAL);

    this.store(models);
    return this.getRemoteMapper().upload(models)
        .then(this._uploaded, this, models);
  },

  _uploaded: function(results) {},

  _downloadCollectionPart: function(collection, limit, isAfter) {
    if (!collection.length) {
      return this.downloadIntoCollection(collection, limit);
    }

    limit = (limit || 10) * 1;
    var filter = collection.getFilter();
    var isAsc  = filter.isAsc();
    var isNext = (isAsc && isAfter) || (!isAsc && !isAfter);
    var model  = isAfter ? collection.last() : collection.first();
    var remoteMapper = this.getRemoteMapper();
    var method = isNext ? remoteMapper.downloadNext :
      remoteMapper.downloadPrevious;

    var result = method.call(remoteMapper, model, filter, limit);
    if (isAfter) {
      result = result.then(this._checkHasMore, this, collection);
    }
    return result.then(this._downloaded, this);
  },

  _checkHasMore: function(collection, models, hasMore) {
    util.run(models, 'set', 'remoteState', STATE.NORMAL);
    collection.setRemoteState(
        hasMore || models.length + collection.length > 0 ?
        SEQUENCE_STATE.NORMAL :
        SEQUENCE_STATE.EMPTY);
    if (!hasMore) {
      if (models.length) {
        models[models.length - 1].set('remoteState', STATE.LAST);
      } else if (collection.length) {
        var last = collection.last();
        last.set('remoteState', STATE.LAST);
        models.unshift(last);
      }
    }
    return (new Deferred()).succeed(models, hasMore);
  },

  _downloaded: function(models) {
    return this.store(models);
  },

  // PROTECTED
  destroy: function() {},

  /**
   * @return {ManagedCollection}
   */
  createCollection: function() {
    return new ManagedCollection(this, { modelType: this.getModelType() });
  }
});
});

// module: shared/springs
// file:   ../../shared/js/springs.js
define("shared/springs", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
// Written by Ryan Patterson

var util = require('bolt/util');

var Spring = exports.Spring = (function() {

  /**
   * Options:
   *   tension - this is the strength of the force that is causing the spring
   *     to contract
   *   friction - this is the strength of the force preventing the spring from
   *     contracting
   *   context - this is the object that will be the context for the getter and
   *     setter (`this' value)
   *
   * The displacement of the spring (x) is modeled by a differential equation,
   * given a friction force F and a spring force (tension) T:
   *
   *   x'' = -T * x + -F * x'
   *   x'' + -F * x' + T * x = 0
   *
   * X is a function of time, t. All of these methods follow from this
   * equation. For a detailed explanation, you may read http://bit.ly/vq5efT.
   */
  function Spring(options) {
    options = options || {};

    // Simulation parameters
    this.t0 = options.t0 || 0;
    this.x0 = options.x0 || 0;
    this.v0 = options.v0 || 0;
    this.xEnd = options.xEnd || 0;

    // Motion parameters
    this.tension = options.tension || 180;
    this.friction = options.friction || 19;
    this.tolerance = options.tolerance || 1;

    this.updateProperties({});
  }

  Spring.prototype.updateProperties = function(properties) {
    // Simulation parameters
    if (properties.t0 || properties.t0 === 0) {
      this.t0 = properties.t0;
    }
    if (properties.x0 || properties.x0 === 0) {
      this.x0 = properties.x0;
    }
    if (properties.v0 || properties.v0 === 0) {
      this.v0 = properties.v0;
    }
    if (properties.xEnd || properties.xEnd === 0) {
      this.xEnd = properties.xEnd;
    }

    // Motion parameters
    this.tension = properties.tension || this.tension;
    this.friction = properties.friction || this.friction;
    this.tolerance = properties.tolerance || this.tolerance;

    // For now we're only going to support tension/friction values s.t. the
    // value will converge on 0.
    var characteristic = this.friction * this.friction - 4 * this.tension;
    if (characteristic >= 0) {
      throw new Error('Spring has too much friction.');
    }

    this._alpha = -this.friction / 2;
    this._beta = Math.sqrt(-characteristic) / 2;
    this._A = this.x0 - this.xEnd;
    this._B = (this.v0 - this._alpha * this._A) / this._beta;

    if (Math.abs(this._A) < this.tolerance) {
      this._duration = 0;
    } else {
      this._duration = this.computeDuration();
      if (isNaN(this._duration)) {
        console.error(this);
        throw new Error('Duration is NaN :\'(');
      }
    }
  };

  Spring.prototype.getDuration = function() {
    return this._duration;
  };

  Spring.prototype.computeXAt = function(time) {
    time -= this.t0;
    if (time >= this.getDuration()) {
      return this.xEnd;
    }
    var phase = this._beta * time;
    return Math.exp(this._alpha * time) *
      (this._A * Math.cos(phase) + this._B * Math.sin(phase)) + this.xEnd;
  };

  Spring.prototype.computeVAt = function(time) {
    time -= this.t0;
    if (time >= this.getDuration()) {
      return 0;
    }
    var cos = Math.cos(this._beta * time);
    var sin = Math.sin(this._beta * time);
    return Math.exp(this._alpha * time) * (
      this._alpha * (this._A * cos + this._B * sin) +
      this._beta * (this._A * -sin + this._B * cos));
  };

  /**
   * Compute the time it will take for the system to converge to 0. This spring
   * simulation is constrained to systems which converge to 0 displacement,
   * which can be verified by using the characteristic equation:
   *
   *   x^2 - F * x + T = 0
   *
   * The roots of the characteristic equation are complex iff.
   * sqrt(F^2 - 4 * T) < 0. If the roots are complex, the system will converge
   * to 0.
   *
   * We can bound the curve by finding the maximum, M, of
   *
   *   A * cos(beta * t) + B * sin(beta * t)
   *
   * The bounding curve will be M * e^(alpha * time), but finding the maximum
   * is complicated. We can simply use the greater of |A| and |B| multiplied by
   * e^(alpha * time) as a sufficient approximation.
   *
   * The system will have approximately converged once
   *
   *   max(|A|, |B|) * e^(alpha * time) < tolerance
   */
  Spring.prototype.computeDuration = function() {
    var coefficient = Math.max(Math.abs(this._A), Math.abs(this._B));
    return Math.log(this.tolerance / coefficient) / this._alpha;
  };

  return Spring;
})();

var DirectSpringAnimation = exports.DirectSpringAnimation = (function() {
  function DirectSpringAnimation(options) {
    options.springParams = options.springParams || {};

    this.number = options.number;
    this.ruleFunction = options.ruleFunction;
    this.node = options.node;
    this.fps = options.fps || 10;

    this._springs = new Array(this.number);
    for (var i = 0; i < this.number; i++) {
      var x0 = options.x0 ? options.x0[i] : 0;
      var v0 = options.v0 ? options.v0[i] : 0;
      var xEnd = options.xEnd;
      if (xEnd !== 0 && !xEnd) {
        xEnd = x0;
      }
      this._springs[i] = new Spring({
        tension: options.springParams.tension || false,
        friction: options.springParams.friction || false,
        tolerance: options.springParams.tolerance || false,
        x0: x0,
        v0: v0,
        xEnd: xEnd
      });
    }

    var sheetEl = document.getElementsByTagName('style');
    if (sheetEl.length > 0) {
      sheetEl = sheetEl[0];
    } else {
      sheetEl = document.createElement('style');
      sheetEl.setAttribute('type', 'text/css');
      document.head.appendChild(sheetEl);
    }

    DirectSpringAnimation.animationCount += 1;
    this.animationName = 'spring-animation-' +
      DirectSpringAnimation.animationCount;

    sheetEl.sheet.addRule('@-webkit-keyframes ' + this.animationName + '-0','');
    sheetEl.sheet.addRule('@-webkit-keyframes ' + this.animationName + '-1','');
    this.animationRules = [
      sheetEl.sheet.rules[sheetEl.sheet.rules.length - 2],
      sheetEl.sheet.rules[sheetEl.sheet.rules.length - 1]
    ];
    this.activeRule = 0;

    this.boundHandler = util.bind(this.onAnimationEnd, this);
    this.animationStart = (new Date()).getTime() / 1000.0;
    this.isRunning = false;
  }

  DirectSpringAnimation.animationCount = 0;

  DirectSpringAnimation.prototype.jumpTo = function(xEnd) {
    for (var i = 0; i < this.number; i++) {
      var data = {
        x0: xEnd[i],
        xEnd: xEnd[i]
      };
      this._springs[i].updateProperties(data);
    }

    // Apply the new styles
    var target = this.ruleFunction(xEnd);
    for (var prop in target) {
      this.node.style[prop] = target[prop];
    }

    this.reset();
  };

  DirectSpringAnimation.prototype.animateTo = function(options) {
    var duration = 0;
    var now = (new Date()).getTime() / 1000.0 - this.animationStart;
    for (var i = 0; i < this.number; i++) {
      var data = {
        x0: (options.x0 ? options.x0[i] : this._springs[i].computeXAt(now)),
        v0: this._springs[i].computeVAt(now) + (options.v0 ? options.v0[i] : 0),
        xEnd: options.xEnd[i]
      };
      this._springs[i].updateProperties(data);
      duration = Math.max(duration, this._springs[i].getDuration());
    }
    if (this.isRunning) {
      // If the animation is currently running, we need to switch the animation
      // name to be able to update it.
      this.activeRule = (this.activeRule + 1) % 2;
    }
    var targetRule = this.animationRules[this.activeRule];
    // Clear out the old animation
    while (targetRule.cssRules.length > 0) {
      targetRule.deleteRule(targetRule.cssRules[0].keyText);
    }
    // Once we know the full duration we can generate the keyframes.
    var numFrames = Math.ceil((options.fps || this.fps) * duration);
    if (numFrames > 0) {
      // Step through the animation
      for (var i = 0; i <= numFrames; i++) {
        var time = i * duration / numFrames;
        var values = new Array(this.number);
        for (var j = 0; j < this.number; j++) {
          values[j] = this._springs[j].computeXAt(time);
        }

        targetRule.insertRule((100.0 * i / numFrames) + '% { }');
        var style = targetRule.cssRules[i].style;
        var target = this.ruleFunction(values);
        for (var prop in target) {
          style[prop] = target[prop];
        }
      }

      // Apply the animation
      //console.debug("Animating %O with animation %O", this.node, targetRule);
      this.node.style.WebkitAnimationName =
        this.animationName + '-' + this.activeRule;
      this.node.style.WebkitAnimationDuration =
        (options.timeDilation || 1) * duration + 's';
      this.node.style.WebkitAnimationTimingFunction = 'linear';
      this.animationStart = (new Date()).getTime() / 1000.0;
      this.isRunning = true;

      // Set up listener
      this.node.addEventListener('webkitAnimationEnd',
                                 this.boundHandler, false);
    }

    // Apply the final styles
    var target = this.ruleFunction(options.xEnd);
    for (var prop in target) {
      this.node.style[prop] = target[prop];
    }
  };

  DirectSpringAnimation.prototype.reset = function() {
    this.node.style.WebkitAnimationName = 'none';
    this.isRunning = false;
    this.node.removeEventListener('webkitAnimationEnd', this.boundHandler);
  };

  DirectSpringAnimation.prototype.onAnimationEnd = function() {
    this.reset();

    if (this.callback) {
      this.callback.call(null);
    }
  };

  DirectSpringAnimation.prototype.getSpring = function(index) {
    return this._springs[index];
  };

  return DirectSpringAnimation;
})();

/**
 * SpringAnimation:
 *   Property values represent those that are presently set on the node's style.
 */
var SpringAnimation = exports.SpringAnimation = {
  mixinReady: function() {
    if (this.springAnimation) {
      // Have to clone the version on our prototype.
      this.springAnimation = util.clone(this.springAnimation);
      this.springAnimation.pendingValues = {};
      this.springAnimation.pending = false;
      var startValues = new Array(this.springAnimation.properties.length);

      this.springAnimation.animator = new DirectSpringAnimation({
        number: this.springAnimation.properties.length,
        node: this.getNode(),
        ruleFunction: util.bind(this.__springAnimationRuleWrapper, this),
        springParams: this.springAnimation.springParams,
        x0: startValues
      });

      for (var i = 0; i < this.springAnimation.properties.length; i++) {
        var property = this.springAnimation.properties[i];
        this.springAnimation.pendingValues[property] = false;
        startValues[i] = this[util.getter(property)]();

        this[util.setter(property)] =
          util.bind(this.__springAnimationSetter, this, property);
        this[util.setter(property + "Direct")] =
          util.bind(this.__springAnimationSetterDirect, this, property);
        this[util.getter(property)] =
          util.bind(this.__springAnimationGetter, this, property);
        this['spring' + util.capitalize(property)] =
          this.springAnimation.animator.getSpring(i);
      }
    }
  },

  resetSpringAnimation: function() {
    var target = new Array(this.springAnimation.properties.length);
    for (var i = 0; i < this.springAnimation.properties.length; i++) {
      var property = this.springAnimation.properties[i];
      target[i] = this.get(property);
    }

    this.springAnimation.animator.jumpTo(target);
  },

  createSpringAnimation: function(options) {
    var that = this;
    var from = util.map(this.springAnimation.properties, function(p) {
      if (options.from && options.from[p] === +options.from[p]) {
        return options.from[p];
      } else {
        return this.get(p);
      }
    }, this);
    var v0 = util.map(this.springAnimation.properties, function(p) {
      return (options.v0 ? ~~options.v0[p] : 0);
    });
    var to = util.map(this.springAnimation.properties, function(p) {
      if (options.to[p] === +options.to[p]) {
        this.set(p, options.to[p]);
        return options.to[p];
      } else {
        return this.get(p);
      }
    }, this);
    // I feel filthy overriding options like this :-X
    this.springAnimation.animator.animateTo(util.extend(options, {
      x0: from,
      v0: v0,
      xEnd: to,
      timeDilation: 1
    }));
    this.springAnimation.animator.callback = options.callback;
  },

  /**
   * Calling this indicates that you are done calling set* methods on
   * springAnimation properties. This is not necessary, but can improve
   * performance by alleviating the need for two reflows.
   */
  startSpringAnimationNow: function() {
    if (this.springAnimation.pending !== false) {
      window.clearTimeout(this.springAnimation.pending);
      this.springAnimation.pending = false;
    }
    this.__springAnimationStart(this);
  },

  __springAnimationSetter: function(property, value) {
    this.springAnimation.pendingValues[property] = value;
    if (this.springAnimation.pending === false) {
      this.springAnimation.pending =
        util.defer(this.__springAnimationStart, this);
    }
  },

  __springAnimationSetterDirect: function(property, value) {
    this.set(property, value);

    var values = new Array(this.springAnimation.properties.length);
    for (var i = 0; i < this.springAnimation.properties.length; i++) {
      values[i] = this.get(this.springAnimation.properties[i]);
    }
    this.springAnimation.animator.jumpTo(values);
  },

  __springAnimationGetter: function(property) {
    var propertyIndex = this.springAnimation.properties.indexOf(property);
    var now = (new Date()).getTime() / 1000.0 -
      this.springAnimation.animator.animationStart;
    return this.springAnimation.animator._springs[propertyIndex]
      .computeXAt(now);
  },

  __springAnimationRuleWrapper: function(values) {
    var niceValues = {};
    for (var i = 0; i < values.length; i++) {
      niceValues[this.springAnimation.properties[i]] = values[i];
    }
    return this[this.springAnimation.ruleFunction].call(this, niceValues);
  },

  __springAnimationStart: function(context) {
    var target = new Array(context.springAnimation.properties.length);
    for (var i = 0; i < context.springAnimation.properties.length; i++) {
      var property = context.springAnimation.properties[i];
      target[i] = context.springAnimation.pendingValues[property];
      if (target[i] === false) {
        target[i] = context[util.getter(property)]();
      } else {
        context.set(property, target[i]);
      }
      context.springAnimation.pendingValues[property] = false;
    }
    context.springAnimation.pending = false;
    context.springAnimation.animator.animateTo({ // the animaniacs!
      xEnd: target
    });
  }
};
});

// module: bolt_touch/views/data_list/rendering_strategy/grid
// file:   ../../../frameworks/bolt_touch/lib/views/data_list/rendering_strategy/grid.js
define("bolt_touch/views/data_list/rendering_strategy/grid", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

/*global undefined: false */


var core = require('bolt/core');
var util = require('bolt/util');

var CircularBuffer = require('../circular_buffer').CircularBuffer;
var CommandQueue = require('../command_queue').CommandQueue;
var eventually = require('../../../util/eventually').eventually;
var BaseRenderingStrategy = require('./base').BaseRenderingStrategy;


function viewIndexGetter(view) {
  return view.__viewIndex;
}


var ACTION_SHOW = 1;
var ACTION_HIDE = 2;

/**
 * @class GridRenderingStrategy
 * @classdesc Renders data a grid of views. Views added to DataLists that
 * use this rendering strategy should have a uniform fixed width and height.
 */
var GridRenderingStrategy = core.createClass({

  extend: BaseRenderingStrategy,

  name: 'GridRenderingStrategy',

  // Array of row views sorted by __viewIndex
  _gridCells: null,

  properties: {
    /**
     * when no data is rendered yet set the height of the list to this value
     */
    emptyHeight: 100,

    /**
     * Animate changes made to the grid
     */
    animateChanges: false,

    /**
     * If true, any available space between grid cells will be uses
     * to create space between the cells.  If false, cells are packed
     * next to each other, and free space is visible on the right.
     */
    allowMargins: false,

    /**
     * If null, the outer margin (the perimeter of the grid) will have
     * the same margin as the space between the cells. If an integer is
     * provided, that will be the outer margin.
     */
    outerMargin: null
  },

  construct: function(options) {
    BaseRenderingStrategy.call(this, options);

    this._gridCells = new CircularBuffer();
    this._gridCellsToActivate = [];
  },

  /**
   * Update the grid if any pending events or changes in the visible
   * range warrant it.
   */
  update: function(commandQueue, range, width) {
    // Get the view width. If it changed, we'll need to do a full reset
    // before we continue.
    //
    // TODO: We should update this class to support width changes without
    // a full reset. We'll need to move every cell to the new position,
    // load a new buffer, and fix the scroll position.
    if (width !== this._viewWidth) {
      if (this._viewWidth) {
        this.clear();
      }
      this._viewWidth = width;
    }

    this._deduceCellSize();
    var changesFromCommands = this._processCommands(commandQueue);
    var changesFromRowUpdates = this._updateGridItems(range);

    return changesFromCommands || changesFromRowUpdates;
  },

  clear: function() {
    while (this._gridCells.length) {
      this._releaseCell(this._gridCells.get(0));
    }
    this._gridCells = new CircularBuffer();
    this._cellHeight = 0;
  },

  /**
   * Sets the option to distribute free horizontal space between the cells
   * rather than leaving blank space to the right of the cells.
   *
   * @property allowMargins {Boolean}
   */
  setAllowMargins: function(allowMargins) {
    this.set('allowMargins', allowMargins);
    this._cellHeight = 0;
  },

  _deduceCellSize: function() {
    var data = this._data;
    if (data.length && !this._cellHeight) {

      var model = data.sample || (data.at ? data.at(0) : data[0]) || '';
      var cell = this._viewManager.acquire(model);

      // Temporarily add the cell to the view so it can be measured
      this._paneView.append(cell);

      var node = cell.getNode();
      this._cellHeight = node.offsetHeight;
      this._cellWidth = node.offsetWidth;

      var outerMargin = (this.getOuterMargin() !== null ? this.getOuterMargin() : 0);
      var width = this._viewWidth - (outerMargin * 2);
      this._cellsPerRow = Math.floor(width / this._cellWidth);

      if (this.getAllowMargins()) {
        // If margins are being used, calculate the distance between cells
        var numGaps = (this.getOuterMargin() !== null ? this._cellsPerRow - 1 : this._cellsPerRow + 1);
        this._cellMargin =
          Math.floor((width - (this._cellsPerRow * this._cellWidth)) / numGaps);
      } else {
        this._cellMargin = 0;
      }
      this._outerMargin = (this.getOuterMargin() !== null ? this.getOuterMargin() : this._cellMargin);

      // Remove the cell from the view now that it has been measured
      this._paneView.removeChild(cell);
    }
  },

  _acquireGridItem: function(index, model, animate) {
    var data  = this._data;

    // Support both Collection and Array storage of Model objects
    model = model || (data.at ? data.at(index) : data[index]);
    var cell  = this._viewManager.acquire(model);
    cell.__viewIndex = index;

    var isNew = this._initCell(index, cell);
    this._moveCell(index, cell, animate);
    this._cacheCell(cell);

    return cell;
  },

  _initCell: function(index, cell) {
    if (!cell.getParentView()) {
      cell.setStyle({
        position: 'absolute',
        left: '0px',
        top: '0px'
      });

      if (this.getAnimateChanges()) {
        cell.addListener('transitionend', this._releaseAfterAnimation, this);
      }
      this._paneView.appendChild(cell);
      return true;
    }
    return false;
  },

  _releaseAfterAnimation: function(e) {
    var cell = e.getTargetView();
    if (cell.getParentView() !== this._view) {
      return;
    }
    if (cell.__viewAction === ACTION_HIDE) {
      this._viewManager.release(cell);
      cell.getNode().style.webkitTransform = 'translate3d(-9999px,0,0)';
      cell.removeClass('bt-data-list-row_disappearing bt-data-list-row_hidden');
      cell.__viewAction = 0;
    } else if (cell.__viewAction === ACTION_SHOW) {
      cell.removeClass('bt-data-list-row_appearing');
      cell.__viewAction = 0;
    } else {
      cell.removeClass('bt-data-list-row_moving');
    }
  },

  _moveCell: function(index, cell, animate, markOnly) {

    var margin = this._cellMargin;
    var row = Math.floor(index / this._cellsPerRow);
    var y = ((this._cellHeight + margin) * row) + this._outerMargin;

    cell.__desiredPositionY = y;

    var x = (this._cellWidth + margin) * (index % this._cellsPerRow) + this._outerMargin;
    cell.__desiredPositionX = x;

    if (!markOnly) {
      cell.__viewPositionX = x;
      cell.__viewPositionY = y;

      cell.removeClass('bt-data-list-row_moving');

      // Place the cell in both the X and Y positions
      cell.getNode().style.webkitTransform = 'translate3d(' + x + 'px,' + y + 'px,0)';

      if (animate) {
        cell.addClass('bt-data-list-row_hidden');
        cell.__viewAction = ACTION_SHOW;
        this._gridCellsToActivate.push(cell);
        cell.__pendingAnimation = true;
        eventually(this._activateAnimation, this);
      }
    }
  },

  _activateAnimation: function() {
    var gridCells = this._gridCellsToActivate;
    for (var i = 0; i < gridCells.length; i++) {
      gridCells[i].addClass('bt-data-list-row_appearing');
      gridCells[i].removeClass('bt-data-list-row_hidden');
      gridCells[i].__pendingAnimation = false;
    }
    this._gridCellsToActivate.length = 0;
  },

  _cacheCell: function(row) {
    var insertIndex = this._gridCells.sortedIndex(row, viewIndexGetter);
    this._gridCells.insert(insertIndex, row);
  },

  _releaseCellByIndex: function(index, animate) {
    this._releaseCell(this._gridCells.get(index), index, animate);
  },

  _releaseCell: function(cell, indexSuggest, animate) {
    if (animate) {
      cell.addClass('bt-data-list-row_disappearing bt-data-list-row_hidden');
      cell.__viewAction = ACTION_HIDE;
    } else {
      this._viewManager.release(cell);
      cell.getNode().style.webkitTransform = 'translate3d(-9999px,0,0)';
    }
    var index = indexSuggest === undefined ?
      this._gridCells.sortedIndex(cell, viewIndexGetter) : indexSuggest;

    this._gridCells.remove(index);
  },

  /**
   * Removes views outside of rendering range and renders new ones inside.
   * Operates under assumption that the rendered range has no gaps.
   *
   * @param {Object} range pixels to render
   * @return {Boolean} true if there were changes to react to, false otherwise.
   */
  _updateGridItems: function(range) {
    var length      = this._data.length;
    var gridCells   = this._gridCells;

    // exit fast if we know that there's nothing to do
    if (!gridCells.length && !length) {
      return false;
    }

    var fromIndex = gridCells.length ? gridCells.get(0).__viewIndex : 0;
    var toIndex = gridCells.length ? gridCells.get(gridCells.length - 1).__viewIndex : -1;

    var changed = false;

    var cell;
    var totalCellHeight = this._cellHeight + this._cellMargin;

    // remove extra above
    while (gridCells.length > 0 &&
      ((cell = gridCells.get(0)).__viewPositionY < range.from)) {
      this._releaseCell(cell);
      changed = true;
    }

    // remove extra below
    while (gridCells.length > 0 &&
      (cell = gridCells.get(gridCells.length - 1)).__viewPositionY > range.to) {

      this._releaseCell(cell);
      changed = true;
    }


    var currY = gridCells.length ?
      gridCells.get(gridCells.length - 1).__viewPositionY : -1;

    // render missing below
    while (currY + totalCellHeight < range.to && toIndex < length - 1) {
      cell = this._acquireGridItem(++toIndex);

      currY = cell.__viewPositionY;
      changed = true;
    }

    // render missing above
    currY = gridCells.length ?
      (cell = gridCells.get(0)).__viewPositionY : -1;
    while (currY >= range.from + totalCellHeight && fromIndex > 0) {

      for (var i = 0; i < this._cellsPerRow; i++) {
        cell = this._acquireGridItem(--fromIndex);
      }
      currY = cell.__viewPositionY;
      changed = true;
    }

    return changed;
  },

  /**
   * Process commands. See CommandQueue for the available actions
   *
   * @return {Boolean} true if commands caused any change, false otherwise
   */
  _processCommands: function(commandQueue) {
    var changed = false;
    if (commandQueue.length > 0) {
      var command = null;
      while (command = commandQueue.shift()) {
        changed = this._processCommand(command) || changed;
      }
      this._applyMove(this.getAnimateChanges());
    }
    return changed;
  },

  getHeight: function() {
    var length = this._data.length;
    if (!length) {
      return this.getEmptyHeight();
    }
    return Math.ceil(length / this._cellsPerRow) *
      (this._cellHeight + this._cellMargin) -
      this._cellMargin + (this._outerMargin * 2);
  },

  _processCommand: function(command) {
    var length      = this._data.length;
    var gridCells   = this._gridCells;
    var fromIndex   = gridCells.length ? gridCells.get(0).__viewIndex : 0;
    var toIndex     = gridCells.length ? gridCells.get(gridCells.length - 1).__viewIndex : 0;
    var cellIndex   = 0;
    var cell;
    var tmp;
    var height;

    var index = command.index;

    if (index <= toIndex && index >= fromIndex) {
      cellIndex = gridCells.sortedIndex({ __viewIndex: index }, viewIndexGetter);
      cell = gridCells.get(cellIndex);
    }

    if (command.action === CommandQueue.RESIZE ||
      command.action === CommandQueue.REDRAW) {
      if (cell) {
        var model = command.model;
        var reusableType = this._viewManager.getReusableType(model);
        this._viewManager.updateView(cell, model, reusableType);
        return true;
      }
      return false;
    }

    if (command.action === CommandQueue.REMOVE) {
      if (cell) {
        this._releaseCell(cell, undefined, this.getAnimateChanges());
      }
      this._offsetViewIndices(index, -1);
      this._offsetCellPositions(index);

     // TODO: move everything again
      return true;
    }

    if (command.action === CommandQueue.INSERT) {
      this._offsetViewIndices(index, 1);
      tmp = this._acquireGridItem(
        index,
        command.model,
        cell && this.getAnimateChanges());
      // remove if invisible
      if (!cell) {
        this._releaseCell(tmp);
      }

      this._offsetCellPositions(index + 1);
      return true;
    }

    return false;
  },

  /**
   * When a row changes height, is added or is removed, the offset height of all
   * gridCells below it must be updated. This'll do that.
   *
   * @property {number} the view index of the row to offset the height by
   * @property {number} the height to offset all gridCells at and below the view
   *  index by.
   */
  _offsetCellPositions: function(viewIndex) {

    var gridCells    = this._gridCells;
    var cell     = null;
    var y;
    for (var i = 0, l = gridCells.length; i < l; i++) {
      cell = gridCells.get(i);
      if (cell.__viewIndex >= viewIndex) {
        this._moveCell(cell.__viewIndex, cell, false, true);
      }
    }
  },

  _applyMove: function(animate) {
    var i, x, y, move;
    var gridCells = this._gridCells;
    var cell = null;

    for (i = 0; i < gridCells.length; i++) {
      cell = gridCells.get(i);
      if (cell.__desiredPositionY !== cell.__viewPositionY ||
          cell.__desiredPositionX !== cell.__viewPositionX) {


        if (animate && !cell.__pendingAnimation) {
          if (cell.__viewPositionX === cell.__desiredPositionX ||
            cell.__viewPositionY === cell.__desiredPositionY) {
            // If the cell is going to move vertically or horizontally,
            // then animate the move.  Do not animate diagonally, as it is
            // too distracting.

            cell.addClass('bt-data-list-row_moving');
          } else {
            cell.removeClass('bt-data-list-row_moving');
            cell.addClass('bt-data-list-row_appearing');
          }
        }

        x = cell.__viewPositionX = cell.__desiredPositionX;

        y = cell.__viewPositionY = cell.__desiredPositionY;

        cell.getNode().style.webkitTransform =
          'translate3d(' + x + 'px,' + y + 'px,0)';
      }
    }
  },

  _offsetViewIndices: function(index, offset) {
    var gridCells    = this._gridCells;
    var toIndex = gridCells.length ? gridCells.get(gridCells.length - 1).__viewIndex : 0;

    if (index <= toIndex) {
      for (var i = 0, l = gridCells.length; i < l; i++) {
        if (gridCells.get(i).__viewIndex >= index) {
          gridCells.get(i).__viewIndex += offset;
        }
      }
    }
  },

  setHighlighted: function(index, state) {
    var rowIndex = this._gridCells.sortedIndex(
      { __viewIndex: index },
      viewIndexGetter);

    if (rowIndex < this._gridCells.length &&
      this._gridCells.get(rowIndex).setHighlighted) {
      this._gridCells.get(rowIndex).setHighlighted(state);
    }
  },

  getIndexForEvent: function(e) {
    var view = e.getTargetView();
    while (view && view.getParentView() != this._paneView) {
      view = view.getParentView();
    }
    if (view) {
      return view.__viewIndex;
    }
    return -1;
  }
});


exports.GridRenderingStrategy = GridRenderingStrategy;
});

// module: mock/bluetooth_api
// file:   ../../mock/js/bluetooth_api.js
define("mock/bluetooth_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;
var util = require('bolt/util');

module.exports = {

  STATE_CHANGE_DELAY: 1500,
  CONNECTION_CHANGE_DELAY: 1000,

  BLUETOOTH_DISABLED: 10,
  BLUETOOTH_DISABLING: 13,
  BLUETOOTH_ENABLED: 12,
  BLUETOOTH_ENABLING: 11,

  DISCOVERY_TIMEOUT: 30,
  DEVICE_NOT_DISCOVERABLE: -1,

  SCAN_MODE_CONNECTABLE_DISCOVERABLE: 23,
  SCAN_MODE_CONNECTABLE: 21,
  SCAN_MODE_NONE: 20,

  BOND_STATE_NONE: 10,
  BOND_STATE_BONDING: 11,
  BOND_STATE_BONDED: 12,

  DEVICE_CLASS_MAJOR_AV: 1024,
  DEVICE_CLASS_MAJOR_COMPUTER: 256,
  DEVICE_CLASS_MAJOR_HEALTH: 2304,
  DEVICE_CLASS_MAJOR_IMAGING: 1536,
  DEVICE_CLASS_MAJOR_MISC: 0,
  DEVICE_CLASS_MAJOR_NETWORKING: 768,
  DEVICE_CLASS_MAJOR_PERIPHERAL: 1280,
  DEVICE_CLASS_MAJOR_PHONE: 512,
  DEVICE_CLASS_MAJOR_TOY: 2048,
  DEVICE_CLASS_MAJOR_UNCATEGORIZED: 7936,
  DEVICE_CLASS_MAJOR_WEARABLE: 1792,

  UNBOND_REASON_AUTH_FAILED: 1,
  UNBOND_REASON_AUTH_REJECTED: 2,
  UNBOND_REASON_AUTH_CANCELED: 3,
  UNBOND_REASON_REMOTE_DEVICE_DOWN: 4,
  UNBOND_REASON_DISCOVERY_IN_PROGRESS: 5,
  UNBOND_REASON_AUTH_TIMEOUT: 6,
  UNBOND_REASON_REPEATED_ATTEMPTS: 7,
  UNBOND_REASON_REMOTE_AUTH_CANCELED: 8,
  UNBOND_REASON_REMOVED: 9,

  PAIRING_VARIANT_PIN: 0,
  PAIRING_VARIANT_PASSKEY: 1,
  PAIRING_VARIANT_PASSKEY_CONFIRMATION: 2,
  PAIRING_VARIANT_CONSENT: 3,
  PAIRING_VARIANT_DISPLAY_PASSKEY: 4,
  PAIRING_VARIANT_OOB_CONSENT: 5,

  PROFILE_A2DP: 0,
  PROFILE_HEADSET: 1,
  PROFILE_PBAP: 2,

  STATE_CHANGED: "bluetooth.STATE_CHANGED",
  SCAN_MODE_CHANGED: "bluetooth.SCAN_MODE_CHANGED",
  SCAN_STARTED: "bluetooth.SCAN_STARTED",
  SCAN_FINISHED: "bluetooth.SCAN_FINISHED",
  DEVICE_FOUND: "bluetooth.DEVICE_FOUND",
  PAIRING_REQUEST: "bluetooth.PAIRING_REQUEST",
  PAIRING_CANCEL: "bluetooth.PAIRING_CANCEL",
  DEVICE_BOND_STATE_CHANGED: "bluetooth.DEVICE_BOND_STATE_CHANGED",
  A2DP_STATE_CHANGED: "bluetooth.A2DP_STATE_CHANGED",
  HEADSET_STATE_CHANGED: "bluetooth.HEADSET_STATE_CHANGED",
  PBAP_STATE_CHANGED: "bluetooth.PBAP_STATE_CHANGED",

  _bluetoothDevices: [
    {
      name: "Fake Monster Clarity",
      address: "40:98:4E:5C:75:73",
      bondState: 10, // BOND_STATE_NONE
      "class": 1032,
      majorClass: 1024,
      profiles: [0, 1] // PROFILE_A2DP, PROFILE_HEADSET
    },
    {
      name: "Fake Motorola Roadster",
      address: "0B:4F:30:3D:1B:48",
      bondState: 10, // BOND_STATE_NONE
      "class": 1032,
      majorClass: 1024,
      profiles: [0, 1] // PROFILE_A2DP, PROFILE_HEADSET
    },
    {
      name: "Fake Plantronics ML10",
      address: "72:45:26:4A:58:34",
      bondState: 10, // BOND_STATE_NONE
      "class": 1032,
      majorClass: 1024,
      profiles: [1] // PROFILE_HEADSET
    },
    {
      name: "Fake Nexus S",
      address: "06:87:82:2E:D3:9B",
      bondState: 10, // BOND_STATE_NONE
      "class": 516,
      majorClass: 512,
      profiles: []
    },
    {
      name: "Fake Thinkpad",
      address: "66:6A:86:97:A8:A1",
      bondState: 10, // BOND_STATE_NONE
      "class": 256,
      majorClass: 256,
      profiles: []
    },
    {
      name: "Fake Medical Device",
      address: "F6:C2:C6:1E:C7:33",
      bondState: 10, // BOND_STATE_NONE
      "class": 2304,
      majorClass: 2304,
      profiles: []
    },
    {
      name: "Fake Webcam",
      address: "45:B7:73:C7:BE:DC",
      bondState: 10, // BOND_STATE_NONE
      "class": 1536,
      majorClass: 1536,
      profiles: []
    },
    {
      name: "Fake Networking Device",
      address: "DF:AF:28:62:DE:FC",
      bondState: 10, // BOND_STATE_NONE
      "class": 768,
      majorClass: 768,
      profiles: []
    },
    {
      name: "Fake Game Controller",
      address: "FE:D4:BE:C5:F2:86",
      bondState: 10, // BOND_STATE_NONE
      "class": 1280,
      majorClass: 1280,
      profiles: []
    },
    {
      name: "Fake Toy",
      address: "F8:38:3E:6B:00:FD",
      bondState: 10, // BOND_STATE_NONE
      "class": 2048,
      majorClass: 2048,
      profiles: []
    },
    {
      name: "Fake Wearable Device",
      address: "48-56-40-E3-88-9F",
      bondState: 10, // BOND_STATE_NONE
      "class": 1792,
      majorClass: 1792,
      profiles: []
    },
    {
      name: "Fake Unknown Device",
      address: "19-EE-0A-A0-85-B3",
      bondState: 10, // BOND_STATE_NONE
      "class": 7936,
      majorClass: 7936,
      profiles: []
    },
    {
      name: "Fake Misc Device",
      address: "CB-C2-BE-12-4B-C8",
      bondState: 10, // BOND_STATE_NONE
      "class": 0,
      majorClass: 0,
      profiles: []
    }
  ],
  _discoveredDevices: {},
  _pairingDevices: {},
  _connectedProfiles: {},
  _connectionTimeouts: {},
  _scanEvents: [],

  state: 10, // DISABLED
  deviceName: "Angel",
  discoverableTimeout: -1,
  isScanning: false,
  bondedDevices: [],

  _setState: function(state) {
    if (state != this.state) {
      var data = {
        state: state,
        oldState: this.state
      };
      this.state = state;
      EventManager.broadcastEvent(this.STATE_CHANGED, data);
    }
  },

  isBluetoothEnabled: function() {
    return (this.state == this.BLUETOOTH_ENABLED)
  },

  setIsBluetoothEnabled: function(enable) {
    if (enable) {
      if (this.state == this.BLUETOOTH_DISABLED) {
        // set intermediate state
        this._setState(this.BLUETOOTH_ENABLING);

        // set final state after a delay
        if (this._stateChangeTimeout) {
          clearTimeout(this._stateChangeTimeout);
        }
        var _this = this;
        this._stateChangeTimeout = setTimeout(function() {
          _this._setState(_this.BLUETOOTH_ENABLED);
        }, this.STATE_CHANGE_DELAY);
      }
    } else {
      if (this.state == this.BLUETOOTH_ENABLED) {
        // set intermediate state
        this._setState(this.BLUETOOTH_DISABLING);

        // set final state after a delay
        if (this._stateChangeTimeout) {
          clearTimeout(this._stateChangeTimeout);
        }
        var _this = this;
        this._stateChangeTimeout = setTimeout(function() {
          _this._setState(_this.BLUETOOTH_DISABLED);
        }, this.STATE_CHANGE_DELAY);
      }
    }
    return true;
  },

  toggleBluetooth: function() {
    var enable = !this.isBluetoothEnabled();
    return this.setIsBluetoothEnabled(enable);
  },

  getState: function() {
    return this.state;
  },

  getDeviceName: function() {
    return this.deviceName;
  },

  setDeviceName: function(name) {
    this.deviceName = name;
    return true;
  },

  getDeviceAddress: function() {
    return "40:98:4E:5C:75:72";
  },

  _updateDiscoverableTimeout: function() {
    if (this.timeout != this.DEVICE_NOT_DISCOVERABLE) {
      this.timeout--;

      // update scan mode
      if (this.timeout <= 0) {
        clearInterval(this._discoverableCountdown);
        this.timeout = this.DEVICE_NOT_DISCOVERABLE;
        EventManager.broadcastEvent(this.SCAN_MODE_CHANGED, {
          mode: this.SCAN_MODE_CONNECTABLE,
          oldMode: this.SCAN_MODE_CONNECTABLE_DISCOVERABLE
        });
      }
    } else {
      clearInterval(this._discoverableCountdown);
    }
  },

  getDiscoverableTimeout: function() {
    if (this.timeout != this.DEVICE_NOT_DISCOVERABLE && this.timeout > 0) {
      return this.timeout;
    } else {
      return this.DEVICE_NOT_DISCOVERABLE;
    }
  },

  makeDiscoverable: function(enable, timeout) {
    if (enable) {
      if (!timeout || timeout < 0) {
        timeout = this.DISCOVERY_TIMEOUT;
      }

      // don't do anything if we're already discoverable
      if (this.getDiscoverableTimeout() == this.DEVICE_NOT_DISCOVERABLE) {
        this.timeout = timeout;
        EventManager.broadcastEvent(this.SCAN_MODE_CHANGED, {
          mode: this.SCAN_MODE_CONNECTABLE_DISCOVERABLE,
          oldMode: this.SCAN_MODE_CONNECTABLE
        });

        // start discoverability countdown
        var _this = this;
        this._discoverableCountdown = setInterval(function() {
          _this._updateDiscoverableTimeout();
        }, 1000);
      }
    } else {
      // don't do anything if we're already not discoverable
      if (this.getDiscoverableTimeout() != this.DEVICE_NOT_DISCOVERABLE) {
        this.timeout = this.DEVICE_NOT_DISCOVERABLE;
        EventManager.broadcastEvent(this.SCAN_MODE_CHANGED, {
          mode: this.SCAN_MODE_CONNECTABLE,
          oldMode: this.SCAN_MODE_CONNECTABLE_DISCOVERABLE
        });
      }
    }
    return true;
  },

  toggleDiscoverability: function() {
    var enable = (this.getDiscoverableTimeout() == this.DEVICE_NOT_DISCOVERABLE);
    return this.makeDiscoverable(enable);
  },

  _addDevice: function(device) {
    this._discoveredDevices[device.address] = device;
    EventManager.broadcastEvent(this.DEVICE_FOUND, device);
  },

  startDeviceScan: function() {
    this.isScanning = true;
    EventManager.broadcastEvent(this.SCAN_STARTED, {});
    for (var i = 0; i < this._scanEvents.length; i++) {
      clearTimeout(this._scanEvents[i]);
    }
    this._scanEvents = [];
    var _this = this, SCAN_DELAY = 750;
    var j = 0;
    for (var i = 0; i < this._bluetoothDevices.length; i++) {
      this._scanEvents[i] = setTimeout(function() {
        _this._addDevice(_this._bluetoothDevices[j++]);
      }, (i+1) * SCAN_DELAY);
    }
    _this.scanEventFinal = setTimeout(function() {
      _this.cancelDeviceScan();
    }, (this._bluetoothDevices.length + 1) * SCAN_DELAY);
    return true;
  },

  cancelDeviceScan: function() {
    this.isScanning = false;
    EventManager.broadcastEvent(this.SCAN_FINISHED, {});
    for (var i = 0; i < this._scanEvents.length; i++) {
      clearTimeout(this._scanEvents[i]);
    }
    this._scanEvents = [];
    return true;
  },

  isDeviceScanActive: function() {
    return this.isScanning;
  },

  getBondedDevices: function() {
    return JSON.stringify(this.bondedDevices);
  },

  _changeBondState: function(address, bondState) {
    var oldBondState = this._discoveredDevices[address].bondState;
    this._discoveredDevices[address].bondState = bondState;
    var device = this._discoveredDevices[address];
    device.oldBondState = oldBondState;
    EventManager.broadcastEvent(this.DEVICE_BOND_STATE_CHANGED, device);
  },

  isPaired: function(address) {
    for (var i = 0; i < this.bondedDevices.length; i++) {
      if (this.bondedDevices[i].address === address) {
        return true;
      }
    }
    return false;
  },

  pairDevice: function(address) {
    if (!this._discoveredDevices[address] && !this.isPaired(address)) {
      return false;
    }

    this._changeBondState(address, this.BOND_STATE_BONDING);
    this._pairingDevices[address] = this._discoveredDevices[address];

    var device = this._discoveredDevices[address];
    device.pairingRequestType = this.PAIRING_VARIANT_CONSENT;
    EventManager.broadcastEvent(this.PAIRING_REQUEST, device);

    return true;
  },

  cancelPairingProcess: function(address) {
    if (!this._discoveredDevices[address]) {
      return false;
    }

    delete this._pairingDevices[address];
    this._changeBondState(address, this.BOND_STATE_NONE);
    EventManager.broadcastEvent(this.PAIRING_CANCEL,
      this._discoveredDevices[address]);

    return true;
  },

  onPair: function(address, pairingRequestType, value) {
    // Since all of the devices are simulated, there's no need
    // to duplicate all of the different pairing request functionality
    // in BluetoothAPI. We just assume every device uses
    // PAIRING_VARIANT_CONSENT and pair any specified device if
    // we can find it
    if (!this._discoveredDevices[address] || !this._pairingDevices[address]) {
      return false;
    }

    delete this._pairingDevices[address];
    this._changeBondState(address, this.BOND_STATE_BONDED);
    this.bondedDevices.push(this._discoveredDevices[address]);

    // connect all profiles after a short delay
    this._connectedProfiles[address] = [];
    var _this = this;
    this._connectionTimeouts[address] = setTimeout(function() {
      _this.connectAllProfiles(address);
    }, this.CONNECTION_CHANGE_DELAY);
  },

  unpairDevice: function(address) {
    this.disconnectAllProfiles(address);

    for (var i = 0; i < this.bondedDevices.length; i++) {
      if (this.bondedDevices[i].address == address) {
        this.bondedDevices.splice(i, 1);
        this._changeBondState(address, this.BOND_STATE_NONE);
        delete this._connectedProfiles[address];
        if (this._connectionTimeouts[address]) {
          clearTimeout(this._connectionTimeouts[address]);
          delete this._connectionTimeouts[address];
        }
        return true;
      }
    }
    return false;
  },

  _changeConnectionState: function(address, profile, connect) {
    // determine the event type
    var eventType;
    switch (profile) {
      case this.PROFILE_A2DP:
        eventType = this.A2DP_STATE_CHANGED;
        break;
      case this.PROFILE_HEADSET:
        eventType = this.HEADSET_STATE_CHANGED;
        break;
      default:
        console.error("Can't change connection for unknown profile type: " + profile);
        return;
    }

    var isConnected = (this._connectedProfiles[address].indexOf(profile) !== -1);
    if (connect != isConnected) {
      // change the connection state
      if (connect) {
        this._connectedProfiles[address].push(profile);
      } else {
        var index = this._connectedProfiles[address].indexOf(profile);
        this._connectedProfiles[address].splice(index, 1);
      }

      // broadcast the connection change event
      var device = this._discoveredDevices[address];
      device.state = connect;
      device.oldState = isConnected;
      EventManager.broadcastEvent(eventType, device);
    }
  },

  isBluetoothConnected: function() {
    for (var address in this._connectedProfiles) {
      if (this.isDeviceConnected(address)) {
        return true;
      }
    }
    return false;
  },

  isDeviceConnected: function(address) {
    if (!this.isPaired(address)) {
      return false;
    }

    var numConnectedProfiles = this._connectedProfiles[address].length;
    return (numConnectedProfiles > 0);
  },

  isDeviceProfileConnected: function(address, profile) {
    if (!this.isPaired(address)) {
      return false;
    }

    var profileIndex = this._connectedProfiles[address].indexOf(profile);
    return (profileIndex !== -1);
  },

  connectAllProfiles: function(address) {
    if (!this.isPaired(address)) {
      return false;
    }

    // clear auto-connect timeout set by onPair()
    if (this._connectionTimeouts[address]) {
      clearTimeout(this._connectionTimeouts[address]);
      delete this._connectionTimeouts[address];
    }

    var profiles = this._discoveredDevices[address].profiles;
    for (var i = 0; i < profiles.length; i++) {
      this._changeConnectionState(address, profiles[i], true);
    }

    return true;
  },

  connectProfile: function(address, profile) {
    if (!this.isPaired(address)) {
      return false;
    }

    this._changeConnectionState(address, profile, true);

    return true;
  },

  disconnectAllProfiles: function(address) {
    if (!this.isPaired(address)) {
      return false;
    }

    var profiles = this._discoveredDevices[address].profiles;
    for (var i = 0; i < profiles.length; i++) {
      this._changeConnectionState(address, profiles[i], false);
    }

    return true;
  },

  disconnectProfile: function(address, profile) {
    if (!this.isPaired(address)) {
      return false;
    }

    this._changeConnectionState(address, profile, false);

    return true;
  }
};
});

// module: bolt_touch/views/scene_stack/index
// file:   ../../../frameworks/bolt_touch/lib/views/scene_stack/index.js
define("bolt_touch/views/scene_stack/index", function(require, exports, module) {
var core = require('bolt/core');
var view = require('bolt/view');
var util = require('bolt/util');
var dom  = require('bolt/dom');

var View = view.View;
var PageHeader = require('../pageheader').PageHeader;


var TRANSITON_TIME = 600;

var SceneStack = core.createClass({
  name: 'SceneStack',

  extend: View,

  construct: function(options) {
    View.call(this, options);
    this.scenes = [];
  },

  properties: {
    inTransition: false,

    hideInactiveScene: false,

    disableHeaders: false
  },

  getDepth: function() {
    return this.scenes.length;
  },

  /**
   * Like getDepth(), but doesn't count scenes that have been marked
   * for removal.
   */
  getActualDepth: function() {
    var numScenes = 0;
    for (var i = 0; i < this.scenes.length; i++) {
      if (!this.scenes[i].getIsPopped()) {
        numScenes++;
      }
    }
    return numScenes;
  },

  deactivateScene: function(scene) {
    scene.setIsActive(false);
    scene.deactivate();
  },

  activateScene: function(scene, data) {
    scene.activate(data);
    scene.setIsActive(true);
  },

  /**
   * Finds the index of the specified scene in the stack. If more than one
   * instance of the scene exists, the one closest to the top will be
   * returned. Returns -1 if no instances of the scene are found.
   *
   * Note that this function does not return scenes with
   * the isPopped property set to true.
   *
   * @param {object|string} scene The class or the declared class name of the
   *                              scene to search for
   * @param {int} startIndex (optional) The index to start at (default is 0)
   */
  indexOf: function(scene, startIndex) {
    startIndex = (typeof startIndex === 'undefined') ? 0 : startIndex;

    // make sure we have a class name, and not a class
    if (typeof scene === 'object') {
      scene = scene.getDeclaredClass();
    }

    for (var i = 0; i < this.scenes.length; i++) {
      if (scene &&
          scene === this.scenes[i].getDeclaredClass() &&
          !this.scenes[i].getIsPopped()) {
        return i;
      }
    }

    return -1;
  },

  /**
  * Push scene into a stack.
  *
  * Activate the scene and then add it to the view.
  * If this scene is not the first one, deactivate the previous scene
  * and perform a css-based transition. Note that transition will not
  * start untill the new scene finished it prepare.
  *
  * @example
  *   stack.push(
  *     { view: Scene, content: 'Hello World!' },
  *     { transition: 'drawer'}
  *   );
  *
  * @param {Scene} scene
  * @param {object} options
  *                 - transition: specify a transition animation from
  *                               transitions.css
  */
  push: function(scene, options) {
    options = options || {};
    // ignore request if we're in transition
    if (this.getInTransition()) {
      console.error(
        'SceneStack.push() failed because scenes were in transition.  ' +
        'Use swap() to push and pop simultaneously.  Otherwise, wait ' +
        'until the transition completes.');
      return;
    }
    this.setInTransition(true);

    try {
      scene = this.build(scene);
      scene.setStack(this);
  
      // handle singletons
      if (scene.getIsSingleton()) {
        var index = this.indexOf(scene);
  
        if (index >= 0) {
          // scene is already in the stack but not showing--tag it for removal
          this.scenes[index].setIsPopped(true);
        }
      }
  
      var wrapper = this.insertScene(scene, options);
      var def = scene.prepare();
      if (def && def.addCallback) {
        def.addCallback(util.bind(function() {
          this.setWrapperVisibility(wrapper, true);
          this.pushPrepareComplete(scene, wrapper, options);
        }, this));
      } else {
        this.setWrapperVisibility(wrapper, true);
        this.pushPrepareComplete(scene, wrapper, options);
      }
    } catch (err) {
      this.setInTransition(false);
      throw err;
    }
  },

  /**
   * convenience method for pushing modal scenes
   */
  pushModal: function(scene, options) {
    if (scene.setModal && typeof scene.setModal === 'function') {
      scene.setModal(true);
    } else {
      scene.modal = true;
    }
    this.push(scene, options);
  },

  /**
  * Pops the last scene from the view.
  *
  * Deactivate the last scene. Activate the previous one if available.
  * Perform a css-based transition. Remove last scene from the view.
  *
   * @param {object} data Optional data to pass back to the activate
   *                      method of the previous scene.
   * @param {boolean} options Options to pass, e.g. an onComplete function,
   *                          or 'noTransition': true to not use animations
  */
  pop: function(data, options) {
    // determine if underlying scenes also need to be popped. if so,
    // use popTo() instead of _pop()
    var popIndex = 1;
    while ((popIndex < this.getDepth()) &&
           this.scenes[popIndex].getIsPopped()) {
      popIndex++;
    }

    if (popIndex > 1) {
      this.popToIndex(popIndex, data, options);
    } else {
      this._pop(data, options);
    }
  },

  /**
   * The regular pop action. This one is called if there are no scenes
   * underlying the top scene that have been marked by remove().
   *
   * @param {object} data Optional data to pass back to the activate
   *                      method of the previous scene.
   * @param {boolean} options Options to pass, e.g. an onComplete function,
   *                          or 'noTransition': true to not use animations
   */
  _pop: function(data, options) {
    // ignore request if we're in transition
    if (this.getInTransition()) {
      console.error(
        'SceneStack.pop() failed because scenes were in transition.  ' +
        'Use popTo() to pop multiple scenes at once.  Use swap() to push ' +
        'and pop simultaneously.  Otherwise, wait until the transition ' +
        'completes.');
      return;
    }
    this.setInTransition(true);

    try {
      this.deactivateScene(this.scenes[0]);
  
      // start activating previous scene (if previous available)
      // and deactivating the last one
      if (this.getDepth() > 1) {
        this.activateScene(this.scenes[1], data);
      }
  
      // run callback when both activation and deactivation are complete
      this.popActivationComplete(options || {});
    } catch (err) {
      this.setInTransition(false);
      throw err;
    }
  },

  /**
   * Pops the top scene off the stack and shows the scene specified
   * by the 'type' parameter.  All scenes in between are destroyed.
   *
   * @param {string|null} type The declared class name of the scene
   *                           which should be transitioned to. If null,
   *                           the first scene is transitioned to
   * @param {object} data Optional data to pass back to the activate
   *                      method of the previous scene.
   * @param {boolean} options Options to pass, e.g. an onComplete function,
   *                          or 'noTransition': true to not use animations
   */
  popTo: function(type, data, options) {
    var scene;

    for (var i = this.scenes.length - 2, j = 1 ; i > 0; i--, j++) {
      if (type && type === this.scenes[j].getDeclaredClass()) {
        break;
      } else {
        scene = this.scenes.splice(j, 1)[0];
        scene.setStack(null);
        // will call .destruct() for scene
        this.removeChild(this.getChildViews()[i]);
        j--;
      }
    }

    if (this.getDepth() > 1) {
      this.pop(data, options);
      return true;
    }
    return false;
  },

  /**
   * Like popTo(), but scenes are referenced by index instead of name.
   *
   * @param {int} index The index of the scene which should be transitioned
   *                    to. If index is less than 1, nothing happens. If
   *                    index is greater than or equal togetDepth(), the
   *                    first scene is transitioned to.
   * @param {object} data Optional data to pass back to the activate
   *                      method of the previous scene.
   * @param {boolean} options Options to pass, e.g. an onComplete function,
   *                          or 'noTransition': true to not use animations
   */
  popToIndex: function(index, data, options) {
    if (index < 1) {
      return false;
    } else if (index >= this.getDepth()) {
      return this.clearStack(data, options);
    }

    var scene, remaining = index;
    for (var i = this.scenes.length - 2, j = 1 ; i > 0; i--, j++) {
      if (j === remaining) {
        break;
      } else {
        remaining--;
        scene = this.scenes.splice(j, 1)[0];
        scene.setStack(null);
        // will call .destruct() for scene
        this.removeChild(this.getChildViews()[i]);
        j--;
      }
    }

    if (this.getDepth() > 1) {
      this._pop(data, options);
      return true;
    }
    return false;
  },

  /**
   * Removes all scenes from the stack.
   *
   * @param {object} data Optional data to pass back to the activate
   *                      method of the previous scene.
   * @param {boolean} options Options to pass, e.g. an onComplete function,
   *                          or 'noTransition': true to not use animations
   */
  clearStack: function(data, options) {
    var i, scene;
    for (i = 1; i < this.scenes.length; i++) {
      scene = this.scenes.splice(i, 1)[0];
      scene.setStack(null);
    }
    for (i = this.scenes.length - 1; i > 0; i--) {
      this.removeChild(this.getChildViews()[i]);
    }

    if (this.getDepth() > 0) {
      this._pop(data, options);
      return true;
    }
    return false;
  },

  /**
   * Removes a scene from the scene stack. If the index specifies the first
   * scene, it is popped normally. Otherwise, it is marked and later removed
   * the next time it would have been exposed.
   *
   * @param {int} index The index of the scene to remove
   */
  removeScene: function(index) {
    // if scene is already at the top, pop it normally
    if (index === 0) {
      this.pop();
    } else {
      this.scenes[index].setIsPopped(true);
    }
  },

  /**
   * Swap last scene with new scene
   *
   * Push new scene on top of the last scene.
   * Perform a css-based transition. Remove last scene from the view.
   *
   */
  swap : function(scene, options) {
    options = options || {};
    // mark push as a swapping action
    options.onComplete = util.bind(this.swapOnCompleteFunction, this);

    // push
    this.push(scene, options);
  },

  swapOnCompleteFunction : function() {
    var childViews = this.getChildViews();

    this.scenes[1].setStack(null);
    this.deactivateScene(this.scenes[1]);
    // will call .destruct() for scene
    this.removeChild(childViews[childViews.length - 2]);
    this.scenes.splice(1, 1);
  },

  insertScene: function(scene, options) {
    // start activating new scene and deactivating the previous one
    // (if previous available)
    if (this.getDepth() > 0) {
      this.deactivateScene(this.scenes[0]);
    }

    // set up header
    options = options || {};

    var headerChildViews = [];
    var childViews = [];
    if (!this.getDisableHeaders() && scene.useHeader()) {
      var left = scene.getHeaderLeft();
      var right = scene.getHeaderRight();
      var title = scene.getTitle();

      if (left) {
        left.headerAlign = 'left';
        left.owner = left.owner || scene;
        headerChildViews.push(left);
      }
      if (right) {
        right.headerAlign = 'right';
        right.owner = right.owner || scene;
        headerChildViews.push(right);
      }

      childViews.push({
          view: 'PageHeader',
          label: title,
          ref: 'header',
          childViews: headerChildViews
      });
    }
    childViews.push(scene);

    // create css-based transition class
    var transition = options.transition || 'slide';
    var className = 'bt-scene-stack-wrapper ' + transition;

    // create a wrapper for header and scene
    scene.setFlex(1);
    var owner = {};
    var wrapper = this.build({
      boxOrientation: 'vertical',
      className: className,
  //    style: { zIndex: this.scenes.length + 10 },
      childViews: childViews
    }, owner);

    var header = owner.refs ? owner.refs.header : null;
    if (header) {
      scene.setHeader(header);
    }

    // store scene, wrapper, and options
    this.setWrapperVisibility(wrapper, false);
    this.insertChild(wrapper);
    this.scenes.unshift(scene);

    return wrapper;
  },

  setWrapperVisibility: function(wrapper, visible) {
    wrapper.setStyle({visibility: (visible ? 'visible' : 'hidden')});
  },

  pushPrepareComplete: function(scene, wrapper, options) {
    this.activateScene(scene);

    // skip first scene, no transition is going to happen
    if (this.getDepth() > 1 && !options.noTransition) {
      if (!scene.getModal()) {
        this.scenes[1].startTransition('out');
        var childViews = this.getChildViews();
        childViews[childViews.length - 2].addClass('out').removeClass('in');
      }
      scene.startTransition('in');

      // one time animation event handler
      var _this = this;
      wrapper.getNode().addEventListener('webkitAnimationEnd', function() {
        wrapper.getNode().removeEventListener('webkitAnimationEnd', arguments.callee);
        _this.pushTransitionComplete();
        options.onComplete && options.onComplete();
      }, false);

      wrapper.addClass('in');
    } else {
      if (this.getDepth() > 1 && this.getHideInactiveScene()) {
        this.scenes[1].getNode().parentNode.style.visibility = 'hidden';
      }
      this.setInTransition(false);
      options.onComplete && options.onComplete();
    }
  },

  pushTransitionComplete: function() {
    this.scenes[1].endTransition('out');
    this.scenes[0].endTransition('in');

    if (this.getHideInactiveScene()) {
      this.scenes[1].getNode().parentNode.style.visibility = 'hidden';
    }
    var childViews = this.getChildViews();

    childViews[childViews.length - 1].removeClass('in');

    this.setInTransition(false);
  },


  popActivationComplete: function(options) {
    var childViews;
    var noTransition = options.noTransition;

    // start css-based transition for previous scene
    if (this.getDepth() > 1) {
      this.scenes[1].getNode().parentNode.style.visibility = 'visible';
      childViews = this.getChildViews();
      if (!this.scenes[0].getModal() || childViews[childViews.length - 2].hasClass('out')) {
        this.scenes[1].startTransition('in.reverse');

        childViews[childViews.length - 2].removeClass('out');
        if (!noTransition) {
          childViews[childViews.length - 2].addClass('in reverse');
        }
      }
    }

    // start css-based transition for poped scene
    this.scenes[0].startTransition('out.reverse');

    childViews = this.getChildViews();

    if (!noTransition) {
      var wrapper = childViews[childViews.length - 1];

      // one time animation event handler
      var _this = this;
      wrapper.getNode().addEventListener('webkitAnimationEnd', function() {
        wrapper.getNode().removeEventListener('webkitAnimationEnd', arguments.callee);
        _this.popTransitionComplete();
        options.onComplete && options.onComplete();
      }, false);

      wrapper.addClass('out reverse');
    } else {
      this.popTransitionComplete();
      options.onComplete && options.onComplete();
    }
  },

  popTransitionComplete: function() {
    var childViews = this.getChildViews();
    if (this.getDepth() > 1) {
      this.scenes[1].endTransition('in.reverse');

      childViews[childViews.length - 2].removeClass('in').removeClass('reverse');
    }

    this.scenes[0].endTransition('out.reverse');
    this.scenes[0].setStack(null);
    // will call .destruct() for scene
    this.removeChild(childViews[childViews.length - 1]);
    this.scenes.shift();

    this.setInTransition(false);
  }
});


exports.SceneStack = SceneStack;
view.SceneStack = SceneStack;
});

// module: shared/data/sql_builder
// file:   ../../shared/js/data/sql_builder.js
define("shared/data/sql_builder", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
var core = require('bolt/core');
var util = require('bolt/util');

var slice = Array.prototype.slice;

function addSqlGroupBy(builder, sql, params) {
  var groupBy = builder.getGroupBy();
  if (!util.isBlank(groupBy)) {
    sql += ' GROUP BY ' + groupBy;
  }
  return sql;
}

function addSqlLimit(builder, sql, params) {
  var limit = builder.getLimit();
  if (limit) {
    sql += ' LIMIT ?';
    params.push(limit);
  }
  return sql;
}

function addSqlOffset(builder, sql, params) {
  var offset = builder.getOffset();
  if (offset) {
    sql += ' OFFSET ?';
    params.push(offset);
  }
  return sql;
}

function addSqlOrderBy(builder, sql) {
  var orderBy = builder.getOrderBy();
  if (!util.isBlank(orderBy)) {
    sql += ' ORDER BY ' + orderBy;
  }
  return sql;
}

function addSqlWhere(builder, sql, params) {
  var filters = builder._filters;
  if (filters.length) {
    sql += ' WHERE ' + filters.join(' AND ');
    params.push.apply(params, builder._filterParams);
  }
  return sql;
}

function addWriteParam(builder, keys, values, key, value, useRawValue) {
  if (!util.isUndefined(value)) {
    keys.push(key);
    values.push(useRawValue ? value : JSON.stringify(value));
  }
}

function getWriteParams(builder) {
  var keys = [];
  var values = [];
  var params = builder._params;
  var columns = builder._columns;
  var localFields = builder._localFields;
  var key;
  var value;
  var data;
  for (var i = 0, l = columns.length; i < l; ++i) {
    key = columns[i];
    value = params[key];
    if (key === 'data') {
      data = (params.hasOwnProperty('_data')  &&
        util.contains(columns, 'pendingData') ?
        params._data :
        params
      );
      data = util.rejectKeys(
        data,
        ['_data'].concat(columns).concat(localFields)
      );
      addWriteParam(builder, keys, values, key, data);
    } else if (key === 'pendingData') {
      if (params.hasOwnProperty('pendingData')) {
        data = params.pendingData;
      } else {
        data = util.rejectKeys(
          params,
          ['_data'].concat(columns).concat(localFields)
        );
        if (params._data) {
          var temp = data;
          data = {};
          util.each(temp, function(v, k) {
            if (!util.isEqual(v, params._data[k])) {
              data[k] = v;
            }
          });
        }
      }
      addWriteParam(builder, keys, values, key, data);
    } else if (key === 'localData') {
      data = (
        params.hasOwnProperty('localData') ?
        params.localData :
        util.filterKeys(params, localFields)
      );
      addWriteParam(builder, keys, values, key, data);
    } else {
      addWriteParam(builder, keys, values, key, value, true);
    }
  }
  return {
    keys: keys,
    values: values
  };
}

/**
 * SqlBuilder
 *
 * Constructs a SQL statement from the specified parameters.  This is intended
 * to simplify construction of SQL statements that are conditioned on optional
 * parameters.
 *
 *
 * General patterns are:
 *
 * Select full object:
 * var builder = new SqlBuilder(
 *   'my_table',                      // the name of the table to query
 *   ['id', 'col1', 'col2', 'data'],  // the columns you want to return
 *   {id: 314}                        // filter on the 'id' column
 * ).addAllParamFilters();            // add the filters from the params (the
 *                                    // 'id' value)
 * tx.executeSql.apply(tx, builder.getSelectArguments()).then(...
 *                                    // must use 'apply' to expand the array
 *
 *
 * Select multiple ids:
 * var builder = new SqlBuilder(
 *   'my_table',                      // the name of the table to query
 *   ['id'],                          // only return the id column
 *   {col1: 'foo'},                   // filter on the 'col1' column
 *   {limit: this.DEFAULT_LIMIT, orderBy: this.DEFAULT_ORDER_BY},
 *                                    // default args (for the class)
 *   {limit: 10, offset: 30}          // args that are typically passed into the
 *                                    // current function
 * )
 *   .addAllParamFilters();           // add the filters from the params (the
 *                                    // 'col1' value)
 * tx.executeSql.apply(tx, builder.getSelectArguments()).then(...
 *                                    // must use 'apply' to expand the array
 *
 *
 * Update an object:
 * var builder = new SqlBuilder(
 *   'my_table',                      // the name of the table to update
 *   ['id', 'col1', 'data'],          // the columns you want to write (this
 *                                    // does NOT need to include all)
 *   {id: 315, col1: 'foo', data: '{"baz": [1, 2], parent_id: 314}'}
 *                                    // the data to write (mapped to the
 *                                    // columns)
 * ).addParamFilter('id');            // make sure we filter on the 'id'
 *                                    // parameter
 * tx.executeSql.apply(tx, builder.getUpdateArguments()).then(...
 *                                    // must use 'apply to expand the array
 *
 *
 * Insert an object:
 * var builder = new SqlBuilder(
 *   'my_table',                      // the name of the table to insert into
 *   ['id', 'col1', 'col2', 'data'],  // the columns you want to write
 *   {id: 316, col1: 'foo', col2: 'bar', data: '{"baz": [1, 2]}'}
 *                                    // the data to write (mapped to the
 *                                    // columns)
 * );                                 // no filters for an insert
 * tx.executeSql.apply(tx, builder.getInsertArguments(true)).then(...
 *                                    // pass true to do INSERT OR REPLACE
 */
exports.SqlBuilder = core.createClass({
  name: 'SqlBuilder',

  /**
   * Constructs the SqlBuilder
   * @param table {String} The name of the table that will be queried
   * @param columns {Array} The table columns used in the query
   * @param params {Object} The parameters to filter the query on (to build up
   *   the WHERE statement)
   * @param args {Object} The non-column arguments to filter on (see setArgs)
   * @param overrideArgs {Object} An additional args object passed to setArgs
   *   (you can pass defaults as args and per-instance args here)
   * @param localFields {Array} The fields that will be split to the localData
   *   column in the database (pass null if no localData column is used)
   */
  construct: function(table, columns, params, args, overrideArgs, localFields) {
    this.setTable(table);
    this._columns = columns;
    this._params = params;
    this._filters = [];
    this._filterParams = [];
    this._localFields = localFields;
    this.setArgs(args);
    this.setArgs(overrideArgs);
  },

  properties: {
    groupBy: null,
    limit: 0,
    offset: 0,
    orderBy: null,
    table: null
  },

  /**
   * Adds filters for all params that were passed into the ctor
   * @return this
   */
  addAllParamFilters: function() {
    var params = this._params;
    if (params) {
      var keys = util.keys(params);
      for (var i = 0, l = keys.length; i < l; ++i) {
        this.addParamFilter(keys[i]);
      }
    }
    return this;
  },

  /**
   * Adds a timestamp exclusion range filter
   * @param min The minimum timestamp to exclude (this value will be included in
   *   the query)
   * @param max The maximum timestamp to exclude (this value will be included in
   *   the query)
   * @return this
   */
  addExcludeTimestampFilters: function(min, max) {
    if (!util.isBlank(min) && !util.isBlank(max)) {
      this.addFilterGroup('OR', ['timestamp<?', 'timestamp>?'], [min, max]);
    }
    return this;
  },

  /**
   * Adds a single filter
   * @param filter The SQL fragment for the filter (should NOT contain 'AND' or
   *   'OR' at the end)
   * @param values Any number of values associated to this filter.  These should
   *   be passed individually, not as an array, to addFilter, and will be pushed
   *   onto _filterParams.
   * @return this
   */
  addFilter: function(filter, values) {
    this._filters.push(filter);
    if (arguments.length > 1) {
      var filterParams = this._filterParams;
      filterParams.push.apply(filterParams, slice.call(arguments, 1));
    }
    return this;
  },

  /**
   * Adds a group of filters with the specified operator
   * @param operator 'AND' or 'OR'
   * @param filters An array of filters to process
   * @param values An array of values for the filters (must match length)
   * @return this
   */
  addFilterGroup: function(operator, filters, values) {
    if (filters.length != values.length) {
      throw 'SqlBuilder.addFilterGroup requires equal length filter and ' +
        'value arrays!';
    }
    for (var i = 0, l = filters.length; i < l; ++i) {
      if (util.isBlank(values[i])) {
        filters.splice(i, 1);
        values.splice(i, 1);
        i--;
        l--;
      }
    }
    switch (filters.length) {
      case 0:
        break;
      case 1:
        this.addFilter(filters[0], values[0]);
        break;
      default:
        var filter = '(' + filters.join(' ' + (operator || 'AND') + ' ') + ')';
        this.addFilter.apply(this, [filter].concat(values));
        break;
    }
    return this;
  },

  /**
   * Conditionally adds a single filter
   * @param condition A condition to check, adding the filter if truthy
   * @param filter The SQL fragment for the filter
   * @param values Any number of values associated to this filter (see
   *   addFilter)
   * @return this
   */
  addFilterIf: function(condition, filter, values) {
    if (condition) {
      this.addFilter.apply(this, slice.call(arguments, 1));
    }
    return this;
  },

  /**
   * Adds a filter for all objects with a column value in the specified set
   * (this evaluates to "column_name IN (value1, value2, ...)")
   *
   * @param column {String} The name of the column
   * @param values {Array} The set of values to match
   */
  addInFilter: function(column, values) {
    if (!util.isEmpty(values)) {
      var filter = column + ' IN (' +
        values.map(function(v) { return '?'; }).join(',') + ')';
      this.addFilter.apply(this, [filter].concat(values));
    }
    return this;
  },

  /**
   * Adds a filter for the param with the specified key against the value in the
   * params object passed into the ctor.
   * @param key The key to pull the param from (must match a column name in the
   *   table)
   * @param checkNull If true and the param value is null will add an IS NULL
   *   check
   * @return this
   */
  addParamFilter: function(key, checkNull) {
    var params = this._params;
    if (params) {
      var value = params[key];
      var isBlank = util.isBlank(value);
      if (checkNull && isBlank) {
        this.addFilter(key + ' IS NULL');
      } else if (!isBlank) {
        this.addFilter(key + '=?', value);
      }
    }
    return this;
  },

  /**
   * Adds a timestamp range filter
   * @param min The minimum timestamp to include (this value will NOT be
   *   included in the query)
   * @param max The maximum timestamp to include (this value will NOT be
   *   included in the query)
   * @return this
   */
  addTimestampFilters: function(min, max) {
    this.addFilterIf(min, 'timestamp>?', min);
    this.addFilterIf(max, 'timestamp<?', max);
    return this;
  },

  /**
   * Gets the arguments for executeSql for a DELETE statement
   * @return An array with [sql, params] that can be passed to executeSql
   */
  getDeleteArguments: function() {
    if (this._staticDelete) {
      return this._staticDelete;
    }
    var sql = 'DELETE FROM ' + this.getTable();
    var params = [];
    sql = addSqlWhere(this, sql, params);
    sql = addSqlOrderBy(this, sql);
    sql = addSqlLimit(this, sql, params);
    sql = addSqlOffset(this, sql, params);
    return [sql, params];
  },

  /**
   * Gets the arguments for executeSql for an INSERT statement
   * @param replace If truthy use INSERT OR REPLACE
   * @return An array with [sql, params] that can be passed to executeSql
   */
  getInsertArguments: function(replace) {
    if (this._staticInsert) {
      return this._staticInsert;
    }
    var writeParams = getWriteParams(this);
    var sql = 'INSERT ';
    if (replace) {
      sql += 'OR REPLACE ';
    }
    sql += 'INTO ' + this.getTable() +
      ' (' + writeParams.keys.join(',') + ') VALUES (' +
      writeParams.keys.map(function(){ return '?'; }).join(',') + ')';
    return [sql, writeParams.values];
  },

  /**
   * Gets the arguments for executeSql for a SELECT statement
   * @return An array with [sql, params] that can be passed to executeSql
   */
  getSelectArguments: function() {
    if (this._staticSelect) {
      return this._staticSelect;
    }
    var sql = 'SELECT ' + (this._columns || ['*']).join(',') +
      ' FROM ' + this.getTable();
    var params = [];
    sql = addSqlWhere(this, sql, params);
    sql = addSqlGroupBy(this, sql);
    sql = addSqlOrderBy(this, sql);
    sql = addSqlLimit(this, sql, params);
    sql = addSqlOffset(this, sql, params);
    return [sql, params];
  },

  /**
   * Gets the arguments for executeSql for an UPDATE statement
   * @return An array with [sql, params] that can be passed to executeSql
   */
  getUpdateArguments: function() {
    if (this._staticUpdate) {
      return this._staticUpdate;
    }
    var writeParams = getWriteParams(this);
    var sql = 'UPDATE ' + this.getTable() +
      ' SET ' + writeParams.keys.join('=?,') + '=?';
    var params = writeParams.values;
    sql = addSqlWhere(this, sql, params);
    sql = addSqlOrderBy(this, sql);
    sql = addSqlLimit(this, sql, params);
    sql = addSqlOffset(this, sql, params);
    return [sql, params];
  },

  /**
   * Sets the non-column arguments to filter on
   * @param args The arguments to check
   *   args.groupBy Adds a GROUP BY ? filter to the query with the specified
   *     value
   *   args.orderBy Adds an ORDER BY ? filter to the query with the specified
   *     value
   *   args.limit Adds a LIMIT ? filter to the query with the specified value
   *   args.offset Adds an OFFSET ? filter to the query with the specified value
   *   args.minTimestamp Adds a minimum timestamp filter (see
   *     addTimestampFilters)
   *   args.maxTimestamp Adds a maximum timestamp filter (see
   *     addTimestampFilters)
   *   args.minExcludeTimestamp Adds a minimum exclude timestamp filter (see
   *     addExcludeTimestampFilters)
   *   args.maxExcludeTimestamp Adds a maximum exclude timestamp filter (see
   *     addExcludeTimestampFilters)
   * @return this
   */
  setArgs: function(args) {
    if (args) {
      if (!util.isUndefined(args.groupBy)) this.setGroupBy(args.groupBy);
      if (!util.isUndefined(args.orderBy)) this.setOrderBy(args.orderBy);
      if (!util.isUndefined(args.limit)) this.setLimit(args.limit);
      if (!util.isUndefined(args.offset)) this.setOffset(args.offset);
      this.addTimestampFilters(args.minTimestamp, args.maxTimestamp);
      this.addExcludeTimestampFilters(
        args.minExcludeTimestamp,
        args.maxExcludeTimestamp
      );
      if (!util.isUndefined(args.flags)) {
        this.addFilter('(flags & ' + args.flags + ') = ?', args.flags);
      }
      if (!util.isUndefined(args.filters)) {
        var filter;
        for (var i = 0, l = args.filters.length; i < l; ++i) {
          filter = args.filters[i];
          if (util.isString(filter)) {
            this.addFilter(filter);
          } else if (util.isArray(filter)) {
            this.addFilter.apply(this, filter);
          }
        }
      }
    }
    return this;
  },

  setTableColumns: function(columns) {
    this._columns = columns;
  },

  /**
   * Sets a static set of arguments for a DELETE statement
   */
  setDeleteArguments: function(sql, params) {
    this._staticDelete = [sql, params];
    return this;
  },

  /**
   * Sets a static set of arguments for a INSERT statement
   */
  setInsertArguments: function(sql, params) {
    this._staticInsert = [sql, params];
    return this;
  },

  /**
   * Sets a static set of arguments for a SELECT statement
   */
  setSelectArguments: function(sql, params) {
    this._staticSelect = [sql, params];
    return this;
  },

  /**
   * Sets a static set of arguments for a UPDATE statement
   */
  setUpdateArguments: function(sql, params) {
    this._staticUpdate = [sql, params];
    return this;
  }
});
});

// module: view/messages_scene/messages_scene
// file:   view/messages_scene/messages_scene.js
define("view/messages_scene/messages_scene", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core   = require('bolt/core');
var util = require('bolt/util');

var Scene  = require('bolt_touch/views/scene').Scene;
var ActionableView = require('bolt_touch/views/actionable_view').ActionableView;
var Dialog = require('shared/boltwidget/dialog').Dialog;
var Filter = require('shared/data2/store/filter').Filter;

var EventManager            = require('shared/event_manager').EventManager;
var sharedUtil              = require('shared/util');
var session                 = require('shared/session');
var MessageList             =
  require('view/message_list/message_list').MessageList;
var Composer                = require('view/composer/composer').Composer;
var ClientMessage =
  require('talk/client/model/message/client_message').ClientMessage;
var threadContactsUtil =
  require('talk/client/model/thread/thread_contacts_util');
var threadChangesClient     = require('talk/client/thread_changes_client');
var sendMessageClient       = require('talk/client/send_message_client');
var telephonyApi            = FBAPI.use('telephony');
var MultiAvatar             = require('views/multiavatar').MultiAvatar;
var MessagesSceneMenu = require('./messages_scene_menu').MessagesSceneMenu;

var logger  = require('shared/logger').logger;


var baseClass = 'bt-messages-scene--';

exports.MessagesScene = core.createClass({
  name: 'MessagesScene',
  extend: Scene,

  delegateProperties: {
    'list': ['collection']
  },

  properties: {
    thread: null,
    controller: null,
    selectionCommand: null
  },

  construct: function() {
    this._perfTimeline = [];
    this._constructTime = Date.now();
    this._dataTimer =
      logger.startTimer('talk.readView.ready', logger.ALLOW_OVERLAPPING);

    Scene.apply(this, arguments);
  },

  declare: function(options) {
    return {
      onsend: this._onSend,
      oncall: this._onCall,
      onattachment: this._onAttachment,
      childViews: [
        {
          boxOrientation: 'vertical',
          className: baseClass + 'header',
          childViews: [
            {
              className: baseClass + 'image',
              ref: 'profileHeaderImage',
              view: ActionableView,
              action: '_onmenu'
            },
            {
              className: 'bt-bar headerButtons',
              boxOrientation: 'horizontal',
              childViews: [
                {
                  className: 'bt-bar-button left bt-back-button',
                  owner: this,
                  view: ActionableView,
                  action: '_onback',
                  ref: 'backButton'
                },
                {
                  owner: this,
                  ref: 'settingsButton',
                  className: 'bt-bar-button right bt-ellipsis-button',
                  view: ActionableView,
                  action: '_onsettings'
                }
              ]
            },
            {
              className: baseClass + 'contact-info',
              ref: 'contactInfo',
              childViews: [
                {
                  ref: 'title',
                  className: baseClass + 'contact-name',
                  content: 'Thread'
                },
                {
                  ref: 'subtitle',
                  className: baseClass + 'contact-location',
                  context: 'Thread',
                  boxOrientation: 'horizontal',
                  childViews: [
                    {
                      ref: 'subtitleIcon',
                      className: baseClass + 'contact-location-icon'
                    },
                    {
                      ref: 'subtitleText',
                      className: baseClass + 'contact-location-text',
                      flex: 1
                    }
                  ]
                }
              ]
            },
            {
              ref: 'contactMenu',
              view: MessagesSceneMenu,
              onselectinfo: '_onSelectInfo',
              onselectcall: '_onSelectCall',
              onselecttimeline: '_onSelectTimeline'
            }
          ]
        },
        {
          view: MessageList,
          className: baseClass + 'list',
          onselection: '_onselection',
          ref: 'list'
        },
        {
          view: Composer,
          className: baseClass + 'composer',
          ref: 'composer'
        },
        {
          content: 'You cannot send/receive messages to this thread yet, ' +
                   'because we do not have metainformation ' +
                   'about it stored in titan. Reopening the thread ' +
                   'could help :)',
          className: baseClass + 'composer-placeholder',
          ref: 'composer_disabled'
        }
      ]
    };
  },

  ready: function() {
    EventManager.addListener(
      'store.ThreadStore.store.update_ids',
      this._onUpdateIds,
      this);
    this.adjustButtons();
    this._perfTimeline.push(['scene ready', Date.now()]);
  },

  destroy: function() {
    Scene.prototype.destroy.call(this);
    EventManager.removeListener(
      'store.ThreadStore.store.update_ids',
      this._onUpdateIds,
      this);
  },

  activate: function() {
    this.setSceneLink();
    this._perfTimeline.push(['scene activated', Date.now()]);
  },

  setSceneLink: function() {
    var thread = this.getThread();
    if (thread) {
      this.getController()
        .setSceneLink({scene: 'messages', tid: thread.getId()});
    }
  },

  startSelection: function(selectionCommand) {
    this.findRef('list').setSelectable(true);
    this.set('selectionCommand', selectionCommand);
    this.adjustButtons();
    this.findRef('composer').hide();
  },

  finishSelection: function(action) {
    var msgs = [];
    if (this.getCollection()) {
      this.getCollection().forEach(function(m) {
        if (m.get('selected')) {
          msgs.unshift(m);
          m.set('selected', false);
        }
      });
    }
    if (action) {
      var result = action(msgs);
      if (result) {
        result.addCallback(this._updateAfterFinishSelection, this);
        return;
      }
    }
    this._updateAfterFinishSelection();
  },

  _updateAfterFinishSelection: function() {
    this.set('selectionCommand', null);
    this.findRef('list').setSelectable(false);
    this.findRef('composer').show();
    this.adjustButtons();
  },

  adjustButtons: function() {
    if (this.getSelectionCommand()) {
      this.findRef('settingsButton').hide();
      this.findRef('backButton').hide();
    } else {
      this.findRef('settingsButton').show();
      this.findRef('backButton').show();
    }
  },

  setThread: function(thread) {
    this.set('thread', thread);
    if (thread.get('participantsHash') == 'N/A') {
      this.findRef('composer').hide();
      this.findRef('composer_disabled').show();
    } else {
      this.findRef('composer').show();
      this.findRef('composer_disabled').hide();
    }
    this.setSceneLink();

    //TODO: use large image url from contacts
    var participants = thread.participantsForAvatar();
    if (participants.length > 0 && participants[0].user_id) {
      this.findRef('profileHeaderImage').setStyle('backgroundImage',
        'url(http://graph.facebook.com/' +
        participants[0].user_id + '/picture?type=large)');
    }
    this.findRef('title').setContent(thread.getTitle());
    //TODO: use real data
    this.findRef('subtitleIcon').setStyle('backgroundImage',
      'url(' + thread.getSubtitleIcon() + ')');
    this.findRef('subtitleText').setContent(thread.getSubtitle());

    if (!this.getThread().hasSubscribedParticipant(session.getUid())) {
      this.findRef('composer').hide();
    } else if (thread.get('localData')) {
      this.refs.composer.setDraftMessage(thread.get('localData').draftMessage);
    }

    var messageClient = require('talk/client/message_client').getInstance();
    messageClient.fetchLastMessages(this.getThread().getId(), 20)
      .addCallback(function(collection) {
        this._perfTimeline.push(['message collection', Date.now()]);
        this._handleThreadLoad(collection);
      }, this);

    return this;
  },

  /**
   * Handle the loading of a thread.
   *
   * @param collection {Collection} A Collection of Thread objects
   */
  _handleThreadLoad: function(collection) {
    var thread = this.getThread();

    if (window.__PERF_LOGGING__) {
      this._startPerfLogging(collection);
    }
    this.findRef('list').addListener('dataDisplayed', function() {
      // data isn't actually displayed until all synchronous things finish
      setTimeout(util.bind(this._dataIsDisplayed, this), 1);
    }, this);

    this.findRef('list')
      .setThread(thread)
      .setCollection(collection);

    if (this._removeIfEmpty()) {
      return;
    }

    // wait for the relationships loading first
    setTimeout(util.bind(this._markThreadAsRead, this, thread), 500);
  },

  _markThreadAsRead: function(thread) {
    if (thread.isUnread()) {
      threadChangesClient.getInstance().markAsRead(thread.getId(), true);
    }
    threadChangesClient.getInstance().uploadChanges(thread.getId());
  },

  _onUpdateIds: function(event) {
    var thread = this.getThread();
    var newId = thread && event.data.updates[thread.getId()];
    if (newId) {
      var threadClient = require('talk/client/thread_client').getInstance();

      this.removeChild(this.findRef('list'));

      var children = this.getChildViews();
      var position;
      for (var i = 0; i < children.length; i++) {
        if (children[i] === this.findRef('composer')) {
          position = i;
          break;
        }
      }

      this.insertChild(this.build({
        flex: 1,
        view: MessageList,
        className: 'talkMessagesScene-list',
        ref: 'list'
      }), position);

      threadClient
        .fetchThreadSnapshot(newId)
        .addCallback(this.setThread, this);
    }
  },

  _startPerfLogging: function(collection) {
    var logStuff = function(e) {
      if (e.type === 'endUpdate') {
        collection.removeListener('all', logStuff, this);
        this._perfTimeline.push(['message data', this._threadEventTimer]);
      } else if (!this._threadEventTimer) {
        if (collection.length > 0) {
          this._threadEventTimer = Date.now();
        }
      }
    };
    collection.addListener('all', logStuff, this);
  },

  _dataIsDisplayed: function() {
    if (this._dataDisplayed) {
      return;
    }
    this.dataDisplayed = true;
    logger.endTimer(this._dataTimer);
    if (window.__PERF_LOGGING__) {
      this._displayPerfLogging();
    }
  },

  _displayPerfLogging: function() {
    this._perfTimeline.push(['done', Date.now()]);

    var text = [];
    this._printPerfTimeline(text);
    this._printPerfTimers(text);
    var info = this.build({
      tagName: 'div',
      style: {
        position: 'fixed',
        top: '0px',
        left: '100px',
        width: '340px',
        zIndex: '999999',
        backgroundColor: 'white',
        padding: '5px'
      },
      childViews: text.map(function(line) {
        var view = {
          tagName: 'div',

          style: {
            fontSize: '14px',
            lineHeight: '16px'
          },
          content: line
        };
        for (var i = 0; line[i] === ' '; i++) {
          view.style.marginLeft = (i + 1) * 5 + 'px';
        }
        return view;
      })
    });
    info.placeIn(this.getNode());
    text.forEach(function(line) {
      console.info(line);
    });
  },

  _printPerfTimeline: function(arr) {
    arr.push('perf timeline');
    this._perfTimeline.forEach(function(entry) {
      var name = entry[0];
      var time = entry[1];
      arr.push('  ' + name + ': ' + (time - this._constructTime));
    }, this);
  },

  _printPerfTimers: function(arr) {
    arr.push('perf timers');
    var perfTimers = this.findRef('list').getPerfTimers();
    util.each(perfTimers, function(time, name) {
      arr.push('  ' + name + ': ' + time);
    });
  },

  _onSelectCall: function() {
    var thread = this.getThread();
    threadContactsUtil.getThreadPhoneNumbers(thread).addCallback(
      function(allPhones) {
        var controller = this.getController();
        if (allPhones.length === 0) {
          controller.openDialer();
        } else if ((allPhones.length === 1) && (this.getThread().is1to1())) {
          sharedUtil.makeCall(
            allPhones[0].phone,
            JSON.stringify({profile: {name: allPhones[0].name}})
          );
        } else {
          controller.openThreadPhoneNumbersScene(allPhones);
        }
      }, this);
  },

  _onSelectInfo: function() {
    // TODO: Pop up infocard
  },

  _onSelectTimeline: function() {
    // TODO
  },

  _onmenu: function(event) {
    this.findRef('contactInfo').toggleClass("hide");
    this.findRef('contactMenu').toggle();
  },

  _onSend: function(e) {
    var attachment = this.refs.composer.getAttachment();

    var messageData = {
      body:        e.data.text,
      forwards:    null,
      coordinates: e.data.coords,
      attachment:  attachment
    };
    this.refs.composer.clear();
    sendMessageClient.getInstance().sendToThread(this.getThread(), messageData);
    this.refs.list.minimizeRefreshInterval();
    this.getController().tryDismissAfterAction();
  },

  _onAttachment: function(e) {
    this.getController().openAttachment(e.data.message, e.data.attachment);
  },

  _onsettings: function() {
    if (this._actionSheet && this._actionSheet._visible) {
      this._actionSheet.hide();
      return;
    }
    var ThreadActionsView = require('../thread_actions').ThreadActionsView;
    this.refs.composer.blur();
    this._actionSheet = this.build({
      view: ThreadActionsView,
      hasScrim: true,
      destroyOnHide: true,
      model: this.getThread(),
      controller: this.getController()
    });
    this._actionSheet.show(this);
  },

  _onselection: function(e) {
    var message =  this.findRef('list').getModelAt(e.data.index);
    if (!(message instanceof ClientMessage)) {
      return;
    }
    if (message.hasError()) {
      var thread = this.getThread();
      var _this = this;
      var dialog;

      if (telephonyApi.isAirplaneModeEnabled()) {
        dialog = this.build({
          view: 'Dialog',
          title: "Can't retry",
          body: "You cannot send messages while in airplane mode. " +
            "Would you like to turn it off to retry?",
          actions: [
            {
              value: 'Yes',
              action: function() {
                telephonyApi.setIsAirplaneModeEnabled(false);
                dialog.dismiss();
              }
            },
            {
              value: 'Discard Message',
              action: function() {
                var messageClient =
                  require('talk/client/message_client').getInstance();
                messageClient.remove([message.getId()]);
                _this._removeIfEmpty();
                dialog.dismiss();
              }
            },
            {
              value: 'Cancel',
              action: 'dismiss'
            }
          ]
        });
      } else {
        dialog = this.build({
          view: 'Dialog',
          title: "Failed message",
          body: "Do you want to retry sending this message?",
          actions: [
            {
              value: 'Retry',
              action: function() {
                sendMessageClient.getInstance()
                  .sendToThread(thread, message);
                dialog.dismiss();
              }
            },
            {
              value: 'Discard Message',
              action: function() {
                var messageClient =
                  require('talk/client/message_client').getInstance();
                messageClient.remove([message.getId()]);
                _this._removeIfEmpty();
                dialog.dismiss();
              }
            },
            {
              value: 'Cancel',
              action: 'dismiss'
            }
          ]
        });
      }

      dialog.show();
    }
  },

  _removeIfEmpty: function() {
    if (this.getThread().isLocal() && !this.getCollection().length) {
      var threadClient = require('talk/client/message_client').getInstance();
      threadClient.remove([this.getThread().getId()]);
      this._onback();
      return true;
    }
    return false;
  },

  _onback: function() {
    this.getThread().get('localData').draftMessage =
      this.refs.composer.getDraftMessage();
    this.getController().backToThreads(this.getThread().getMailbox());
  }
});
});

// module: shared/util
// file:   ../../shared/js/util.js
define("shared/util", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var util = require('bolt/util');
var dialogUtil = require('./dialogs');
var uriUtil = require('./uri_util');
var dateUtil = require('./date_util');
var Text = require('./text');
var pinUtil = require('shared/simpin/pin_util');

var Deferred = require('shared/deferred').Deferred;

util.extend(exports, uriUtil);
util.extend(exports, dateUtil);

// this function is way up here because requiring shared/incall
// ends up requiring shared/util through some dependency, but
// the only function it needs in shared/util is isBuffyDevice,
// so declaring it here makes everything work.
exports.isBuffyDevice = function () {
  return (!!navigator.appVersion.match(/BFF/)) &&
    (!!navigator.appVersion.match(/Linux/));
};

// Not ready to be initialized on the first require, let's do only when needed
var phoneApi = null;

/**
 * Fix for links until we have native implementation of _blank target
 * TODO: remove this once we have _blank implemented
 */
var global = this;
global.addEventListener && global.addEventListener('click', function(event) {
  var target = event.target;
  if (target.tagName === 'A' && target.getAttribute('target') === '_blank') {
    //Stop right there, criminal scum!
    event.preventDefault();
    global.openUrl(target.href);
  }
}, true);

/**
 * Open a user's profile
 */
exports.openProfile = function(id) {
  window.openProfile(id);
};

/**
 * Open an FB object in a new window
 */
exports.openFBObject = function(id, type) {
  var url;
  switch (type) {
    case 'user':
      exports.openProfile(id);
      break;
    case 'page':
      url = 'https://m.facebook.com/profile.php?id=' + id;
      window.openUrl(url);
      break;
    case 'group':
      url = 'https://m.facebook.com/groups/' + id;
      window.openUrl(url);
      break;
    default:
      console.error('unrecognized fb object type: ', type, id);
      break;
  }
};

/**
 * Make a phone call to a specific number
 */
exports.makeCall = function(number, peerContext, isEmergency) {
  phoneApi = phoneApi || FBAPI.use('phone');
  function dial() {
    var callStatus = phoneApi.makeCall(number, peerContext, isEmergency);
    if (callStatus == phoneApi.CALL_DIALED) {
      // show the in-call screen
      var glitter = FBAPI.use('glitter');
      if (glitter) {
        glitter.sendSystemMessage('incall.SHOW',
          JSON.stringify({show: 'show'}));
      }
    }

    // display error messages
    switch (callStatus) {
      case phoneApi.CALL_FAILED_POWER_OFF:
        dialogUtil.showSpecialDialog(dialogUtil.TYPE_DISABLE_AIRPLANE_MODE, {
          number: number
        });
        break;

      case phoneApi.CALL_FAILED_OUT_OF_SERVICE:
        var id = dialogUtil.createDialog();
        dialogUtil.appendTitle(id, 'Call Failed');
        dialogUtil.appendText(id, 'No service');
        dialogUtil.showModalDialog(id);
        break;

      case phoneApi.CALL_FAILED_INVALID_PHONE_NUMBER:
        var id = dialogUtil.createDialog();
        dialogUtil.appendTitle(id, 'Call Failed');
        dialogUtil.appendText(id, 'Invalid phone number');
        dialogUtil.showModalDialog(id);
        break;

      case phoneApi.CALL_FAILED_INVALID_VOICEMAIL_NUMBER:
        dialogUtil.showSpecialDialog(dialogUtil.TYPE_INVALID_VOICEMAIL, {});
        break;

      case phoneApi.CALL_FAILED_EMERGENCY_CALLS_ONLY:
        var id = dialogUtil.createDialog();
        dialogUtil.appendTitle(id, 'Call Failed');
        dialogUtil.appendText(id, 'Emergency calls only');
        dialogUtil.showModalDialog(id);
        break;

      case phoneApi.CALL_FAILED:
        var id = dialogUtil.createDialog();
        dialogUtil.appendTitle(id, 'Call Failed');
        dialogUtil.appendText(id, 'The call failed for an unknown reason');
        dialogUtil.showModalDialog(id);
        break;

      case phoneApi.CALL_DIALED_MMI:
        dialogUtil.showSpecialDialog(dialogUtil.TYPE_CALL_MMI);
        break;

      default:
    }

    return callStatus;
  }
  if (isEmergency || phoneApi.isEmergencyPhoneNumber(number)) {
    var def = new Deferred();
    def.succeed();
    return def.then(dial);
  } else {
    return pinUtil.verifySimUnlocked('make calls').then(dial);
  }
};

/**
 * Shorten a string to a max length of a certain number of characters
 */
exports.shorten = function(str, size) {
  return (str.length <= size) ? str :
    (str.substring(0, size-3).trim() + "...");
};

/**
 * Decode an encoded URL.
 */
exports.urldecode = function(str) {
  return unescape(str.replace(/\+/g, " "));
};

/**
 * String starts with
 */
exports.stringStartsWith = function(str1, str2) {
  return str1.substring(0, str2.length) === str2;
};

/**
 * String ends with
 */
exports.stringEndsWith = function(str, needle) {
  if (str.length < needle.length) {
    return false;
  }

  return str.substring(str.length - needle.length) === needle;
};

var UTFDelimiters = '\\u0020|\\u0009|\\u000a|\\u000b|\\u000c|\\u000d|\\u00a0' +
  '|\\u1680|\\u180e|\\u2000|\\u2001|\\u2002|\\u2003|\\u2004|\\u2005|\\u2006|' +
  '\\u2007|\\u2008|\\u2009|\\u200a|\\u2028|\\u2029|\\u202f|\\u205f|\\u3000';
/**
 * UTF-aware function to replace \b in regular expressions
 */
exports.matchWordStartUTF = function(subject, pattern, prepend, append) {
  var regex = new RegExp('(^|' + UTFDelimiters + '])(' +
      exports.escapeRegEx(pattern) + ')', 'gi');
  if (prepend && append) {
    if (subject.match(regex)) {
      return subject.replace(regex, '$1' + prepend + '$2' + append);
    } else {
      return null;
    }
  } else {
    return subject.match(regex);
  }
};
exports.wordBoundariesRegexUTF = new RegExp('([' + UTFDelimiters + '])', 'i');


// This regexp is a list of all possible UTF alphanumeric characters
// Taken from http://stackoverflow.com/questions/2344587/how-can-i-know-in-javascript-if-character-is-part-of-alphabet-not-just-english-a/2345367#2345367
exports.getAlnumRegexUTF = /[A-Z0-9\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0523\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0621-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971\u0972\u097B-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D28\u0D2A-\u0D39\u0D3D\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC\u0EDD\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8B\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10D0-\u10FA\u10FC\u1100-\u1159\u115F-\u11A2\u11A8-\u11F9\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u1676\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19A9\u19C1-\u19C7\u1A00-\u1A16\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u2094\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2C6F\u2C71-\u2C7D\u2C80-\u2CE4\u2D00-\u2D25\u2D30-\u2D65\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31B7\u31F0-\u31FF\u3400\u4DB5\u4E00\u9FC3\uA000-\uA48C\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA65F\uA662-\uA66E\uA67F-\uA697\uA717-\uA71F\uA722-\uA788\uA78B\uA78C\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA90A-\uA925\uA930-\uA946\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAC00\uD7A3\uF900-\uFA2D\uFA30-\uFA6A\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/i;

/**
 * Return all key attributes from the set of items in obj.
 */
exports.pluck = function(obj, key) {
  return util.map(obj, function(value){
    return value[key];
  });
};

/**
 * Truncate text to a maximum length. Does not respect word or sentence breaks,
 * so know what you're getting into.
 * @param text The text to truncate
 * @param maxLength The length to truncate it to
 */
exports.truncate = function(text, length) {
  if (text && text.length > length) {
    return text.substr(0, length) + '\u2026';
  } else {
    return text;
  }
};

exports.autogrow = function (element, maxrows) {
  var nodestyle = getComputedStyle(element.getNode());
  var lineHeight = parseInt(nodestyle.lineHeight, 10);
  /* textarea's size is real size + paddings
   * If we skip padding, then it will not grow correct with padding different from 0
   */
  var hPadding = parseInt(nodestyle.paddingLeft, 10) + parseInt(nodestyle.paddingRight, 10);
  var vPadding = parseInt(nodestyle.paddingTop, 10) + parseInt(nodestyle.paddingBottom, 10);

  var shadow = element.build({
    tagName: 'pre',
    additionalClasses: 'bt-autogrow-shadow-div',
    style: {
      width: nodestyle.width,
      fontSize: nodestyle.fontSize,
      fontFamily: nodestyle.fontFamily,
      lineHeight: nodestyle.lineHeight,
      paddingLeft: nodestyle.paddingLeft,
      paddingTop: nodestyle.paddingTop,
      paddingRight: nodestyle.paddingRight,
      paddingBottom: nodestyle.paddingBottom
    }
  });

  element.getOwner().appendChild(shadow);
  element.addClass("bt-autogrow-textarea");

  function handler(e) {
    /*
     * if text ends with \n, in textarea cursor will be on new empty line
     * but in <pre> we don't have a "cursor" so there will be no empty line
     * to fix it, we can just add a \n at the end of a line.
     * It wont change anything if line is non-empty or will fix our problem if line is empty
     */
    shadow.setContent( element.getNode().value + "\n" );

    var newHeight = Math.min(vPadding + maxrows * lineHeight, shadow.getNode().clientHeight);
    newHeight = Math.max(vPadding + newHeight, lineHeight);

    element.setStyle('height', newHeight + "px");
  }

  element.getNode().addEventListener('keyup', handler);
  element.getNode().addEventListener('change', handler);
  element.getNode().addEventListener('blur', handler);
  handler();
};

var emailPattern = /^[-.\+\w]+@(?:[a-z\d][-a-z\d]+\.)+[a-z]{2,6}$/;
var isEmail = exports.isEmail = function(str) {
  return str && str.match(emailPattern);
};

var isPhone = exports.isPhone = function(str) {
  // isPossiblePhoneNumber correctly doesn't recognize e.g. short codes
  // as possible numbers. It also validates string length and more...
  // Use this function to checks that passed in value really could be a *phone*
  phoneApi = phoneApi || FBAPI.use('phone');
  return str && phoneApi.isPossiblePhoneNumber(str);
};

exports.getE164orRawNumber = function(number) {
  // numbers in database are in E164 format
  // it identifies the number so we can
  // use it for comparing purpose
  phoneApi = phoneApi || FBAPI.use('phone');
  return phoneApi.getE164Format(number) || number;
};

var regexCanBePhone = exports.regexCanBePhone = /^[\+(\-]?\d+/;
exports.isShortCode = function(str) {
  // Short code rules:
  // - Anything less or equal to 8 digits can be considered a shortcode
  // - Anything explicitely started with a plus and greater equal to 8 digits
  //    should be considered a number for an actual device
  // - A 10 digit number without an explicit plus that begins with 111
  //    should be considered a shortcode
  // - we only allow dash as a separator (e.g. 326-65) and optional '+' prefix
  var isShortCode = false;

  if (str && regexCanBePhone.test(str)) {
    var number = str.split('-').join('');
    if (!isNaN(number)) {
      var length = number.length;
      var startWithPlus = (number[0] === '+');

      if (length <= 8 ||
         (length === 10 && !startWithPlus && number.indexOf('111') === 0)) {
        isShortCode = true;
      }
    }
  }

  return isShortCode;
};

exports.isPhoneOrShortCode = function(str) {
  return this.isPhone(str) || this.isShortCode(str);
};

exports.defer = function(fn) {
  // the browser specific timeout for deferring a function call
  // a value of 0 is OK for most browser
  return setTimeout(fn, 15);
};

exports.abstractMethod = function(name) {
  throw(name + ' is used directly. This should not happen.');
};

exports.nop = function() {};

exports.convertDeferredListResult = function (res) {
  if (!res[0]) {
    return []; // or throw an exception
  } else {
    var result = [];
    for (var i = 0; i < res.length; i++) {
      if (1 < res[i].length) {
        result.push(res[i][1]);
      } else {
        result.push(null);
      }
    }
    return result;
  }
};

exports.makeHash = function(array, property) {
  var obj = {};
  for (var i = 0; i < array.length; i++) {
    obj[array[i][property]] = array[i];
  }
  return obj;
};

exports.escapeRegEx = function(str) {
  return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
};

exports.getLength = function(obj) {
  return util.isBlank(obj) ? 0 :
         util.isArray(obj) ? obj.length :
         util.isObject(obj) ? util.keys(obj).length : 0;
};

exports.getParticipantAPIParam = function(participant) {
  var apiParticipant = null;

  if (participant.user_id) {
    apiParticipant = participant.user_id;
  } else if (participant.email) {
    apiParticipant = participant.email;
  } else if (participant.phone) {
    apiParticipant = {
      type: 'phone',
      phone: participant.phone,
      country: participant.phoneCountry || 'US',
      name: participant.name || participant.phone
    };
  } else {
    console.warn('Invalid participant: ' + JSON.stringify(participant));
  }

  return apiParticipant;
};

exports.isLocalStorageDefined = function() {
  return (typeof localStorage !== 'undefined');
};

exports.isTestContext = function() {
  return location.href.indexOf('runTests.html') > -1;
};

var messageCounter = 0;
exports.getMessageContactUrl = function(uid) {
  messageCounter++;
  // We need both counter and UUID because UUID is unique for a given scene,
  // and counter gives us different "rnd" values each time we try to
  // get the URL from same scene
  var url = 'fbcf:///apps/talk/index.html#uid=' + uid + '&rnd=' +
    util.generateUUID() + messageCounter;
  return url;
};


exports.getCanonicalPhoneNumber = function(phoneNumber) {
  var phoneUtil =
    require('third-party/libphonenumber').PhoneNumberUtil.getInstance();
  var parsedNumber = phoneUtil.parse(phoneNumber, 'US');
  if (phoneUtil.isPossibleNumber(parsedNumber) &&
      phoneUtil.isValidNumber(parsedNumber)) {
    return phoneUtil.format(parsedNumber,
                              require('third-party/libphonenumber')
                                .PhoneNumberFormat.INTERNATIONAL);
  } else {
    return phoneNumber;
  }
};
});

// module: view/message_composer_scene/message_composer_scene
// file:   view/message_composer_scene/message_composer_scene.js
define("view/message_composer_scene/message_composer_scene", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

// The MessageComposerScene provides a modal view for composing new Threads

var core              = require('bolt/core');
var sharedUtil        = require('shared/util');
var util              = require('bolt/util');
var Model             = require('bolt/model').Model;
var Collection        = require('bolt/collection').Collection;
var CollectionView    = require('bolt/collection_view').CollectionView;

var Scene             = require('bolt_touch/views/scene').Scene;
var ActionableView    =
  require('bolt_touch/views/actionable_view').ActionableView;
var DataList          = require('bolt_touch/views/data_list').DataList;
var ScrollView        = require('bolt_touch/views/scroll_view_j').ScrollView;

var RecipientCollection = require('./recipient_collection').RecipientCollection;
var RecipientToken    = require('./recipient_token').RecipientToken;

var PickerInput       = require('./picker_input').PickerInput;
var PickerRow         = require('./picker_row').PickerRow;
var ForwardsView      = require('./forwards_view').ForwardsView;
var Composer          = require('view/composer/composer').Composer;
var Dialog            = require('shared/boltwidget/dialog').Dialog;
var pinUtil           = require('shared/simpin/pin_util');
var LocalContactsList =
  require('../../contacts/local_contacts_list').LocalContactsList;
var userUtil          = require('shared/util/user');
var contactUtils      = require('talk/client/model/thread/contacts');
var ContactsFilter = require('lib/contacts_filter').ContactsFilter;

var contactsList;

exports.MessageComposerScene = core.createClass({

  name: 'MessageComposerScene',

  extend: Scene,

  statics: {
    FOCUS_COMPOSER: 0,
    FOCUS_PICKER: 1
  },

  properties: {
    controller: null,
    // list of messages to be forwarded
    forwardMessages: null,
    recipient: null,
    recipientUid: null,
    localId: null, // for local contact
    body: null,
    // must be set to either the composer or picker to keep keyboard up
    focus: 1
  },

  construct: function(options) {
    contactsList = contactsList || new LocalContactsList();

    this.recipients = new RecipientCollection({
      contactsList: contactsList
    });

    Scene.call(this, options);
  },

  declare: function(options) {
    return {
      onsend: this.onSend,
      childViews: [
        {
          boxOrientation: 'horizontal',
          className: 'bt-bar',
          childViews: [
            {
              className: 'bt-bar-button bt-x-button left',
              view: ActionableView,
              action: '_showDiscardDialog'
            },
            {
              flex: 1,
              content: 'New Message',
              className: 'bt-bar-title',
              ref: 'title'
            }
          ]
        },
        {
          className: 'bt-picker-field',
          ref: 'recipientField',
          childViews: [
            {
              content: 'To:',
              className: 'bt-picker-label'
            },
            {
              view: CollectionView,
              collection: this.recipients,
              className: 'bt-recipient-tokens',
              modelViewMapping: {
                Model: {
                  view: RecipientToken,
                  action: 'onTokenAction',
                  bindingConfig: [
                    { modelProperty: 'label', viewProperty: 'content' },
                    { property: 'selected' }
                  ],
                  owner: this
                }
              }
            },
            {
              view: PickerInput,
              ref: 'pickerInput',
              oninput: 'onPickerValueChange',
              onkeydown: 'onPickerKeydown'
            }
          ],
          ontouchstart: 'onPickerTouch'
        },
        {
          view: ScrollView,
          ref: 'scroller',
          flex: 1,
          childViews: [
            {
              view: DataList,
              ref: 'resultsDataList',
              onselection: 'onPickerTableSelection',
              createView: function(model) {
                var view = new PickerRow();
                this.updateView(view, model);
                return view;
              },
              updateView: function(view, model) {
                view.setHighlighted(false);
                view.setContact(model);
                return view;
              }
            }
          ]
        },
        {
          view: ForwardsView,
          ref: 'forwardedMessages'
        },
        {
          view: Composer,
          ref: 'composer',
          controller: options.controller,
          model: options.model,
          ontouchstart: 'goComposer',
          onmousedown: 'goComposer'
        },
        {
          className: 'bt-sending-view',
          childViews: [{
            content: 'Sending...',
            className: 'bt-sending-text'
          }]
        }
      ]
    };
  },

  ready: function() {
    this.composer             = this.refs.composer;
    this.forwardedMessages    = this.refs.forwardedMessages;
    this.recipientField       = this.refs.recipientField;
    this.pickerInput          = this.refs.pickerInput;

    this.recipients.addListener('modelAdded', this.clearPickerInput, this);

    contactsList.allContacts().then(this._onContactsLoaded, this);

    this.tryAddRecipient();

    if (this.getBody()) {
      this.composer.setText(this.getBody());
    }

    var messages = this.getForwardMessages();
    if (messages) {
      this.forwardedMessages.setMessages(messages);
      this.refs.title.setContent('Forward Messages');
      this.composer.setForwarding();
    }
  },

  changeFocus: function(focus) {
    if (focus === this.klass.FOCUS_PICKER) {
      this.pickerInput.getNode().focus();
      this.setFocus(this.klass.FOCUS_PICKER);
    } else {
      this.composer.focus();
      this.setFocus(this.klass.FOCUS_COMPOSER);
    }
  },

  goComposer: function() {
    this._composerFocus = true;
  },

  tryAddRecipient: function() {
    var recipient = this.getRecipient();
    var recipientUid = this.getRecipientUid();
    var localId = this.getLocalId();

    if (!(recipient || recipientUid || localId)) {
      return;
    }
    // first check if uid
    if (recipientUid) {
      contactsList.findByFacebookId(recipientUid)
        .then(function(contact) {
          this._tryAddContact(contact, recipientUid);
        }, this);
    } else if (localId) {
      contactsList.findById(localId)
        .then(function(contact) {
          this._tryAddContact(contact);
        }, this);
    } else if (!this._addEmailOrPhone(recipient)) {
      console.warn('invalid recipient', recipient);
    }
  },

  _tryAddContact: function(contact, uid) {
    if (contact) {
      this.recipients.addContactRecipient(contact);
    } else if (uid) {
      require('shared/api_xhr').graph('GET', uid)
        .addCallback(function(data) {
          if (data) {
            this.recipients.addRecipient(new Model({
              label: data.name,
              ident: 'fbid:' + data.id
            }));
          } else {
            console.warn('invalid recipient', uid);
          }
        }, this);
    }
  },

  _onContactsLoaded: function(rows) {
    this.contactData = rows;
    this.batchFilter = new ContactsFilter(
      this.contactData,
      {
        chunkSize: 20,
        timeout: 10,
        maxResults: 50
      }
    );
    this.findRef('resultsDataList').setData(this.batchFilter.getCollection());
    this.batchFilter.addListener('searchFinish', this.onSearchFinish, this);

    if (this.pickerInput.getValue() > 0) {
      this._processPickerText(this.pickerInput.getValue());
    }

    var messages = this.getForwardMessages();
    if (messages) {
      this.forwardedMessages.setMessages(messages);
      this.refs.title.setContent('Forward Messages');
    }

    this.pickerInput.addListener('focusout', this.onPickerInputLeave, this);
    this.composer.composerTextField
      .addListener('focusout', this.onComposerLeave, this);
  },

  activate: function(e) {
    if (this.getForwardMessages()) {
      this.forwardedMessages.show();
      this.forwardedMessages.setStyle('display', '-webkit-box');
    } else {
      this.forwardedMessages.hide();
    }
    this.setSceneLink();
  },

  setSceneLink: function() {
    this.getController().setSceneLink({scene: 'composer'});
  },

  // TOKENIZER

  onPickerTableSelection: function(e) {
    var contact = this.findRef('resultsDataList').getData().at(e.data.index);
    this.clearPickerInput();
    this.recipients.addContactRecipient(contact);
    this.clearBatchFilter();
  },

  // ### PickerField
  onPickerTouch: function(e) {
    this.changeFocus(this.klass.FOCUS_PICKER);
    e.preventDefault();
  },

  clearPickerInput: function() {
    this.batchFilter.clear();
    this.pickerInput.setValue('');
    this.hidePicker();
  },

  showComposer: function() {
    this.composer.show();
    this.composer.setStyle('display', '-webkit-box');
  },

  // hides picker and shows message composer, forwarded messages
  hidePicker: function() {
    this.batchFilter.clear();
    this.showComposer();
    if (this.getForwardMessages()) {
      this.forwardedMessages.show();
      this.forwardedMessages.setStyle('display', '-webkit-box');
    }
  },

  // TODO: create index for searchable fields to help performance
  _filterContactsForPicker: function(contact) {
    delete contact._matchingValue;

    var contactIdent = contactUtils.buildContactIdent(contact);
    for (var r in this.recipients) {
      if (contactIdent == this.recipients[r]) {
        return false;
      }
    }

    if (this.regexName.test(contact.getName())) {
      return true;
    }

    // Ideally we'd want to only look for the mobile numbers
    if (this.regexPhone) {
      var phones = contact.getPhoneNumbers();
      for (var p in phones) {
        if (this.regexPhone.test(phones[p].number)) {
          contact._matchingValue = phones[p].number;
          return true;
        }
      }
    }
    if (this.regexEmail) {
      var email = contact.getEmail();
      if (email && this.regexEmail.test(email)) {
        contact._matchingValue = email;
        return true;
      }
    }

    return false;
  },

  // Tries to add given email or phone as a recipient.
  //
  // @param str {string}  email or phone to add
  // @return    {boolean} true if added successfully
  _addEmailOrPhone: function(str) {
    if (sharedUtil.isEmail(str)) {
      this.recipients.addEmailRecipient(str);
      return true;
    }
    if (sharedUtil.isPhoneOrShortCode(str)) {
      this.recipients.addPhoneRecipient(str);
      return true;
    }
    return false;
  },

  onPickerValueChange: function(e) {
    this._processPickerText(e.target.value);
  },

  onPickerKeydown: function(e) {
    var value = e.target.value;
    var keyCode = e.keyCode;
    if (value === '' && keyCode === 8) {
      // If the value is empty, and its last value was empty,
      // delete any selected tokens, and hide the picker

      if (this.recipients.getSelectedModel()) {
        this._deleteSelectedRecipient();
      } else {
        this.selectRecipient(this.recipients.last());
      }
      this.hidePicker();
    } else if (keyCode === 13) {
      this._addEmailOrPhone(value);
    }
  },

  _processPickerText: function(value) {
    this.clearBatchFilter();

    var terminators = ' ,;';

    if (value === '') {
      this.selectRecipient(null);
      this.hidePicker();
    } else {
      this.selectRecipient(null);

      if (!this.batchFilter) {
        return;
      }

      // must escape regex special chars before string-concat to create regex
      var escapedValue = sharedUtil.escapeRegEx(value);
      var regexName = new RegExp('\\b' + escapedValue, 'i');
      var regexEmail = new RegExp('^' + escapedValue, 'i');
      var regexPhone = null;
      if (escapedValue.length > 1) {
        regexEmail = new RegExp('^' + escapedValue, 'i');
        if (sharedUtil.regexCanBePhone.test(value)) {
          regexPhone = new RegExp(value.replace(/[\+()\-\.]/g, ''));
        }
      }

      this.batchFilter.search(
        this._filterContactsForPicker,
        {
          scene: this,
          recipients: this.recipients.getIdents(),
          regexName: regexName,
          regexEmail: regexEmail,
          regexPhone: regexPhone
        }
      );

      // if value ends in a terminator, check for phone or email recipient
      var lastChar = value.charAt(value.length - 1);
      if (terminators.indexOf(lastChar) !== -1) {
        var str = value.substr(0, value.length - 1);
        this._addEmailOrPhone(str);
      }
    }
  },

  onSearchFinish: function(evt) {
    if (evt.data.iterator.found === 0) {
      this.showComposer();
    }
  },

  clearBatchFilter: function() {
    if (this.batchFilter) {
      this.batchFilter.stopSearch();
    }
  },

  // When we leave the picker input field that might mean
  // that we've typed some number (not chosen a contact),
  // so we need to try to tokenize what's in the input
  onPickerInputLeave: function(e) {
    var value = this.pickerInput.getValue();
    this._addEmailOrPhone(value);
    this.hidePicker();

    //prevent hiding of keyboard
    if (this._composerFocus) {
      this.changeFocus(this.klass.FOCUS_COMPOSER);
      this._composerFocus = false;
    } else {
      this.changeFocus(this.klass.FOCUS_PICKER);
    }
    e.preventDefault();
  },

  onComposerLeave: function() {
    this.changeFocus(this.klass.FOCUS_PICKER);
  },

  onTokenAction: function(view, e) {
    var model = view.get('model');
    if (!model.get('selected')) {
      this.selectRecipient(model);
    } else {
      this.selectRecipient(null);
    }
  },

  selectRecipient: function(recipient) {
    this.recipients.setSelectedModel(recipient);
  },

  _deleteSelectedRecipient: function() {
    var recipients = this.recipients;
    recipients.remove(recipients.getSelectedModel());
    this.selectRecipient(null);
  },

  // END TOKENIZER

  setSending: function(sending) {
    if (sending) {
      this.addClass('bt-sending');
    } else {
      this.removeClass('bt-sending');
    }
  },

  onSend: function(e) {
    var pickerValue = this.pickerInput.getValue();
    if (pickerValue) {
      this._addEmailOrPhone(pickerValue);
      this.clearPickerInput();
    }
    if (this.recipients.length > 0) {
      var messageText = this.composer.getText();
      var attachment  = this.composer.getAttachment();
      var coords      = this.composer.getLocation();
      var forwards    = this.getForwardMessages();
      var controller  = this.getController();

      pinUtil.verifySimUnlocked().addCallback(function() {
        this.setSending(true);
        var sendMessageClient = require('talk/client/send_message_client');

        var messageData = {
            body:        messageText,
            forwards:    forwards,
            coordinates: coords,
            attachment:  attachment
          };

        var idents = this.recipients.getIdents();
        sendMessageClient.getInstance().shouldSplitGroup(idents)
          .then(function(should) {
            if (should) {
              for (var r in idents) {
                sendMessageClient.getInstance()
                  .resolveThread([idents[r]], messageData)
                  .addCallback(this._sendMessage, this, messageData);
              }
              this.goBack();
            } else {
              sendMessageClient.getInstance()
                .resolveThread(idents, messageData)
                .addCallback(this._sendMessage, this, messageData)
                .addCallback(controller.openMessages, controller);
            }
            this.getController().tryDismissAfterAction();
          }, this);
      }, this);
    }
  },

  _sendMessage: function(messageData, thread) {
    var sendMessageClient = require('talk/client/send_message_client');
    sendMessageClient.getInstance().sendToThread(thread, messageData);
  },

  _showDiscardDialog: function() {
    if (this.composer.isMessageEmpty()) {
      this.goBack();
      return;
    }

    var dialog = this.build({
      view: 'Dialog',
      title: "Discard Message",
      body: "Are you sure you want to discard your message?",
      actions: [
        {
          value: 'No',
          action: 'hide'
        },
        {
          value: 'Discard',
          action: util.bind(this.goBack, this)
        }
      ]
    });
    dialog.show();
  },

  // return to the previous scene
  goBack: function() {
    this.pickerInput.getNode().blur();
    this.clearBatchFilter();
    this.getController().backToThreads();
    this.getController().tryDismissAfterAction();
  }
});
});

// module: bolt_touch/views/data_list/rendering_strategy/variable_height
// file:   ../../../frameworks/bolt_touch/lib/views/data_list/rendering_strategy/variable_height.js
define("bolt_touch/views/data_list/rendering_strategy/variable_height", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.
/*global undefined: false */
var PERF_WARNINGS = false;
var DEBUG_LOGS    = false;

var core = require('bolt/core');
var util = require('bolt/util');

var OffsetCache = require('../offset_cache').OffsetCache;
var CircularBuffer = require('../circular_buffer').CircularBuffer;
var CommandQueue = require('../command_queue').CommandQueue;
var eventually = require('../../../util/eventually').eventually;
var BaseRenderingStrategy = require('./base').BaseRenderingStrategy;


//                        - Rendered Rows
//                      /
//              HHHHH /
//         +----HHHHH----+  Visible Range
//         |    HHHHH    |
//         |    HHHHH    |
//         +----HHHHH----+
//              HHHHH
//
//
//         +-------------+
//         |             |
//         |    HHHHH    |
//         |    HHHHH    |
//         |             |
//         +-------------+
//
//
//
//              HHHHH
//         +----HHHHH----+
//         |    HHHHH    |
//         |    HHHHH    |
//         |             |
//         +-------------+
//
//
//         +-------------+
//         |             |
//         |    HHHHH    |
//         |    HHHHH    |
//         +----HHHHH----+
//              HHHHH

function viewIndexGetter(view) {
  return view.__viewIndex;
}

if (DEBUG_LOGS) {
  var totalRenderingTime = 0;
  var rowsRendered = 0;
}

var ACTION_SHOW = 1;
var ACTION_HIDE = 2;

/**
 * @class VariableHeightRenderingStrategy
 * @classdesc Main rendering strategy for the DataList. Renders a vertical list
 * of arbitrary data. Measures and caches heights of rendered rows.
 */
var VariableHeightRenderingStrategy = core.createClass({

  extend: BaseRenderingStrategy,

  name: 'VariableHeightRenderingStrategy',

  // Array of row views sorted by __viewIndex
  _rows: null,
  // OffsetCache object maintaining known heights
  _heightCache: null,
  // Guess for height of row
  _rowHeightGuess: 500,

  properties: {
    /**
     * @property {Number} emptyHeight - when no data is rendered yet set the
     * height of the list to this value
     */
    emptyHeight: 100,

    /**
     * @property {}
     */
    animateChanges: false
  },

  construct: function(options) {
    BaseRenderingStrategy.call(this, options);
    this._rows = new CircularBuffer();
    this._rowsToActivate = [];
    this._rowsToMeasureAbove = [];
    this._rowsToMeasureBelow = [];
    this._rowHeightsAbove = [];
    this._rowHeightsBelow = [];
  },

  update: function(commandQueue, range, width) {
    var changesFromCommands = this._processCommands(commandQueue);
    var changesFromRowUpdates = this._updateRows(range);

    return changesFromCommands || changesFromRowUpdates;
  },

  clear: function() {
    this._heightCache = new OffsetCache();
    while (this._rows.length) {
      this._releaseRow(this._rows.get(0));
    }
  },

  setHighlighted: function(index, state) {
    var rowIndex = this._rows.sortedIndex(
      { __viewIndex: index },
      viewIndexGetter);

    if (rowIndex < this._rows.length &&
      this._rows.get(rowIndex).setHighlighted) {
      this._rows.get(rowIndex).setHighlighted(state);
    }
  },

  getIndexForEvent: function(e) {
    var view = e.getTargetView();
    while (view && view.getParentView() != this._paneView) {
      view = view.getParentView();
    }
    if (view) {
      return view.__viewIndex;
    }
    return -1;
  },

  _acquireRow: function(index, _model, animate, dontMove) {
    if (DEBUG_LOGS) {
      var t = Date.now();
    }
    var data  = this._data;
    var model = _model ? _model : (data.at ? data.at(index) : data[index]);
    var row   = this._viewManager.acquire(model);
    row.__viewIndex = index;

    var isNew = this._initRow(index, row);
    if (!dontMove) {
      this._moveRow(index, row, animate);
    }
    this._cacheRow(row);

    if (DEBUG_LOGS) {
      var d = Date.now() - t;
      if (!isNew) {
        totalRenderingTime += d;
        rowsRendered += 1;
      }
      var avg = totalRenderingTime/rowsRendered;
      console.log('rendering #' + index + ' at ' + row.__viewPosition +
        ' in ' + d + 'ms' +
        (rowsRendered ? ', avg ' + (avg) + 'ms' : ''));
    }

    return row;
  },

  _initRow: function(index, row) {
    if (!row.getParentView()) {
      if (PERF_WARNINGS) {
        console.warn('creating for', index);
      }
      row.setStyle({
        position: 'absolute',
        left: '0px'
      });
      if (this._isReverse) {
        row.setStyle('bottom', '0px');
      } else {
        row.setStyle('top', '0px');
      }
      if (this.getAnimateChanges()) {
        row.addListener('transitionend', this._releaseAfterAnimation, this);
      }
      this._paneView.appendChild(row);
      return true;
    }
    return false;
  },

  _releaseAfterAnimation: function(e) {
    var row = e.getTargetView();
    if (row.getParentView() !== this._view) {
      return;
    }
    if (row.__viewAction === ACTION_HIDE) {
      this._viewManager.release(row);
      row.getNode().style.webkitTransform = 'translate3d(-9999px,0,0)';
      row.removeClass('bt-data-list-row_disappearing bt-data-list-row_hidden');
      row.__viewAction = 0;
    } else if (row.__viewAction === ACTION_SHOW) {
      row.removeClass('bt-data-list-row_appearing');
      row.__viewAction = 0;
    } else {
      row.removeClass('bt-data-list-row_moving');
    }
  },

  _moveRow: function(index, row, animate, rowHeight) {
    var heightCache = this._heightCache;

    if (!rowHeight) {
      rowHeight = row.getNode().offsetHeight;
    }
    heightCache.set(index, rowHeight);
    heightCache.seekIndex(index);
    var y = heightCache.getCurrentOffset();
    row.__viewPosition = y;
    row.__desiredPosition = y;
    if (this._isReverse) {
      y = y * -1;
    }
    row.removeClass('bt-data-list-row_moving');
    row.getNode().style.webkitTransform = 'translate3d(0,' + y + 'px,0)';
    if (animate) {
      row.addClass('bt-data-list-row_hidden');
      row.__viewAction = ACTION_SHOW;
      this._rowsToActivate.push(row);
      row.__pendingAnimation = true;
      eventually(this._activateAnimation, this);
    }
  },

  _activateAnimation: function() {
    var rows = this._rowsToActivate;
    for (var i = 0; i < rows.length; i++) {
      rows[i].addClass('bt-data-list-row_appearing');
      rows[i].removeClass('bt-data-list-row_hidden');
      rows[i].__pendingAnimation = false;
    }
    this._rowsToActivate.length = 0;
  },

  _cacheRow: function(row) {
    var insertIndex = this._rows.sortedIndex(row, viewIndexGetter);
    this._rows.insert(insertIndex, row);
  },

  _releaseRowByIndex: function(index, animate) {
    this._releaseRow(this._rows.get(index), index, animate);
  },

  _releaseRow: function(row, indexSuggest, animate) {
    if (animate) {
      row.addClass('bt-data-list-row_disappearing bt-data-list-row_hidden');
      row.__viewAction = ACTION_HIDE;
    } else {
      this._viewManager.release(row);
      row.getNode().style.webkitTransform = 'translate3d(-9999px,0,0)';
    }
    var index = indexSuggest === undefined ?
      this._rows.sortedIndex(row, viewIndexGetter) :
      indexSuggest;
    if (DEBUG_LOGS) {
      console.log('releasing', row.__viewIndex);
    }
    this._rows.remove(index);
  },

  /**
   * Removes views outside of rendering range and renders new ones inside.
   * Operates under assumption that the rendered range has no gaps.
   *
   * @param {Object} range pixels to render
   * @return {Boolean} true if there were changes to react to, false otherwise.
   */
  _updateRows: function(range) {
    var length      = this._data.length;
    var rows        = this._rows;
    // exit fast if we know that there's nothing to do
    if (!rows.length && !length) {
      return false;
    }
    if (DEBUG_LOGS) {
      console.log('start', range.from, range.to);
    }

    var fromIndex   = rows.length ? rows.get(0).__viewIndex : 0;
    var toIndex     = rows.length ? rows.get(rows.length - 1).__viewIndex : -1;
    var heightCache = this._heightCache;
    var changed     = false;

    // remove extra above
    heightCache.seekIndex(fromIndex);
    while (heightCache.getNextOffset() < range.from && fromIndex < length
      && rows.length) {
      this._releaseRowByIndex(0);
      heightCache.seekIndex(++fromIndex);
      changed = true;
    }

    // remove extra below
    heightCache.seekIndex(toIndex);
    while (heightCache.getCurrentOffset() > range.to && toIndex > 0
      && rows.length) {
      this._releaseRowByIndex(rows.length - 1);
      heightCache.seekIndex(--toIndex);
      changed = true;
    }

    // support for jumps
    if (rows.length === 0) {
      heightCache.seekOffset(range.from);
      if (PERF_WARNINGS) {
        console.warn('jumped from', fromIndex, heightCache.getCurrentIndex());
      }
      fromIndex = heightCache.getCurrentIndex();
      toIndex   = heightCache.getCurrentIndex() - 1;
    }

    while (true) {
      if (heightCache.getLength() > 0) {
        this._rowHeightGuess =
          heightCache.getTotalOffset() / heightCache.getLength();
      }

      // Fill in remaining space above and below rendered rows.  To prevent
      // layout we measure all offsetHeights at once, so we need to guess the
      // number of rows to layout.  Keep track of rows above and below
      // separately.
      var rowsToMeasureAbove = this._rowsToMeasureAbove;
      var rowsToMeasureBelow = this._rowsToMeasureBelow;
      var rowHeightsAbove = this._rowHeightsAbove;
      var rowHeightsBelow = this._rowHeightsBelow;
      rowsToMeasureAbove.length = 0;
      rowsToMeasureBelow.length = 0;
      rowHeightsAbove.length = 0;
      rowHeightsBelow.length = 0;

      // create rows below
      var pixelsBelow = range.to - heightCache.getNextOffset();
      var heightGuessBelow = 0;
      var row;
      while (heightGuessBelow < pixelsBelow && toIndex < length - 1) {
        toIndex++;
        row = this._acquireRow(toIndex, undefined, undefined, true);
        rowsToMeasureBelow.push(row);
        heightGuessBelow += this._guessRowHeight(row, toIndex);
        changed = true;
      }

      // create rows above
      heightCache.seekIndex(fromIndex);
      var pixelsAbove = heightCache.getCurrentOffset() - range.from;
      var heightGuessAbove = 0;
      while (heightGuessAbove < pixelsAbove && fromIndex > 0) {
        fromIndex--;
        row = this._acquireRow(fromIndex, undefined, undefined, true);
        rowsToMeasureAbove.push(row);
        heightGuessAbove += this._guessRowHeight(row, fromIndex);
        changed = true;
      }

      var i;
      // measure rows
      var heightActualAbove = 0;
      var heightActualBelow = 0;
      var height;
      for (i = 0; i < rowsToMeasureAbove.length; i++) {
        height = rowsToMeasureAbove[i].getNode().offsetHeight;
        rowHeightsAbove.push(height);
        heightActualAbove += height;
      }
      for (i = 0; i < rowsToMeasureBelow.length; i++) {
        height = rowsToMeasureBelow[i].getNode().offsetHeight;
        rowHeightsBelow.push(height);
        heightActualBelow += height;
      }

      // move rows into correct positions
      for (i = 0; i < rowsToMeasureAbove.length; i++) {
        row = rowsToMeasureAbove[i];
        this._moveRow(row.__viewIndex, row, false, rowHeightsAbove[i]);
      }
      for (i = 0; i < rowsToMeasureBelow.length; i++) {
        row = rowsToMeasureBelow[i];
        this._moveRow(row.__viewIndex, row, false, rowHeightsBelow[i]);
      }

      // 2 ways to be done; either we've filled the empty space or we've run
      // out of rows to render
      if ((heightActualAbove >= pixelsAbove || fromIndex <= 0) &&
          (heightActualBelow >= pixelsBelow || toIndex >= length - 1)) {
        break;
      }
    }

    if (DEBUG_LOGS) {
      console.log('finished');
    }
    return changed;
  },

  _guessRowHeight: function(row, index) {
    var cachedHeight = this._heightCache.getOffsetAt(index);
    if (typeof(cachedHeight) === 'undefined') {
      return this._rowHeightGuess;
    } else {
      return cachedHeight;
    }
  },

  /**
   * Process commands. See CommandQueue for the available actions
   *
   * @return {Boolean} true if commands caused any change, false otherwise
   */
  _processCommands: function(commandQueue) {
    var changed = false;
    if (commandQueue.length > 0) {
      var command = null;
      while (command = commandQueue.shift()) {
        changed = this._processCommand(command) || changed;
      }
      this._applyMove(this.getAnimateChanges());
    }
    return changed;
  },

  getHeight: function() {
    var heightCache = this._heightCache;
    if (!heightCache.getLength()) {
      return this.getEmptyHeight();
    }
    var estimatedRowHeight = heightCache.getTotalOffset() /
      heightCache.getLength();
    return Math.round(this._data.length * estimatedRowHeight);
  },

  _processCommand: function(command) {
    var heightCache = this._heightCache;
    var length      = this._data.length;
    var rows        = this._rows;
    var fromIndex   = rows.length ? rows.get(0).__viewIndex : 0;
    var toIndex     = rows.length ? rows.get(rows.length - 1).__viewIndex : 0;
    var rowIndex    = 0, row, tmp, height;

    // if the height was not even cached, just return
    var index = command.index;
    if (index >= heightCache.getLength()) {
      return false;
    }

    if (index <= toIndex && index >= fromIndex) {
      rowIndex = rows.sortedIndex({ __viewIndex: index }, viewIndexGetter);
      row = rows.get(rowIndex);
    }

    if (command.action === CommandQueue.RESIZE ||
      command.action === CommandQueue.REDRAW) {
      if (row) {
        var model = command.model;
        var reusableType = this._viewManager.getReusableType(model);
        this._viewManager.updateView(row, model, reusableType);
        height = heightCache.set(index, row.getNode().offsetHeight);
      } else if (command.action === CommandQueue.RESIZE) {
        tmp = this._acquireRow(index, command.model);
        height = heightCache.set(index, tmp.getNode().offsetHeight);
        this._releaseRow(tmp);
      } else {
        return false;
      }
      this._offsetRowPositions(index + 1, height);
      return true;
    }

    if (command.action === CommandQueue.REMOVE) {
      if (row) {
        this._releaseRow(row, undefined, this.getAnimateChanges());
      }
      this._offsetViewIndices(index, -1);
      height = this._heightCache.remove(index);
      this._offsetRowPositions(index, -height);
      return true;
    }

    if (command.action === CommandQueue.INSERT) {
      this._offsetViewIndices(index, 1);
      this._heightCache.insert(index, 0);
      tmp = this._acquireRow(
        index,
        command.model,
        row && this.getAnimateChanges());
      // remove if invisible
      if (!row) {
        this._releaseRow(tmp);
      }
      this._offsetRowPositions(
        index + 1,
        this._heightCache.getOffsetAt(index));
      return true;
    }

    return false;
  },

  /**
   * When a row changes height, is added or is removed, the offset height of all
   * rows below it must be updated. This'll do that.
   *
   * @property {number} the view index of the row to offset the height by
   * @property {number} the height to offset all rows at and below the view
   *  index by.
   */
  _offsetRowPositions: function(viewIndex, offset) {
    if (!offset) {
      return;
    }
    var rows    = this._rows;
    var row     = null;
    var y;
    for (var i = 0, l = rows.length; i < l; i++) {
      row = rows.get(i);
      if (row.__viewIndex < viewIndex) {
        continue;
      }
      row.__desiredPosition = row.__desiredPosition + offset;
    }
  },

  _applyMove: function(animate) {
    var i, y, move;
    var rows = this._rows;
    var reverse = this._isReverse;
    var row = null;

    for (i = 0; i < rows.length; i++) {
      row = rows.get(i);
      if (row.__desiredPosition !== row.__viewPosition) {
        y = row.__viewPosition = row.__desiredPosition;
        if (reverse) {
          y = y * -1;
        }
        if (animate && !row.__pendingAnimation) {
          row.addClass('bt-data-list-row_moving');
        }
        row.getNode().style.webkitTransform =
          'translate3d(0,' + y + 'px,0)';
      }
    }
  },

  _offsetViewIndices: function(index, offset) {
    var rows    = this._rows;
    var toIndex = rows.length ? rows.get(rows.length - 1).__viewIndex : 0;

    if (index <= toIndex) {
      for (var i = 0, l = rows.length; i < l; i++) {
        if (rows.get(i).__viewIndex >= index) {
          rows.get(i).__viewIndex += offset;
        }
      }
    }
  }
});


exports.VariableHeightRenderingStrategy = VariableHeightRenderingStrategy;
});

// module: views/composer/js/composer_view
// file:   ../../views/composer/js/composer_view.js
define("views/composer/js/composer_view", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core              = require('bolt/core');
var util              = require('bolt/util');
var View              = require('bolt_touch/view').View;
var Model             = require('bolt/model').Model;
var WindowManager     = require('shared/window_manager').WindowManager;
var EventManager      = require('shared/event_manager').EventManager;
var ComposerTextareaContainer =
  require('./composer_textarea_container').ComposerTextareaContainer;
var PhotoActionSheet  = require('./photo_action_sheet').PhotoActionSheet;
var ScreenShield      = require('./screen_shield').ScreenShield;
var AudienceConstants = require('audience_picker/audience_constants');
var PostManager       = require('shared/post_manager').PostManager;
var photoPicker       =
  require('views/picker/photo_picker/photo_picker').photoPicker;
var placePicker       = require('place_picker/place_picker').placePicker;
var audiencePicker =
  require('audience_picker/audience_picker').audiencePicker;

var contactPicker;
var glitter = window.FBAPI && FBAPI.use('glitter');
if (!glitter) {
  contactPicker = require('contact_picker/contact_picker_view').contactPicker;
}

var ComposerView = exports.ComposerView = core.createClass({
  name: 'ComposerView',

  extend: View,

  properties: {
    composerModel : null,

    // The composeType of the contained ComposerView (null, 'photo' or 'place').
    // If it is set, the required picker will pop up automatically.
    composeType: null,

    inScene: false,

    buttons: ['contacts', 'place', 'photos', 'audience']
  },

  statics: {
    // A static variable to indicate a keyboard.
    KEYBOARD : 'keyboard',

    BAR_HEIGHT: 64,

    // An array of classes for clickable elements.
    // Note: need an array since it is checking
    // substring.
    CLICKABLE_ELEMENTS: [
      'composer-share-button',
      'contact-picker',
      'place-picker',
      'photo-picker',
      'audience-picker',
      'composer-thumbnail',
      'composer-x-button',
      'composer-text-input',
      'composer-text-shadow',
      'bt-back-button'
    ]
  },

  declare: function(options) {
    var inputButtonConfig =  this._createComposerInputPanel(options.inScene);

    return {
      boxOrientation: 'vertical',
      childViews: [
        {
          view: 'ComposerTextareaContainer',
          ref: 'textarea',
          inScene: options.inScene
        },
        {
          ref: 'inputButtons',
          additionalClasses: 'bt-bar composer-input-panel',
          boxOrientation: 'horizontal',
          childViews : inputButtonConfig
        },
        {
          view: PhotoActionSheet,
          ref: 'photoActionSheet'
        },
        {
          view: ScreenShield,
          ref: 'screenShield'
        }
      ]
    };
  },

  ready: function() {
    this._initRefs();
    this._initHandlers();
    this._initComposer();
  },

  useHeader: function() {
    return false;
  },

  show: function() {
    this.setStyle('display', '-webkit-box');

    this.setNewModal(this.klass.KEYBOARD);
  },

  destroy: function() {
    // Make sure composer is properly dismissed even if the stack was "popTo"
    // away from this, rather than explicitly closing the composer
    this.setNewModal(null);

    if (this._contactPickerToken) {
      this._contactPickerToken.remove();
    }

    View.prototype.destroy.call(this);
  },

  close: function() {
    // Dismiss the keyboard
    this.setNewModal(null);

    if (!this.getInScene()) {
      this.hide();
    }

    if (this.getOwner().onComposerDidClose) {
      this.getOwner().onComposerDidClose();
    }
  },

  postStatus: function() {
    var composerModel = this.getComposerModel();
    var input = this._input.getStatus() ? this._input.getStatus().trim() : null;

    composerModel.set('status', input);
    this._postParams = this._convertModelToPostParams(composerModel);

    // Do not post the status when the input is empty. But photo
    // is an exception.
    if (input || (this._postParams.photos &&
      this._postParams.photos.length > 0)) {
      this._makeGraphAPIPost(this._postParams);
    }

    if (this.getOwner().onComposerDidPostStatus) {
      this.getOwner().onComposerDidPostStatus(this._postParams);
    }

    this.close();
  },

  setPhotos: function(photos) {
    this._photoButton.conditionClass(
      'highlight',
      photos && photos.length > 0);
  },

  setContacts: function(contacts) {
    this._friendsButton.conditionClass(
      'highlight',
      contacts && contacts.length > 0);
  },

  setPlace: function(place) {
    this._placeButton.conditionClass(
      'highlight',
      place);
  },

  setAudience: function(audience) {
    audience = (!audience) ? AudienceConstants.PUBLIC_ID : audience;

    if (this._currentAudienceIcon) {
      this._audienceButton.removeClass(this._currentAudienceIcon);
    }

    this._currentAudienceIcon = AudienceConstants.getAudienceIcon(audience);
    this._audienceButton.addClass(this._currentAudienceIcon);
  },

  // Hide the existing modal and set to the new one.
  setNewModal: function(newModal) {
    if (this._curModal) {
      if (this._curModal !== newModal) {
        if (this._curModal === this.klass.KEYBOARD) {
          document.body.removeEventListener(
            'touchstart',
            this._blockTouchstartHandler);
          this._input.blur();
        } else {
          this._curModal.hide();
        }
      }
    }

    if (newModal === this.klass.KEYBOARD) {
      setTimeout(this._focusHandler, 1);
      document.body.addEventListener(
        'touchstart',
        this._blockTouchstartHandler);
    }

    this._curModal = newModal;
  },

  initPickers: function() {
    // Prepare the pickers
    this._photoPicker = photoPicker;
    this._placePicker = placePicker;
    this._audiencePicker = audiencePicker;

    if (contactPicker) {
      contactPicker.refresh();
    }
  },

  initModal: function() {
    var composeType = this.getComposeType();

    switch (composeType) {
      case 'photo':
        this._showPhotoPicker();
        break;
      case 'place':
        this._showPlacePicker();
        break;
      default:
        // Show Keyboard if not explicitly set
        this.setNewModal(this.klass.KEYBOARD);
        break;
    }
  },

  onTextareaCancelButtonTouched: function() {
    this.close();
  },

  onRemovePhoto: function(id) {
    var selectedPhotos = this.getModel().get('photos') || [];
    selectedPhotos = selectedPhotos.slice(0);
    for (var i = 0 ; i < selectedPhotos.length; i++) {
      if (selectedPhotos[i].get('id') == id) {
        selectedPhotos.splice(parseInt(i, 10), 1);
        break;
      }
    }
    this.getModel().set('photos', selectedPhotos);
    this.setNewModal(this.klass.KEYBOARD);
  },

  onCancelRemovePhoto: function() {
    this.setNewModal(this.klass.KEYBOARD);
  },

  _createComposerInputPanel: function(inScene) {
    var inputPanelConfig = [
      {
        flex: 1,
        ref: 'friendsButton',
        additionalClasses: 'composer-friends-button contact-picker'
      },
      {
        flex: 1,
        ref: 'placeButton',
        additionalClasses: 'composer-location-button place-picker'
      },
      {
        flex: 1,
        ref: 'photoButton',
        additionalClasses: 'composer-camera-button photo-picker'
      },
      {
        ref: 'inputPanelBuffer',
        flex: 10
      },
      {
        flex: 1,
        ref: 'audienceButton',
        additionalClasses: 'composer-audience-button audience-picker'
      }
    ];

    // Explicitly set the display attribute
    for (var i = 0; i < inputPanelConfig.length; i++) {
      if (inputPanelConfig[i].ref !== 'inputPanelBuffer') {
        inputPanelConfig[i].style = {display: 'none'};
      }
    }

    if (!inScene) {
      inputPanelConfig.push({
        flex: 2,
        ref: 'shareButton',
        content: 'Share',
        additionalClasses: 'bt-bar-button right composer-share-button'
      });
    }

    return inputPanelConfig;
  },

  _initRefs: function() {
    this._input = this.findRef('textarea');
    this._audienceButton = this.findRef('audienceButton');
    this._friendsButton = this.findRef('friendsButton');
    this._placeButton = this.findRef('placeButton');
    this._photoButton = this.findRef('photoButton');
    this._inputButtons = this.findRef('inputButtons');

    // Other auxilary widget
    this._screenShield = this.findRef('screenShield');
    this._photoActionSheet = this.findRef('photoActionSheet');
  },

  _initHandlers: function() {
    this._photoUploadCompleteHandler =
      util.bind(this._onPhotoUploadComplete, this);
    EventManager.listen('PhotoStore/upload', this._photoUploadCompleteHandler);

    this._placePickerDoneHandler = util.bind(this._onPlacePickerDone, this);
    this._photoPickerDoneHandler = util.bind(this._onPhotoPickerDone, this);
    this._contactPickerDoneHandler = util.bind(this._onContactPickerDone, this);
    this._audiencePickerDoneHandler =
      util.bind(this._onAudiencePickerDone, this);
    this._focusHandler = util.bind(this._focus, this);
    this._showPhotoPickerHandler =
      util.bind(this._performShowPhotoPicker, this);

    this._blockTouchstartHandler = util.bind(this._onTouchstart, this);
  },

  _initComposer: function() {
    this._initInputPanel();
    this._initModel();
    this._initDimensions();
    this._initImplicitPlace();

    if (!this.getInScene()) {
      // These two inits need to happen
      // after the scene animation ends.
      this.initPickers();
      this.initModal();
    }
  },


  _initModel: function() {
    var model = this.getComposerModel();
    if (model === null) {
      model = new Model();
      this.setComposerModel(model);
    }

    this._input.setBinding(
      model,
      [
        {property: 'place'},
        {property: 'contacts'},
        {property: 'status'},
        {property: 'photos'}
      ]
    );

    this.setBinding(
      model,
      [
        {property: 'place'},
        {property: 'contacts'},
        {property: 'photos'},
        {property: 'audience'}
      ]
    );
  },

  _initDimensions: function() {
    this._shieldTop =
      WindowManager.getDimensions().height - WindowManager.FULL_KEYBOARD_HEIGHT;
    if (this.getInScene()) {
      this._shieldTop -= ComposerView.BAR_HEIGHT;
    }
    this._shieldHeight = WindowManager.FULL_KEYBOARD_HEIGHT;
    this._screenShield.show(this._shieldTop, this._shieldHeight);

    this.setStyle('height', (this._shieldTop - 1) + 'px');
  },

  _initImplicitPlace: function() {
    this._locationManager =
      require('place_picker/location_manager').getLocationManager();

    var model = this.getComposerModel();

    // Refresh the implicit place
    this._locationManager.getCity(function(city) {
      if (city && !model.get('place')) {
        city.implicit = true;
        model.set('place', city);
      }
    });
  },

  _initInputPanel: function() {
    this.refs.inputPanelBuffer.show();

    if (!this.getInScene()) {
      this.refs.shareButton.show();
    }

    for (var i  = 0; i < this.getButtons().length ; i ++) {
      switch (this.getButtons()[i]) {
        case 'contacts':
          this._friendsButton.show();
          break;
        case 'place':
          this._placeButton.show();
          break;
        case 'photos':
          this._photoButton.show();
          break;
        case 'audience':
          this._audienceButton.show();
          break;
      }
    }
  },

  _focus: function() {
    this._input.focus();
  },

  _showButton: function(button) {
    button.setStyle('display', '-webkit-box');
  },

  _showPhotoPicker: function() {
    this.setNewModal(this._photoPicker);
    setTimeout(this._showPhotoPickerHandler, 100);
  },

  _performShowPhotoPicker: function() {
    this._photoPicker.show(this._photoPickerDoneHandler, this._shieldHeight);
  },

  _showPlacePicker: function() {
    this.setNewModal(this._placePicker);

    var place = this.getComposerModel().get('place');
    var name = (place) ? place.name: null;

    this._placePicker.show(this._placePickerDoneHandler, name);
  },

  _showFriendsPicker: function() {
    if (contactPicker) {
       // Need to clear the contacts first in order to trigger a reset
      this.setNewModal(contactPicker);
      contactPicker.show({
        callback: this._contactPickerDoneHandler,
        fbFriendsOnly: true
      });
      contactPicker.setSelectedContacts(
        this.getComposerModel().get('contacts'));

    } else {
      var data = {
        selectedContacts:
          util.invoke(this.getComposerModel().get('contacts'), 'toObject'),
        fbFriendsOnly: true
      };

      if (!this._contactPickerToken) {
        this._contactPickerToken = EventManager.listen(
          'contact_picker.DONE', this._onContactPickerDone, this);
      }

      this.setNewModal(null);
      EventManager.notifyCore('contact_picker.REQUEST', data);
    }
  },

  _showAudiencePicker: function() {
    this.setNewModal(this._audiencePicker);
    this._audiencePicker.show(
      this._audiencePickerDoneHandler,
      this.getComposerModel().get('audience'));
  },

  _onPhotoPickerDone: function(photos) {
    this.setNewModal(this.klass.KEYBOARD, 200);
    if (photos) {
      photos = !util.isArray(photos) ? [photos] : photos;
      var selectedPhotos = this.getComposerModel().get('photos') || [];
      selectedPhotos = selectedPhotos.slice(0);

      util.forEach(photos, function(photo) {
        for (var i = 0; i < selectedPhotos.length; i++) {
          if (selectedPhotos[i].get('id') == photo.get('id')) {
            return;
          }
        }
        selectedPhotos.push(photo);
      });

      this.getComposerModel().set('photos', selectedPhotos);
    }
  },

  _onPhotoUploadComplete: function(obj) {
    if (obj.path) {
      var photos = this.getComposerModel().get('photos');
      var matchedPhotos = util.filter(photos, function(photo) {
        return photo.id === obj.path;
      });

      util.forEach(matchedPhotos, function(photo) {
        photo.set('id', obj.id);
      });
    }
  },

  _onPlacePickerDone: function(place, clearPlace) {
    this.setNewModal(this.klass.KEYBOARD);
    if (place || clearPlace) {
      this.getComposerModel().set('place', place || null);
    }
  },

  _onContactPickerDone: function(data) {
    if (this._contactPickerToken) {
      this._contactPickerToken.remove();
      this._contactPickerToken = null;
    }

    this.setNewModal(this.klass.KEYBOARD);

    var contacts = data.contacts ? data.contacts : data;
    if (contacts) {
      this.getComposerModel().set('contacts', contacts);
    }
  },

  _onAudiencePickerDone: function(audience) {
    this.setNewModal(this.klass.KEYBOARD);
    if (audience) {
      this.getComposerModel().set('audience', audience);
    }
  },

  _onThumbnailTouched: function(e) {
    if (e.target.id) {
      this.setNewModal(this._photoActionSheet);

      var basePos = this._input.getScrollerOffsetPos();
      var baseTop = basePos.top;
      var baseLeft = basePos.left + this._input.getScrollerCoords()[0];

      var startTop = baseTop + e.target.offsetTop + 5;
      var startLeft = baseLeft + e.target.offsetLeft;

      var endTop = this._shieldHeight + 20;
      var endLeft =
        (WindowManager.getDimensions().width  - e.target.clientWidth) / 2;

      this._photoActionSheet.show(startTop, startLeft, endTop, endLeft,
        this._shieldHeight, e.target);
    }
  },

  // Block all the clicks on the screen so that keyboard
  // always stays up.
  _onTouchstart: function(e) {
    var className = e.target.className;
    var clickable = util.some(ComposerView.CLICKABLE_ELEMENTS, function(name) {
      return className.indexOf(name) != -1;
    });

    if (!clickable) {
      e.preventDefault();
    }
  },

  _makeGraphAPIPost: function(params) {
    if (!params.photos || params.photos.length === 0) {
      PostManager.updateStatus(params.text, params.place, params.tags,
        params.group, params.privacy, null);
    } else {
      PostManager.updateStatusWithPhotos(params.text, params.place, params.tags,
        params.group, params.photos, params.privacy);
    }
  },

  _convertModelToPostParams: function(composerModel) {
    var params = {};

    params.text = composerModel.get('status') || '';
    params.tags = util.map(composerModel.get('contacts'), function(contact) {
      return contact.get('id');
    });

    var place = composerModel.get('place');

    params.place = place && place.page_id ? place.page_id : null;
    params.photos = composerModel.get('photos');

    // If there is no valid object returned, then this should be a post to
    // a group.
    var privacyId = composerModel.get('audience');
    privacyId = (privacyId) ? privacyId : AudienceConstants.PUBLIC_ID;

    var privacyObj;

    if (params.photos && params.photos.length > 0) {
      // TODO: If it is not group post, restrict the access to
      // be at most FB only.
      //
      // If it is group post, do not do anything special.
      //
      // Remove this logic after camera callibration!!!
      privacyObj = AudienceConstants.getPhotoAudienceObject(privacyId);
    } else {
      privacyObj = AudienceConstants.getAudienceObject(privacyId);
    }

    if (!privacyObj) {
      params.group = privacyId;
      params.privacy = null;
    } else {
      params.group = null;
      params.privacy = privacyObj;
    }

    return params;
  },

  friendsButtonClick: function(evt) {
    this._showFriendsPicker(evt);
  },

  placeButtonClick: function(evt) {
    this._showPlacePicker(evt);
  },

  photoButtonClick: function(evt) {
    this._showPhotoPicker(evt);
  },

  audienceButtonClick: function(evt) {
    this._showAudiencePicker(evt);
  },

  shareButtonClick: function(evt) {
    this.postStatus(evt);
  }
});
});

// module: mock/mail_api
// file:   ../../mock/js/mail_api.js
define("mock/mail_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;

module.exports = {
  registerReceiver: function() {
  },

  initialHandler:function() {
    EventManager.broadcastEvent('InitialHandlerCompleteCallBack', null);
  },

  createAccount: function(name, emailaddress, username, outusername, password,
    outpassword, desc, protocol, inserver, inport, outserver, outport,
    usesslin, usesslout, domainNamei, EASAccount, simplemethod) {
    /*setTimeout(function() {
      EventManager.broadcastEvent('GetAccountCompleteCallBack');
    }, 3500);

    setTimeout(function() {
      EventManager.broadcastEvent('UpdateCreateAccountProgressCallBack',
        [{'progressValue':33}]);
    }, 1000);

    setTimeout(function() {
      EventManager.broadcastEvent('UpdateCreateAccountProgressCallBack',
        [{'progressValue':66}]);
    }, 2000);

    setTimeout(function() {
      EventManager.broadcastEvent('UpdateCreateAccountProgressCallBack',
        [{'progressValue':100}]);
    }, 3000);*/

    //EventManager.broadcastEvent('GetAccountInCompleteCallBack');
    EventManager.broadcastEvent('NeedProvisionCallBack', this.getPolicyData());
  },

  hasAccount: function() {
    EventManager.broadcastEvent('HasAccountCompleteCallBack', this.getHasAccountData());
  },

  setAccount: function() {
    EventManager.broadcastEvent('LoadMailCallBack');
  },

  updateAccount: function() {
    EventManager.broadcastEvent('UpdateAccountCompleteCallBack', [{'result':true}]);
  },

  deleteAccount: function() {
    EventManager.broadcastEvent('DeleteAccountCompleteCallBack', [{'result':true}]);
  },

  refreshMail: function() {
    EventManager.broadcastEvent('ReceiveMailCallBack');
  },

  receiveMail: function(data, sort) {
    EventManager.broadcastEvent('LoadMailCallBack', this.getMailListData());
  },

  getFolderList: function() {
    EventManager.broadcastEvent('GetFolderListCompleteCallBack',
      this.getFolderListData());
  },

  changeFolder: function() {
    EventManager.broadcastEvent('ChangeFolderCompleteCallBack');
  },

  loadMail: function(mid) {
    EventManager.broadcastEvent('LoadMailContentCallBack', this.getReadMailData());
    EventManager.broadcastEvent('LoadPrevNextMailCallBack', this.getPrevNextMail());
  },

  getPrevNextMail: function(){
    return [{
      'nextmailid':  1,
      'prevmailid': '2'}];
  },

  getMailContentJsondata: function() {
    return this.getReadMailData();
  },

  actBatchMailAction: function(mid, type, extradata) {
    console.debug('type is ' + type + 'extradata is ' + extradata);
    console.debug('mid is ' + mid);
  },

  downloadAttachment: function(id) {
    EventManager.broadcastEvent('DownLoadAttachmentCompleteCallBack',
      this.getDownloadAttachData());
  },

  getMailContentImage: function() {
    //EventManager.broadcastEvent('GetReLoadMailDataCallBack', this.getContentImage());
    EventManager.broadcastEvent('ReloadMailContentFail', this.getReoladMailContentFail(1));
  },

  getRemainingMail: function() {
    //EventManager.broadcastEvent('GetReLoadMailDataCallBack', this.getRemaining());
    EventManager.broadcastEvent('ReloadMailContentFail', this.getReoladMailContentFail(2));
  },

  setReadStatus: function() {
  },

  deleteMail: function() {
  },

  loadSendMailData: function(sendMode, mId) {
    EventManager.broadcastEvent('GetSendMailDataCompleteCallBack',
      this.getAttachData());
  },

  getSendMailJsondata: function(){
    return null;
  },

  sendMail: function(to, subject, mailContext, cc, bcc, attachments,
    importance, indexforremoveattach) {
    //EventManager.broadcastEvent('ShowDialogCallBack',
    //  this.getShowDialogCallbackData(1));
    EventManager.broadcastEvent('SendMailParameterReadyCallBack',
     [{'result':true}]);
  },

  saveToDraft: function(to, subject, mailContext, cc, bcc, attachments,
    importance, indexforremoveattach) {
  },

  closeReplyText: function() {
  },

  getAttachmentFileList: function() {
    EventManager.broadcastEvent('GetAttachmentFileListCallBack',
      this.getAttachmentFileListData());
  },

  searchGal: function(searchText) {
    EventManager.broadcastEvent('SearchGalCompleteCallBack',
      this.getSearchContactsData());
  },

  searchMail: function(searchText) {
    EventManager.broadcastEvent('SearchMailCompleteCallBack',
      this.getMailListData());
  },

  notAcceptPolicy: function() {
  },

  setExchangePIN: function(bSet, pin) {
    EventManager.broadcastEvent('SetExchangePinResultCallBack', [{'result':true}]);
  },

  getShowDialogCallbackData: function(positiveEvent) {
    return [{
     'title':'Warning',
     'message':'The email address is not valid.',
     'positiveButton':'OK',
     'negativeButton':'',
     'positiveEvent':positiveEvent,
     'negativeEvent':-1,
     'value':-1,
     'dialogStyle':0
    }];
  },
  moveMail: function(mailid, mailboxid) {
    console.debug('move mail');
  },

  dialogEvent: function(positiveEvent) {
    EventManager.broadcastEvent('DismissDialogCallBack',
      this.getDismissDialogCallbackData(positiveEvent));
  },

  getDismissDialogCallbackData: function(positiveEvent) {
    return [{
     'eventId':positiveEvent,
     'result':true
    }];
  },

  getReoladMailContentFail: function(type) {
    return [{
     'type':type,
     'id':-1
    }];
  },

  createAccountAfterSetPin: function() {
    EventManager.broadcastEvent('GetAccountCompleteCallBack', this.getAccountCompleteData());
    //EventManager.broadcastEvent('GetAccountInCompleteCallBack');
  },

  testExchangePIN: function(pin) {
    EventManager.broadcastEvent('TestExchangePinResultCallBack', [{'result':true}]);
  },

  modifyExchangePIN: function() {
    EventManager.broadcastEvent('ModifyEasPinResultCallBack', [{'result':1}]);
  },

  getAccountCompleteData: function() {
    return [[{
       "emailaddress":"junyen_chen@htc.com",
       "username":"junyen_chen@htc.com",
       "outusername":"junyen_chen@htc.com",
       "desc": "Exchange",
       "protocol":4,
       "inserver":"taomail.htc.com",
       "outserver": "taomail.htc.com",
       "inport":0,
       "outport":0,
       "usesslin":1,
       "usesslout": 1,
       "domainName": "",
       "EASAccount": true}]];
  },

  getHasAccountData: function() {
    return [[{
      'result':false,
      'bHasPasswordPolicy':true,
      'mailAddress': 'bsummers@fb.com',
      'serverName': 'mail.thefacebook.com',
      'domainName': 'thefacebook',
      'userName': 'bsummers',
      'password': '8dY:\'S!1',
      'useSSL': 1,
      'MinDevicePasswordLength': '4',
      'MaxDevicePasswordFailedAttempts': '3',
      'AlphanumericDevicePasswordRequired': '1',
      'PasswordComplexity': '5',
      'RequireManualSyncWhenRoaming': '',
      'DevicePasswordHistory': '4',
      'DevicePasswordExpiration': '1',
      'MinDevicePasswordComplexCharacters': ''}]];
  },

  getPolicyData: function() {
    return [{
      'MinDevicePasswordLength': '4',
      'MaxDevicePasswordFailedAttempts': '3',
      'AlphanumericDevicePasswordRequired': '1',
      'PasswordComplexity': '5',
      'RequireManualSyncWhenRoaming': '',
      'DevicePasswordHistory': '4',
      'DevicePasswordExpiration': '1',
      'MinDevicePasswordComplexCharacters': ''}];
  },

  getMailListData: function() {
    return [[{
        'subject':'Remote Device Wipe Confirmation',
        'date':1318991038000,
        'showcctoforoutbox':'',
        'mailactFlag': 0,
        'read': 1,
        'priorityFlag': 1,
        'hasAttach': 1,
        'sender': 'Buffy Summers1',
        'flags': 0,
        'boxId': 1,
        'mAccountId': 1,
        'mID': 4
      },
      {
        'subject':'Remote Device Wipe Confirmation',
        'date':1318991038000,
        'showcctoforoutbox':'',
        'mailactFlag': 1,
        'read': 1,
        'priorityFlag': 1,
        'hasAttach': 1,
        'sender': 'Buffy Summers2',
        'flags': 0,
        'boxId': 1,
        'mAccountId': 1,
        'mID': 3
      },
      {
        'subject':'Remote Device Wipe Confirmation',
        'date':1318991038000,
        'showcctoforoutbox':'',
        'mailactFlag': 1,
        'read': 0,
        'priorityFlag': 1,
        'hasAttach': 1,
        'sender': 'Buffy Summers3',
        'flags': 0,
        'boxId': 1,
        'mAccountId': 1,
        'mID': 2
      },
      {
        'subject':'Remote Device Wipe Confirmation',
        'date':1318991038000,
        'showcctoforoutbox':'',
        'read': 0,
        'priorityFlag': 1,
        'mailactFlag': 2,
        'hasAttach': 0,
        'sender': 'Buffy Summers4',
        'flags': 0,
        'boxId': 1,
        'mAccountId': 1,
        'mID': 1
      }]];
  },

  getFolderListData: function() {
    return [[{
        'text':'Inbox',
        'type': 1,
        'value': 0,
      },
      {
        'text':'Outbox',
        'type': 5,
        'value': 1,
      },
      {
        'text':'Draft',
        'type': 4,
        'value': 2,
      },
      {
        'text':'Sent',
        'type': 3,
        'value': 3,
      }]];
  },

  getReadMailData: function() {
    return [{
      'subject':'Remote Device Wipe Confirmation',
      'date':1318991038000,
      'showcctoforoutbox':'',
      'read': 0,
      'priorityFlag': 1,
      'hasAttach': 1,
      'sender': 'Buffy Summers',
      'flags': 0,
      'boxId': 1,
      'mAccountId': 1,
      'mID': 7,
      'toSapphire': 'To',
      'downloadimage': 1,
      'remaningsize': 1,
      'mailcontent': '<html>\r\n<head>\r\n<\/head>\r\n' +
      '<body>\r\nasdfaf<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>' +
      '\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>' +
      '\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>' +
      '\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>' +
      '\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>' +
      '\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>' +
      '\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>' +
      '\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>' +
      '\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>' +
      '\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\n<br></br>' +
      '\r\n<br></br>\r\n<br></br>\r\n<br></br>\r\nfdfdf' +
      '<img src=\'cid:332@goomoji.gmail\' style=\'margin:0pt 0.2ex; ' +
      'vertical-align:middle\'><img src=\'cid:364@goomoji.gmail\' ' +
      'style=\'margin:0pt 0.2ex; vertical-align:middle\'><br>' +
      '\r\n<\/body>\r\n<\/html>\r\n',
      'ReplyTofromAddr': 'From',
      'ccSapphire': 'CC',
      'attachment': [ {
        'mimetype': 'image\/jpeg',
        'attachPath': '.',
        'attachName': 'IMG_2862.JPG',
        'attachIndexinArray': 0,
        'attachsize': 0
      }, {
        'mimetype': 'text\/x-txt',
        'attachPath': '.',
        'attachName': 'log.txt',
        'attachIndexinArray': 1,
        'attachsize': 0
      },{
        'mimetype': 'text\/x-html',
        'attachPath': '.',
        'attachName': 'test.html',
        'attachIndexinArray': 2,
        'attachsize': 0
      },{
        'mimetype': 'text\/x-java',
        'attachPath': '.',
        'attachName': 'AbsRequestController.java',
        'attachIndexinArray': 3,
        'attachsize': 0
      },{
        'mimetype': 'pdf\/x-pdf',
        'attachPath': '.',
        'attachName': 'schedules.pdf',
        'attachIndexinArray': 4,
        'attachsize': 0
      } ]
    }];
  },

  getDownloadAttachData: function() {
    return [{
      'id': 0,
      'MessageId': 0,
      'ret': 0}];
  },

  getContentImage: function() {
    return [{
      'ret': 1,
      'mailcontent': 'test',
      'downloadimage' : 0,
      'downloadingimage': true}];
  },

  getRemaining: function() {
    return [{
      'ret': 1,
      'mailcontent': 'test',
      'gettingremaining': true,
      'mLoadAllDataDone': false,
      'remaningsize': 0}];
  },

  getAttachData: function() {
    return [{
      'attachment':[
        {
          'mimetype':'image\/jpeg',
          'attachPath': '.',
          'attachName': 'IMG_2862.JPG',
          'attachIndexinArray': 0,
          'attachsize': 0,
          'fromServer': 1
        },
        {
          'mimetype': 'text\/x-txt',
          'attachPath': '.',
          'attachName': 'log.txt',
          'attachIndexinArray': 1,
          'attachsize': 0,
          'fromServer': 1
        },
        {
          'mimetype': 'text\/x-html',
          'attachPath': '.',
          'attachName': 'test.html',
          'attachIndexinArray': 2,
          'attachsize': 0,
          'fromServer': 1
        },
        {
          'mimetype': 'text\/x-java',
          'attachPath': '.',
          'attachName': 'AbsRequestController.java',
          'attachIndexinArray': 3,
          'attachsize': 0,
          'fromServer': 1
        },
        {
          'mimetype': 'pdf\/x-pdf',
          'attachPath': '.',
          'attachName': 'schedules.java',
          'attachIndexinArray': 4,
          'attachsize': 0,
          'fromServer': 1
        }]}];
  },

  setPeakTimeSettingData: function(set,
    onSelectedSchedule, offSelectedSchedule, startHourofDay,
    startMinute, endHourofDay, endMinute) {
    EventManager.broadcastEvent('SetPeakTimeCompleteSettingCallBack', [{}]);
  },

  getPeakTimeSettingData: function() {
    EventManager.broadcastEvent('GetPeakTimeSettingCallBack',
      this.getPeakTimeData());
  },

  updateMailDownloadDays: function(mode, newVal){
    EventManager.broadcastEvent('UpdateMailDownloadDaysCompleteCallBack',
      [{'result':true}]);
  },

  getMailDownloadDays: function() {
    EventManager.broadcastEvent('GetMailDownloadDaysCallBack',
      this.getDownloadDaysData());
  },

  getAccountSettingData: function() {
    EventManager.broadcastEvent('GetAccountSettingDataCallBack',
      this.getAccountSetting());
  },

  getPeakTimeData: function() {
    /**
     * peakDays is union of selected days value
     * Days value: Mon(1), Tue(2), Wen(4), Thu(8), Fri(16), Sat(32), Sun(64)
     * For example 31 mean Mon(1), Tue(2), Wen(4), Thu(8), Fri(16) will be
     * selected
     */
    /**
     * syncSchedulePeak and syncScheduleOffPeak is 0~9 and is illustrated as
     * 0  'Manual';
     * 1  'As items arrive (Push)';
     * 2  'Every 5 minutes';
     * 3  'Every 10 minutes';
     * 4  'Every 15 minutes';
     * 5  'Every 30 minutes';
     * 6  'Every hour';
     * 7  'Every 2 hours';
     * 8  'Every 4 hours';
     * 9  'Once a day';
     */
    return [{
      'syncSchedule': 2,
      'allowautosync': true}];
    return peakTimeData;
  },

  getDownloadDaysData: function() {
    /**
     * filterType
     * 0 : ALL
     * 1 : 1 day
     * 2 : 3 days
     * 3 : 1 week
     * 4 : 2 weeks
     * 5 : 1 month
     */
    return [{'filterType': 2}];
  },

  getAccountSetting: function () {
    return [{
      'signatureContent': 'Send from my mobile',
      'usesignature': true,
      'askBeforeDelete': true,
      'refreshMailOpenFolder': true,
      'defaultaccount': true}];
  },

  setAccountSettingData: function () {
  },

  getAccountData: function() {
    return [{
      'easpasswordpolicy': '0',
      'mailAddress': 'bsummers@fb.com',
      'serverName': 'mail.thefacebook.com',
      'domainName': 'thefacebook',
      'userName': 'bsummers',
      'password': '8dY:\'S!1',
      'useSSL': 1}];
  },

  getSearchContactsData: function() {
    return [[{
      'displayName':'wrosenberg','emailAddress':'wrosenberg@fb.com'}, {
      'displayName':'bsummers','emailAddress':'bsummers@fb.com'}, {
      'displayName':'wrosenberg','emailAddress':'wrosenberg@fb.com'}, {
      'displayName':'bsummers','emailAddress':'bsummers@fb.com'}]];
  },

  getAttachmentFileListData: function() {
    return [[{'fileName': 'log.txt'}]];
  },

  getCalendarData: function() {
    EventManager.broadcastEvent('CalendarGetDataCallBack',
      this.getCalendarDataCallBack());
  },

  getCalendarDataCallBack: function() {
    return [[{
        'date':'Sat, Nov 5, 2011',
        'firstcell':112,
        'event': [
      {
        'point1':[9.0,38.0],
        'point2':[533.0,70.399994],
        'title':'NHL',
        'date':'Fri, Nov 4, 2011 - Sat, Nov 5, 2011',
        'index':0,
        'calendarid':3,
        'allday':true,
        'starttime':960,
        'endtime':960,
        'location':'san jose',
        'participants':'GY_chen@abc.com',
        'description':' '
      },
      {
        'point1':[9.0,74.0],
        'point2':[533.0,106.399994],
        'title':'ff',
        'date':'Fri, Nov 4, 2011 - Sat, Nov 5, 2011',
        'index':1,
        'calendarid':2,
        'allday':true,
        'starttime':960,
        'endtime':960,
        'location':'ff',
        'participants':'',
        'description':' '
      },
      {
        'point1':[84.0,128.0],
        'point2':[233.66667,1646.0],
        'title':'gfghhjjhhjj@ 2011-11-05 (saturday) (GY_chen@abc.com)',
        'date':'Fri, Nov 4, 2011 - Sat, Nov 5, 2011',
        'index':2,
        'calendarid':26,
        'allday':false,
        'starttime':960,
        'endtime':960,
        'location':'',
        'participants':'GYchen0330@gmail.com',
        'description':' '
      },
      {
        'point1':[233.66667,508.0],
        'point2':[383.33334,601.0],
        'title':'es(GY_chen@abc.com)',
        'date':'Sat, Nov 5, 2011 - Sat, Nov 5, 2011',
        'index':3,
        'calendarid':11,
        'allday':false,
        'starttime':240,
        'endtime':300,
        'location':'',
        'participants':'GYchen0330@gmail.com',
        'description':' '
      },
      {
        'point1':[383.33334,508.0],
        'point2':[533.0,601.0],
        'title':'GY_chen@abc.com)',
        'date':'Sat, Nov 5, 2011 - Sat, Nov 5, 2011',
        'index':4,
        'calendarid':12,
        'allday':false,
        'starttime':240,
        'endtime':300,
        'location':'',
        'participants':'GYchen0330@gmail.com',
        'description':' '
      },
      {
        'point1':[233.66667,934.0],
        'point2':[383.33334,1029.0],
        'title':'9:30 (GY_chen@abc.com)',
        'date':'Sat, Nov 5, 2011 - Sat, Nov 5, 2011',
        'index':5,
        'calendarid':10,
        'allday':false,
        'starttime':510,
        'endtime':570,
        'location':'',
        'participants':'GYchen0330@gmail.com',
        'description':' '
      },
      {
        'point1':[383.33334,983.0],
        'point2':[533.0,1076.0],
        'title':' (GY_chen@abc.com)',
        'date':'Sat, Nov 5, 2011 - Sat, Nov 5, 2011',
        'index':6,
        'calendarid':9,
        'allday':false,
        'starttime':540,
        'endtime':600,
        'location':'',
        'participants':'GYchen0330@gmail.com',
        'description':' '
      }]}]];
  },

  getEventInfoData: function() {
    EventManager.broadcastEvent('CalendarGetDetailInfoCallBack',
      this.getEventCalendarInfoDataCallBack());
  },

  getEventCalendarInfoDataCallBack: function() {
    return [{
      'result':true,
      'starttime':'Thu, Jan 1, 1970 (GMT)',
      'endtime':'12:00 AM - 12:00 AM',
      'location':'Giga 10F 8001',
      'phoneNumber':'',
      'title':'Internal Training',
      'allDay':true,
      'description':'this is a meeting',
      'eventTimezone':'Antarctica\/Casey',
      'color':0,
      'hasAlarm':true,
      'rRule':'FREQ=WEEKLY;WKST=SU;BYDAY=MO;INTERVAL=1',
      'organizer':'test@ff.com',
      'calendarname':'ffffn@ff.com',
      'repeatString':'Weekly (every Monday)',
      'participants':'abc; edg'
    }];
  },

  refreshCalendar: function() {
  }
};
});

// module: bolt_touch/vendor/jinertial_model
// file:   ../../../frameworks/bolt_touch/lib/vendor/jinertial_model.js
define("bolt_touch/vendor/jinertial_model", function(require, exports, module) {
// Copyright 2011 Facebook, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.

/*
  jInertialModel scrolling library model
  Author: Jonathan Kaldor (jmkaldor@fb.com)

  Library which plugs into JScroll and provides standard
  one dimensional inertial scrolling behavior

*/
function JInertialModel(options) {
  // Parameters to control the physical simulation
  this.options = JInertialModel.getDefaultOptions();

  for (var i in options) {
    this.options[i] = options[i];
  }

  this.scrollEnabled = true;

  // Variables holding the simulated data.
  this.sim = {
    "position" : Array(32),
    "velocity" : Array(32),
    "dataLen" : 0,
    "duration" : 0,
    "fps" : this.fps,
    "getPosition" : function(time) { return this.interp(time, this.position); },
    "getVelocity" : function(time) { return this.interp(time, this.velocity); },
    "needAnimation" : function() { return this.dataLen >= 2 && this.position[0] != this.position[1]; },
    "interp" : function(time, arr) {
      var index = time*this.fps;
      var val = 0;
      if (index >= this.dataLen - 1) {
        val = arr[this.dataLen-1];
      } else if (index < 0) {
        val = arr[0];
      } else {
        var param = index - Math.floor(index);
        index = Math.floor(index);
        val = arr[index]*(1-param) + arr[index+1]*param;
      }
      return val;
    }
  };

  this.options.pageChangeRatio = Math.max(0.0, Math.min(1.0, this.options.pageChangeRatio));
  this.location = 0;
  this.desiredLocation = 0;
  this.viewportArea = 0;
  this.scrollAreaStart = 0;
  this.scrollAreaEnd = 0;
  this._currentPagePosition = 0;
  this._currentPage = 0;
  this._tmpPageBounds = [0, 0];
  this._tmpViewBounds = [0, 0];
}

JInertialModel.getDefaultOptions = function() {
  return {
    overscrollRatio: 1.0,
    fps: 30.0,
    constDampFree: 1.5,
    constDampBounce: 3.0,
    linDampFree: 2.2,
    linDampBounce: 18.0,
    linSpringBounce: 280.0,
    posDampBounce: 15.0,
    linSpringPage: 16000,
    constDampPage: 10,
    posDampPage: 13.0,
    stopAtBoundary: true,
    minBounceVel: 10.0,
    pageSizes: [],
    pageChangeRatio: 0.8,
    maxPageChanges: 2,
    maxOscillations: 1,
  };
}

JInertialModel.getDefaultPaginatedOptions = function(pageSize) {
  var opts = JInertialModel.getDefaultOptions();
  opts.pageSizes = [pageSize || -1];
  opts.minBounceVel = 100.0;
  return opts;
}

JInertialModel.getDefaultSelectorOptions = function(pageSize) {
  var opts = JInertialModel.getDefaultOptions();
  opts.pageSizes = [pageSize || -1];
  opts.minBounceVel = 100.0;
  opts.linSpringPage = 2000;
  opts.posDampPage = 2.5;
  opts.constDampPage = 5;
  opts.maxPageChanges = 100000;
  opts.maxOscillations = 2;
  return opts;
}

JInertialModel.prototype.enabled = function(enable) {
  this.scrollEnabled = enable;
}

JInertialModel.prototype.setViewportSize = function(width) {
  this.viewportArea = width;
}
JInertialModel.prototype.getViewportSize = function() {
  return this.viewportArea;
}

JInertialModel.prototype.setScrollableArea = function(left, right) {
  this.scrollAreaStart = left;
  this.scrollAreaEnd = right;
  this._currentPagePosition = this.scrollAreaStart;
  this._currentPage = 0;
  this._updatePageForPosition(this.location);
}

JInertialModel.prototype.getPosition = function() {
  return this.location;
}

JInertialModel.prototype.setPosition = function(x) {
  this.location = x;
  this.desiredLocation = x;
  this._updatePageForPosition(this.location);
}

JInertialModel.prototype.getPage = function() {
  return this._currentPage;
}
JInertialModel.prototype.setPageSizes = function(pageSize) {
  this.options.pageSizes = pageSize;
  this._currentPagePosition = this.scrollAreaStart;
  this._currentPage = 0;
  this._updatePageForPosition(this.location);
}

JInertialModel.prototype.updatePosition = function(dx) {
  // Update the desired location of the scrollable region.  This is where it
  // would be if we didn't have any overscroll resistance
  this.desiredLocation = this.desiredLocation + (this.scrollEnabled ? dx : 0);

  var viewLen = this.viewportArea;
  var scrollLen = this.scrollAreaEnd - this.scrollAreaStart;
  var desired = this.desiredLocation;
  var targetLen = Math.max(scrollLen, this.viewportArea);
  var actualV = desired;
  // Compute the static equilibrium of the overscroll springs
  // if the box is out of bounds
  if (desired < this.scrollAreaStart ||
      desired > this.scrollAreaStart + targetLen - viewLen) {
    var bound = this.scrollAreaStart;
    if (desired > this.scrollAreaStart + targetLen - viewLen) {
      bound += targetLen - viewLen;
    }
    actualV = (desired + this.options.overscrollRatio*bound) / (1 + this.options.overscrollRatio);
  }
  this.location = actualV;
  this._updatePageForPosition(this.location);
  return this.location;
}

JInertialModel.prototype.fling = function(vx) {
  // If the scroll is disabled we set the velocity to 0 but still simulate in case
  // we were in an overscroll situation
  if (!this.scrollEnabled) {
    vx = 0;
  }
  this.sim.dataLen = this.simulate1D(this.location, vx, this.sim.position, this.sim.velocity,
                                     this.scrollAreaStart, this.scrollAreaEnd, this.viewportArea);
  this.sim.duration = (this.sim.dataLen-1)/this.options.fps;
  this.sim.fps = this.options.fps;

  return this.sim;
}

JInertialModel.prototype.simulate1D = function(pos, vel, posArr, velArr, scrollStart, scrollEnd, viewLen) {
  var h = 1.0/this.options.fps;
  // This is the effective size of the scrollable region.  If the scrollable
  // region is smaller than the actual viewport, we treat it as if it were as
  // big as the viewport
  var scrollLen = scrollEnd - scrollStart;
  var targetLen = Math.max(scrollLen, viewLen);
  var maxOverscrollDist = Math.max(viewLen / (1 + this.options.overscrollRatio), 1);

  posArr[0] = pos;
  velArr[0] = vel;
  var dataLen = 1;

  var pages = this.options.pageSizes;
  var numPages = pages.length;
  var paginatedMode = (numPages > 0);
  this._updatePageForPosition(pos);
  var remainingPageChanges = this.options.maxPageChanges;
  var startPage = this._currentPage;
  var farthestPage = this._currentPage;
  var lastGoodPageStep = -1;
  var lastGoodPagePosition = -1;
  var oscillationCount = 0;

  // Flag to mark if we need to simulate regardless of velocity
  // tolerance.  We force ourselves to take one step, and then
  // we force simulation if we're outside the bounds of the container
  var mustSim = true;
  while (Math.abs(vel) > 1 || mustSim) {
    // \dot{x} = v
    // \dot{v} = f/m
    // assume unit mass (unless we want to scroll large windows
    // differently?)

    // implict euler for stability
    // x_{i+1} - x_{i} = h v_{i+1}
    // v_{i+1} - v_{i} = h f(x_{i+1}, v_{i+1})

    // dx = h (v_i + dv)
    // dv = h f(x + dx, v + dv)
    // linearize f
    // dv = h (f_i + dx*partial(f, x) + dv*partial(f, v))
    // dv = h f_i + h*(h v_i + h dv)*partial(f, x) + h*dv*partial(f, v)
    // dv - h*dv*partial(f,v) - h^2*dv*partial(f, x) = h f_i + h^2 * v_i * partial(f, x)
    // dv = (h f_i + h^2 * v_i * partial(f, x)) / (1 - h*partial(f, v) - h^2*partial(f,x))
    // substitute into expression for dx to get position
    var force = 0;
    var dfdv = 0;
    var dfdx = 0;
    var constDamp = 0;
    // Whether or not we're in the bounce part of the animation,
    var isBouncing = false;
    var isBouncingOnBoundary = false;
    var bounceTarget = 0;
    var minBounceVelScale = 0;

    // Determine whether we're bouncing at the top or bottom of the page,
    // or inertial scrolling somewhere between.  The first if block also
    // applies the spring force and set the bouncing parameters appropriately,
    // as well as mustSim so we don't accidentally stop at the bounce peak
    if (pos < scrollStart || pos > scrollStart + targetLen - viewLen) {
      var overscrollDist = 0;
      var overscrollDirection = 0;
      var shouldDamp = false;
      isBouncing = true;
      isBouncingOnBoundary = true;
      if (pos < scrollStart) {
        overscrollDist = scrollStart - pos;
        overscrollDirection = -1;
        shouldDamp = vel > 0;
        bounceTarget = scrollStart;
      } else {
        overscrollDist = pos - (scrollStart + targetLen - viewLen);
        overscrollDirection = 1;
        shouldDamp = vel < 0;
        bounceTarget = scrollStart + targetLen - viewLen;
      }
      force = -this.options.linDampBounce*vel - overscrollDirection*overscrollDist*this.options.linSpringBounce;
      dfdx = -this.options.linSpringBounce;
      dfdv = -this.options.linDampBounce;

      if (shouldDamp && overscrollDist < maxOverscrollDist) {
        var posScale = (maxOverscrollDist - overscrollDist)/maxOverscrollDist;
        force = force - vel*this.options.posDampBounce*posScale;
        dfdx = dfdx + vel*overscrollDirection*this.options.posDampBounce/maxOverscrollDist;
        dfdv = dfdv - this.options.posDampBounce*posScale;
      }

      mustSim = true;
      constDamp = this.options.constDampBounce;
    } else {
      force = -this.options.linDampFree*vel;
      dfdv = -this.options.linDampFree;
      dfdx = 0;
      mustSim = false;
      constDamp = this.options.constDampFree;

      if (paginatedMode) {
        // Current page should be updated, so we only need to check whether
        // the centerline is outside of the free scrolling region of the current
        // page to tell whether we should attract to something (if so, we then
        // need to determine which free scrolling region to attract to)
        var index = this._currentPage % numPages;
        var pageLen = (pages[index] <= 0 ? viewLen : pages[index]);
        var pageAttractionSize = Math.min(pageLen, viewLen) / 2;
        var pageFreeScrollSize = pageLen/2 - pageAttractionSize;
        var centerline = pos + viewLen / 2;
        var pageCenterDelta = this._currentPagePosition + (pageLen/2) - centerline;

        if (Math.abs(pageCenterDelta) > pageFreeScrollSize) {
          var attractionPoint = 0;
          var attractionScale = 0;

          if (pageCenterDelta > pageFreeScrollSize + pageAttractionSize) {
            // Attracted to previous page
            if (this._currentPage > 0) {
              index = (this._currentPage - 1) % numPages;
              pageLen = (pages[index] <= 0 ? viewLen : pages[index]);
              pageAttractionSize = Math.min(pageLen, viewLen) / 2;
              attractionPoint = this._currentPagePosition - pageAttractionSize;
              attractionScale = 1.0 / pageAttractionSize;
            }

          } else if (pageCenterDelta >= pageFreeScrollSize) {
            // Attracted to left boundary of current page
            attractionPoint = this._currentPagePosition + pageAttractionSize;
            attractionScale = 1.0 / pageAttractionSize;

          } else if (pageCenterDelta >= -pageFreeScrollSize - pageAttractionSize) {
            // Attracted to right boundary of current page
            attractionPoint = this._currentPagePosition + pageLen - pageAttractionSize;
            attractionScale = 1.0 / pageAttractionSize;

          } else {
            // Attracted to next page
            if (this._currentPagePosition + pageLen < scrollStart + scrollLen) {
              attractionPoint = this._currentPagePosition + pageLen;
              index = (this._currentPage + 1) % numPages;
              pageLen = (pages[index] <= 0 ? viewLen : pages[index]);
              pageAttractionSize = Math.min(pageLen, viewLen) / 2;
              attractionPoint += pageAttractionSize;
              attractionScale = 1.0 / pageAttractionSize;
            }
          }

          var direction = attractionPoint - centerline;
          force += attractionScale * this.options.linSpringPage * (attractionPoint - centerline);
          dfdx += -attractionScale * this.options.linSpringPage;
          var dampScale = this.options.posDampPage*attractionScale;
          if (vel > 0 && direction > 0) {
            dampScale = this.options.posDampPage*attractionScale;
          } else if (vel < 0 && direction < 0) {
            dampScale = -this.options.posDampPage*attractionScale;
          }
          force -= vel*dampScale*direction;
          // TODO: wtf signage?
          dfdx -= vel*dampScale
          dfdv -= dampScale*direction;

          mustSim = true;
          constDamp = this.options.constDampPage;
          // Have to shift bounce target because it is relative to the left
          // boundary of the viewport
          bounceTarget = attractionPoint - viewLen/2;
          isBouncing = true;
        }
      }
    }

    var denom = (1 - h*dfdv - h*h*dfdx);
    if (denom < 0) {
      // Bad things have happened.  Need to recover somehow.
      // I'll need to think about this some more.  With good
      // parameters this should never happen, though
      denom = 1;
    }
    var dv = (h*force + h*h*vel*dfdx) / denom
    vel = vel + dv;

    // Apply the constant damping.  This looks like
    // vCons = vOld - sign(vOld)*constDamp
    // vNew = (sign(vCons) != sign(vOld) ? 0 : vCons)
    // i.e. remove a constant amount from the velocity, up until
    // we either remove constCorrect amount of velocity or we
    // zero the velocity
    var constCorrect = (vel > 0 ? -constDamp : constDamp);
    if (Math.abs(constCorrect) > Math.abs(vel)) {
      vel = 0;
    } else {
      vel += constCorrect;
    }

    // Need to make sure if we're bouncing up we don't go past the overscroll boundary.
    // This is pretty hacky at the moment; still trying to think of a better way.
    // Note: NOT keyed on bouncingTop or bouncingBottom since otherwise a super hard
    // flick from the other side of the boundary won't be caught by this.
    if (vel < 0 && pos + h*vel < scrollStart - maxOverscrollDist) {
      // adjust velocity so that we don't go past 80% of the remaining distance
      vel = Math.min(0.8*(-maxOverscrollDist - pos) / h, 0);
    } else if (vel > 0 && pos + h*vel > scrollStart + targetLen - viewLen + maxOverscrollDist) {
      vel = Math.max(0.8*(targetLen - viewLen + maxOverscrollDist - pos) / h, 0);
    }

    // Need to make sure if we're on the wrong side of the boundary that we
    // don't stop, because we might not be able to start back up.  This
    // can happen if constDampBounce > 0
    if (isBouncing && Math.abs(vel) < this.options.minBounceVel) {
      vel = (pos < bounceTarget ? this.options.minBounceVel : -this.options.minBounceVel);
    }

    var oldPos = pos;
    pos = pos + h*vel;
    // If we're stopping at the boundary, and we were bouncing at the start
    // of the step but would no longer be bouncing on the next step, fix
    // the position at the boundary and break out of the loop
    if (this.options.stopAtBoundary && isBouncingOnBoundary &&
        ((oldPos < bounceTarget && pos >= bounceTarget) ||
         (oldPos > bounceTarget && pos <= bounceTarget))) {
      pos = bounceTarget;
      mustSim = false;
      vel = 0;
    }

    posArr[dataLen] = pos;
    velArr[dataLen++] = vel;

    // Update the page variables for the new position
    if (paginatedMode) {
      var oldPage = this._currentPage;
      this._updatePageForPosition(pos);
      var currPageLen = this.options.pageSizes[this._currentPage % numPages];
      currPageLen = (currPageLen <= 0 ? viewLen : currPageLen);

      if (oldPage != this._currentPage) {
        oscillationCount = 0;
        remainingPageChanges = remainingPageChanges - Math.abs(oldPage - this._currentPage);
        if (remainingPageChanges < 0) {
          var pageDelta = (oldPage < this._currentPage ? 1 : -1) * remainingPageChanges;
          pos = this._getPositionForPage(this._currentPage + pageDelta);
          this._updatePageForPosition(pos);
          posArr[dataLen-1] = pos;
          velArr[dataLen-1] = 0;
          break;
        }
      }

      var pageCenterline = this._currentPagePosition + currPageLen/2;
      var pageAttractionSize = Math.min(currPageLen, viewLen) / 2;
      var pageFreeScrollSize = currPageLen/2 - pageAttractionSize;
      var centerline = pos + viewLen / 2;
      var oldCenterline = posArr[dataLen-2] + viewLen/2;
      // Check whether the centerline of the view crossed through the free
      // scrolling region of the page
      var leftCrossedLR = (pageCenterline - pageFreeScrollSize >= centerline &&
                           pageCenterline - pageFreeScrollSize <= oldCenterline);
      var leftCrossedRL = (pageCenterline - pageFreeScrollSize <= centerline &&
                           pageCenterline - pageFreeScrollSize >= oldCenterline);
      var rightCrossedLR = (pageCenterline + pageFreeScrollSize >= centerline &&
                            pageCenterline + pageFreeScrollSize <= oldCenterline);
      var rightCrossedRL = (pageCenterline + pageFreeScrollSize <= centerline &&
                            pageCenterline + pageFreeScrollSize >= oldCenterline);

      if (leftCrossedLR || leftCrossedRL || rightCrossedLR || rightCrossedRL) {
        // We started out on one side of the page boundary and ended up on the
        // other side
        oscillationCount++;
        if (pageFreeScrollSize > 0 &&
            ((leftCrossedLR && rightCrossedLR) || (leftCrossedRL && rightCrossedRL))) {
          // The page had a nonzero free scroll range and we crossed both
          // sides.  Count it as a double oscillation
          oscillationCount++;
        }
        if (oscillationCount > this.options.maxOscillations &&
            oldPage == this._currentPage) {
          // We're oscillating around a single page.  Break, and use the last
          // time we crossed the boundary as the final point to move to
          break;
        }

        // Record this as the last good index in case we are going to come to
        // a stop on this page
        lastGoodPageStep = dataLen-1;

        if (leftCrossedLR || (!rightCrossedRL && leftCrossedRL)) {
          lastGoodPagePosition = pageCenterline - pageFreeScrollSize - viewLen/2;
        } else {
          lastGoodPagePosition = pageCenterline + pageFreeScrollSize - viewLen/2;
        }
      }
    }

    if (dataLen > 200) {
      // Something has clearly gone wrong.  We should never get here
      // with reasonable parameters
      break;
    }
  }

  if (lastGoodPageStep > 0) {
    dataLen = lastGoodPageStep+1;
    posArr[dataLen-1] = lastGoodPagePosition;
    velArr[dataLen-1] = 0;
  }
  return dataLen;
}

// Note: updates private properties _currentPagePosition and _currentPage which
// are used during simulate1D().  Only updates to the next page when the old page
// slides completely out of view
JInertialModel.prototype._updatePageForPosition = function(pos) {
  var pages = this.options.pageSizes;
  var numPages = pages.length;
  if (numPages == 0) {
    this._currentPagePosition = this.scrollAreaStart;
    this._currentPage = 0;
    return;
  }

  var centerline = pos + this.viewportArea / 2;
  var pagePos = this._currentPagePosition;
  var page = this._currentPage;
  var index = page % numPages;
  var pageLen = pages[index] <= 0 ? this.viewportArea : pages[index];

  var changeRatio = this.options.pageChangeRatio;
  var pageAttractionSize = Math.min(pageLen, this.viewportArea) / 2;
  // Skim ahead until we get to a page whose end boundary is past the current
  // position
  while (centerline - pagePos - pageLen >= changeRatio*pageAttractionSize &&
         pagePos + pageLen < this.scrollAreaEnd) {
    pagePos += pageLen;
    page = page + 1;
    index = page % numPages;
    pageLen = pages[index] <= 0 ? this.viewportArea : pages[index];
    pageAttractionSize = Math.min(pageLen, this.viewportArea) / 2;
  }

  // Now skim backwards until we get to a page whose start boundary is
  // before the right edge of the page viewport (the smaller of the viewport
  // and the page size
  while (pagePos - centerline >= changeRatio*pageAttractionSize &&
         page > 0) {
    page = page - 1;
    index = (page - 1) % numPages;
    pageLen = pages[index] <= 0 ? this.viewportArea : pages[index];
    pagePos -= pageLen;
    pageAttractionSize = Math.min(pageLen, this.viewportArea) / 2;
  }
  this._currentPagePosition = pagePos;
  this._currentPage = page;
}

JInertialModel.prototype._getPositionForPage = function(pageNum) {
  var pos = this.scrollAreaStart;
  var pages = this.options.pageSizes;
  var numPages = pages.length;
  for (var i = 0; i < pageNum; ++i) {
    var index = i % numPages;
    var pageLen = (pages[index] <= 0 ? this.viewportArea : pages[index]);
    if (pos + pageLen >= this.scrollAreaEnd) {
      break;
    }
    pos += pageLen;
  }
  return pos;
}

if (typeof exports !== 'undefined') {
  exports.jInertialModel = JInertialModel;
}
});

// module: bolt/mixins/container
// file:   ../../../frameworks/bolt/lib/mixins/container.js
define("bolt/mixins/container", function(require, exports, module) {
/**
 * Copyright (c) 2011-2012, Facebook, Inc.
 * All rights reserved.
 *
 * @option preserve-header
 *
 */

var util     = require('../util');
var core     = require('../core');
var dom      = require('../dom');
var builder  = require('../builder');
var domEvent = require('../dom_event');
var Event    = require('../event').Event;
var defaultEventDispatcher = require('../event_dispatcher').defaultEventDispatcher;

var Binding  = require('../binding').Binding;
var TokenList = require('../token_list').TokenList;

var EventShim = require('../compat/event').EventShim;

/* This options are special. They are handled during or event before setup
 * There's no way to define normal options with the given names */
var SETUP_OPTIONS = {
  owner: true,
  childViews: true,
  view: true,
  tagName:true
};

var ContainerRegistry = {};

var emptyArr = [];

/**
 * Mixin for dom-node-rooted containers.
 * A Container is a dom-node-rooted object that provides the functionality:
 *  1. Ability to contain other Containers.
 *  2. May be contained within another Container.
 *  3. Partially participates in reference tracking - to the extent that it
 *     may *be a reference* of it's owner.
 *
 * The requirements for using this mixin are:
 *  1. The class who mixes this in must provide the container's node when
 *      requested with this.getNode(). The mixer may allocate the node in any
 *      way they wish, but it mustn't be appended to the dom yet. The BoltJs
 *      system will handle placing the container into the heirarchy and
 *      eventually placing the entire tree into the dom.
 *  2. Before invoking the constructor from this mixin, the ability to provide
 *     this.getNode() must be implemented - the node needs to be allocated and
 *     available before invoking this mixin's 'construct' function.
 *
 * Does *not* provide functionality for:
 *  1. Keeping track of it's own references. There should never be references
 *    to this.refs. This mixin might be used in mixers who do not track their
 *    references (TagView etc.)
 *  2. Delegating any properties to it's node. (This might not be true - but
 *    we should try to make it true.)
 *
 * Any class that mixes in Container also receive seters and getters on some
 * very commonly used attributes that are relevant to any view that is a
 * container.
 *
 * @jwalke todo: consider removing ownership tracking (at least from this
 *                mixin. It can consume a lot of time for mixers who don't
 *                need to establish ownership).
 *
 */

var findClosest = exports.findClosest = function(node) {
  while (node) {
    var id = dom.identify(node);
    if (ContainerRegistry[id]) {
      return ContainerRegistry[id];
    }
    node = node.parentNode;
  }
  return null;
};

var Container = exports.Container = {

  properties: {
    model: null,
    persistentDisplay: null,
    eventManager: null
  },

  classExtended: function(klass, config) {
    addDelegateProperties(klass, config);
  },

  mixinIncluded: function(klass, config) {
    addDelegateProperties(klass, config);
  },

  delegateProperties: {
    node: [
      /* @jwalke let's not delegate tagName, it's just extra CPU to set,
       * is redundant, and if you want to get the tagName, you should know it
       * because you set it!        // this'tagName', */
      'scrollTop',
      'scrollLeft',
      'scrollHeight',
      'scrollWidth',
      { name: 'innerHTML', alias: 'content'},
      { name: 'innerHTML', alias: 'dangerouslyInjectedHtml' }
    ]
  },

  /* private properties with getters and setters that have default values */
  _node: null,
  _owner: null,
  _parentView: null,
  _inDocument: false,

  setContent: function(content) {
    this.clearChildren();
    dom.replaceContent(this.getNode(), content);
  },

  /**
   * This function is equivalent to eval(), with a slightly different
   * input encoding. Passing around raw HTML strings is the easiest
   * way to accidentally introduce XSS holes. When it cannot be
   * avoided, e.g. when you receive a trusted HTML string from outside
   * your program, the easiest way to limit the amount of code that
   * can potentially introduce an XSS hole is to exchange the string
   * for an actual DOM nodes as soon as possible (see DOM.fromHTML).
   */
  setDangerouslyInjectedHtml: function(dangerouslyInjectedHtml) {
    this.clearChildren();
    dom.dangerouslyInjectHtml(this.getNode(), dangerouslyInjectedHtml);
  },

  /*
   * The following functions are called often during view construction, so we
   * optimize them.
   */
  getNode: function() {
    return this._node;
  },
  setNode: function(node) {
    this._node = node;
    return this;
  },

  getClassName: function() {
    return this._node.className;
  },
  setClassName: function(className) {
    this._node.className = className;
    return this;
  },

  /**
   * This sets up the child views, establishing ownership, and sets the options.
   *
   * Before: this.getNode() must return the container node.
   */
  setup: function(options) {
    if (!this._childViews) {
      this._childViews = [];
    }

    // owner is used in various places during the setup process so we
    // guarantee that it is always set before any other options.
    if ('owner' in options) {
      this._owner = options.owner;
    }

    // childViews is always handled first. This means that we setup the
    // hierarchy recursively depth first. This is important because it
    // allows the full hierarchy of refs to be defined before any potential
    // delegate properties are setup which might need to reference a child.
    if ('childViews' in options) {
      this.setChildViews(options.childViews);
    }

    this.setupOptions(options);

    /* register a reference on the dom node, so we can find the view later
     * from it. To prevent possible memory leaks in some of the browsers
     * register through an id instead of an attribute on a node */
    ContainerRegistry[dom.identify(this._node)] = this;

    if (defaultEventDispatcher.getEnabled()) {
      defaultEventDispatcher.registerView(this);
    }
  },


  /**
   * Mixers may override this to do something more optimial.
   */
  setupOptions: function(options) {
    /*
     * This likely doesn't belong in the 'Container' mixin. Containers only
     * provide functionality for managing a set of children under a dom node
     * root.
     */
    for (var key in options) {
      if (!SETUP_OPTIONS[key]) {
        this._setupOption(key, options[key]);
      }
    }
  },


  /**
   * #todoverysoon: This probably doesn't belong in this base class and we
   * should not automatically set things on the node by default when we can't
   * find a setter.
   */
  _setupOption: function(key, value) {
    var setter = util.setter(key);

    if (this[setter]) {
      // if we have a setter, just set
      this[setter](value);
    } else if (key.substring(0,2) === 'on') {
      // if it looks like event, add an event listener
      var context = null;
      if (typeof value === 'string') {
        var owner = this.getOwner();
        if (owner[value]) {
          context = owner;
        } else {
          // Must be able to assign a listener to yourself from declare()
          context = this;
        }
        value = context[value];
      }

      this.addListener(key.substring(2), value, context);
    } else {
      // as a last resort set the value on the node directly
      if(typeof(value) !== 'function' && typeof(value) !== 'object')
        this.getNode().setAttribute(key, value);
    }
  },

  getOwner: function() {
    var owner = this._owner;
    if (!owner) {
      var parentView = this._parentView;
      owner = (parentView && parentView.getOwner()) || this;
      this._owner = owner;
    }
    return owner;
  },

  setOwner: function(owner) {
    this._owner = owner;
    return this;
  },


  /**
   * DATA BINDING
   */

  /**
   * TODO:wbailey revisit this
   */
  setBinding: function(options) {
    // NB:wbailey deprecating the 3 arguments signature in favor of passing
    // a single object argument that contains the three required keys.
    var model, bindingOptions, defaultBindingOptions;
    if (arguments.length === 1 && typeof options === 'object') {
      model = options.model;
      bindingOptions = options.options;
      defaultBindingOptions = options.defaultOptions;
    } else {
      model = arguments[0];
      bindingOptions = arguments[1];
      defaultBindingOptions = arguments[2];
    }
    this.set('model', model);
    this.removeBinding();
    this._binding = [];

    // Create multiple binding objects, one per property binding.
    // This creates a listener per binding.  It optimizes for the use
    // case where a widget will almost always have just one binding.
    // The alternative is to create a single binding that listens to
    // a single 'onChange' method on a view, then does a map lookup
    // for each view-to-model binding and executes it.  At runtime
    // this will be much less performant, hence this approach.
    var opt;
    if (!util.isArray(bindingOptions)) {
      bindingOptions = [bindingOptions];
    }
    for (var i = 0; i < bindingOptions.length; i++) {
      opt = util.extend({}, bindingOptions[i]);
      if (defaultBindingOptions) {
        opt = util.copy(opt, defaultBindingOptions, true);
      }
      this._binding.push(new Binding(this, model, opt));
    }
  },

  /**
   * remove the view binding
   */
  removeBinding: function() {
    this._binding && util.run(this._binding, 'destroy');
  },


  /**
   * LAYOUT PROPERTIES
   */

  /**
   * show the view
   */
  show: function(disp) {
    if (disp) {
      core.deprecated('view.show(disp)',
        'view.show() (override the value of persistent display)');

      // Override the persistent display
      this.setPersistentDisplay(disp);
    }

    var currentDisplay = this.getStyle().display;
    if (!currentDisplay || currentDisplay === 'none')  {
      this.getStyle().display = this.getPersistentDisplay() || '';
    }
    return this;
  },

  /**
   * hide the view
   */
  hide: function() {
    var currentDisplay = this.getStyle().display || '';
    if (currentDisplay && currentDisplay !== 'none') {
      this.setPersistentDisplay(currentDisplay);
    }
    this.getStyle().display = 'none';
    return this;
  },

  toggle: function(state) {
    if (typeof state === 'undefined') {
      state = this.getStyle().display === 'none';
    }
    return state ? this.show() : this.hide();
  },

  /**
   * This is simply a duplication of the functions above, but in a form that is
   * suitable for properties in buidler views.
   */
  setIsDisplayed: function(isDisplayed) {
    if (isDisplayed) {
      this.show();
    } else {
      this.hide();
    }
    return this;
  },

  getIsDisplayed: function() {
    return this.getStyle().display !== 'none';
  },

  /**
   * add a class to the view
   */
  addClass: function(className) {
    dom.addClass(this.getNode(), className);
    return this;
  },

  /**
   * remove a class from the view
   */
  removeClass: function(className) {
    dom.removeClass(this.getNode(), className);
    return this;
  },

  // add a class if it is not present; remove it if it is
  toggleClass: function(className) {
    dom.toggleClass.apply(
      dom,
      [this.getNode()].concat(util.toArray(arguments)));
    return this;
  },

  // COMPAT
  conditionClass: function() {
    core.deprecated('view.conditionClass', 'view.toggleClass');
    return this.toggleClass.apply(this, arguments);
  },

  hasClass: function(className) {
    return dom.hasClass(this.getNode(), className);
  },

  /**
   * apply a css class that is mutually exclusive with other classes
   * in a given set and save the state in an instance variable
   *
   * e.g.
   *
   * setMode('flavor', 'chocolate');
   * setMode('flavor', 'vanilla');
   * setMode('flavor', 'strawberry');
   * would toggle between flavor-chocolate, flavor-vanilla and
   * strawberry-flavor css classes and capture the value in this.modes.state.
   *
   * This is useful when you have a view that has various mutually exclusive
   * modes that can be transitioned through via a top level css class.
   */
  setMode: function(mode, setting) {
    var node = this.getNode(),
        classes = node.className.split(/\s+/),
        newClasses = '',
        regexp = new RegExp('^' + mode + '-');
    for (var i = 0; i < classes.length; i++) {
      var cssClass = classes[i];
      if (!regexp.test(classes[i])) {
        newClasses += ' ' + cssClass;
      }
    }
    // if the mode being set is false then we remove
    // any set mode.
    this._modes = this._modes || {};
    if (setting) {
      newClasses += ' ' + mode + '-' + setting;
      this._modes[mode] = setting;
    } else {
      delete this._modes[mode];
    }
    node.className = util.trim(newClasses);
    return this;
  },

  /**
   * get a mode value from the cache
   */
  getMode: function(mode) {
    this._modes = this._modes || {};
    return this._modes[mode];
  },

  getStyle: function() {
    return this.getNode().style;
  },

  /**
   * set attributes on the node
   */
  setAttributes: function(attributes) {
    var node = this.getNode();
    for (var name in attributes) {
      node.setAttribute(name, attributes[name]);
    }
  },

  /**
   * build a layout from a layout spec with the specified owner
   */
  build: function(config, owner) {
    return builder.build(config, owner || this);
  },

  /**
   * build and append a layout
   */
  setLayout: function(layout, owner) {
    this.append(this.build(layout, owner));
  },

  getRect: function() {
    return dom.getRect(this.getNode());
  },

  getScrollAdjustedRect: function() {
    return dom.getScrollAdjustedRect(this.getNode());
  },

  /**
   * Apply a set of styles to the view.  Supports three variants of arguments.
   * The first is to pass the name and value of a single CSS property to
   * change, where the name is camelCased, e.g.
   *   setStyle('fontWeight', 'bold');
   *
   * The second is to pass a JSON object with name value pairs of one or more
   * style values to change, where the names are camelCased, e.g.
   *   setStyle({color: 'red', fontWeight: 'bold'});
   *
   * The third is to pass a CSS string, where names are hyphenated, and rules
   * are separated with semi-colons, as in a CSS file.
   *   setStyle('color:red; font-weight: bold;');
   */
  setStyle: function(styles) {
    var styleObj = this.getNode().style;
    if (arguments.length === 2) {
      // Apply the name/value pair
      styleObj[arguments[0]] = arguments[1];
    } else if (typeof(styles) == 'string') {
      styleObj.cssText += ';' + styles;
    } else {
      for (var name in styles) {
        styleObj[name] = styles[name];
      }
    }
    return this;
  },

  /**
   * REFERENCES
   */

  /**
   * get the reference for this view
   */
  getRef: function() {
    return this._ref;
  },

  /**
   * set the reference for the view
   */
  setRef: function(ref) {
    this._ref = ref;
    this._node.setAttribute('data-ref', ref);

    var owner = this.getOwner();
    owner.refs = owner.refs || {};
    owner.refs[ref] = this;
    return this;
  },

  _clearRef: function() {
    var owner = this.getOwner();
    var ref   = this.getRef();
    if (ref && owner.refs) {
      delete owner.refs[ref];
    }
  },


  /**
   * Insert the view into a node at the requested position
   *
   * @param node {Node|String} A DOM node, or the ID of a DOM node, in which
   *                           to place this view.
   * @param position {String}  Optional parameter. Specifies where to place the
   *                           view within the DOM node. Acceptable values are
   *                           'append', 'before' and 'prepend'.  If no value is
   *                           specified, the default is 'append'
   */
  placeIn: function(node, position) {
    position = position || 'append';
    var n = this.getNode();

    if (typeof node === 'string') {
      node = document.getElementById(node);
    }
    switch (position) {
      case 'append':
        node.appendChild(n);
        break;
      case 'before':
        node.parentNode.insertBefore(n, node);
        break;
      case 'prepend':
        node.insertBefore(n, node.firstChild);
        break;
      default:
        throw "Invalid node placement: " + position;
    }
    this.setInDocument(true);

    if (defaultEventDispatcher.getEnabled()) {
      defaultEventDispatcher.setup();
    }

    return this;
  },

  getInDocument: function() {
    return this._inDocument;
  },

  setInDocument: function(state) {
    state = !!state;
    var old = !!this._inDocument;
    if (old !== state) {
      this._inDocument = state;
      if (state && this.onDocumentInsertion) {
        this.onDocumentInsertion();
      }
      util.run(this._childViews, 'setInDocument', state);
    }
    return this;
  },

  getParentView: function() {
    return this._parentView;
  },

  setParentView: function(view) {
    this._parentView = view;
    return this.setInDocument(view && view.getInDocument());
  },

  /**
   * remove the view from the dom without destroying it
   */
  remove: function() {
    dom.removeElement(this.getNode());
    return this;
  },

  /**
   * destroy a view
   *  - removes child views
   *  - removes listeners
   *  - cleans up references
   */
  destroy: function() {
    defaultEventDispatcher.unregisterView(this);
    delete ContainerRegistry[dom.identify(this.getNode())];
    if (this._eventTokens) {
      util.run(this._eventTokens, 'remove');
      this._eventTokens = null;
    }
    util.run(this._childViews, 'destroy');
    this._clearRef();
    this.remove();
    this.removeBinding();
    this.isDestroyed = true;
  },

  /**
   * CHILD VIEWS
   */

  getChildViews: function() {
    return this._childViews;
  },

  setChildViews: function(childViews) {
    util.forEach(
      this._childViews,
      this.removeChild,
      this);
    if (childViews.length > 0) {
      util.forEach(
        builder.build(childViews, this.getOwner()),
        this.appendChild,
        this);
    }
  },

  removeChild: function(child, doNotDestroy) {
    child.setParentView(null);
    this._childViews = util.without(this._childViews, child);
    this._removeChildNode(child);
    doNotDestroy || child.destroy();
    return this;
  },

  _removeChildNode: function(child) {
    dom.removeElement(child.getNode());
  },

  append: function(arg) {
    if (util.isArray(arg)) {
      util.forEach(arg, this.appendChild, this);
    } else {
      this.appendChild(arg);
    }
  },

  appendChild: function(child) {
    this._childViews.push(child);
    this._appendChildNode(child);
    child.setParentView(this);
    return this;
  },

  prependChild: function(child) {
    this.insertChild(child, 0);
  },

  clearChildren: function() {
    // Note that the input to setChildViews is discarded, and not mutated
    // getChildViews returns an Array of zero or more View or TagView
    // objects.
    this.setChildViews(emptyArr);
  },

  // protected
  _appendChildNode: function(child) {
    this._node.appendChild(child.getNode());
  },

  insertChild: function(child, position) {
    var children = this._childViews;
    if (position === undefined) { position = children.length; }
    if (position >= children.length) {
      this.appendChild(child);
    } else {
      position = Math.max(0, position);
      this._insertAt(child, position);
    }
    return this;
  },

  _insertAt: function(child, position) {
    var children = this._childViews;
    var beforeChild = children[position];
    children.splice(position, 0, child);
    this._insertNodeBefore(child, beforeChild);
    child.setParentView(this);
    return this;
  },

  // protected
  _insertNodeBefore: function(child, beforeChild) {
    this.getNode().insertBefore(child.getNode(), beforeChild.getNode());
  },

  addListener: function(type, listener, contextOrNull) {
    if (defaultEventDispatcher.getEnabled()) {
      defaultEventDispatcher.addListener(this, type, listener, contextOrNull || this);
      return this;
    }

    var args = util.toArray(arguments);
    args[2] = contextOrNull || this;
    var node = this._nodeForEvent(type);
    this._eventTokens || (this._eventTokens = []);
    args.unshift(node);
    var token = domEvent.addListener.apply(domEvent, args);
    this._eventTokens.push(token);
    return token;
  },

  // COMPAT
  listen: function(type, listener, contextOrNull) {
    if (typeof listener === 'string') {
      throw new Error('listen(string, string) is no longer supported');
    }
    core.deprecated('container.listen', 'container.addListener');
    return this.addListener.apply(this, arguments);
  },

  removeListener: function(type, listener, contextOrNull) {
    if (defaultEventDispatcher.getEnabled()) {
      defaultEventDispatcher.removeListener(this, type, listener);
      return this;
    }

    contextOrNull = contextOrNull || this;
    var node = this._nodeForEvent(type);
    domEvent.removeListener(node, type, listener, contextOrNull);
    return this;
  },

  invoke: function(eventName, data) {
    if (typeof eventName !== 'string' || arguments.length > 2) {
      console.error('Container#invoke is being called with a deprecated API. ' +
        'Passing arbitrary arguments is no longer supported. Update your code to invoke ' +
        'the event with .invoke(type, data). Your listener will be invoked with ' +
        'an event object containing a type and data property.');
    }

    if (defaultEventDispatcher.getEnabled()) {
      var baseEvent;

      if (defaultEventDispatcher.getCompatibilityMode() && data === undefined && data !== null && typeof eventName === "object") {
        data = eventName;
        baseEvent = eventName;
        eventName = eventName.type;
      }

      var eventObject = new EventShim(eventName, data);
      eventObject.targetView = this;

      if (baseEvent) {
        eventObject.baseEvent = baseEvent;
      }

      return defaultEventDispatcher.invoke(this, eventObject);
    }

    if (util.isString(eventName)) {
      eventName = new EventShim(eventName, data);
    }

    var args = util.toArray(arguments);
    args.unshift(this._nodeForEvent(eventName.type));
    return domEvent.invoke.apply(domEvent, args);
  },

  /**
   * find a reference within the views hierarchy
   */
  findRef: function(ref) {
    if (this.refs) {
      return this.refs[ref];
    }
    return null;
  },

  _nodeForEvent: function(name) {
    return this.getNode();
  }
};


function generateDelegateSetter(target, setValue, name, getTarget) {
  return function(value) {
    // Support both getting a value directly from the refs
    // object created by the builder, and from a target with a
    // defined getter
    var obj = (this.findRef ? this.findRef(target) : null) || this[getTarget]();
    if (obj[setValue]) {
      obj[setValue](value);
    } else {
      if (value !== undefined) {
        obj[name.name || name] = value;
      }
    }
    return this;
  };
}

function generateDelegateGetter(target, getValue, name, getTarget) {
  return function() {
    /* We check for a getter first, because not all classes will have a
     * member called findRef - we could take reference to findRef out of
     * core.js */
    var obj = (this.findRef ? this.findRef(target) : null) || this[getTarget]();
    return obj[getValue] ? obj[getValue]() : obj[name.name || name];
  };
}

function addDelegateProperties(klass, config) {
  if (!config.delegateProperties) {
    return;
  }
  var delegateProperties = config.delegateProperties;

  var proto = klass.prototype;

  var names;
  for (var target in delegateProperties) {
    names = delegateProperties[target];
    var name;
    for (var i = 0; i < names.length; i++) {
      name = names[i];
      if (target === (name.alias || name)) {
        console.warn('Do not give a delegateProperty target and property (or ' +
          'property alias) the same name. Fix delegateProperty "' + target +
          '" in class "' + klass.klassName + '".');
      }
      var aliasSetValue  = util.setter(name.alias || name);
      var aliasGetValue  = util.getter(name.alias || name);

      var getTarget = util.getter(target);
      // Support both simple string names and objects of the
      // form {alias: 'src name', name: 'target name'}, e.g.
      // {alias: 'content', name: 'innerHTML'}
      var setValue = util.setter(name.name || name);
      var getValue = util.getter(name.name || name);
      if (!proto.hasOwnProperty(aliasSetValue)) {
        proto[aliasSetValue] = generateDelegateSetter(target, setValue, name, getTarget);
      }

      if (!proto.hasOwnProperty(aliasGetValue)) {
        proto[aliasGetValue] = generateDelegateGetter(target, getValue, name, getTarget);
      }
    };
  };
}
});

// module: bolt/vendor/_
// file:   ../../../frameworks/bolt/lib/vendor/_.js
define("bolt/vendor/_", function(require, exports, module) {
//     Underscore.js 1.1.7
//     (c) 2011 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore is freely distributable under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var slice            = ArrayProto.slice,
      unshift          = ArrayProto.unshift,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) { return new wrapper(obj); };

  // Export the Underscore object for **CommonJS**, with backwards-compatibility
  // for the old `require()` API. If we're not in CommonJS, add `_` to the
  // global object.
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = _;
    _._ = _;
  } else {
    // Exported as a string, for Closure Compiler "advanced" mode.
    root['_'] = _;
  }

  // Current version.
  _.VERSION = '1.1.7';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (hasOwnProperty.call(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = memo !== void 0;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError("Reduce of empty array with no initial value");
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return memo !== void 0 ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var reversed = (_.isArray(obj) ? obj.slice() : _.toArray(obj)).reverse();
    return _.reduce(reversed, iterator, memo, context);
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    each(obj, function(value, index, list) {
      if (!iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator = iterator || _.identity;
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result |= iterator.call(context, value, index, list)) return breaker;
    });
    return !!result;
  };

  // Determine if a given value is included in the array or object using `===`.
  // Aliased as `contains`.
  _.include = _.contains = function(obj, target) {
    var found = false;
    if (obj == null) return found;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    any(obj, function(value) {
      if (found = value === target) return true;
    });
    return found;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (method.call ? method || value : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Return the maximum element or (element-based computation).
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj)) return Math.max.apply(Math, obj);
    var result = {computed : -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj)) return Math.min.apply(Math, obj);
    var result = {computed : Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, iterator, context) {
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      return a < b ? -1 : a > b ? 1 : 0;
    }), 'value');
  };

  // Groups the object's values by a criterion produced by an iterator
  _.groupBy = function(obj, iterator) {
    var result = {};
    each(obj, function(value, index) {
      var key = iterator(value, index);
      (result[key] || (result[key] = [])).push(value);
    });
    return result;
  };

  // Use a comparator function to figure out at what index an object should
  // be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator) {
    iterator || (iterator = _.identity);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >> 1;
      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(iterable) {
    if (!iterable)                return [];
    if (iterable.toArray)         return iterable.toArray();
    if (_.isArray(iterable))      return slice.call(iterable);
    if (_.isArguments(iterable))  return slice.call(iterable);
    return _.values(iterable);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    return _.toArray(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head`. The **guard** check allows it to work
  // with `_.map`.
  _.first = _.head = function(array, n, guard) {
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the first entry of the array. Aliased as `tail`.
  // Especially useful on the arguments object. Passing an **index** will return
  // the rest of the values in the array from that index onward. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = function(array, index, guard) {
    return slice.call(array, (index == null) || guard ? 1 : index);
  };

  // Get the last element of an array.
  _.last = function(array) {
    return array[array.length - 1];
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, function(value){ return !!value; });
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array) {
    return _.reduce(array, function(memo, value) {
      if (_.isArray(value)) return memo.concat(_.flatten(value));
      memo[memo.length] = value;
      return memo;
    }, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted) {
    return _.reduce(array, function(memo, el, i) {
      if (0 == i || (isSorted === true ? _.last(memo) != el : !_.include(memo, el))) memo[memo.length] = el;
      return memo;
    }, []);
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays. (Aliased as "intersect" for back-compat.)
  _.intersection = _.intersect = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and another.
  // Only the elements present in just the first array will remain.
  _.difference = function(array, other) {
    return _.filter(array, function(value){ return !_.include(other, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
    return results;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i, l;
    if (isSorted) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
    for (i = 0, l = array.length; i < l; i++) if (array[i] === item) return i;
    return -1;
  };


  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item) {
    if (array == null) return -1;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
    var i = array.length;
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
  // We check for `func.bind` first, to fail fast when `func` is undefined.
  _.bind = function(func, obj) {
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    var args = slice.call(arguments, 2);
    return function() {
      return func.apply(obj, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return hasOwnProperty.call(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(func, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Internal function used to implement `_.throttle` and `_.debounce`.
  var limit = function(func, wait, debounce) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var throttler = function() {
        timeout = null;
        func.apply(context, args);
      };
      if (debounce) clearTimeout(timeout);
      if (debounce || !timeout) timeout = setTimeout(throttler, wait);
    };
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    return limit(func, wait, false);
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds.
  _.debounce = function(func, wait) {
    return limit(func, wait, true);
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      return memo = func.apply(this, arguments);
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func].concat(slice.call(arguments));
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = slice.call(arguments);
    return function() {
      var args = slice.call(arguments);
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) { return func.apply(this, arguments); }
    };
  };


  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (hasOwnProperty.call(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    return _.map(obj, _.identity);
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (source[prop] !== void 0) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (obj[prop] == null) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    // Check object identity.
    if (a === b) return true;
    // Different types?
    var atype = typeof(a), btype = typeof(b);
    if (atype != btype) return false;
    // Basic equality test (watch out for coercions).
    if (a == b) return true;
    // One is falsy and the other truthy.
    if ((!a && b) || (a && !b)) return false;
    // Unwrap any wrapped objects.
    if (a._chain) a = a._wrapped;
    if (b._chain) b = b._wrapped;
    // One of them implements an isEqual()?
    if (a.isEqual) return a.isEqual(b);
    if (b.isEqual) return b.isEqual(a);
    // Check dates' integer values.
    if (_.isDate(a) && _.isDate(b)) return a.getTime() === b.getTime();
    // Both are NaN?
    if (_.isNaN(a) && _.isNaN(b)) return false;
    // Compare regular expressions.
    if (_.isRegExp(a) && _.isRegExp(b))
      return a.source     === b.source &&
             a.global     === b.global &&
             a.ignoreCase === b.ignoreCase &&
             a.multiline  === b.multiline;
    // If a is not an object by this point, we can't handle it.
    if (atype !== 'object') return false;
    // Check for different array lengths before comparing contents.
    if (a.length && (a.length !== b.length)) return false;
    // Nothing else worked, deep compare the contents.
    var aKeys = _.keys(a), bKeys = _.keys(b);
    // Different object sizes?
    if (aKeys.length != bKeys.length) return false;
    // Recursive comparison of contents.
    for (var key in a) if (!(key in b) || !_.isEqual(a[key], b[key])) return false;
    return true;
  };

  // Is a given array or object empty?
  _.isEmpty = function(obj) {
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (hasOwnProperty.call(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType == 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Is a given variable an arguments object?
  _.isArguments = function(obj) {
    return !!(obj && hasOwnProperty.call(obj, 'callee'));
  };

  // Is a given value a function?
  _.isFunction = function(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  };

  // Is a given value a string?
  _.isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  // Is a given value a number?
  _.isNumber = function(obj) {
    return !!(obj === 0 || (obj && obj.toExponential && obj.toFixed));
  };

  // Is the given value `NaN`? `NaN` happens to be the only value in JavaScript
  // that does not equal itself.
  _.isNaN = function(obj) {
    return obj !== obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false;
  };

  // Is a given value a date?
  _.isDate = function(obj) {
    return !!(obj && obj.getTimezoneOffset && obj.setUTCFullYear);
  };

  // Is the given value a regular expression?
  _.isRegExp = function(obj) {
    return !!(obj && obj.test && obj.exec && (obj.ignoreCase || obj.ignoreCase === false));
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function (n, iterator, context) {
    for (var i = 0; i < n; i++) iterator.call(context, i);
  };

  // Add your own custom functions to the Underscore object, ensuring that
  // they're correctly added to the OOP wrapper as well.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      addToWrapper(name, _[name] = obj[name]);
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(str, data) {
    var c  = _.templateSettings;
    var tmpl = 'var __p=[],print=function(){__p.push.apply(__p,arguments);};' +
      'with(obj||{}){__p.push(\'' +
      str.replace(/\\/g, '\\\\')
         .replace(/'/g, "\\'")
         .replace(c.interpolate, function(match, code) {
           return "'," + code.replace(/\\'/g, "'") + ",'";
         })
         .replace(c.evaluate || null, function(match, code) {
           return "');" + code.replace(/\\'/g, "'")
                              .replace(/[\r\n\t]/g, ' ') + "__p.push('";
         })
         .replace(/\r/g, '\\r')
         .replace(/\n/g, '\\n')
         .replace(/\t/g, '\\t')
         + "');}return __p.join('');";
    var func = new Function('obj', tmpl);
    return data ? func(data) : func;
  };

  // The OOP Wrapper
  // ---------------

  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  var wrapper = function(obj) { this._wrapped = obj; };

  // Expose `wrapper.prototype` as `_.prototype`
  _.prototype = wrapper.prototype;

  // Helper function to continue chaining intermediate results.
  var result = function(obj, chain) {
    return chain ? _(obj).chain() : obj;
  };

  // A method to easily add functions to the OOP wrapper.
  var addToWrapper = function(name, func) {
    wrapper.prototype[name] = function() {
      var args = slice.call(arguments);
      unshift.call(args, this._wrapped);
      return result(func.apply(_, args), this._chain);
    };
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      method.apply(this._wrapped, arguments);
      return result(this._wrapped, this._chain);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      return result(method.apply(this._wrapped, arguments), this._chain);
    };
  });

  // Start chaining a wrapped Underscore object.
  wrapper.prototype.chain = function() {
    this._chain = true;
    return this;
  };

  // Extracts the result from a wrapped and chained object.
  wrapper.prototype.value = function() {
    return this._wrapped;
  };

})();
});

// module: shared/data/store_base
// file:   ../../shared/js/data/store_base.js
define("shared/data/store_base", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;
var core           = require('bolt/core');
var db             = require('shared/data/db');
var deferred       = require('shared/deferred');
var logger         = require('shared/logger').logger;
var sharedUtil     = require('shared/util');
var util           = require('bolt/util');
var Deferred       = deferred.Deferred;
var DeferredList   = deferred.DeferredList;
var EventManager   = require('shared/event_manager').EventManager;
var SqlBuilder     = require('shared/data/sql_builder').SqlBuilder;
var SqlTransaction = require('shared/data/sql_transaction').SqlTransaction;
var StoreMeta      = require('shared/data/store_meta').StoreMeta;

var _executionTime = 0;

var LOG_THRESHOLD = 10;
var VARIABLE_COUNT_LIMIT = 500;
var VERSION_UNDEFINED = -1;

var PRIORITY = {
  LOW: 0,
  NORMAL: 1,
  PERMANENT: 2
};

function _getObjects(result) {
  var objects = [];
  var rows = result.rows;
  var row, object, data;
  for (var i = 0, l = rows.length; i < l; ++i) {
    row = rows.item(i);
    if (row.data) {
      data = JSON.parse(row.data);
      object = util.clone(data);
      object._data = data;
    } else {
      object = {};
    }
    if (row.pendingData) {
      object = util.extend(object, JSON.parse(row.pendingData));
    }
    if (row.localData) {
      object = util.extend(object, JSON.parse(row.localData));
    }
    for (var col in row) {
      if ('data' !== col && 'pendingData' !== col && 'localData' !== col) {
        // A field may exist both as raw 'data' and as a table column.
        // If so, the table column will override the value in raw 'data'.
        object[col] = row[col];
      }
    }
    objects.push(object);
  }
  return objects;
}

/**
 * Events that are trigger from the store:
 */
var EVENTS = {
  // triggered with a parameter of store reference
  // at a major change in the content that probably
  // needs the subscriber to refetch all contents;
  // must listened by the JS API
  UPDATE: 'update',

  // triggered when the store is cleared
  CLEAR: 'clear',

  // triggered when the syncer wants to execute code on all stores
  // WARNING: this allows remote execution on each store, this should go away
  // once we have stores running in a SharedWorker
  SYNCER_UPDATE: 'syncerUpdate',

  // triggered by setHasMoreRemoteData when the value is false
  NO_MORE_REMOTE_DATA: 'noMoreRemoteData'
};

var StoreBase = exports.StoreBase = core.createClass({
  name: 'StoreBase',
  extend: Deferred,

  // reference these statics here so they are available to subclasses
  EVENTS: EVENTS,
  PRIORITY: PRIORITY,

  init: function() {
    if (!this._initialized) {
      this._initialized = true;
      this._storeInitialized = true;

      this.addListener(EVENTS.SYNCER_UPDATE, this._onSyncerUpdate, this);

      StoreMeta.addCallback(this._onStoreMeta, this);
    } else if (!this._storeInitialized) {
      // store is not initialized, doing it again
      this._storeInitialized = true;
      var tx = new SqlTransaction();
      return this.initializeStore(tx);
    }

    this._invokeClearEvent = util.bind(this.invoke, this, 'clear', {}, null);

    return this;
  },

  /**
   * Returns the name of the store
   *
   * @default The class name of the store
   */
  getName: function() {
    return this.klass.klassName;
  },

  /**
   * Returns the priority of the store
   *
   * @override
   */
  getPriority: function() {
    return PRIORITY.NORMAL;
  },

  /**
   * Returns the version for this store
   *
   * @override
   */
  getStoreVersion: function() {
    sharedUtil.abstractMethod('StoreBase.getStoreVersion');
    return 1;
  },

  /**
   * Returns the cumulative execution time of SQL transactions by this store
   */
  getExecutionTime: function() {
    return _executionTime;
  },

  /**
   * Listens for events of data changes.
   */
  addListener: function(eventName, contextOrCallback, callbackOrNull) {
    var args = util.toArray(arguments);
    args[0] = this._getEventName(args[0]);

    // TODO: remove this compatibility code when all callers pass the callback
    // first (left in here now for compatibility with the dojo parameter order)
    if (args[1] && !util.isFunction(args[1])) {
      var tmp = args[2];
      args[2] = args[1];
      args[1] = (util.isFunction(tmp) ? tmp : null);
    }

    return EventManager.addListener.apply(EventManager, args);
  },

  listen: function() {
    // COMPAT, temporarily copied from addListener
    require('bolt/core').deprecated('Store.listen', 'Store.addListener');
    var args = util.toArray(arguments);
    args[0] = this._getEventName(args[0]);
    if (args[1] && !util.isFunction(args[1])) {
      var tmp = args[2];
      args[2] = args[1];
      args[1] = (util.isFunction(tmp) ? tmp : null);
    }
    return EventManager.listen.apply(EventManager, args);
  },

  /**
   * Stop listening for an event
   */
  removeListener: function(eventName, callback, contextOrNull) {
    // TODO: remove this compatibility code when all callers pass the callback
    // first (left in here now for compatibility with the dojo parameter order)
    if (callback && !util.isFunction(callback)) {
      var tmp = contextOrNull;
      contextOrNull = callback;
      callback = (util.isFunction(tmp) ? tmp : null);
    }

    return EventManager.removeListener(
      this._getEventName(eventName),
      callback,
      contextOrNull
    );
  },

  /**
   * Sends update signal for the store's information change.
   */
  invoke: function(eventName, content, localOnly) {
    eventName = this._getEventName(eventName);
    if (localOnly) {
      EventManager.invoke(eventName, content);
    } else {
      EventManager.broadcastEvent(eventName, content);
    }
  },

  /**
   * Logs a SQL error
   */
  logError: function(tx, err) {
    console.error('Store (' + this.getName() + ') SQL error: ' + err.message);
  },

  /**
   * This is a wrapper around database.transaction() which supports
   * auto-initialize of store class.
   *
   * @return deferred object for user to set success/error call backs.
   */
  createTransaction: function() {
    var deferred = this.init();
    return new SqlTransaction(deferred);
  },

  /**
   * Creates a SqlBuilder with the default table name and columns
   *
   * @param params {Object} The parameters to filter the query on (to build up
   *   the WHERE statement)
   * @param args {Object} The non-column arguments to filter on (see setArgs)
   * @param overrideArgs {Object} An additional args object passed to setArgs
   *   (you can pass defaults as args and per-instance args here)
   */
  createSqlBuilder: function(params, args, overrideArgs) {
    return new SqlBuilder(
      this.getTableName(),
      this.getTableColumns(),
      params,
      args,
      overrideArgs,
      this.getLocalFields()
    );
  },

  /**
   * Ensures that a batch exists on a transaction for this store
   *
   * @param tx {Object} Sqltransaction object that the batch belongs to
   */
  ensureBatch: function(tx) {
    var name = this.getName();
    var batch = tx.getBatch(name);
    if (!batch) {
      batch = tx.setBatch(name, this.createStoreEventBatch(tx));
    }
    return batch;
  },

  /**
   * Creates a single object in the database
   *
   * @param tx {Object} SqlTransaction object to create the object in
   * @param id {String} The id for the object (passed to the batch)
   * @param builder {Object} SqlBuilder object to get the INSERT statement from
   */
  createObjectWithTransaction: function(tx, id, builder) {
    var batch = this.ensureBatch(tx);
    return tx.executeSql.apply(tx, builder.getInsertArguments(true))
      .then(function(result) {
        if (result && result.rowsAffected) {
          batch.addItem(id);
        }
        return (new Deferred()).succeed(result, id);
      });
  },

  /**
   * Updates a single object in the database
   *
   * @param tx {Object} SqlTransaction object to update the object in
   * @param id {String} The id for the object (passed to the batch)
   * @param builder {Object} SqlBuilder object to get the UPDATE statement from
   */
  updateObjectWithTransaction: function(tx, id, builder) {
    var batch = this.ensureBatch(tx);
    return tx.executeSql.apply(tx, builder.getUpdateArguments())
      .then(function(result) {
        if (result && result.rowsAffected) {
          batch.changeItem(id);
        }
        return (new Deferred()).succeed(result, id);
      });
  },

  /**
   * Updates or creates a single object in the database
   *
   * @param tx {Object} SqlTransaction object to create the object in
   * @param id {String} The id for the object (passed to the batch)
   * @param builder {Object} SqlBuilder object to get the UPDATE statement from
   */
  updateOrCreateObjectWithTransaction: function(tx, id, builder) {
    return this.updateObjectWithTransaction(tx, id, builder)
    .then(this._onUpdateOrCreateObjectWithTransaction, this, tx, builder);
  },
  _onUpdateOrCreateObjectWithTransaction: function(tx, builder, result, id) {
    if (result && result.rowsAffected) {
      return (new Deferred()).succeed(result, id);
    } else {
      return this.createObjectWithTransaction(tx, id, builder);
    }
  },

  /**
   * Deletes a single object in the database
   *
   * @param tx {Object} SqlTransaction object to create the object in
   * @param id {String} The id for the object (passed to the batch)
   * @param builder {Object} SqlBuilder object to get the UPDATE or DELETE
   * statement from
   */
  deleteObjectWithTransaction: function(tx, id, builder) {
    var batch = this.ensureBatch(tx);
    return tx.executeSql.apply(tx, builder.getDeleteArguments())
      .then(function(result) {
        if (result && result.rowsAffected) {
          batch.removeItem(id);
        }
        return (new Deferred()).succeed(result, id);
      });
  },

  /**
   * Deletes objects in the database
   *
   * @param tx {Object} SqlTransaction object to create the object in
   * @param builder {Object} SqlBuilder object to get the UPDATE statement from
   * @param propToReturn: {String} The property of the deleted objects to
   * broadcast in a removeItem event. Omit to skip event broadcasting.
   */
  deleteObjectsWithTransaction: function(tx, builder, propToReturn) {
    var batch = this.ensureBatch(tx);
    return this.getObjectsWithTransaction(tx, builder)
    .then(this._onGotIdsForDeletion, this, tx, builder,
      propToReturn, batch);
  },

  _onGotIdsForDeletion: function(tx, builder, propToReturn, batch, results) {
    // Get all the ids to broadcast
    var ids = [];

    if (propToReturn) {
      var result;
      for (var i = 0, l = results.length; i < l; i++) {
        result = results[i];
        ids.push(result[propToReturn]);
      }
    }
    return tx.executeSql.apply(tx, builder.getDeleteArguments())
      .then(function(result) {
        if (result && result.rowsAffected) {
          for (var i = 0; i < ids.length; i++) {
            batch.removeItem(ids[i]);
          }
        }
        return (new Deferred()).succeed(result, ids);
      });
  },

  queryObject: function(tx, cols, params) {
    var builder = new SqlBuilder(this.getName(), cols, params)
      .addAllParamFilters();
    return this.getObjectWithTransaction(tx, builder);
  },

  queryObjects: function(tx, cols, params) {
    var builder = new SqlBuilder(this.getName(), cols, params)
      .addAllParamFilters();
    return this.getObjectsWithTransaction(tx, builder);
  },

  /**
   * Gets a single object from the database
   *
   * @param tx {Object} SqlTransaction object to select in
   * @param builder {Object} SqlBuilder object to get the UPDATE statement from
   */
  getObjectWithTransaction: function(tx, builder) {
    return tx.executeSql.apply(tx, builder.getSelectArguments())
      .then(function(result) {
        var objects = _getObjects(result);
        var object = objects && objects.length ? objects[0] : null;
        return object;
      });
  },

  /**
   * Gets a collection of objects from the database
   *
   * @param tx {Object} SqlTransaction object to select in
   * @param builder {Object} SqlBuilder object to get the UPDATE statement from
   */
  getObjectsWithTransaction: function(tx, builder) {
    return tx.executeSql.apply(tx, builder.getSelectArguments())
      .then(_getObjects);
  },

  /**
   * Gets objects with specified ids.
   *
   * @param tx {Object} The SqlTransaction to get the messages within
   * @param column {String} The name of the column that the IDs belong to
   * @param ids {Array} The ids to fetch
   * @return {Object} A SqlTransaction deferred object that you can chain on
   */
  getObjectsWithIDsWithTransaction: function(tx, column, ids) {
    var deferreds = [];
    var count = Math.ceil(ids.length / VARIABLE_COUNT_LIMIT);
    var builder;
    for (var i = 0; i < count; ++i) {
      builder = this.createSqlBuilder().addInFilter(
        column,
        ids.slice(VARIABLE_COUNT_LIMIT * i, VARIABLE_COUNT_LIMIT * (i + 1))
      );
      deferreds.push(this.getObjectsWithTransaction(tx, builder));
    }
    return (new DeferredList(deferreds)).then(
      this._onGetObjectsWithIDsWithTransaction,
      this
    );
  },
  _onGetObjectsWithIDsWithTransaction: function() {
    var objects = util.flatten(
      sharedUtil.convertDeferredListResult(
        util.toArray(arguments).slice(1)
      )
    );
    return objects;
  },

  /**
   * Counts the objects in the database grouping by the specified statement
   *
   * @param tx {Object} SqlTransaction object to count in
   * @param groupBy {String} The GROUP BY statement fragment (typically just a
   *   column name)
   * @param columnOrNull {String} The name of the column in the SELECT statement
   *   fragment (just pass null if groupBy is the column)
   * @return SqlTransaction that will have a map of the counts keyed by the
   *   specified column values
   */
  countObjectsWithTransaction: function(tx, groupBy, columnOrNull) {
    var groupByArr = util.isArray(groupBy) ? groupBy : [groupBy];
    var columnArr = columnOrNull || groupByArr;
    columnArr = util.isArray(columnArr) ? columnArr : [columnArr];
    return this.getObjectsWithTransaction(
      tx,
      (new SqlBuilder(
        this.getTableName(),
        util.union(columnArr, ['COUNT(*) AS count']),
        null,
        {groupBy: groupByArr}
      ))
    )
    .then(this._onCountObjectsWithTransaction, this, columnArr);
  },
  _onCountObjectsWithTransaction: function(columnArr, objects) {
    var map = {};
    var total = 0;
    if (objects) {
      var obj;
      for (var i = 0, l = objects.length; i < l; ++i) {
        obj = objects[i];
        var key;
        if (columnArr.length === 1) {
          key = obj[columnArr[0]];
        } else {
          key = util.map(columnArr, function(c) { return obj[c]; }).join(',');
        }
        map[key] = obj.count;
        total += obj.count;
      }
    }
    return (new Deferred()).succeed(map, total);
  },

  /**
   * Issues a query to the database. Does not have any automatic response
   * handling, the raw result will be returned.
   *
   * @param sql {String} The sql query
   * @param args {Object} The data arguments
   * @return {Object} A Deferred object. The successful callback with be called
   *   with the raw results
   */
  executeSql: function(sql, args) {
    var tx = this.createTransaction();
    var timerId = logger.startTimer("SQL", logger.ALLOW_OVERLAPPING);
    return tx.executeSql(sql, args)
      .then(function(result) {
        var time = logger.queryTimer(timerId);
        if (LOG_THRESHOLD <= time) {
          logger.endTimer(timerId, {SQL: sql});
        } else {
          logger.clearTimer(timerId);
        }
        _executionTime += time;

        return result;
      });
  },

  /**
   * Return a blank Deferred to use for failed conditions
   */
  getFailedDeferred: function() {
    return (new Deferred()).fail();
  },

  /**
   * Used by the default implementation of storage management that assumes a
   * single table per store.  If a store manages multiple tables then it should
   * return null and manage the tables manually.
   *
   * By default this will return the name of the store.
   *
   * @return {String} The name of the table that this store manages
   */
  getTableName: function() {
    return this.getName();
  },

  /**
   * @return {Array} Array of strings representing all of the tables used by
   * this store. Must override if you are not using the default implementation
   * of storage management (i.e. are using more than one table).
   */
  getAllTables: function() {
    if (!!this.getTableName()) {
      return [this.getTableName()];
    }
    else {
      console.error("getAllTables not over-written for store: " +
        this.getName());
      sharedUtil.abstractMethod('StoreBase.getAllTables');
      return [];
    }
  },

  /**
   * Used by the default implementation of storage management that assumes a
   * single table per store.  If a store manages multiple tables then it should
   * return null and manage the tables manually.
   *
   * @return {Array} An array of string column names that will be created for
   *   the table
   */
  getTableColumns: function() {
    return null;
  },

  /**
   * Optionally returns fields for the object that should be stored in a
   * localData column (if it exists) instead of in the data column.  These
   * fields will not be overwritten by changes that originate from the server.
   */
  getLocalFields: function() {
    return null;
  },

 /**
  * Used by the default implementation of storage management that assumes a
  * single table per store.  If a store manages multiple tables then it should
  * return null and manage the tables manually.
  *
  * @return {Array} An array of string SQL constraints to be included in the
  *   CREATE TABLE statement
  */
  getTableConstraints: function() {
    return null;
  },

  /**
   * Gets the flag for whether there are more remote objects for this store
   * @see setHasMoreRemoteData
   *
   * @param key {String} The key to check for more
   * @return {Deferred} A deferred object
   */
  hasMoreRemoteData: function(key) {
    // Return true by default
    if (this.updateOrCreateKeyValue) { // if has KeyValueMixin
      return this.getKeyValue(key).then(this._checkHasMoreRemoteData);
    } else {
      var deferred = new Deferred();

      var result =
        (!this._hasMoreRemoteDataMap ||
        false !== this._hasMoreRemoteDataMap[key]);
      deferred.succeed(result);
      return deferred;
    }
  },
  _checkHasMoreRemoteData: function(result) {
    return !(result === false || result === 'false');
  },


  /**
   * Sets a flag for whether there are more remote objects for this store.
   * If this store is set up to use the KeyValueStore, then uses that, otherwise
   * just stores the flag in memory.
   *
   * @param key {String} The key to store the flag for
   * @param flag {Boolean} true if there is more data on the server
   */
  setHasMoreRemoteData: function(key, value) {
    if (this.updateOrCreateKeyValue) { // if has KeyValueMixin
      this.updateOrCreateKeyValue(key, value);
    } else {
      var map = this._hasMoreRemoteDataMap = this._hasMoreRemoteDataMap || {};
      map[key] = value;
    }
    if (!value) {
      this.invoke(EVENTS.NO_MORE_REMOTE_DATA, {key: key}, true);
    }
  },

  /**
   * Initializes the table for this store.  The default implementation will
   * generate the table from getTableName, getTableColumns, getTableConstraints.
   * If you need different logic or want multiple tables, override and do not
   * call the base implementation.  If you want indices call the base
   * implementation first and then create the indices.
   *
   * @override
   * @param tx {Object} A SqlTransaction
   */
  initializeStore: function(tx) {
    var name = this.getTableName();
    var columns = this.getTableColumns();
    if (util.isEmpty(name) || util.isEmpty(columns)) {
      // must either override initializeStore or provide a table name and
      // columns
      sharedUtil.abstractMethod('StoreBase.initializeStore');
      return new Deferred().succeed();
    }
    columns = columns.concat(this.getTableConstraints() || []);
    return tx.executeSql('CREATE TABLE IF NOT EXISTS ' + name +
      '(' + columns.join(',') + ')');
  },

  /**
   * Seeds the store with some data.  The default implementation does nothing.
   */
  seedStore: function(tx) {
    return new Deferred().succeed();
  },

  /**
   * Clears the table for this store.  The default implementation will drop the
   * table from getTableName, and remove any values stored in KeyValueStore.
   *
   * @override
   * @param tx {Object} A SqlTransaction
   */
  clearStore: function(tx) {
    this._storeInitialized = false;
    if (util.isEmpty(this.getTableName())) {
      // must either override clearStore or provide a table name
      sharedUtil.abstractMethod('StoreBase.clearStore');
    }

    // TODO: create a task to add context into addTransactionCallback
    tx.addTransactionCallback(this._invokeClearEvent);

    // If store is using Key Value Pairs, must clear them all out
    if (this.clearKeyValuePairs) {
      return this.clearKeyValuePairs(tx)
      .then(this._dropTable, this, tx);
    } else {
      return this._dropTable(tx);
    }
  },

  /**
   * Purges the store.
   *
   * It deletes all the data in tables which belong to this store. But no table
   * will be dropped.
   *
   * @tx the transaction handler
   * @return the chained deferred transaction handler
   */
  purgeStore: function(tx) {
    // searched on google, it is more efficient to drop and recreate the table
    // than using "delete from table_name ...".
    // from Todd:  clearStore doesn't guarantee that we're dropping the tables
    // (some stores override to do deletes) - this should be OK, though
    console.log('[purgeStore] is called for store ' + this.getName());
    return this.clearStore(tx).then(this.initializeStore, this, tx);
  },

  _dropTable: function(tx) {
    return tx.executeSql('DROP TABLE IF EXISTS ' + this.getTableName());
  },

  /**
   * shrinking the store to a certain size upon request
   * @param tx {Object} A SqlTransaction
   * @param target_size {Number} The size that we want the store to shrink to
   */
  shrinkStore: function(tx, target_size) {
    // default shrinking plan: clean the DB for non permanent store
    if (this.getPriority() !== PRIORITY.PERMANENT) {
      return this._clear(tx);
    } else {
      return new Deferred().succeed();
    }
  },

  /**
   * migrate the DB from one revision to another
   * default behavior: clear the DB completely
   *
   * This function should bring the store from the old revision
   * to the new revision, *before* the initialized state.
   *
   * TODO: we should revisit the above definition after more usage
   * cases. It might be better to redefine this as a function that
   * migrate from old data to new data, *after* the initialized state
   * if a lot of stores override this function with a initialing migration.
   *
   *
   * @param tx {Object} A SqlTransaction
   * @param old_version {Number} The old version the store DB is on
   */
  migrateStore: function(tx, old_version) {
    // default migration plan: clean the DB
    return this._clear(tx);
  },

  /**
   * Migrates a single table from one table name to another, allowing you to
   * transform each row in the process
   *
   * @param tx {Object} A SqlTransaction
   * @param tableName {String} The name of the table to migrate from
   * @param rowCallback {Function} The function that is called for each row
   *   found (takes 2 parameters, the row and the data object)
   */
  migrateTableData: function(tx, tableName, rowCallback) {
    return this.getObjectWithTransaction(
      tx,
      new SqlBuilder(
        'sqlite_master',
        ['type', 'name'],
        {
          type: 'table',
          name: tableName
        }
      )
    )
    .then(this._onMigrateTableData1, this, tx, tableName)
    .then(this._onMigrateTableData2, this, tx, rowCallback);
  },
  _onMigrateTableData1: function(tx, tableName, data) {
    if (data) {
      return this.getObjectsWithTransaction(tx,
        new SqlBuilder(tableName, ['*']));
    } else {
      return new Deferred().succeed();
    }
  },
  _onMigrateTableData2: function(tx, rowCallback, data) {
    if (data) {
      for (var i = 0, l = data.length; i < l; ++i) {
        rowCallback(tx, data[i]);
      }
    }
  },

  /**
   * head_seq operation:
   *
   * head_seq is the server-responded sequence for the last time the store
   * is synced with the server with a syncer. It is associated with the data:
   * if the data is cleared, we should clear the head_seq so that the syncer
   * knows to re-sync in the future.
   *
   * We support a store changed by more than one syncers, but a syncer changing
   * only one store (if there is a need in the future, we can also support
   * many-to-many).
   *
   * The head_seq object in the store_meta DB is a JSON encoded object,
   * with each entry for a syncer.
   *
   * When a store is cleared, the head_seq object would be cleared (and
   * translated into -1 when queried).
   *
   * When a syncer tries to get its head_seq, it would query its associated
   * store, find the corresponding head_seq for it by getSyncSequence --
   * so that the syncer knows to sync if any of the store is cleared.
   */
  clearSyncSequence: function(tx) {
    return StoreMeta.clearStoreSyncSequence(tx, this.getName());
  },

  /**
   * @param syncerName {String} The name of the syncer
   * @return {Object} A SqlTransaction that would call the callback with the
   *   head_seq
   */
  getSyncSequence: function(syncerName) {
    var tx = this.createTransaction();
    return StoreMeta.getStoreSyncSequence(tx, this.getName(), syncerName);
  },

  /**
   * Creates an event batch to collect object ids to dispatch in a group
   *
   * @param tx {Object} The SqlTransaction object to attach the event batch to
   * @param eventName {String} The name of the event to fire
   * @param keyOrFormatter {String|Function} Either a string key for the id
   *   array or a function that will return the event payload from the ids.
   * @return {Object} The event batch, with an addEvent method
   */
  createStoreEventBatch: function(tx, eventName, eventData) {
    var store = this;
    var batch = {
      _data: {
        addItems: [],
        removeItems: [],
        changeItems: []
      },
      _modified: false,
      _eventName: eventName || EVENTS.UPDATE,
      _eventData: eventData || {type: this.getName()},

      _checkItem: function(id, items) {
        if (id && (-1 === items.indexOf(id))) {
          items.push(id);
          this._modified = true;
        }
      },

      addItem: function(id) {
        this._checkItem(id, this._data.addItems);
      },

      removeItem: function(id) {
        this._checkItem(id, this._data.removeItems);
      },

      changeItem: function(id) {
        this._checkItem(id, this._data.changeItems);
      }
    };
    tx && tx.addTransactionCallback(util.bind(function() {
      if (this._modified) {
        store.invoke(this._eventName, util.extend(this._eventData, this._data));
      }
    }, batch));
    return batch;
  },

  _clear: function(tx) {
    this.clearSyncSequence(tx);
    this.clearStore(tx);
    return new Deferred().succeed();
  },

  _getEventName: function(eventName) {
    return this.getName() + '/' + eventName;
  },

  _onStoreMeta: function() {
    var name = this.getName();
    var currentVersion = StoreMeta.getStoreVersion(name);
    var desiredVersion = this.getStoreVersion();
    var tx = new SqlTransaction();
    this._migrateIfOld(tx, desiredVersion, currentVersion)
      .then(StoreMeta.setStoreVersion, StoreMeta, tx, name,
        desiredVersion)
      .then(this.initializeStore, this, tx)
      .then(this.seedIfOld, this, tx, currentVersion)
      .then(this.succeed, this.fail, this);
  },

  _migrateIfOld: function(tx, desiredVersion, currentVersion) {
    if (desiredVersion !== currentVersion &&
        StoreMeta.STORE_VERSION_UNDEFINED !== currentVersion) {
      return this.migrateStore(tx, currentVersion);
    } else {
      return (new Deferred()).succeed();
    }
  },

  seedIfOld: function(tx, currentVersion) {
    if (StoreMeta.STORE_VERSION_UNDEFINED === currentVersion) {
      return this.seedStore(tx);
    } else {
      return (new Deferred()).succeed();
    }
  },

  _onSyncerUpdate: function(event, payload) {
    this[payload.method].apply(this, payload.args);
  }
});

function defineTransactionWrapperFunctions(klass, methods) {
  util.each(methods, function(method) {
    klass.prototype[method] = function() {
      var tx = this.createTransaction();
      var func = this[method + 'WithTransaction'];
      return func.apply(this, [tx].concat(util.toArray(arguments)));
    };
  });
}

defineTransactionWrapperFunctions(StoreBase, ['countObjects']);

exports.StoreBase.defineTransactionWrapperFunctions =
  defineTransactionWrapperFunctions;
});

// module: mock/phone_api
// file:   ../../mock/js/phone_api.js
define("mock/phone_api", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var EventManager = require('shared/event_manager').EventManager;

var TelephonyApi = FBAPI.use('telephony');

var PhoneApi = module.exports = {
  // 0. Constants

  PHONE_EVENT_NOTIFICATION: 'phone.EVENT',
  PHONE_ERROR_NOTIFICATION: 'phone.ERROR',
  PHONE_LOG_NOTIFICATION: 'phone.LOG',
  PHONE_MMI_INITIATE_NOTIFICATION: 'phone.MMI_INITIATE',
  PHONE_MMI_PROGRESS_NOTIFICATION: 'phone.MMI_PROGRESS',
  PHONE_SETTING_COMPLETE_NOTIFICATION: 'phone.SETTING_COMPLETE',

  CALL_DIALED: 0,
  CALL_DIALED_MMI: 1,
  CALL_FAILED_POWER_OFF: 2,
  CALL_FAILED_OUT_OF_SERVICE: 3,
  CALL_FAILED_INVALID_PHONE_NUMBER: 4,
  CALL_FAILED_INVALID_VOICEMAIL_NUMBER: 5,
  CALL_FAILED_EMERGENCY_CALLS_ONLY: 6,
  CALL_SECRET_CODE: 7,
  CALL_FAILED: 8,

  CLIR_DEFAULT: 0,
  CLIR_INVOCATION: 1,
  CLIR_SUPPRESSION: 2,

  SIM_STATE_UNKNOWN: 0,
  SIM_STATE_ABSENT: 1,
  SIM_STATE_PIN_REQUIRED: 2,
  SIM_STATE_PUK_REQUIRED: 3,
  SIM_STATE_NETWORK_LOCKED: 4,
  SIM_STATE_IMEI_LOCKED: 5,
  SIM_STATE_BLOCKED: 6,
  SIM_STATE_READY: 7,

  _SIM_PUK: '0000',
  _SIM_PIN_RETRIES: 3,
  _SIM_PUK_RETRIES: 10,

  NT_MODE_WCDMA_PREF: 0,
  NT_MODE_GSM_ONLY: 1,
  NT_MODE_WCDMA_ONLY: 2,
  NT_MODE_GSM_UMTS: 3,

  _PHONE_LINE: {
    uri: 'tel:+12345678900',
    type: 'GSM',
    displayName: 'Opus',
    state: 'in_service'
  },

  // 1. State variables
  // Note: State that needs to be preserved across view transitions must be
  // persisted in localStorage.  This includes the following elements: speaker,
  // mute, bluetooth, calls, and mmiCode.  Any of these elements may also be
  // cached locally, and this._initialized tracks whether the local cached value
  // has been primed.  Today, we only cache calls and mmiCode.

  _calls: [],
  _mmiCode: '',
  _initialized: false,

  // Cellular network settings.
  _clir: 0,                     // CLIR_DEFAULT
  _callForwardStatus: false,
  _callForwardNumber: "",
  _simState: 7,                 // SIM_STATE_READY
  _simPinStatus: false,
  _simPin: '1111',              // Default PIN1 on most SIMs
  _simPinRetries: 3,            // _SIM_PIN_RETRIES
  _simPukRetries: 10,           // _SIM_PUK_RETRIES

  // 2. Utility methods.

  _broadcast: function(id, data) {
    EventManager.broadcastEvent(id, data);
  },

  _stringToBoolean: function(value) {
    return (typeof(value) === 'string') ?
      (value.toLowerCase() === 'true') :
      false;
  },

  _stringToJsonArray: function(value) {
    var array;
    if (typeof(value) === 'string') {
      array = JSON.parse(value);
      if (Array.isArray(array)) {
        return array;
      }
    }
    return [];
  },


  // 3. Internal methods.

  _readState: function() {
    if (this._initialized) {
      return;
    }

    console.log('Reading state from localStorage');

    this._readCalls();
    this._readMmiCode();
    this._initialized = true;
  },

  _readCalls: function() {
    var storedCalls = this._stringToJsonArray(localStorage['calls']);
    var peer, peers, call, calls = [];
    storedCalls.forEach(function(call) {
      peers = [];
      call.peers.forEach(function(peer) {
        peers[peers.length] = new PhoneApi.Peer(peer.displayName);
      });
      calls[calls.length] =
        new PhoneApi.Call(call.id, call.state, peers);
    });

    this._calls = calls;
  },

  _writeCalls: function() {
    // Filter out IDLE calls.
    this._calls =
      this._getCalls().filter(function(call) {
        return call.state !== 'IDLE';
      });

    localStorage['calls'] = JSON.stringify(this._getCalls());
  },

  _clearDroppedAndIdleCalls: function() {
    this._calls =
      this._getCalls().filter(function(call) {
        return this._getPhoneCallStatePriority(call.state) > 2;
      }, this);
    localStorage['calls'] = JSON.stringify(this._getCalls());
  },

  _getCalls: function() {
    this._readState();

    // Update call duration for any call that had connected in the past.
    // TODO: Really, a call should only track its connect time,
    // TODO: and leave calculation of its duration to the view.
    this._calls.forEach(function(call) {
      if (call.connectTime !== 0) {
        var endTime = call.disconnectTime || Date.now();
        call.duration = endTime - call.connectTime;
      }
    });

    return this._calls;
  },

  _publishCalls: function() {
    // Persist the new state.
    PhoneApi._writeCalls();
    // And then notify clients.
    PhoneApi._broadcastEventNotification();
  },

  _addCall: function(call) {
    this._calls[this._getCalls().length] = call;
    this._publishCalls();
  },

  _broadcastEventNotification: function() {
    // Broadcast the notification asynchronously.
    var id = this.PHONE_EVENT_NOTIFICATION;
    setTimeout(
      function() {
        console.log('Firing ' + id);
        PhoneApi._broadcast(id, {});
      },
      0);
  },

  _broadcastErrorNotification: function(errorCode) {
    // Broadcast the notification asynchronously.
    var id = this.PHONE_ERROR_NOTIFICATION;
    setTimeout(
      function() {
        console.log('Firing ' + id);
        PhoneApi._broadcast(id, {'errorCode': errorCode});
      },
      0);
  },

  _broadcastLogNotification: function(message) {
    // Broadcast the notification asynchronously.
    var id = this.PHONE_LOG_NOTIFICATION;
    setTimeout(
      function() {
        console.log('Firing ' + id);
        PhoneApi._broadcast(id, message);
      },
      0);
  },

  _getState: function() {
    // TODO: Do we really need a global phone state?
    if (this._getCalls().length === 0) {
      return 'IDLE';
    }
    switch (this._getDefaultPhoneCall().state) {
    case 'RINGING':
      return 'RINGING';
    case 'DIALING':
    case 'ACTIVE':
    case 'HOLDING':
      return 'OFFHOOK';
    case 'DISCONNECTED':
    case 'IDLE':
    default:
      return 'IDLE';
    }
  },

  _getSpeaker: function() {
    return this._stringToBoolean(localStorage['speaker']);
  },

  _getMute: function() {
    return this._stringToBoolean(localStorage['mute']);
  },

  _getBluetooth: function() {
    return this._stringToBoolean(localStorage['bluetooth']);
  },

  _canMakeCall: function() {
    if (this._getCalls().length === 0) {
      return true;
    }
    if (this._getCalls().length > 1) {
      return false;
    }
    // Set based on default call state.
    switch (this._getDefaultPhoneCall().state) {
    case 'RINGING':
    case 'DIALING':
      return false;
    default:
      return true;
    }
  },

  _canAnswerCall: function(call) {
    return (call !== null) && (call.state === 'RINGING');
  },

  _canEndCall: function(call) {
    return (call !== null) && (call.state !== 'DISCONNECTED') && (call.state !== 'IDLE');
  },

  _canHoldCall: function(call) {
    if (this._getCalls().length > 1) {
      return false;
    }
    return (call !== null) && (call.state === 'ACTIVE');
  },

  _canResumeCall: function(call) {
    if (this._getCalls().length > 1) {
      return false;
    }
    return (call !== null) && (call.state === 'HOLDING');
  },

  _canSendDtmf: function(call) {
    return (call !== null) && (call.canSendDtmf === true);
  },

  _canSwitchCalls: function() {
    var calls = this._getCalls();
    // There should be exactly 2 calls.
    if (calls.length !== 2) {
      return false;
    }
    // Of which, one should be active and another holding.
    switch (calls[0].state) {
    case 'ACTIVE':
      return calls[1].state === 'HOLDING';
    case 'HOLDING':
      return calls[1].state === 'ACTIVE';
    default:
      return false;
    }
  },

  _canMergeCalls: function() {
    // Same conditions as _canSwitchCalls:
    // There should be exactly 2 calls.
    // Of which, one should be active and another holding.
    return this._canSwitchCalls();
  },

  _canSetSpeaker: function() {
    if (this._getCalls().length === 0) {
      return false;
    }
    // Set based on default call state.
    switch (this._getDefaultPhoneCall().state) {
    case 'RINGING':
    case 'DIALING':
    case 'ACTIVE':
    case 'HOLDING':
      return true;
    default:
      return false;
    }
  },

  _canSetMute: function() {
    if (this._getCalls().length === 0) {
      return false;
    }
    // Set based on default call state.
    // TODO: Should be able to set mute when RINGING or HOLDING.
    switch (this._getDefaultPhoneCall().state) {
    case 'ACTIVE':
      return true;
    default:
      return false;
    }
  },

  _canSetBluetooth: function() {
    // TODO: Set based on default call state.
    return false;
  },

  _readMmiCode: function() {
    var mmiCode = localStorage['mmiCode'];
    if (typeof(mmiCode) !== 'string') {
      mmiCode = '';
    }
    this._mmiCode = mmiCode;

    if (this._isMmiCode(this._mmiCode)) {
      this._createMmiCode(this._mmiCode);
    }
  },

  _writeMmiCode: function() {
    localStorage['mmiCode'] = this._mmiCode;
  },

  _isMmiCode: function(dialString) {
    // True if the string is of the form "*NN...N#".
    return (/^\*\d*#$/.test(dialString));
  },

  _updateMmiCode: function(mmiCode) {
    // Update and persist the new state.
    this._mmiCode = mmiCode;
    this._writeMmiCode();
  },

  _createMmiCode: function(mmiCode) {
    this._updateMmiCode(mmiCode);

    // Broadcast the notification asynchronously.
    var mmiInitiateId = this.PHONE_MMI_INITIATE_NOTIFICATION;
    setTimeout(
      function() {
        console.log('Firing ' + mmiInitiateId);
        PhoneApi._broadcast(mmiInitiateId, {isCancelable: "false"});
      },
      0);

    // Pretend that the network responds after 5s.
    var _this = this;
    setTimeout(
      function() {
        // Complete requests for MMI codes of odd length,
        // and fail requests for MMI codes of even length.
        var state = (mmiCode.length % 2) ? 'COMPLETE' : 'FAILED';
        var message = (state === 'COMPLETE') ?
          'The network completed the request :)' :
          'The network failed the request :(';

        // Broadcast the notification asynchronously.
        var mmiProgressId = _this.PHONE_MMI_PROGRESS_NOTIFICATION;
        setTimeout(
          function() {
            console.log('Firing ' + mmiProgressId);
            PhoneApi._broadcast(mmiProgressId, {state: state, message: message});
          },
          0);

        _this._updateMmiCode('');
      },
      5 * 1000);
  },

  // 4. Interface methods.

  getProperties: function() {
    var defaultPhoneCall = this._getDefaultPhoneCall();
    var properties = {
      state: this._getState(),
      speaker: this._getSpeaker(),
      mute: this._getMute(),
      bluetooth: this._getBluetooth(),
      hasPendingMmiCode: !!this._mmiCode,
      canMakeCall: this._canMakeCall(),
      canAnswerCall: this._canAnswerCall(defaultPhoneCall),
      canEndCall: this._canEndCall(defaultPhoneCall),
      canHoldCall: this._canHoldCall(defaultPhoneCall),
      canResumeCall: this._canResumeCall(defaultPhoneCall),
      canSendDtmf: this._canSendDtmf(defaultPhoneCall),
      canSwitchCalls: this._canSwitchCalls(),
      canMergeCalls: this._canMergeCalls(),
      canSetSpeaker: this._canSetSpeaker(),
      canSetMute: this._canSetMute(),
      canSetBluetooth: this._canSetBluetooth()
    };
    return JSON.stringify(properties);
  },

  getPhoneLine: function() {
    return JSON.stringify(this._PHONE_LINE);
  },

  getPhoneCalls: function() {
    // TODO: Why is phoneCalls an object with only one field that's an array?
    var phoneCalls = { calls: this._getCalls() };
    return JSON.stringify(phoneCalls);
  },

  /**
   * The default call is chosen in the following priority order:
   * RINGING > ACTIVE | DIALING > HOLDING > DISCONNECTED > IDLE
   */
  _getPhoneCallStatePriority: function(state) {
    switch(state) {
    case 'RINGING':
      return 5;
    case 'ACTIVE':
    case 'DIALING':
      return 4;
    case 'HOLDING':
      return 3;
    case 'DISCONNECTED':
      return 2;
    case 'CONGESTION':
    case 'LIMIT_EXCEEDED':
    case 'LOST_SIGNAL':
      return 1.5;
    case 'IDLE':
      return 1;
    default:
      return 0;
    }
  },

  _getDefaultPhoneCall: function() {
    if (this._getCalls().length === 0) {
      return null;
    }

    var defaultCall = { state: 'IDLE' };
    this._getCalls().forEach(function(call) {
      if (this._getPhoneCallStatePriority(call.state) >
          this._getPhoneCallStatePriority(defaultCall.state)) {
        defaultCall = call;
      }
    }, this);
    return defaultCall;
  },

  getDefaultPhoneCall: function() {
    return JSON.stringify(this._getDefaultPhoneCall());
  },

  getE164Format: function(phoneNumber) {
    var e164Number = "";
    if (/^1\d{10}$/.test(phoneNumber)) {
      e164Number = "+" + phoneNumber;
    } else if (/^\d{10}$/.test(phoneNumber)) {
      e164Number = "+1" + phoneNumber;
    }
    return e164Number;
  },

  getRegionCodeForPhoneNumber: function(phoneNumber) {
    return 'US';
  },

  _meaninglessCharsPattern: /[ ()-\/.]/g,
  _possibleNumberPattern: /\+?\d{3,15}/,
  isPossiblePhoneNumber: function(phoneNumber) {
    return phoneNumber &&
      phoneNumber.replace(this._meaninglessCharsPattern, "").
        match(this._possibleNumberPattern);
  },

  isEmergencyPhoneNumber: function(phoneNumber) {
    return (phoneNumber === '611') || (phoneNumber === '911');
  },

  _getNextCallId: function() {
    var maxId = -1;
    this._getCalls().forEach(function(call) {
      var id = parseInt(call.id, 10);
      if (id > maxId) {
        maxId = id;
      }
    });
    return (maxId + 1).toString();
  },

  _getCall: function(callId) {
    var found = null;
    if (callId) {
      this._getCalls().forEach(function(call) {
        if (call.id === callId) {
          found = call;
        }
      });
    }
    return found || this._getDefaultPhoneCall();
  },

  _getCallTypes: function() {
    var callTypes = {};
    this._getCalls().forEach(function(call) {
      callTypes[call.state] = call;
    });
    return callTypes;
  },

  _transitionCall: function(fromState, toState) {
    var foundCall;
    // Find one call in the required state.
    this._getCalls().forEach(function(call) {
      if (call.state == fromState) {
        foundCall = call;
      }
    });
    // And transition it to the requested state.
    if (foundCall) {
      foundCall._setState(toState);
    }
  },

  _handleSecretCode: function(dialString) {
    if (dialString.length > 8 && dialString.match(/^\*#\*#/) && dialString.match(/#\*#\*$/)) {
      var code = dialString.substring(4, dialString.length - 4);
      console.info("Dialed secret code: " + code);
      return true;
    }
    return false;
  },

  makeCall: function(dialString, peerContext, isEmergency) {
    var state = this.getSimState();

    // PhoneAPI.makeCall() also checks to see if the build type != 'user',
    // but it's probably safe to skip that here
    if (!isEmergency && this._handleSecretCode(dialString)) {
      return this.CALL_SECRET_CODE;
    }

    if (dialString === 'voicemail' && !TelephonyApi.getVoiceMailNumber()) {
      return this.CALL_FAILED_INVALID_VOICEMAIL_NUMBER;
    }

    var peer = new PhoneApi.Peer(dialString);
    if (isEmergency && peer._getType() !== 'EMERGENCY') {
      return this.CALL_FAILED_EMERGENCY_CALLS_ONLY;
    }

    if (TelephonyApi.isAirplaneModeEnabled()) {
      return this.CALL_FAILED_POWER_OFF;
    }

    if (state === this.SIM_STATE_ABSENT ||
        state === this.SIM_STATE_UNKNOWN) {
      return this.CALL_FAILED_OUT_OF_SERVICE;
    }

    if (!this._canMakeCall()) {
      return this.CALL_FAILED;
    }

    if (this._isMmiCode(dialString)) {
      this._createMmiCode(dialString);
      return this.CALL_DIALED_MMI;
    }

    // Hold currently active call.
    this._transitionCall('ACTIVE', 'HOLDING');

    var call =
      new PhoneApi.Call(this._getNextCallId(), 'DIALING', [peer]);
    this._addCall(call);
    return this.CALL_DIALED;
  },

  answerCall: function(callId) {
    var call = this._getCall(callId);
    if (!this._canAnswerCall(call)) {
      return;
    }

    // Hold currently active call.
    this._transitionCall('ACTIVE', 'HOLDING');

    call._setState('ACTIVE');
  },

  endCall: function(callId) {
    var call = this._getCall(callId);
    if (!this._canEndCall(call)) {
      return;
    }

    // Activate currently held call.
    this._transitionCall('HOLDING', 'ACTIVE');

    call && call._setState('DISCONNECTED');
  },

  dropCall: function(callId) {
    var call = this._getCall(callId);
    // no checking to see if call can end, no politely transitioning from
    // holding to active, this call is droppin'

    call._setState('CONGESTION'); // alternatives: LIMIT_EXCEEDED, LOST_SIGNAL
  },

  holdCall: function(callId) {
    var call = this._getCall(callId);
    if (!this._canHoldCall(call)) {
      return;
    }

    // Activate currently held call.
    this._transitionCall('HOLDING', 'ACTIVE');

    call._setState('HOLDING');
  },

  resumeCall: function(callId) {
    var call = this._getCall(callId);
    if (!this._canResumeCall(call)) {
      return;
    }

    // Hold currently active call.
    this._transitionCall('ACTIVE', 'HOLDING');

    call._setState('ACTIVE');
  },

  sendDtmf: function(callId, c) {
    // Do nothing
  },

  cleanupCalls: function() {
    // TODO: Remove disconnected peers.
    console.error('Not implemented!');
  },

  switchCalls: function() {
    if (!this._canSwitchCalls()) {
      return;
    }

    // Hold currently active call & activate currently held call.
    var callTypes = this._getCallTypes();
    if (callTypes['ACTIVE'] && callTypes['HOLDING']) {
      callTypes['ACTIVE']._setState('HOLDING');
      callTypes['HOLDING']._setState('ACTIVE');
    }
  },

  mergeCalls: function() {
    if (!this._canMergeCalls()) {
      return;
    }

    // Merge peers from held call into active call & disconnect held call.
    // TODO: Confirm that this mirrors the real phone behavior.
    var callTypes = this._getCallTypes();
    if (callTypes['ACTIVE'] && callTypes['HOLDING']) {
      callTypes['ACTIVE'].isMergedCall = true;
      callTypes['ACTIVE'].peers =
        callTypes['ACTIVE'].peers.concat(callTypes['HOLDING'].peers);
      callTypes['HOLDING']._setState('DISCONNECTED');
    }
  },

  setSpeaker: function(speakerMode) {
    var speaker = this._getSpeaker();
    if (this._canSetSpeaker() && (speaker !== speakerMode)) {
      localStorage['speaker'] = speakerMode;
      this._broadcastEventNotification();
    }
  },

  setMute: function(muteMode) {
    var mute = this._getMute();
    if (this._canSetMute() && (mute !== muteMode)) {
      localStorage['mute'] = muteMode;
      this._broadcastEventNotification();
    }
  },

  setBluetooth: function(bluetoothMode) {
    var bluetooth = this._getBluetooth();
    if (this._canSetBluetooth() && (bluetooth !== bluetoothMode)) {
      localStorage['bluetooth'] = bluetoothMode;
      this._broadcastEventNotification();
    }
  },

  getCallerIdSetting: function() {
    var _this = this;
    setTimeout(
      function() {
        var id = _this.PHONE_SETTING_COMPLETE_NOTIFICATION;
        var phoneSetting = {
          type: 'GET_CLIR_SETTING',
          success: true,
          value: _this._clir
        };
        console.log('Firing ' + id);
        PhoneApi._broadcast(id, {phoneSetting: JSON.stringify(phoneSetting)});
      },
      2 * 1000);
  },

  setCallerIdSetting: function(value) {
    var _this = this;
    setTimeout(
      function() {
        var id = _this.PHONE_SETTING_COMPLETE_NOTIFICATION;
        _this._clir = value;
        var phoneSetting = {
          type: 'SET_CLIR_SETTING',
          success: true
        };
        console.log('Firing ' + id);
        PhoneApi._broadcast(id, {phoneSetting: JSON.stringify(phoneSetting)});
      },
      2 * 1000);
  },

  getCallForwardSetting: function() {
    var _this = this;
    setTimeout(
      function() {
        var id = _this.PHONE_SETTING_COMPLETE_NOTIFICATION;
        var phoneSetting = {
          type: 'GET_CALL_FORWARD_SETTING',
          success: true,
          status: _this._callForwardStatus,
          number: _this._callForwardNumber
        };
        console.log('Firing ' + id);
        PhoneApi._broadcast(id, {phoneSetting: JSON.stringify(phoneSetting)});
      },
      2 * 1000);
  },

  setCallForwardSetting: function(status, number) {
    var _this = this;
    setTimeout(
      function() {
        var id = _this.PHONE_SETTING_COMPLETE_NOTIFICATION;
        _this._callForwardStatus = status;
        _this._callForwardNumber = number || _this._callForwardNumber;
        TelephonyApi._setCallForwardingState(status);
        var phoneSetting = {
          type: 'SET_CALL_FORWARD_SETTING',
          success: true
        };
        console.log('Firing ' + id);
        PhoneApi._broadcast(id, {phoneSetting: JSON.stringify(phoneSetting)});
      },
      2 * 1000);
  },

  _verifySimPin: function(pin) {
    if ((this._simState !== this.SIM_STATE_PIN_REQUIRED) &&
        (this._simState !== this.SIM_STATE_READY)) {
      return false;
    }

    if (pin === this._simPin) {
      this._simState = this.SIM_STATE_READY;
      this._simPinRetries = this._SIM_PIN_RETRIES;
      return true;
    }

    if (this._simPinRetries > 0) {
      this._simPinRetries--;
    }
    if (this._simPinRetries === 0) {
      this._simState = this.SIM_STATE_PUK_REQUIRED;
    }
    return false;
  },

  _verifySimPuk: function(puk) {
    if (this._simState !== this.SIM_STATE_PUK_REQUIRED) {
      return false;
    }

    if (puk === this._SIM_PUK) {
      this._simState = this.SIM_STATE_READY;
      this._simPinRetries = this._SIM_PIN_RETRIES;
      this._simPukRetries = this._SIM_PUK_RETRIES;
      return true;
    }

    if (this._simPukRetries > 0) {
      this._simPukRetries--;
    }
    if (this._simPukRetries === 0) {
      this._simState = this.SIM_STATE_BLOCKED;
    }
    return false;
  },

  getSimState: function() {
    if ((this._simState === this.SIM_STATE_READY) &&
        TelephonyApi && TelephonyApi.isAirplaneModeEnabled()) {
      return this.SIM_STATE_UNKNOWN;
    }
    return this._simState;
  },

  // Test hook.
  _setSimState: function(state) {
    this._simState = state;
    PhoneApi._broadcast(
      this.PHONE_SETTING_COMPLETE_NOTIFICATION,
      {
        phoneSetting: JSON.stringify({
          type: 'SUPPLY_SIM_PIN',
          success: true
        })
      }
    );
    PhoneApi._broadcast('telephony.SIM_STATE_CHANGED', {});
  },

  getSimPinSetting: function() {
    return this._simPinStatus;
  },

  getSimPinRetries: function() {
    return this._simPinRetries;
  },

  getSimPukRetries: function() {
    return this._simPukRetries;
  },

  // Test hook.
  _setSimPinSetting: function(status) {
    this._simPinStatus = status;
    PhoneApi._broadcast(
      this.PHONE_SETTING_COMPLETE_NOTIFICATION,
      {
        phoneSetting: JSON.stringify({
          type: 'SET_SIM_PIN_SETTING',
          success: true
        })
      }
    );
  },

  setSimPinSetting: function(status, pin) {
    var _this = this;
    setTimeout(
      function() {
        var id = _this.PHONE_SETTING_COMPLETE_NOTIFICATION;
        var success =
          (_this._simState === _this.SIM_STATE_READY) &&
          _this._verifySimPin(pin);
        if (success) {
          _this._simPinStatus = status;
        }
        var phoneSetting = {
          type: 'SET_SIM_PIN_SETTING',
          success: success
        };
        console.log('Firing ' + id);
        PhoneApi._broadcast(id, {phoneSetting: JSON.stringify(phoneSetting)});
      },
      2 * 1000);
  },

  supplySimPin: function(pin) {
    var _this = this;
    setTimeout(
      function() {
        var id = _this.PHONE_SETTING_COMPLETE_NOTIFICATION;
        var success = _this._verifySimPin(pin);
        if (success) {
          _this._simState = _this.SIM_STATE_READY;
          PhoneApi._broadcast('telephony.SIM_STATE_CHANGED', {});
        }
        var phoneSetting = {
          type: 'SUPPLY_SIM_PIN',
          success: success
        };
        console.log('Firing ' + id);
        PhoneApi._broadcast(id, {phoneSetting: JSON.stringify(phoneSetting)});
      },
      2 * 1000);
  },

  changeSimPin: function(oldPin, newPin) {
    var _this = this;
    setTimeout(
      function() {
        var id = _this.PHONE_SETTING_COMPLETE_NOTIFICATION;
        var success = _this._verifySimPin(oldPin);
        if (success) {
          _this._simPin = newPin;
        }
        var phoneSetting = {
          type: 'CHANGE_SIM_PIN',
          success: success
        };
        console.log('Firing ' + id);
        PhoneApi._broadcast(id, {phoneSetting: JSON.stringify(phoneSetting)});
      },
      2 * 1000);
  },

  resetSimPin: function(puk, newPin) {
    var _this = this;
    setTimeout(
      function() {
        var id = _this.PHONE_SETTING_COMPLETE_NOTIFICATION;
        var success = _this._verifySimPuk(puk);
        if (success) {
          _this._simPin = newPin;
        }
        var phoneSetting = {
          type: 'RESET_SIM_PIN',
          success: success
        };
        console.log('Firing ' + id);
        PhoneApi._broadcast(id, {phoneSetting: JSON.stringify(phoneSetting)});
      },
      2 * 1000);
  },

  _notifyPhoneSettingComplete: function(phoneSetting) {
    var _this = this;
    setTimeout(
      function() {
        var id = _this.PHONE_SETTING_COMPLETE_NOTIFICATION;
        console.debug('Firing ' + id);
        PhoneApi._broadcast(id, {phoneSetting: JSON.stringify(phoneSetting)});
      },
      2 * 1000);
  },

  getNetworkList: function() {
    this._notifyPhoneSettingComplete({
      type: 'GET_NETWORK_LIST',
      success: true,
      networks: [{name: 'Corona', numeric: '100200', state: 'unknown'}]
    });
  },

  getNetworkSelectionAllowed: function() {
    return true;
  },

  setNetworkSelectionManual: function(name, numeric) {
    this._notifyPhoneSettingComplete({
      type: 'SET_NETWORK_SELECTION_MANUAL',
      success: true
    });
  },

  setNetworkSelectionAutomatic: function() {
    this._notifyPhoneSettingComplete({
      type: 'SET_NETWORK_SELECTION_AUTOMATIC',
      success: true
    });
  },

  setPreferredNetworkType: function(networkType) {
    localStorage['networkType'] = networkType;
    this._notifyPhoneSettingComplete({
      type: 'SET_PREFERRED_NETWORK_TYPE',
      success: true,
    });
  },

  getPreferredNetworkType: function() {
    var type = localStorage['networkType'];
    this._notifyPhoneSettingComplete({
      type: 'GET_PREFERRED_NETWORK_TYPE',
      success: true,
      networkType: type
    });
  },

  silenceRinger: function() {
    // Do nothing.
  },

  setPeerContext: function(callId, peerId, context) {
    var call = this._getCall(callId);
    if (!call) {
      return;
    }

    call.peers.forEach(function(peer) {
      if (peer.id === peerId) {
        peer.context = context;
      }
    });
  },

  sendMmiResponse: function(response) {
    // TODO: Implement.
  },

  cancelMmi: function() {
    // TODO: Implement.
  },

  // This API is a test-aid, used to trigger incoming calls,
  // invoke it as PhoneAPI.receiveCall('911').
  // On the device, it uses Twilio.
  // On the simulator, it fakes an incoming calls as implemented below.
  receiveCall: function(caller) {
    var _this = this;

    if (!caller) {
      return false;
    }

    // Iff we can make a call, we can receive a call.
    if (!_this._canMakeCall()) {
      console.error('Mock PhoneApi.receive: cannot receive a call');
      return false;
    }

    setTimeout(
      function() {
        var peer = new PhoneApi.Peer(caller);
        var call =
          new PhoneApi.Call(_this._getNextCallId(), 'RINGING', [peer]);
        _this._addCall(call);
      },
      5 * 1000);

    return true;
  }
};

PhoneApi.Peer = function(number) {
  var PhoneNumberUtil =
    require('third-party/libphonenumber').PhoneNumberUtil;
  this.id = Date.now().toString();
  this.uri = 'tel:' + number;
  this.type = this._getType();
  this.displayName = PhoneNumberUtil.normalize(number);
  this.context = '';

  if (number === 'voicemail') {
    this.uri = 'tel:' + TelephonyApi.getVoiceMailNumber();
  }
};

PhoneApi.Peer.prototype._getType = function() {
  switch(this.uri) {
  case 'tel:': return 'UNKNOWN';
  case 'tel:911': return 'EMERGENCY';
  case 'tel:611': return 'EMERGENCY'; // Used on 'eng' builds for the device.
  case 'tel:voicemail': return 'VOICEMAIL';
  default: return 'NORMAL';
  }
};

PhoneApi.Call = function(callId, state, peers) {
  this.id = callId;
  this.state = 'IDLE';
  this.disconnectCause = 'NOT_DISCONNECTED';
  this.isMergedCall = false;
  this.isIncoming = false;
  this.duration = 0;
  this.connectTime = 0;
  this.disconnectTime = 0;
  this.canSendDtmf = false;
  this.peers = peers;

  this._setState(state);
};

PhoneApi.Call.prototype = {
  /**
   * The following diagram encodes the transitions between call states:
   *
   *             .--1--> RINGING --3--.
   *             |                    |
   *     IDLE ---+                    +--> ACTIVE <--[5,6]--> HOLDING
   *      ^      |                    |
   *      |      '--2--> DIALING --4--'
   *      8
   *      |
   * DISCONNECTED <--7-- [RINGING | DIALING | ACTIVE | HOLDING]
   *
   * Triggering Events:
   * 1: new incoming call
   * 2: makeCall()
   * 3: answerCall()
   * 4: peer accepts call
   * 5: holdCall()
   * 6: resumeCall()
   * 7: call disconnected, e.g. due to invocation of endCall()
   * 8: timeout (2s) or cleanupCalls()
   */
  _setState: function(state) {
    var _this = this;

    if (this.peers === []) {
      // We should have a valid set of peers in all states.
      return;
    }

    switch(state) {
    case 'RINGING':
      if (this.state === 'IDLE') {
        this.state = state;
        this.isIncoming = true;
      }
      break;

    case 'DIALING':
      if (this.state === 'IDLE') {
        this.state = state;

        // Pretend that the peer accepts after 5s.
        setTimeout(
          function() { _this._setState('ACTIVE'); },
          5 * 1000);
      }
      break;

    case 'ACTIVE':
      if ((this.state === 'IDLE') ||
          (this.state === 'RINGING') ||
          (this.state === 'DIALING') ||
          (this.state === 'HOLDING')) {
        this.state = state;
        if (this.connectTime === 0) {
          this.connectTime = Date.now();
        }
        this.canSendDtmf = true;
      }
      break;

    case 'HOLDING':
      if ((this.state === 'IDLE') ||
          (this.state === 'ACTIVE')) {
        this.state = state;
        this.canSendDtmf = false;
      }
      break;

    case 'DISCONNECTED':
      this.state = state;
      if (this.disconnectTime === 0) {
        this.disconnectTime = Date.now();
        this.disconnectCause = 'LOCAL';
        PhoneApi._broadcastLogNotification({
          callDetails: JSON.stringify(this)
        });
      }
      this.canSendDtmf = false;

      // Go idle after 2s.
      setTimeout(
        function() { _this._setState('IDLE'); },
        2 * 1000);
      break;

    case 'CONGESTION':
    case 'LIMIT_EXCEEDED':
    case 'LOST_SIGNAL':
      this.state = state;
      PhoneApi._broadcastLogNotification({callDetails: JSON.stringify(this)});
      break;

    case 'IDLE':
      if (this.state === 'DISCONNECTED') {
        this.state = state;
      }
      break;

    default:
      console.error('Mock PhoneApi.Call.setState: Invalid state ' + state);
      break;
    }

    // Notify PhoneApi (asynchronously).
    setTimeout(PhoneApi._publishCalls, 0);
  }
};
});

// module: bolt_touch/vendor/jscroll
// file:   ../../../frameworks/bolt_touch/lib/vendor/jscroll.js
define("bolt_touch/vendor/jscroll", function(require, exports, module) {
// Copyright 2011 Facebook, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.


// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind
if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== "function") {
      // closest thing possible to the ECMAScript 5 internal IsCallable function
      throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var fSlice = Array.prototype.slice,
        aArgs = fSlice.call(arguments, 1),
        fToBind = this,
        fNOP = function () {},
        fBound = function () {
          return fToBind.apply(this instanceof fNOP
                                 ? this
                                 : oThis || window,
                               aArgs.concat(fSlice.call(arguments)));
        };

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();

    return fBound;
  };
}


/*
  jScroll scrolling library
  Author: Jonathan Kaldor (jmkaldor@fb.com)

  Current limitations: only scrolls vertically

*/
function JScroll(root, viewport, name, options) {

  if (!root || !viewport) {
    return false;
  }

  // the actual region which is scrolling
  this.box = root;
  // the container which bounds
  this.viewport = viewport;
  // unique name for this scrolling region w/r/t the webview
  this.name = name;

  // last touch event and the time we handled it
  this.lastDragTime = 0;
  // copy of the touch event params since safari seems to reuse the touch objects
  // (btw: wtf!)
  this.activeTouchCoords = {"clientX": 0, "clientY": 0};

  // Flags indicating whether certain events are occurring now
  this.touchEventOccurring = false;
  this.scrollEventOccurring = false;
  this.animationEventOccurring = false;
  // Whether the currently active scroll allows scrolling in the x and y direction.
  // This is determined per-scroll as a combination of the options.scrollEnabled
  // variables and the primary direction of the touch event
  this.currentScrollEnabledX = false;
  this.currentScrollEnabledY = false;

  this.options = {};

  this.canChangeScrollDirection = true;
  this.hasClampedScrollDirection = false;

  // The model used to scroll.  A null model means no scrolling in that direction
  this.options.scrollModel = {"x": null, "y": null};
  this.scrollEnabledX = true;
  this.scrollEnabledY = true;
  // Null simulator used for convenience when there is a null model
  this.nullSim = {
    "position" : [0],
    "velocity" : [0],
    "dataLen"  : 1,
    "duration" : 0,
    "fps"      : 30,
    "getPosition" : function(time) { return 0; },
    "getVelocity" : function(time) { return 0; },
    "needAnimation" : function() { return false; },
  };

  this.options.clampingBreakTimeThreshold = 500;
  this.touchStartTime = 0;

  this.options.velocityEstimatorX = options.velocityEstimatorX || new JVelocityEstimator();
  this.options.velocityEstimatorY = options.velocityEstimatorY || new JVelocityEstimator();

  // Whether to do a delayed scrollEnd broadcast if the scrolling animation is interrupted.
  // If this is enabled and a scrollStart event happens during an inertial scroll animation,
  // the end event will not be broadcast unless no move events occur during the threshold
  // period.
  this.options.delayScrollEnd = true;
  this.options.delayScrollEndThreshold = 300;

  //Variables controlling the multiple swipe acceleration feature
  this.options.swipeVelocityThreshold = 1000;
  this.options.swipeIntervalCount = 3;
  this.options.swipeMaxAverageInterval = 500; // in ms
  this.options.swipeVelocityMultiplier = 1.2;
  this.options.swipeMaxVelocityScale = 4.0;

  this.options.animationQuality = 1.0/15.0;

  // Variables holding the simulated data.  When not scrolling, simPosition[0] holds the
  // current position of the scrollable area
  this.scrollStartTime = 0;
  this.simPositionX = Array(32);
  this.simVelocityX = Array(32);
  this.simPositionY = Array(32);
  this.simVelocityY = Array(32);
  this.simPositionX[0] = 0;
  this.simPositionY[0] = 0;
  this.simVelocityX[0] = 0;
  this.simVelocityY[0] = 0;
  this.simDataLength = 1;
  this.duration = 0;

  this.options.debugTouches = false;
  this.debugMousePos = [];

  this.options.scrollStartListener = function(event) {}
  this.options.scrollEndListener = function(event) {}
  this.options.scrollMoveListener = function(event) {}
  this.options.scrollToListener = function(event) {}
  this.options.inertialScrollInterruptedListener = function(event) {}
  this.beginAnimationListenerFn = this.beginAnimatedScroll.bind(this);
  this.moveAnimationListenerFn = this.moveAnimatedScroll.bind(this);
  this.endAnimationListenerFn = this.endAnimatedScroll.bind(this);
  this.broadcastScrollEndFn = this.broadcastScrollEnd.bind(this);
  this.broadcastScrollEndTimeout = null;
  this.didBroadcastScrollStart = false;

  this._touchStartCaptureFn = this.consumeTouchOnScroll.bind(this);
  this._touchStartBubbleFn = this.startTouch.bind(this);
  this._touchMoveFn = this.updateTouch.bind(this);
  this._touchEndFn = this.endTouch.bind(this);
  this.isTouchDevice = ("ontouchstart" in window);
  this.viewport.addEventListener(this.isTouchDevice ? 'touchstart' : 'mousedown',
                                 this._touchStartCaptureFn, true);
  this.viewport.addEventListener(this.isTouchDevice ? 'touchstart' : 'mousedown',
                                 this._touchStartBubbleFn, false);
  this.viewport.addEventListener(this.isTouchDevice ? 'touchmove' : 'mousemove',
                                 this._touchMoveFn, false);
  this.viewport.addEventListener(this.isTouchDevice ? 'touchend' : 'mouseup',
                                 this._touchEndFn, true);

  this.animCssPage = JScroll._getCSSRule();
  this.animCssScrollH = JScroll._getCSSRule();
  this.animCssScrollV = JScroll._getCSSRule();

  this.options.scrollbarEnabled = true;
  this.options.scrollbarClass = '';
  this.options.scrollbarStyle = {
    padding: 2,
    size: 5,
    minLength: 12,
    borderWidth: 2,
    borderColor: "rgba(204,204,204,0.353)",
    borderRadius: 5,
    backgroundColor: "rgba(51,51,51,0.647)",
  };

  // Dimensions of viewport and scrollable region.  Viewport starts at
  // (1,1) because a viewport width of 0 makes the inertial model unhappy
  this.viewportSize = {width: 1, height: 1};
  this.scrollableAreaSize = {left: 0, top: 0, right: 0, bottom: 0};
  // Used to position the scrollbars on screen.  Set in positionScrollbars()
  this.scrollbarViewWidth = 0;
  this.scrollbarViewHeight = 0;
  this.scrollbarScrollWidth = 0;
  this.scrollbarScrollHeight = 0;

  for (var i in options) {
    this.options[i] = this.deepCopy(this.options[i], options[i]);
  }

  // Copy the model from options to internal variables
  this.modelX = this.options.scrollModel.x;
  this.modelY = this.options.scrollModel.y;
  this.velocityEstimatorX = this.options.velocityEstimatorX;
  this.velocityEstimatorY = this.options.velocityEstimatorY;

  this.swipeVelocityScale = 1.0;
  this.swipeIntervals = Array(this.options.swipeIntervalCount);
  this.swipeIntervalsNextIndex = 0;
  this.swipeStartAngX = 0;
  this.swipeStartAngY = 0;

  var viewportStyle = getComputedStyle(this.viewport);
  var scrollStyle = getComputedStyle(this.box);
  this.setViewport(parseInt(viewportStyle.width), parseInt(viewportStyle.height));
  this.setHorizontalScrollRegion(0, parseInt(scrollStyle.width));
  this.setVerticalScrollRegion(0, parseInt(scrollStyle.height));
  this.enableScrollbars(this.options.scrollbarEnabled);
  setTimeout(this.hideScrollbars.bind(this), 0);
}

// Static private members

JScroll._globalPrefix = 'JScroll_';

// Static functions

// Set the global prefix for all JScroll objects.  JScroll needs to create
// some objects (particularly CSS rules) which will leak into global
// namespaces.  This sets the prefix that JScroll will use to identify these
// objects, which should be a unique prefix in the system
JScroll.setGlobalPrefix = function(name) {
  JScroll._globalPrefix = name;
}

// Private method to retrieve a CSS keyframe rule suitable for animation
JScroll._getCSSRule = function() {
  // We use a single global stylesheet for all JScroll objects
  if (!JScroll._animCssStyleSheet) {
    var sheet = document.createElement("style");
    document.head.appendChild(sheet);
    JScroll._animCssStyleSheet = document.styleSheets[document.styleSheets.length-1];
    JScroll._animCssFreeRules = [];
    JScroll._animCssNextRuleID = 0;
  }
  if (JScroll._animCssFreeRules.length == 0) {
    // We have no free rules.  Add some more
    for (var i = 0; i < 9; ++i) {
      var css = '@-webkit-keyframes \'' + JScroll._globalPrefix +
        (JScroll._animCssNextRuleID++) + '\' {\n';
      css += 'from { -webkit-transform: translate3d(0px, 0px, 0px); }\n';
      css += 'to { -webkit-transform: translate3d(0px, 0px, 0px); }\n';
      css += '}\n';
      var index = JScroll._animCssStyleSheet.cssRules.length;
      JScroll._animCssStyleSheet.insertRule(css, index);
      JScroll._animCssFreeRules.push(JScroll._animCssStyleSheet.cssRules[index]);
    }
  }
  return JScroll._animCssFreeRules.pop();
}

// Private method to return a requested CSS keyframe rule back to the pool
JScroll._freeCSSRule = function(rule) {
  JScroll._animCssFreeRules.push(rule);
}

// Destroy all DOM connections and free any allocated resources
JScroll.prototype.destroy = function() {
  JScroll._freeCSSRule(this.animCssPage);
  JScroll._freeCSSRule(this.animCssScrollH);
  JScroll._freeCSSRule(this.animCssScrollV);
  // Remove the event listeners
  this.viewport.removeEventListener(this.isTouchDevice ? 'touchstart' : 'mousedown',
                                    this._touchStartCaptureFn, true);
  this.viewport.removeEventListener(this.isTouchDevice ? 'touchstart' : 'mousedown',
                                    this._touchStartBubbleFn, false);
  this.viewport.removeEventListener(this.isTouchDevice ? 'touchmove' : 'mousemove',
                                    this._touchMoveFn, false);
  this.viewport.removeEventListener(this.isTouchDevice ? 'touchend' : 'mouseup',
                                    this._touchEndFn, true);
  // This will cause any scrollbars, if created, to be removed from
  // the DOM
  this.enableScrollbars(false);
}

JScroll.prototype.deepCopy = function(oSrc, oDest) {
  if (oDest == null) {
    return oSrc;
  }
  // From http://james.padolsey.com/javascript/deep-copying-of-objects-and-arrays/ .
  // Ugh, JS is ugly.
  if (Object.prototype.toString.call(oDest) === '[object Array]') {
    var arr = [];
    for (var i = 0, len = oDest.length; i < len; ++i) {
      arr[i] = this.deepCopy(null, oDest[i]);
    }
    return arr;
  } else if (typeof(oDest) == "object") {
    var obj = oSrc || {};
    for (var i in oDest) {
      obj[i] = this.deepCopy(obj[i], oDest[i]);
    }
    return obj;
  } else {
    return oDest;
  }
}

JScroll.prototype.assert = function(val, msg) {
  if (!val) {
    console.log("ASSERTION FAILURE: '" + msg + "'");
    throw msg;
  }
}

JScroll.prototype.setViewport = function(width, height) {
  this.viewportSize.width = width
  this.viewportSize.height = height;
  if (this.modelX) {
    this.modelX.setViewportSize(this.viewportSize.width);
  }
  if (this.modelY) {
    this.modelY.setViewportSize(this.viewportSize.height);
  }
  this.positionScrollbars();
}

JScroll.prototype.setHorizontalScrollRegion = function(left, right) {
  this.scrollableAreaSize.left = left;
  this.scrollableAreaSize.right = right
  if (this.modelX) {
    this.modelX.setScrollableArea(this.scrollableAreaSize.left, this.scrollableAreaSize.right);
  }
  this.positionScrollbars();
}

JScroll.prototype.setVerticalScrollRegion = function(top, bottom) {
  this.scrollableAreaSize.top = top;
  this.scrollableAreaSize.bottom = bottom;
  if (this.modelY) {
    this.modelY.setScrollableArea(this.scrollableAreaSize.top, this.scrollableAreaSize.bottom);
  }
  this.positionScrollbars();
}

JScroll.prototype.enableHScroll = function(enabled) {
  this.scrollEnabledX = enabled;
  this.currentScrollEnabledX = (this.currentScrollEnabledX && this.scrollEnabledX);
  this.modelX && this.modelX.enabled(this.currentScrollEnabledX);
}

JScroll.prototype.enableVScroll = function(enabled) {
  this.scrollEnabledY = enabled;
  this.currentScrollEnabledY = (this.currentScrollEnabledY && this.scrollEnabledY);
  this.modelY && this.modelY.enabled(this.currentScrollEnabledY);
}

JScroll.prototype.enableScrollbars = function(enabled) {
  this.options.scrollbarEnabled = enabled;
  var needsPositioning = false;
  if (this.options.scrollbarEnabled && this.modelX) {
    if (!this.horizontalScrollbar) {
      this.horizontalScrollbar = document.createElement("div");
      this.styleScrollbar(this.horizontalScrollbar);
      this.viewport.appendChild(this.horizontalScrollbar);
      needsPositioning = true;
    }
  } else {
    if (this.horizontalScrollbar) {
      this.viewport.removeChild(this.horizontalScrollbar);
      delete this.horizontalScrollbar;
      needsPositioning = true;
    }
  }
  if (this.options.scrollbarEnabled && this.modelY) {
    if (!this.verticalScrollbar) {
      this.verticalScrollbar = document.createElement("div");
      this.styleScrollbar(this.verticalScrollbar);
      this.viewport.appendChild(this.verticalScrollbar);
      needsPositioning = true;
    }
  } else {
    if (this.verticalScrollbar) {
      this.viewport.removeChild(this.verticalScrollbar);
      delete this.verticalScrollbar;
      needsPositioning = true;
    }
  }
  if (needsPositioning) {
    this.positionScrollbars();
  }
}

JScroll.prototype.styleScrollbar = function(scrollbar) {
  if (this.options.scrollbarClass) {
    scrollbar.className = this.options.scrollbarClass + (scrollbar == this.horizontalScrollbar ? "H" : "V");
  } else {
    scrollbar.style.backgroundColor = this.options.scrollbarStyle.backgroundColor;
    scrollbar.style.borderRadius = this.options.scrollbarStyle.borderRadius + "px";
    scrollbar.style.border = this.options.scrollbarStyle.borderWidth +"px solid " + this.options.scrollbarStyle.borderColor;
    scrollbar.style.padding = "0px";
  }
  scrollbar.style.position = "absolute";
  scrollbar.style.top = "0";
  scrollbar.style.left = "0";
  scrollbar.style.webkitTransformOrigin = "0% 0%";
}

JScroll.prototype.showScrollbars = function() {
  // Weirdly, setting the opacity to 1 here causes layout / repaint
  // every time the opacity is toggled.  Set it to 0.999 instead, ???, profit.
  if (this.horizontalScrollbar) {
    this.horizontalScrollbar.style.opacity = 0.999;
    this.horizontalScrollbar.style.webkitTransition = "";
  }
  if (this.verticalScrollbar) {
    this.verticalScrollbar.style.opacity = 0.999;
    this.verticalScrollbar.style.webkitTransition = "";
  }
}

JScroll.prototype.hideScrollbars = function() {
  if (this.horizontalScrollbar) {
    this.horizontalScrollbar.style.webkitTransition = "opacity 0.75s linear 0s";
    this.horizontalScrollbar.style.opacity = 0.0;
  }
  if (this.verticalScrollbar) {
    this.verticalScrollbar.style.webkitTransition = "opacity 0.75s linear 0s";
    this.verticalScrollbar.style.opacity = 0.0;
  }
}

JScroll.prototype.positionScrollbars = function() {
  var padding = this.options.scrollbarStyle.padding;
  var barWidth = this.options.scrollbarStyle.size;
  var borderWidth = this.options.scrollbarStyle.borderWidth;
  var minBarLen = this.options.scrollbarStyle.minLength;

  this.scrollbarViewWidth = this.viewportSize.width - 2*padding;
  this.scrollbarViewHeight = this.viewportSize.height - 2*padding;

  this.scrollbarScrollWidth = Math.max(
    this.scrollableAreaSize.right - this.scrollableAreaSize.left,
    this.scrollbarViewWidth
  );
  this.scrollbarScrollHeight = Math.max(
    this.scrollableAreaSize.bottom - this.scrollableAreaSize.top,
    this.scrollbarViewHeight
  );

  if (this.verticalScrollbar) {
    // reduce horizontal view to account for scrollbar
    this.scrollbarViewWidth = this.scrollbarViewWidth - borderWidth - barWidth;
  }
  if (this.horizontalScrollbar) {
    // reduce vertical view to account for scrollbar
    this.scrollbarViewHeight = this.scrollbarViewHeight - borderWidth - barWidth;
  }

  if (this.verticalScrollbar) {
    var height = Math.max(this.scrollbarViewHeight * this.scrollbarViewHeight / this.scrollbarScrollHeight, minBarLen);
    this.verticalScrollbar.style.width = barWidth + "px";
    this.verticalScrollbar.style.height = height + "px";
    this.verticalScrollbar.style.webkitTransform = this.getScrollbarCssTransform(this.getCurrentPositionY(this.getCurrentTime()), false);
  }
  if (this.horizontalScrollbar) {
    var width = Math.max(this.scrollbarViewWidth * this.scrollbarViewWidth / this.scrollbarScrollWidth, minBarLen);
    this.horizontalScrollbar.style.width = width + "px";
    this.horizontalScrollbar.style.height = barWidth + "px";
    this.horizontalScrollbar.style.webkitTransform = this.getScrollbarCssTransform(this.getCurrentPositionX(this.getCurrentTime()), true);
  }
}

JScroll.prototype.getScrollbarCssTransform = function(scrollPos, isHoriz) {
  var viewL, scrollL, offset;
  if (isHoriz) {
    viewL = this.scrollbarViewWidth;
    scrollL = this.scrollbarScrollWidth;
    offset = this.scrollableAreaSize.left;
  } else {
    viewL = this.scrollbarViewHeight;
    scrollL = this.scrollbarScrollHeight;
    offset = this.scrollableAreaSize.top;
  }
  var padding = this.options.scrollbarStyle.padding;
  var minBarLen = this.options.scrollbarStyle.minLength;

  var visFrac = viewL / scrollL;
  var valueFrac = (scrollL - viewL > 0 ? (scrollPos - offset) / (scrollL - viewL) : 0.0);
  var length = Math.max(viewL * visFrac, minBarLen);
  var pos = 0;
  var scale = 1.0;
  if (valueFrac < 0) {
    scale = Math.max(length + scrollPos - offset, minBarLen) / length;
  } else if (valueFrac > 1.0) {
    scale = Math.max(length - (scrollPos - offset - (scrollL - viewL)), minBarLen) / length;
    pos = viewL - scale*length;
  } else {
    pos = valueFrac * (1.0 - visFrac)*viewL;
  }
  if (isHoriz) {
    return "translate3d(" + Math.round(pos + padding) + "px," + Math.round(this.scrollbarViewHeight) + "px, 0px) scaleX(" + scale + ")";
  } else {
    return "translate3d(" + Math.round(this.scrollbarViewWidth) + "px, " + Math.round(pos + padding) + "px, 0px) scaleY(" + scale + ")";
  }
}

JScroll.prototype.updatePosition = function(dx, dy) {
  var x = this.modelX ? Math.round(this.modelX.updatePosition(dx)) : 0;
  var y = this.modelY ? Math.round(this.modelY.updatePosition(dy)) : 0;
  this.simPositionX[0] = x;
  this.simPositionY[0] = y;
  this.simDataLength = 1;
  this.box.style.webkitTransform = "translate3d(" + (-x) + "px, " + (-y) + "px, 0px)";
  if (this.verticalScrollbar) {
    this.verticalScrollbar.style.webkitTransform = this.getScrollbarCssTransform(y, false);
  }
  if (this.horizontalScrollbar) {
    this.horizontalScrollbar.style.webkitTransform = this.getScrollbarCssTransform(x, true);
  }
  if (this.options.scrollMoveListener) {
    this.options.scrollMoveListener(x, y);
  }
}

// Do all of the messy CSS-related stuff to apply a scrolling
// animation to the box, given initial velocity vx and vy (vx
// is ignored for the moment).  This calls the simulator to
// generate a set of keyframes, generates the CSS stylesheet
// containing the keyframes, updates the animation properties
// of the box to point to the new keyframes, and fires off the
// animation
JScroll.prototype.doAnimatedScroll = function(vx, vy) {
  var simX = this.modelX ? this.modelX.fling(vx) : this.nullSim;
  var simY = this.modelY ? this.modelY.fling(vy) : this.nullSim;
  if (!simX.needAnimation() && !simY.needAnimation()) {
    // Don't actually animate a scroll
    if (this.didBroadcastScrollStart) {
      this.broadcastScrollEnd(false);
    }
    this.scrollEventOccurring = false;
    this.hideScrollbars();
    return;
  }

  // We may have a pending scrollEnd notification due to an interrupted
  // animation.  Make sure we cancel it so we dont send two scrollEnds
  this.cancelBroadcastScrollEnd();

  // We may not have broadcast a scroll start before doing a fling, for
  // instance if we clicked down while it was in an overscrolled position
  // and then lifted up without moving
  if (!this.didBroadcastScrollStart) {
    this.broadcastScrollStart();
  }

  for (var i = this.animCssPage.cssRules.length-1; i >= 0; --i) {
    this.animCssPage.deleteRule(this.animCssPage.cssRules[i].keyText);
  }
  for (var i = this.animCssScrollH.cssRules.length-1; i >= 0; --i) {
    this.animCssScrollH.deleteRule(this.animCssScrollH.cssRules[i].keyText);
  }
  for (var i = this.animCssScrollV.cssRules.length-1; i >= 0; --i) {
    this.animCssScrollV.deleteRule(this.animCssScrollV.cssRules[i].keyText);
  }
  this.simPositionX[0] = Math.round(simX.getPosition(0));
  this.simPositionY[0] = Math.round(simY.getPosition(0));
  this.simVelocityX[0] = Math.round(simX.getVelocity(0));
  this.simVelocityY[0] = Math.round(simY.getVelocity(0));
  this.simDataLength = 1;
  this.duration = Math.max(simX.duration, simY.duration);
  this.animCssPage.insertRule('from { -webkit-transform: translate3d(' + (-this.simPositionX[0]) + 'px, ' + (-this.simPositionY[0]) + 'px, 0px); }');
  this.horizontalScrollbar && this.animCssScrollH.insertRule('from { -webkit-transform: ' + this.getScrollbarCssTransform(this.simPositionX[0], true) + '}');
  this.verticalScrollbar && this.animCssScrollV.insertRule('from { -webkit-transform: ' + this.getScrollbarCssTransform(this.simPositionY[0], false) + '}');
  // Figure out how many 'animation quality' frames occur over the duration, then how many steps
  // need to be taken in 0%...100% to approximately create that many frames
  var numFrames = Math.min(this.duration / this.options.animationQuality, 20);
  var stepSize = Math.ceil(100/numFrames);
  for (var i = stepSize; i < 100; i = i + stepSize, ++this.simDataLength) {
    var currTime = this.duration*i/100.0;
    this.simPositionX[this.simDataLength] = simX.getPosition(currTime);
    this.simVelocityX[this.simDataLength] = simX.getVelocity(currTime);
    this.simPositionY[this.simDataLength] = simY.getPosition(currTime);
    this.simVelocityY[this.simDataLength] = simY.getVelocity(currTime);
    this.animCssPage.insertRule('' + i + '% {-webkit-transform: translate3d(' + (-this.simPositionX[this.simDataLength]) + 'px, ' + (-this.simPositionY[this.simDataLength]) + 'px, 0px); }');
    if (this.horizontalScrollbar && this.simPositionX[this.simDataLength] != this.simPositionX[this.simDataLength-1]) {
      this.animCssScrollH.insertRule('' + i + '% { -webkit-transform: ' + this.getScrollbarCssTransform(this.simPositionX[this.simDataLength], true) + '}');
    }
    if (this.verticalScrollbar && this.simPositionY[this.simDataLength] != this.simPositionY[this.simDataLength-1]) {
      this.animCssScrollV.insertRule('' + i + '% { -webkit-transform: ' + this.getScrollbarCssTransform(this.simPositionY[this.simDataLength], false) + '}');
    }
  }
  var targetX = this.simPositionX[this.simDataLength] = Math.round(simX.getPosition(this.duration));
  var targetY = this.simPositionY[this.simDataLength] = Math.round(simY.getPosition(this.duration));
  this.simVelocityX[this.simDataLength] = 0;
  this.simVelocityY[this.simDataLength] = 0;
  this.animCssPage.insertRule('to { -webkit-transform: translate3d(' + (-targetX) + 'px, ' + (-targetY) + 'px, 0px); }');
  this.horizontalScrollbar && this.animCssScrollH.insertRule('to { -webkit-transform: ' + this.getScrollbarCssTransform(this.simPositionX[this.simDataLength], true) + '}');
  this.verticalScrollbar && this.animCssScrollV.insertRule('to { -webkit-transform: ' + this.getScrollbarCssTransform(this.simPositionY[this.simDataLength], false) + '}');
  this.simDataLength++;

  this.enableAnimationOnNode(this.box, this.animCssPage.name, this.duration);
  this.box.addEventListener("webkitAnimationStart", this.beginAnimationListenerFn, false);
  this.box.addEventListener("webkitAnimationEnd", this.endAnimationListenerFn, false);

  this.horizontalScrollbar && this.enableAnimationOnNode(this.horizontalScrollbar, this.animCssScrollH.name, this.duration);
  this.verticalScrollbar && this.enableAnimationOnNode(this.verticalScrollbar, this.animCssScrollV.name, this.duration);

  if (this.options.scrollToListener) {
    this.options.scrollToListener(targetX, targetY);
  }
  this.box.style.webkitTransform = "translate3d(" + (-targetX) + "px, " + (-targetY) + "px, 0px)";
}

JScroll.prototype.enableAnimationOnNode = function(node, animName, duration) {
  node.style.webkitAnimationName = '';
  node.style.webkitAnimationName = animName;
  node.style.webkitAnimationDuration = duration + 's';
  node.style.webkitAnimationIterationCount = 1;
  node.style.webkitAnimationTimingFunction = 'linear';
  node.style.webkitAnimationPlayState = "running";
}

JScroll.prototype.getCurrentTime = function() {
  return Date.now();
}

JScroll.prototype.getInterpValue = function(currTime, arr) {
  var index = this.duration > 0 ? (this.simDataLength-1)*(currTime - this.scrollStartTime + 16.67)/(1000*this.duration) : this.simDataLength;
  if (index >= this.simDataLength - 1) {
    return arr[this.simDataLength-1];
  } else if (index < 0) {
    return arr[0];
  } else {
    var param = index - Math.floor(index);
    index = Math.floor(index);
    return arr[index]*(1-param) + arr[index+1]*param;
  }
}

JScroll.prototype.getCurrentPositionX = function(currTime) {
  return this.getInterpValue(currTime, this.simPositionX);
}

JScroll.prototype.getCurrentPositionY = function(currTime) {
  return this.getInterpValue(currTime, this.simPositionY);
}

JScroll.prototype.getCurrentVelocityX = function(currTime) {
  return this.getInterpValue(currTime, this.simVelocityX);
}

JScroll.prototype.getCurrentVelocityY = function(currTime) {
  return this.getInterpValue(currTime, this.simVelocityY);
}

JScroll.prototype.requestAnimationFrame = function(callback) {
  var fn = window.requestAnimationFrame || window.webkitRequestAnimationFrame || function(func) {setTimeout(func, 16);};
  fn(callback);
}

JScroll.prototype.beginAnimatedScroll = function(event) {
  this.scrollStartTime = event.timeStamp;
  this.animationEventOccurring = true;
  this.box.removeEventListener("webkitAnimationStart", this.beginAnimationListenerFn, false);
  this.requestAnimationFrame(this.moveAnimationListenerFn);
}

JScroll.prototype.moveAnimatedScroll = function(now) {
  if (!now) {
    // The fallback behavior for when requestAnimationFrame is missing (ios5) is
    // setTimeout, which does not pass the current time in.  If it's not set, fetch it
    now = this.getCurrentTime();
  }
  if (!this.animationEventOccurring) {
    return;
  }
  if (this.options.scrollMoveListener) {
    this.options.scrollMoveListener(this.getCurrentPositionX(now),
                                    this.getCurrentPositionY(now));
  }
  this.requestAnimationFrame(this.moveAnimationListenerFn);
}

// Function which runs when the animation is terminated.  Performs
// cleanup by updating the transform to point to the final position
// the box stopped at.  This is also triggered when the animation is
// interrupted by e.g. a touch event, so it's not simply
// simPosition[simDataLength-1]
JScroll.prototype.endAnimatedScroll = function(event) {
  // If there is no animation event occurring, dont end the animated scroll.
  // If the target was not the scrollable area or the animation was not the scroll animation we
  // added, don't end the animated scroll.
  if (!this.animationEventOccurring || (event.target != this.box || event.animationName != this.animCssPage.name)) {
    return;
  }
  this.cleanupAnimationIfPlaying(false, false);
}

JScroll.prototype.cleanupAnimationIfPlaying = function(wasInterrupted, doDelayedEnd) {
  if (!this.animationEventOccurring) {
    return;
  }

  this.box.style.webkitAnimationPlayState = "paused";
  this.horizontalScrollbar && (this.horizontalScrollbar.style.webkitAnimationPlayState = "paused");
  this.verticalScrollbar && (this.verticalScrollbar.style.webkitAnimationPlayState = "paused");

  var animationEndTime;
  if (wasInterrupted) {
    animationEndTime = event.timeStamp;
  } else {
    // Make sure the end time is the end of the animation
    animationEndTime = this.scrollStartTime + 1000.0*this.duration;
  }
  // Generate samples over the past few frames to seed
  // the velocity estimator.  These will be used in the case
  // of rapid fire flicking
  // temporarily disabled since it's acting up with the refactored estimator
  var numberOfSamples = 0;
  for (var i = 0; i < numberOfSamples; ++i) {
    // Generate a sample every 16.67 ~= 17ms
    var timeEnd = animationEndTime - i*17
    var timeStart = animationEndTime - (i+1)*17;
    // Negate position because we want in scroll position, not translated space
    this.velocityEstimatorX.addSample(-this.getCurrentPositionX(timeStart), timeStart,
                                      -this.getCurrentPositionX(timeEnd), timeEnd);
    this.velocityEstimatorY.addSample(-this.getCurrentPositionY(timeStart), timeStart,
                                      -this.getCurrentPositionY(timeEnd), timeEnd);
  }
  this.animationEventOccurring = false;
  this.scrollEventOccurring = false;
  var finalPosX = this.getCurrentPositionX(animationEndTime);
  var finalPosY = this.getCurrentPositionY(animationEndTime);
  this.modelX && this.modelX.setPosition(finalPosX);
  this.modelY && this.modelY.setPosition(finalPosY);
  this.updatePosition(0, 0);
  this.box.style.webkitAnimationName = '';
  this.horizontalScrollbar && (this.horizontalScrollbar.style.webkitAnimationName = '');
  this.verticalScrollbar && (this.verticalScrollbar.style.webkitAnimationName = '');
  this.box.removeEventListener("webkitAnimationEnd", this.endAnimationListenerFn, false);
  this.hideScrollbars();
  this.broadcastScrollEnd(doDelayedEnd);
};

JScroll.prototype.broadcastScrollStart = function() {
  this.assert(!this.didBroadcastScrollStart, "Already sent scroll start");
  if (this.options.scrollStartListener) {
    this.options.scrollStartListener(this.modelX ? this.modelX.getPosition() : 0, this.modelY ? this.modelY.getPosition() : 0);
  }
  this.didBroadcastScrollStart = true;
}

JScroll.prototype.broadcastScrollEnd = function(doDelayedEnd) {
  if (doDelayedEnd) {
    this.broadcastScrollEndTimeout = setTimeout(this.broadcastScrollEndFn, this.options.delayScrollEndThreshold);
  } else {
    this.assert(this.didBroadcastScrollStart, "Has not sent scroll start");
    this.cancelBroadcastScrollEnd();
    if (this.options.scrollEndListener) {
      this.options.scrollEndListener(this.modelX ? this.modelX.getPosition() : 0, this.modelY ? this.modelY.getPosition() : 0);
    }
    this.didBroadcastScrollStart = false;
    this.broadcastScrollEndTimeout = null;
  }
}

JScroll.prototype.cancelBroadcastScrollEnd = function() {
  if (this.broadcastScrollEndTimeout) {
    clearTimeout(this.broadcastScrollEndTimeout);
    this.broadcastScrollEndTimeout = null;
  }
}

JScroll.prototype.consumeTouchOnScroll = function(event) {
  if (this.animationEventOccurring) {
    event.preventDefault();
    event.stopPropagation();
    this.startTouch(event);
  }
}

JScroll.prototype.startTouch = function(event) {
// Note: we don't want to prevent default on this because it seems to prevent the click
// handlers on child elements from being called normally only on touch devices.  However,
// we need to eat it on non-touch devices since otherwise we start a drag.  Sigh.
  if (!this.isTouchDevice) {
    event.preventDefault();
  }
  if (this.touchEventOccurring) {
    // We're already touching.  We need to determine if the new touch is
    // a second finger or related to the touch handling bug we currently
    // have where quick swipes get recorded as disjoint presses.

    // Just bail out for now.  Maybe we want to cancel the scrolling entirely?
    return false;
  }

  this.touchEventOccurring = true;
  this.scrollEventOccurring = false;
  if (event.touches && event.touches.length > 1) {
    // Multitouch!  If there are two or more touches registered, then
    // we started with a multitouch gesture.  Don't actually start scrolling
    // in this case
    return false;
  }
  if (this.animationEventOccurring) {
    if (this.options.inertialScrollInterruptedListener) {
      this.options.inertialScrollInterruptedListener(this.getCurrentPositionX(this.getCurrentTime()),
                                                     this.getCurrentPositionY(this.getCurrentTime()));
    }
    this.cleanupAnimationIfPlaying(true, this.options.delayScrollEnd);
    // We're already scrolling.  Don't allow the direction to change.
    this.canChangeScrollDirection = false;
    // Make sure to show the scrollbars again, since we're in the middle of a scroll
    this.showScrollbars();
  } else {
    this.velocityEstimatorX.invalidate();
    this.velocityEstimatorY.invalidate();
    // We weren't scrolling, so we can change direction
    this.canChangeScrollDirection = true;
  }
  this.hasClampedScrollDirection = false;

  var evt = (event.touches ? event.touches[0] : event);
  this.velocityEstimatorX.setStartPositionSample(evt.clientX, event.timeStamp);
  this.velocityEstimatorY.setStartPositionSample(evt.clientY, event.timeStamp);

  this.activeTouchCoords.clientX = evt.clientX;
  this.activeTouchCoords.clientY = evt.clientY;

  if (this.options.debugTouches) {
    this.debugMousePos = [evt];
  }
  this.touchStartTime = event.timeStamp;
}

JScroll.prototype.updateTouch = function(event) {
  var evt = (event.touches ? event.touches[0] : event);
  if (!this.touchEventOccurring) {
    // We aren't touching the screen, so just bail out
    return;
  }
  // Don't actually flag a scroll event as starting until we receive
  // a move
  if (!this.scrollEventOccurring) {
    this.scrollEventOccurring = true;
    // Once there's a scroll event actually occuring, show the scrollbars
    this.showScrollbars();

    this.cancelBroadcastScrollEnd();
    if (!this.didBroadcastScrollStart) {
      this.broadcastScrollStart();
    }
  }

  var dx = evt.clientX - this.activeTouchCoords.clientX;
  var dy = evt.clientY - this.activeTouchCoords.clientY;
  if (!this.hasClampedScrollDirection &&
      (this.canChangeScrollDirection || event.timeStamp - this.touchStartTime > this.options.clampingBreakTimeThreshold) &&
      dx != 0 && dy != 0) {
    this.hasClampedScrollDirection = true;
    this.canChangeScrollDirection = false;
    this.currentScrollEnabledX = (this.modelX && this.scrollEnabledX);
    this.currentScrollEnabledY = (this.modelY && this.scrollEnabledY);
    if (Math.abs(dy) < (Math.sqrt(2) - 1) * Math.abs(dx)) {
      this.currentScrollEnabledY = false;
    } else if (Math.abs(dy) > (Math.sqrt(2) + 1) * Math.abs(dx)) {
      this.currentScrollEnabledX = false;
    }
    this.modelY && this.modelY.enabled(this.currentScrollEnabledY);
    this.modelX && this.modelX.enabled(this.currentScrollEnabledX);
  }

  event.preventDefault();
  this.velocityEstimatorX.addPositionSample(evt.clientX, event.timeStamp);
  this.velocityEstimatorY.addPositionSample(evt.clientY, event.timeStamp);
  this.updatePosition(-dx, -dy);
  this.activeTouchCoords.clientX = evt.clientX;
  this.activeTouchCoords.clientY = evt.clientY;
  if (this.options.debugTouches) {
    this.debugMousePos[this.debugMousePos.length] = evt;
  }
}

JScroll.prototype.endTouch = function(event) {
  var evt = (event.changedTouches ? event.changedTouches[0] : event);
  if (!this.touchEventOccurring) {
    return;
  }
  if (this.activeTouchCoords.clientX != evt.clientX || this.activeTouchCoords.clientY != evt.clientY) {
    // If we haven't received a mouse move event for this position,
    // update the velocity estimator
    this.velocityEstimatorX.addPositionSample(evt.clientX, event.timeStamp);
    this.velocityEstimatorY.addPositionSample(evt.clientY, event.timeStamp);
  }

  if (this.options.debugTouches) {
    this.debugMousePos[this.debugMousePos.length] = evt;
    if (!this.debugRegion) {
      this.debugRegion = document.createElement("div");
      this.debugRegion.style.position = "absolute";
      this.debugRegion.style.top = "0px";
      this.debugRegion.style.left = "0px";
      this.viewport.appendChild(this.debugRegion);
    }

    var children = this.debugRegion.childNodes;
    for (var i = children.length - 1; i >= 0; --i) {
      this.debugRegion.removeChild(children[i]);
    }
    for (var i = 0; i < this.debugMousePos.length; ++i) {
      var ping = document.createElement("div");
      ping.style.width = "5px";
      ping.style.height = "5px";
      ping.style.backgroundColor = "#ff0000";
      ping.style.position = "absolute";
      ping.style.left = this.debugMousePos[i].clientX;
      ping.style.top = this.debugMousePos[i].clientY;
      this.debugRegion.appendChild(ping);
    }
  }

  this.touchEventOccurring = false;

  var velX = this.velocityEstimatorX.estimate(event.timeStamp);
  var velY = this.velocityEstimatorY.estimate(event.timeStamp);

  // Compute whether we should apply a multiplier to the velocity based on multiple swipes
  // Ported from the native implementation
  var swipeLen = Math.sqrt(velX*velX + velY*velY);
  if (swipeLen > this.options.swipeVelocityThreshold) {
    if (this.swipeIntervalsNextIndex == 0) {
      this.swipeStartAngX = velX / swipeLen;
      this.swipeStartAngY = velY / swipeLen;
    } else {
      // Dot product of the velocities == cosine of the angle between them
      var cosAng = (this.swipeStartAngX*velX + this.swipeStartAngY*velY) / swipeLen;
      if (cosAng < Math.sqrt(2)/2) {
        // Angle is greater than 45 deg
        this.swipeVelocityScale = 1.0;
        this.swipeIntervalsNextIndex = 0;
        this.swipeStartAngX = velX / swipeLen;
        this.swipeStartAngY = velY / swipeLen;
      }
    }
    if (this.swipeIntervalsNextIndex >= this.options.swipeIntervalCount) {
      for (var i = 1; i < this.options.swipeIntervalCount; ++i) {
        this.swipeIntervals[i-1] = this.swipeIntervals[i];
      }
      this.swipeIntervals[this.options.swipeIntervalCount-1] = this.touchStartTime;
      // Want to make sure the average swipe time is less than the threshold.  This is
      // equivalent to computing the difference between the most recent and the oldest
      // swipe time and averaging it over the total number of swipe intervals
      var avgInterval = (this.touchStartTime - this.swipeIntervals[0]) / (this.options.swipeIntervalCount - 1);
      if (avgInterval < this.options.swipeMaxAverageInterval) {
        this.swipeVelocityScale = Math.min(this.swipeVelocityScale*this.options.swipeVelocityMultiplier,
                                           this.options.swipeMaxVelocityScale);
      } else {
        this.swipeVelocityScale = 1.0;
      }
    } else {
      this.swipeIntervals[this.swipeIntervalsNextIndex] = this.touchStartTime;
      this.swipeIntervalsNextIndex = this.swipeIntervalsNextIndex + 1;
    }
  } else {
    this.swipeIntervalsNextIndex = 0;
    this.swipeVelocityScale = 1.0;
  }
  // Scale the velocity by the appropriate amount.  Don't clamp to the maximum velocity
  // in order to allow it to really pick up speed.
  velX = velX*this.swipeVelocityScale;
  velY = velY*this.swipeVelocityScale;
  this.doAnimatedScroll(-velX, -velY);
}

if (typeof exports !== 'undefined') {
  exports.jScroll = JScroll;
}
});

// module: bolt_touch/views/table_view/index
// file:   ../../../frameworks/bolt_touch/lib/views/table_view/index.js
define("bolt_touch/views/table_view/index", function(require, exports, module) {
var core              = require('bolt/core');
var util              = require('bolt/util');
var view              = require('bolt/view');
var TableViewItem  = require('../../mixins/table-view-item').TableViewItem;
require('bolt/compat/view');
var defaultEventDispatcher =
      require('bolt/event_dispatcher').defaultEventDispatcher;

var View              = require('bolt_touch/view').View;

var TABLE_VIEW_ACTION_TYPE_RELOAD_ROW = 'reloadRow';
var TABLE_VIEW_ACTION_TYPE_INSERT_ROW = 'insertRow';
var TABLE_VIEW_ACTION_TYPE_INSERT_SECTION = 'insertSection';
var TABLE_VIEW_ACTION_TYPE_REMOVE_ROW = 'removeRow';
var TABLE_VIEW_ACTION_TYPE_REMOVE_SECTION = 'removeSection';

var TABLE_VIEW_CELL_TYPE_HEADER = 'header';
var TABLE_VIEW_CELL_TYPE_ROW = 'row';

var TABLE_VIEW_ANIMATION_MODES = {
  NONE: undefined,
  FADE: 'fade',
  RIGHT: 'right',
  LEFT: 'left',
  TOP: 'top',
  BOTTOM: 'bottom',
  MIDDLE: 'middle'
};

var queuedIndex = {'item-index': 'queued'};

var queuedPosition = 'translate3d(-5000px,0,0)';

// ### TableView
// TableView provides an efficient mechanism for progressively
// rendering from a data source provided by the owner object.
// Cells are queued for reuse when they go offscreen and then
// translated back into position with updated content as they
// are reused.
var TableView = exports.TableView = core.createClass({
  name: 'TableView',
  extend: View,

  statics: {
    ANIMATION_MODES: TABLE_VIEW_ANIMATION_MODES,
    CELL_HIGHLIGHT_TIME: 50 // in ms
  },

  properties: {
    bufferSize: 1,
    dataSource: null,
    debug: false,
    delegate: null,
    fixedRowHeight: undefined,
    fixedSectionHeaderHeight: undefined,
    loading: false,
    multiSelectionEnabled: false,
    stickySectionHeaders: false,
    sectioned: true,
    useNativeScroll: false,
    customScroller: null,
    reloadCellOnResize: false
  },

  declare: function(options) {
    var scroller = options.customScroller || this.getCustomScroller();
    if (!scroller) {
      scroller = (!options.useNativeScroll ?
        require('../scroll_view') : require('../scroll_view_lite')).ScrollView;
    }

    return {
      bufferSize: 1,
      flex: 1,
      boxOrientation: 'vertical',

      // Stick a header to the top of the list
      stickySectionHeaders: false,

      childViews: [
        {
          ref: 'floatingSection',
          additionalClasses: 'bolt-table-view-floating-section'
        },
        {
          view: scroller,
          ref: 'scrollView',
          flex: 1
        },
        {
          additionalClasses: 'bt-table-loading-view',
          ref: 'loadingView',
          style: {display: 'none'},
          childViews: [
            {
              content: 'Loading...',
              additionalClasses: 'bt-loading-view-text'
            }
          ]
        }
      ]
    };
  },

  // ## Properties

  getBufferSize: function() {
    return this._bufferSize;
  },

  setBufferSize: function(value) {
    value = parseInt(value, 10);
    this._bufferSize = (isNaN(value) ? 0 : value);
    this._renderCells();
  },

  setShowScrollbar: function(show) {
    // When using native scrolling, this function has no effect.
    var scrollView = this.refs.scrollView;
    scrollView.setUseScrollbar && scrollView.setUseScrollbar(show);
  },

  getShowScrollbar: function() {
    // If using native scrolling, this function always returns true, as
    // scrollbars are always enabled.
    var scrollView = this.refs.scrollView;
    if (scrollView.setUseScrollbar) {
      return scrollView.getUseScrollbar();
    }
    return true;
  },

  getContentSize: function() {
    var size = {
      width: 0,
      height: 0
    };
    if (this._cacheData) {
      size.width = this._getViewPort().width;
      size.height = this._cacheData.contentHeight;
    }
    return size;
  },

  getDataSource: function() {
    return this._dataSource;
  },

  setDataSource: function(value) {
    this._dataSource = value;
    this._dataSourceCellForRowInSection = (value.cellForRowInSection ||
      this._null);
    this._dataSourceNumberOfRowsInSection = (value.numberOfRowsInSection ||
      this._zero);
    this._dataSourceNumberOfSections = (value.numberOfSections || this._one);
    this._dataSourceViewForHeaderInSection = (value.viewForHeaderInSection ||
      this._null);
  },

  getDelegate: function() {
    return this._delegate;
  },

  setDelegate: function(value) {
    this._delegate = value;
    this._delegateCellDeselectedAtRowInSection = (
      value.cellDeselectedAtRowInSection || this._null);
    this._delegateCellSelectedAtRowInSection = (
      value.cellSelectedAtRowInSection || this._null);
    this._delegateDidScrollEnd = (value.didScrollEnd || this._null);
    this._delegateDidScrollStart =
      (value !== this ? value.didScrollStart || this._null : this._null);
    this._delegateHeightForRowInSection = (value.heightForRowInSection ||
      this._zero);
    this._delegateHeightForSectionHeader = (value.heightForSectionHeader ||
      this._zero);
    this._delegateViewForHeaderInSection = (value.viewForHeaderInSection ||
      this._null);
  },

  getLoading: function() {
    return this._loading;
  },

  setLoading: function(value) {
    value = !!value;
    this._loading = value;
    if (value) {
      this._loadingView && this._loadingView.show();
    } else {
      this._loadingView && this._loadingView.hide();
    }
  },

  getScrollOffset: function() {
    return {
      x: 0,
      y: this._getViewPort().y
    };
  },

  getSelectedRowAndSection: function() {
    return this.getSelectedRowsAndSections()[0];
  },

  getSelectedRowsAndSections: function() {
    var cells = this._cacheData && this._cacheData.selectedCells;
    return cells ? util.map(cells, this._rowAndSectionForCell) : [];
  },

  // ## View Lifecycle

  clear: function() {
    if (this._cacheData) {
      util.forEach(this._cacheData.cells, this._reapCell, this);
      delete this._cacheData;
    }
    delete this._viewPort;
  },

  // after the setup method is invoked we cache a few references for
  // later use.
  ready: function() {
    // use the owner as the dataSource and delegate if nothing else is provided
    var owner = this.getOwner();
    if (!this.getDataSource()) {
      this.setDataSource(owner);
    }
    if (!this.getDelegate()) {
      this.setDelegate(owner);
    }

    // cache the subview references
    this._floatingSection = this.findRef('floatingSection');
    this._loadingView = this.findRef('loadingView');
    this._scrollView = this.findRef('scrollView');

    this.setLoading(this.getLoading());

    // create the debug view if necessary
    if (this.getDebug()) {
      this._debugView = this.build({
        style: {
          position: 'absolute', bottom: '0px',
          right: '0px', background: '#000',
          width: '100px', opacity: '0.5',
          color: '#fff', paddingLeft: '6px',
          fontSize: '16px', zIndex: '99',
          lineHeight: '30px', whiteSpace: 'nowrap',
          overflow: 'hidden'
        }
      });
    }
  },

  refresh: function() {
    this.clear();
    this._loadData();
  },

  scrollTo: function(y, time) {
    this._scrollView && this._scrollView.scrollTo(0, y, time || 0, false);
  },

  scrollToEnd: function(time) {
    // If the height of the scroll view is less than or equal to the viewport,
    // then just scroll to top. If the height of the scroll view is greater than
    // the viewport, then the position to scroll to is scrollHeight -
    // viewportHeight - 1. Since if the height of the screen is n, the pixel
    // number range is actually [0, n-1]
    var y = 0;
    var viewPort = this._getViewPort();
    if (this._cacheData.contentHeight > viewPort.height) {
      y = this._cacheData.contentHeight - viewPort.height - 1;
    }
    this.scrollTo(y, time);
  },

  scrollToSection: function(section, time) {
    if (this._cacheData) {
      var cell = this._cellAtOrAfterRowInSection(undefined, section);
      if (cell) {
        this.scrollTo(
          cell.y,
          time
        );
      }
    }
  },

  scrollToTop: function(time) {
    this.scrollTo(0, time);
  },

  scrollToRowInSection: function(row, section, time) {
    if (this._cacheData) {
      var cell = this._cellAtOrAfterRowInSection(row, section);
      if (cell) {
        this.scrollTo(
          cell.y,
          time
        );
      }
    }
  },

  show: function() {
    this.setStyle({display: '-webkit-box'});
    setTimeout(this._tableViewRefresh, 100, this);
  },

  // ## Content Management

  dequeueReusableCellWithIdentifier: function(identifier) {
    return (this._reusableCells[identifier] || []).shift();
  },

  enqueueReusableCellWithIdentifier: function(view, identifier) {
    view.getNode().style.webkitTransform = queuedPosition;
    view.setSelected(false);
    view.cleanForReuse();
    view.setMetadata(queuedIndex);
    this._reusableCells[identifier] =
      (this._reusableCells[identifier] || []);
    this._reusableCells[identifier].push(view);
  },

  // measure the height of a cell at a given index taking advantage of reusable
  // cells if possible
  measureCellForRowInSection: function(row, section) {
    var view = this._dataSourceCellForRowInSection.call(
      this.getDataSource(),
      this,
      row,
      section
    );
    this._setCellViewY(view, -5000);
    this._addToScrollView(view);
    var height = view.getRect().height;
    this._enqueueReusableCell(view);
    return height;
  },

  // measure the height of a section header taking advantage of a reuseable
  // header if possible
  measureViewForSection: function(section) {
    var view = this._delegateViewForHeaderInSection.call(
      this.getDelegate(),
      this,
      section
    );
    this._setCellViewY(view, -5000);
    this._addToScrollView(view);
    var height = view.getRect().height;
    this._enqueueReusableCell(view);
    return height;
  },

  // ## Actions

  beginUpdates: function() {
    if (this._cacheData) {
      this._cacheData.batchFlag = true;
    }
  },

  clearSelection: function() {
    var cacheData = this._cacheData;
    if (cacheData) {
      var cells = util.clone(cacheData.selectedCells);
      var cell;
      for (var i = 0, l = cells.length; i < l; ++i) {
        cell = cells[i];
        this.deselectRowInSection(cell.row, cell.section);
      }
    }
  },

  deselectRowInSection: function(row, section) {
    var cell = this._cellForRowInSection(row, section);
    if (cell) {
      cell.selected = false;
      cell.view && cell.view.setSelected(false);
      var selectedCells = this._cacheData.selectedCells;
      var index = selectedCells.indexOf(cell);
      if (-1 !== index) {
        selectedCells.splice(index, 1);
      }
    }
  },

  endUpdates: function() {
    if (this._cacheData && this._cacheData.actionFlag) {
      this._postProcessUpdateActions();
    }
  },

  reloadRowInSection: function(row, section) {
    this._beginAction();
    this._processUpdateAction({
      action: TABLE_VIEW_ACTION_TYPE_RELOAD_ROW,
      section: section,
      row: row
    });
    this._endAction();
  },

  insertRowInSection: function(row, section, animationMode) {
    this._beginAction();
    this._processUpdateAction({
      action: TABLE_VIEW_ACTION_TYPE_INSERT_ROW,
      section: section,
      row: row,
      animationMode: animationMode || TABLE_VIEW_ANIMATION_MODES.FADE
    });
    this._endAction();
  },

  insertSection: function(section, animationMode) {
    this._beginAction();
    this._processUpdateAction({
      action: TABLE_VIEW_ACTION_TYPE_INSERT_SECTION,
      section: section,
      animationMode: animationMode
    });
    this._endAction();
  },

  removeRowInSection: function(row, section, animationMode) {
    this._beginAction();
    this._processUpdateAction({
      action: TABLE_VIEW_ACTION_TYPE_REMOVE_ROW,
      section: section,
      row: row,
      animationMode: animationMode
    });
    this._endAction();
  },

  removeSection: function(row, section, animationMode) {
    this._beginAction();
    this._processUpdateAction({
      action: TABLE_VIEW_ACTION_TYPE_REMOVE_SECTION,
      section: section,
      animationMode: animationMode
    });
    this._endAction();
  },

  selectRowInSection: function(row, section) {
    var cell = this._cellForRowInSection(row, section);
    if (cell) {
      cell.selected = true;
      cell.view && cell.view.setSelected(true);
      var selectedCells = this._cacheData.selectedCells;
      var index = selectedCells.indexOf(cell);
      if (-1 === index) {
        selectedCells.push(cell);
      }
    }
  },

  // ## DOM event handlers

  // Fired by the baseview. We set the initial Y coordinate of the TableView
  // and invalidate it, which forces buffering to occur
  onDocumentInsertion: function() {
    delete this._viewPort;
    setTimeout(this._tableViewLoadData, 10, this);
    this._resizeHandler = this._resizeHandler ||
      util.debounce(util.bind(this._onResize, this), 200);
    window.addEventListener('resize', this._resizeHandler, true);
  },

  //TODO: wbailey revisit the right way to handle cell activation
  //      after touchstart. We've added a touched boolean flag to
  //      separate highlighting logic from selection logic.
  cellTapStarted: function(eventShim) {
    var index = eventShim.data;
    var cacheData = this._cacheData;
    var cell = cacheData && cacheData.cells[index];
    var view = cell && cell.view;
    // If there's no view or it's not selectable, move along
    if (!view || !view.getSelectable()) return;
    if (this.get('editMode')) return;

    clearTimeout(this._cellHighlightTimer);
    this._touched = true;
    this._cellHighlightTimer = setTimeout(
      this._tableViewHighlightCell,
      this.klass.CELL_HIGHLIGHT_TIME,
      this,
      cell,
      true
    );
  },

  cellTapEnded: function(eventShim) {
    var index = eventShim.data;
    var cacheData = this._cacheData;
    var cell = cacheData && cacheData.cells[index];
    var view = cell && cell.view;
    // If there's no view or it's not selectable, move along
    if (!view || !view.getSelectable()) return;
    if (this.get('editMode')) return;

    clearTimeout(this._cellHighlightTimer);
    delete this._cellHighlightTimer;
    if (this._touched) {
      delete this._touched;
      this._selectCell(cell);
    } else {
      this._tableViewHighlightCell(this, cell, false);
    }
  },

  cellTapMoved: function(eventShim) {
    var index = eventShim.data;
    var cacheData = this._cacheData;
    var cell = cacheData && cacheData.cells[index];
    var view = cell && cell.view;
    // If there's no view or it's not selectable, move along
    if (!view || !view.getSelectable()) return;
    if (this.get('editMode')) return;

    clearTimeout(this._cellHighlightTimer);
    cell.view && cell.view.setHighlighted(cell.view.getSelected());
    delete this._cellHighlightTimer;
    delete this._touched;
  },

  _onResize: function() {
    delete this._viewPort;
    this._renderCells();
  },

  // ## ScrollView delegate callbacks

  // Delegate callback from the scrollview when scrolling ends
  // TODO (toddkrabach): update ScrollView to change the arg order to this
  didScrollTo: function(x, y, scrollView) {
    var viewPort = this._getViewPort();
    viewPort.y = y;
    viewPort.lastY = y;
    this._renderCells();
    this._delegateDidScrollEnd.call(this.getDelegate(), this);
  },

  // Delegate callback from the scrollview when scrolling begins
  didScrollStart: function(scrollView) {
    var delegate = this.getDelegate();
    this._delegateDidScrollStart.call(delegate, this);
  },

  // Delegate callback from the scrollview indicating that it scrolled to the
  // current x, y coordinates from user interaction
  scrollViewDidScrollTo: function(scrollView, x, y) {
    this._touched = false;
    var viewPort = this._getViewPort();
    viewPort.y = y;
    if (this._debugView) {
      var content = 'y:' + (viewPort ? viewPort.y : 'undefined');
      this._debugView.setContent(content);
    }
    var deltaY = Math.abs(viewPort.y - viewPort.lastY);
    var threshold = (
      Math.abs(viewPort.y) < 10 && this.getStickySectionHeaders() ?
      0 :
      20
    );
    if (deltaY > threshold) {
      viewPort.lastY = y;
      this._renderCells();
    }
  },

  // ## Private Helper Methods

  _addToScrollView: function(view) {
    if (view && this._scrollView) {
      var parentNode = view.getNode().parentNode;
      if (!parentNode || parentNode === this._floatingSection.getNode()) {
        this._scrollView.appendChild(view);
      }
    }
  },

  _addToFloatingSection: function(view) {
    if (view && this._floatingSection) {
      var parentNode= view.getNode().parentNode;
      if (!parentNode || parentNode !== this._floatingSection.getNode()) {
        this._floatingSection.appendChild(view);
      }
    }
  },

  _beginAction: function() {
    if (this._cacheData) {
      this._cacheData.actionFlag = true;
    }
  },

  _buildCellForRowInSection: function(row, section, cellIndex, y, heightOrNull) {
    var cell = null;
    var cacheData = this._cacheData;
    var sectionData = cacheData && cacheData.sections[section];
    if (sectionData) {
      cell = {
        section: section,
        selected: false,
        y: y,
        cellIndex: cellIndex
      };
      var height = heightOrNull;
      if (util.isUndefined(row)) {
        cell.type = TABLE_VIEW_CELL_TYPE_HEADER;

        if (util.isUndefined(height)) {
          height = this.getFixedSectionHeaderHeight();
        }
        cell.height = (
          isNaN(height) ?
          this._delegateHeightForSectionHeader.call(
            this.getDelegate(),
            this,
            section
          ) :
          height
        );
      } else {
        cell.type = TABLE_VIEW_CELL_TYPE_ROW;
        cell.row = row;

        if (util.isUndefined(height)) {
          height = this.getFixedRowHeight();
        }
        cell.height = (
          isNaN(height) ?
          this._delegateHeightForRowInSection.call(
            this.getDelegate(),
            this,
            row,
            section,
            false
          ) :
          height
        );
      }
    }
    return cell;
  },

  // return the cell that is after the specified row and section (or null)
  _cellAfterRowInSection: function(row, section) {
    return (
      this._cellForRowInSection(row + 1, section) ||
      this._cellForRowInSection(undefined, section + 1) ||
      this._cellForRowInSection(0, section + 1)
    );
  },

  // return the cell that is in the specified row and section or the next cell
  // if there is none at that position
  _cellAtOrAfterRowInSection: function(row, section) {
    return (
      this._cellForRowInSection(row, section) ||
      this._cellAfterRowInSection(row, section)
    );
  },

  // return the cell that is in the specified row and section (or null)
  _cellForRowInSection: function(row, section) {
    var sections = this._cacheData.sections;
    if (sections.length <= section) {
      // return null if this section is out of range
      return null;
    }

    if (isNaN(row)) {
      return sections[section].header;
    }

    // return null if this row is out of range
    return sections[section].rows[row];
  },

  // Use binary search to find the item in the itemList that wraps the
  // requested coordinate.
  _cellIndexForRowAtY: function(y) {
    var cacheData = this._cacheData;
    var cells = cacheData.cells;
    if (0 >= y) {
      return Math.min(0, cells.length - 1);
    }
    if (cacheData.contentHeight <= y) {
      return cells.length - 1;
    }
    var low = 0;
    var high = cells.length;
    var cell;
    var mid;
    while (low < high) {
      mid = (low + high) >> 1;
      cell = cells[mid];
      // A cell's area is specified by the "edges".
      // E.g., cell.y = 0, cell.height = 50
      // then the pixels covered by this item is
      // actually 0 - 49.
      // viewPort.y is in terms of pixel, hence
      // there is no "equal" on the end side.
      if (cell.y + cell.height > y) {
        if (cell.y <= y) return mid;
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    return mid;
  },

  _cellIndexForRowInSection: function(row, section) {
    // return NaN if this row is out of range
    var cell = this._cellForRowInSection(row, section);
    return cell ? cell.cellIndex : NaN;
  },

  // decrement the update count and process any updates
  _endAction: function() {
    if (this._cacheData && !this._cacheData.batchFlag) {
      this._postProcessUpdateActions();
    }
  },

  _enqueueReusableCell: function(view) {
    if (view) {
      var reuseIdentifier = view.getReuseIdentifier();
      if (reuseIdentifier) {
        this.enqueueReusableCellWithIdentifier(view, reuseIdentifier);
      } else if (view.getNode().parentNode) {
        view.getNode().parentNode.removeChild(view);
      }
    }
  },

  _getSelectedAtRowInSection: function(row, section) {
    var cell = this._cellForRowInSection(row, section);
    return cell && cell.selected;
  },

  _getViewPort: function() {
    var viewPort = this._viewPort;
    if (!viewPort) {
      var scrollView = this._scrollView;
      if (scrollView) {
        viewPort = scrollView.getRect();
        var coords = scrollView.coords();
        viewPort = {
          y: coords[1],
          lastY: coords[1],
          width: viewPort.width,
          height: viewPort.height
        };
      } else {
        viewPort = {y:0, lastY:0, width:0, height:0};
      }
      this._viewPort = viewPort;
    }
    return viewPort;
  },

  _initializeCacheData: function() {
    this._reusableCells = this._reusableCells || {};
    var cacheData = this._cacheData;
    if (cacheData) {
      util.forEach(cacheData.cells, this._reapCell, this);
    }
    cacheData = this._cacheData = {
      actionFlag: false,
      batchFlag: false,
      cells: [],
      sections: [],
      selectedCells: [],
      visibleCellIndexEnd: NaN,
      visibleCellIndexStart: NaN
    };
    var cells = cacheData.cells;
    var sections = cacheData.sections;
    var numberOfSections = this._dataSourceNumberOfSections.call(
      this.getDataSource()
    );
    var sectionData;
    var fixedSectionHeaderHeight = this.getFixedSectionHeaderHeight();
    var isSectionHeaderHeightFixed = !isNaN(fixedSectionHeaderHeight);
    var fixedRowHeight = this.getFixedRowHeight();
    var isRowHeightFixed = !isNaN(fixedRowHeight);
    var cell;
    var cellIndex = 0;
    var y = 0;

    // store 2 types of data for the sections/rows
    // 1. this._cacheData.cells will hold a flat array of meta data for all
    //    cells that are renderable.  These objects are in the form of:
    //    {
    //      type: TABLE_VIEW_CELL_TYPE_HEADER | TABLE_VIEW_CELL_TYPE_ROW,
    //      section: int,
    //      row: int | undefined, // undefined for section headers
    //      height: float,
    //      y: float,
    //      cellIndex: int
    //    }
    //
    // 2. this._cacheData.sections will hold a hierarchical collection of
    //    sections and rows.  The sections are in the form of:
    //    {
    //      header: cell,
    //      rows: array of cells
    //    }
    //
    // TODO: extend this storage with a sparse option when row heights are fixed
    //
    for (var s = 0; s < numberOfSections; ++s) {
      var height = (
        isSectionHeaderHeightFixed ?
        fixedSectionHeaderHeight :
        this._delegateHeightForSectionHeader.call(this.getDelegate(), this, s)
      );
      sectionData = {
        rows: []
      };
      sections.push(sectionData);
      if (this.getSectioned()) {
        cell = this._buildCellForRowInSection(
          undefined,
          s,
          cellIndex++,
          y,
          height
        );
        sectionData.header = cell;
        cells.push(cell);
        y += height;
      }
      var numberOfRows = this._dataSourceNumberOfRowsInSection.call(
        this.getDataSource(),
        this,
        s
      );
      var rows = sectionData.rows;
      for (var r = 0; r < numberOfRows; ++r) {
        cell = this._buildCellForRowInSection(
          r,
          s,
          cellIndex++,
          y,
          fixedRowHeight
        );
        rows.push(cell);
        cells.push(cell);
        y += cell.height;
      }
    }
    cacheData.contentHeight = y;
  },

  _loadData: function() {
    this._initializeCacheData();
    var cacheData = this._cacheData;
    if (this._scrollView) {
      this._scrollView.setContentHeight(cacheData.contentHeight);
      this._scrollView.refresh && this._scrollView.refresh();
    }
    this._renderCells();
  },

/**
 * Moves a cell to a new index, and moves the cells between the old and new
 * positions to the correct places around it.
 */
  _moveCellToIndex: function(cell, index) {
    var cacheData = this._cacheData;
    var cells = cacheData && cacheData.cells;
    var sectionData = cacheData.sections[cell.section];

    var oldIndex = cell.cellIndex;
    var indexShift = index - oldIndex;
    var heightShift = indexShift * cell.height;

    // remove cell from cacheData
    this._uncacheCell(cell);

    // move the cell to the correct position
    cell.y += heightShift;
    cell.cellIndex += indexShift;
    cell.view && cell.view.setMetadata({'item-index': cell.cellIndex});
    cell.row += indexShift;
    this._setCellY(cell);

    // move cells around it to the correct positions
    var shiftSign = -1 * indexShift / Math.abs(indexShift);
    var i;
    heightShift = cell.height * shiftSign;
    var currentCell;
    if (cells) {
      if (shiftSign === -1) {
        // cells move down
        for (i = oldIndex; i < index; i -= shiftSign) {
          currentCell = cells[i];
          currentCell.y += heightShift;
          currentCell.cellIndex += shiftSign;
          currentCell.view && currentCell.view.setMetadata({'item-index': currentCell.cellIndex});
          currentCell.row += shiftSign;
          this._setCellY(currentCell);
        }
      } else {
        // cells move up
        for (i = oldIndex - 1; i >= index; i -= shiftSign) {
          currentCell = cells[i];
          currentCell.y += heightShift;
          currentCell.cellIndex += shiftSign;
          currentCell.view && currentCell.view.setMetadata({'item-index': currentCell.cellIndex});
          currentCell.row += shiftSign;
          this._setCellY(currentCell);
        }
      }
    }

    // add cell back in to cacheData
    sectionData.rows.splice(cell.row, 0, cell);
    cells.splice(cell.cellIndex, 0, cell);
  },

  _moveCellsForCell: function(cell, indexShift) {
    var cellIndex = cell.cellIndex;
    var section = cell.section;
    var heightShift = cell.height * indexShift / Math.abs(indexShift);
    var cells = this._cacheData && this._cacheData.cells;
    if (cells) {
      for (var i = cellIndex, l = cells.length; i < l; ++i) {
        cell = cells[i];
        cell.y += heightShift;
        cell.cellIndex += indexShift;
        cell.view && cell.view.setMetadata({'item-index': cell.cellIndex});
        if (section === cell.section) cell.row += indexShift;
        this._setCellY(cell);
      }
    }
    return heightShift;
  },

  // used as a placeholder for unimplemented delegate/dataSource methods
  // returning null
  _null: function() { return null; },

  _processUpdateAction: function(updateAction) {
    var cacheData = this._cacheData;
    var cells = cacheData.cells;
    var sections = cacheData.sections;
    var section = updateAction.section;
    var row = updateAction.row;
    var sectionData = sections[section];
    var cell;
    var heightShift = 0;
    switch (updateAction.action) {
      case TABLE_VIEW_ACTION_TYPE_RELOAD_ROW:
        cell = this._cellForRowInSection(row, section);
        heightShift += this._reloadCell(cell);
        break;
      case TABLE_VIEW_ACTION_TYPE_INSERT_ROW:
        if (util.isUndefined(row) && sectionData.header) {
          heightShift += this._reloadCell(sectionData.header);
        } else {
          cell = this._cellAtOrAfterRowInSection(row, section);
          if (!cell) {
            // create a mock to properly position the cell if it is the last
            // cell in the list
            cell = {
              cellIndex: cells.length,
              y: cacheData.contentHeight + heightShift
            };
          }
          cell = this._buildCellForRowInSection(
            row,
            section,
            cell.cellIndex,
            cell.y
          );
          heightShift += this._moveCellsForCell(cell, 1);
          sectionData.rows.splice(cell.row, 0, cell);
          cells.splice(cell.cellIndex, 0, cell);
        }
        break;
      case TABLE_VIEW_ACTION_TYPE_INSERT_SECTION:
        console.error('TODO: implement insert section');
        break;
      case TABLE_VIEW_ACTION_TYPE_REMOVE_ROW:
        cell = this._cellForRowInSection(row, section);
        this.deselectRowInSection(row, section);
        this._uncacheCell(cell);
        heightShift += this._moveCellsForCell(cell, -1);
        this._reapCell(cell);
        break;
      case TABLE_VIEW_ACTION_TYPE_REMOVE_SECTION:
        console.error('TODO: implement remove section');
        break;
    }
    cacheData.contentHeight += heightShift;
  },

  _postProcessUpdateActions: function() {
    // processing pending updates
    // TODO: once we have an animation framework in place, move these actions
    // to use the appropriate animations.  actions should be taken in order wrt
    // index management, but animations should happen with removes first
    // followed by inserts
    var cacheData = this._cacheData;
    cacheData.visibleCellIndexStart = NaN;
    cacheData.visibleCellIndexEnd = NaN;
    var scrollView = this._scrollView;
    if (scrollView) {
      scrollView.setContentHeight(cacheData.contentHeight);
      scrollView.refresh && scrollView.refresh();
    }
    this._renderCells();
    cacheData.actionFlag = false;
    cacheData.batchFlag = false;
  },

  _reapCell: function(cell) {
    var view = cell.view;
    // support doNotReap for reorderable cells; when reordering, cell floats
    // above table while scrolling, and should not be reaped.
    if (view && view.getDoNotReap()) {
      return;
    }
    if (cell.resizeToken) {
      cell.resizeToken.remove();
      delete cell.resizeToken;
    }
    if (view) {
      delete cell.view;
      this._enqueueReusableCell(view);
    }
  },

  _reapCellAt: function(index) {
    if (this._cacheData) {
      this._reapCell(this._cacheData.cells[index]);
    }
  },

  _reloadCellHandler: function(cell) {
    this.reloadRowInSection(cell.row, cell.section);
  },

  _reloadCell: function(cell) {
    var heightShift = 0;
    if (cell) {
      var cacheData = this._cacheData;
      if (cacheData) {
        var oldHeight = cell.height;
        var height;
        if (cell.type === TABLE_VIEW_CELL_TYPE_HEADER) {
          height = this.getFixedSectionHeaderHeight();
          height = (
            isNaN(height) ?
            this._delegateHeightForSectionHeader.call(
              this.getDelegate(),
              this,
              cell.section
            ) :
            height
          );
        } else if (cell.type === TABLE_VIEW_CELL_TYPE_ROW) {
          height = this.getFixedRowHeight();
          height = (
            isNaN(height) ?
            this._delegateHeightForRowInSection.call(
              this.getDelegate(),
              this,
              cell.row,
              cell.section,
              true
            ) :
            height
          );
        }
        if (oldHeight !== height) {
          cell.height = height;
          heightShift = height - oldHeight;
          var cells = cacheData.cells;
          for (var i = cell.cellIndex + 1, l = cells.length; i < l; ++i) {
            cells[i].y += heightShift;
            this._setCellY(cells[i]);
          }

          // If we're changing the size of a cell above the viewport, scroll to
          // stay within the viewport.
          if (cell.y < this._getViewPort().y) {
            this._scrollView.scrollTo(0, heightShift, 0, true);
          }
        }
      }

      if (cell.view) {
        this._reapCell(cell);
        this._renderCellAtIndex(cell.cellIndex);
      }
    }
    return heightShift;
  },

  _renderCellAtIndex: function(index) {
    var cell = this._cacheData && this._cacheData.cells[index];

    // the view is already there, skip
    if (!cell || cell.view) {
      return;
    }

    var view;
    switch (cell.type) {
      case TABLE_VIEW_CELL_TYPE_HEADER:
        // get the header view from the delegate
        view = this._delegateViewForHeaderInSection.call(
          this.getDelegate(),
          this,
          cell.section
        );
        break;
      case TABLE_VIEW_CELL_TYPE_ROW:
        // get the row view from the data source
        view = this._dataSourceCellForRowInSection.call(
          this.getDataSource(),
          this,
          cell.row,
          cell.section
        );

        var fixedRowHeight = this.getFixedRowHeight();

        if (fixedRowHeight && view.setHeight) {
          view.setHeight(fixedRowHeight);
        }

        var numRows = this._dataSourceNumberOfRowsInSection.call(
                        this.getDataSource(),
                        this,
                        cell.section
                      );

        view.toggleClass('first', cell.row === 0);
        view.toggleClass('last', cell.row === numRows - 1);
        break;
    }
    if (this.getReloadCellOnResize()) {
      cell.resizeToken = view.listen(
        'resize',
        this._reloadCellHandler,
        this,
        cell
      );
    }
    cell.view = view;


    // TODO: luiz
    // I'm commenting these listeners for now because custom events
    // still bubble, so we don't want them to get double-called. As
    // soon as custom events stop bubbling, we will need to uncomment
    // these listeners
    // view.addListener('cellTapStarted', this.cellTapStarted, this);
    // view.addListener('cellTapMoved', this.cellTapMoved, this);
    // view.addListener('cellTapEnded', this.cellTapEnded, this);

    view.setMetadata({'item-index': index});

    this._renderCellViewForRowInSection(
      cell.row,
      cell.section,
      view,
      cell.y
    );
    this._addToScrollView(view);
  },

  _renderCellViewForRowInSection: function(row, section, view, y) {
    this._setCellViewY(view, y);
    if (this._getSelectedAtRowInSection(row, section)) {
      view.setSelected(true);
    }
  },

  _renderCells: function() {
    var cacheData = this._cacheData;
    if (cacheData && this._scrollView) {
      var viewPort = this._getViewPort();
      var start = this._cellIndexForRowAtY(viewPort.y);
      var end = start;
      var y = viewPort.y + viewPort.height;
      var cells = cacheData.cells;
      for (var l = cells.length; 0 <= end && end < l; ++end) {
        if (cells[end].y > y) {
          end--;
          break;
        }
      }
      end = Math.min(end, cells.length - 1);
      if (0 <= start && 0 <= end) {
        this._renderCellsInRange(
          start,
          end
        );
      }
    }
  },

  // renders the cells in the specified range, INCLUSIVELY - this function will
  // also reap items that were visible that are outside of this range
  _renderCellsInRange: function(start, end) {
    var cacheData = this._cacheData;
    var cells = cacheData.cells;
    var cellCount = cells.length;
    var bufferSize = this.getBufferSize();
    var firstVisible = start;
    var lastVisible = end;
    start = Math.min(start, cellCount - 1);
    end = Math.min(end + bufferSize, cellCount - 1);
    var first = start;
    start = Math.max(0, start - bufferSize);
    var lastStart = cacheData.visibleCellIndexStart;
    var lastEnd = cacheData.visibleCellIndexEnd;
    if (isNaN(lastStart)) lastStart = cellCount - 1;
    if (isNaN(lastEnd)) lastEnd = -1;
    if (lastStart > start || lastEnd < end) {
      var headerCellIndex = -1;
      // update the sticky header
      if (this.getStickySectionHeaders()) {
        if (-1 === first) {
          var view = cacheData.visibleSectionHeaderView;
          delete cacheData.visibleSectionHeaderView;
          delete cacheData.visibleSectionHeader;
          this._enqueueReusableCell(view);
        } else {
          var section = cells[first].section;
          var lastSection = cacheData.visibleSectionHeader;
          if (lastSection !== section) {
            // TODO: recycle sticky section headers instead of getting a new one
            // (this requires moving the section headers to/from the scrollview)
            // it also currently leaves 2 overlapping section headers and
            // doesn't quite switch headers at the right time
            this._enqueueReusableCell(cacheData.visibleSectionHeaderView);
            var sectionHeaderView = this._delegateViewForHeaderInSection.call(
              this.getDelegate(),
              this,
              section
            );
            this._renderCellViewForRowInSection(
              undefined,
              section,
              sectionHeaderView,
              0
            );
            this._addToFloatingSection(sectionHeaderView);
            cacheData.visibleSectionHeaderView = sectionHeaderView;
            cacheData.visibleSectionHeader = section;
          }
        }
      }
      // reap the cells that are no longer visible
      for (; lastStart < start && lastStart < lastEnd; ++lastStart) {
        this._reapCellAt(lastStart);
      }
      // reap the cells that are no longer visible
      for (; lastEnd > end && lastEnd > lastStart; --lastEnd) {
        this._reapCellAt(lastEnd);
      }
      for (var i = start; i <= end; ++i) {
        if ((lastStart > i || lastEnd < i) && headerCellIndex !== i) {
          this._renderCellAtIndex(i);
        }
      }
      this._cacheData.visibleCellIndexStart = start;
      this._cacheData.visibleCellIndexEnd = end;
    }
  },

  _rowAndSectionForCell: function(cell) {
    return {
      row: cell.row,
      section: cell.section
    };
  },

  _rowAndSectionForCellIndex: function(cellIndex) {
    var section = NaN;
    var row = NaN;
    var currentIndex = 0;
    var sections = this._cacheData.sections;
    var numberOfSections = sections.length;
    var sectionData;
    var numberOfRows;

    // loop through the sections
    for (var s = 0; s < numberOfSections; ++s) {
      sectionData = sections[s];
      numberOfRows = (sectionData.header ? 1 : 0) + sectionData.rows.length;

      // check if the section include the specified cell index
      if (currentIndex + numberOfRows > cellIndex) {
        section = s;
        row = cellIndex - currentIndex;
        break;
      }

      // advance past the rows in this section
      currentIndex += numberOfRows;
    }

    // return whatever we found
    return {
      section: section,
      row: row
    };
  },

  _selectCell: function(cell) {
    delete this._touched;
    var selectionFunction;
    var delegateFunction;
    if (this._getSelectedAtRowInSection(cell.row, cell.section)) {
      this.deselectRowInSection(cell.row, cell.section);
      this._delegateCellDeselectedAtRowInSection.call(
        this.getDelegate(),
        this,
        cell.row,
        cell.section,
        cell.view
      );
    } else {
      if (!cell.selected && !this.getMultiSelectionEnabled()) {
        // if multi-select is not enabled, deselect all cells first
        this.clearSelection();
      }
      this.selectRowInSection(cell.row, cell.section);
      this._delegateCellSelectedAtRowInSection.call(
        this.getDelegate(),
        this,
        cell.row,
        cell.section,
        cell.view
      );
    }
  },

  _setCellViewY: function(view, y) {
    if (view) {
      view.getNode().style.webkitTransform = 'translate3d(0,' + y + 'px,0)';
    }
  },

  _setCellY: function(cell) {
    cell && cell.view && this._setCellViewY(cell.view, cell.y);
  },

  _tableViewHighlightCell: function(tableView, cell, value) {
    cell.view && cell.view.setHighlighted(cell.view.getSelected() || value);
  },

  _tableViewLoadData: function(tableView) {
    tableView._loadData();
  },

  _tableViewRefresh: function(tableView) {
    tableView.refresh();
    // TODO: do we really want to move to top here, or just make sure the
    // viewport is accurate?
    tableView.scrollToTop();
  },

  _uncacheCell: function(cell) {
    var cacheData = this._cacheData;
    var sectionData = cacheData && cacheData.sections[cell.section];
    if (sectionData) {
      if (util.isUndefined(cell.row)) {
        delete sectionData.header;
      } else {
        sectionData.rows.splice(cell.row, 1)[0];
      }
      cacheData.cells.splice(cell.cellIndex, 1);
    }
  },

  // used as a placeholder for unimplemented delegate/dataSource methods
  // returning 0
  _zero: function() { return 0; },

  // used as a placeholder for unimplemented delegate/dataSource methods
  // returning 1
  _one: function() { return 1; },

  // ## DEPRECATED - the functions below are for backward compatibility only and
  // should be deleted, remove all references to them

  _deprecated: function(oldMethod, newMethod) {
    var message = 'DEPRECATED - TableView.' + oldMethod;
    if (newMethod) {
      message += ' (replace with ' + newMethod + ')';
    }
    console.warn(message);
  },

  dequeueReusableSectionHeaderWithIdentifier: function(identifier) {
    this._deprecated(
      'dequeueReusableSectionHeaderWithIdentifier',
      'dequeueReusableCellWithIdentifier'
    );
    return this.dequeueReusableCellWithIdentifier(identifier);
  },

  enqueueReusableSectionHeaderWithIdentifier: function(view, identifier) {
    this._deprecated(
      'enqueueReusableSectionHeaderWithIdentifier',
      'enqueueReusableCellWithIdentifier'
    );
  },

  moveToEnd: function(time) {
    this._deprecated('moveToEnd', 'scrollToEnd');
    this.moveToEnd(time);
  },

  moveToSection: function(section, time) {
    this._deprecated('moveToSection', 'scrollToSection');
    this.scrollToSection(section, time);
  },

  moveToTop: function(time) {
    this._deprecated('moveToTop', 'scrollToTop');
    this.scrollToTop(time);
  },

  setScrollbar: function(value) {
    this._deprecated('setScrollbar', 'setShowScrollbar');
    this.setShowScrollbar(value);
  }
});

// ### TableViewCell
// TableViews are populated with TableViewCell instances.
// Cells should generally not be subclassed, you should instead provide the
// cell with its content by specifying childViews in the builder.
var TableViewCell = exports.TableViewCell = core.createClass({
  name: 'TableViewCell',
  extend: View,
  mixins: [TableViewItem],

  properties: {
    highlighted: false,
    selectable: true,
    selected: false,
    // in edit mode, can this cell be reordered?
    reorderable: false,
    reuseIdentifier: 'cell',
    // don't reap the cell; for instance, in edit mode when a cell is
    // being reordered and floating above the table view.
    doNotReap: false,

    height: null,

    icon: '',

    title: '',

    accessoryType: '',
    accessoryTitle: null,
    accessoryView: null
  },


  // TODO: luiz
  // this is a temporary fix to make tableview work on desktop
  // browsers.  In the long run we want a way for touch events to be
  // called smartly from normal browsers.
  mousedown: function(e) {
    this.touchstart(e);
  },

  mousemove: function(e) {
    this.touchmove(e);
  },

  mouseup: function(e) {
    this.touchend(e);
  },

  touchstart: function(e) {
    this.invoke('cellTapStarted', this.getMetadata()['item-index']);
  },

  touchmove: function(e) {
    this.invoke('cellTapMoved', this.getMetadata()['item-index']);
  },

  touchend: function(e) {
    this.invoke('cellTapEnded', this.getMetadata()['item-index']);
  },

  touchcancel: function(e) {
    this.invoke('cellTapEnded', this.getMetadata()['item-index']);
  },

  declare: function() {
    return {
      childViews: [{
        ref: 'icon',
        className: 'bt-table-view-cell--icon'
      },
      {
        ref: 'title',
        className: 'bt-table-view-cell--title'
      },
      {
        ref: 'accessory',
        className: 'bt-table-view-cell--accessory',

        childViews: [{
          ref: 'accessory_text',
          className: 'bt-table-view-cell--accessory-text'
        },{
          ref: 'accessory_type',
          className: 'bt-table-view-cell--accessory-type'
        }]
      }]
    };
  },

  setIcon: function(value) {
    var icon = this.findRef('icon');

    // Only set these styles if an icon has been set.
    icon.setStyle({
      height: '100%',
      width: '75px',
      'background': "url('"+value+"') center center no-repeat"
    });
  },

  setTitle: function(value) {
    this.set('title',value);
    this.refs.title.setContent(value);
  },

  setAccessoryType: function(value) {
    var accessory = this.refs.accessory_type;
    accessory.addClass('bt-table-view--accessory-'+value);

    this.set('accessoryType', value);
  },

  setAccessoryTitle: function(value) {
    this.refs.accessory_text.setContent(value);

    this.set('accessoryTitle', value);
  },

  setAccessoryView: function(value) {
    var accessory = this.refs.accessory;
    var height = 55;

    accessory.appendChild(value);
    accessory.setStyle({
      height: height + 'px',
      top: '50%',
      'margin-top': '-' + Math.floor(height / 2) + 'px'
    });

    this.set('accessoryView', value);
  },

  setHighlighted: function(value) {
    if (this.getHighlighted() !== value) {
      this.set('highlighted', value);
      if (this.getSelectable()) {
        this.toggleClass('bt-active', value);
      }
    }
  },

  setHeight: function(fixedRowHeight) {
    this.setStyle({
      height: fixedRowHeight + 'px'
    });

    var title = this.refs.title;

    if (title) {
      title.setStyle({
        lineHeight: fixedRowHeight + 'px'
      });
    }

    var accessoryTitle = this.refs.accessory_text;

    if (accessoryTitle) {
      accessoryTitle.setStyle({
        lineHeight: fixedRowHeight + 'px'
      });
    }
  },

  setSelected: function(value) {
    // cells can be highlighted while they are not selected - synchronize the
    // state when selection changes
    if (this.getSelected() !== value) {
      this.set('selected', value);
      this.setHighlighted(value);
    }
  },

  setReorderable: function(value) {
    this.toggleClass('bt-reorderable', value);
    this.set('reorderable', value);
  },

  // Called when a cell is enqueued. Use this to remove event listeners or to
  // clean up the contents of a cell and return it to a blank state.
  cleanForReuse: function() {}
});

// ### TableViewSectionHeader
// Tables may optionally include section headers
var TableViewSectionHeader = exports.TableViewSectionHeader =
core.createClass({
  name: 'TableViewSectionHeader',
  extend: TableViewCell,
  mixins: [TableViewItem],

  properties: {
    reuseIdentifier: 'section'
  }
});
});

// module: views/deprecated/table_view/index
// file:   ../../views/deprecated/table_view/index.js
define("views/deprecated/table_view/index", function(require, exports, module) {
// Copyright 2004-present Facebook. All Rights Reserved.

var core              = require('bolt/core');
var util              = require('bolt/util');
var view              = require('bolt/view');
var TableViewItem  = require('bolt_touch/mixins/table-view-item').TableViewItem;
require('bolt/compat/view');
var defaultEventDispatcher =
      require('bolt/event_dispatcher').defaultEventDispatcher;

var HasEventListeners = require('bolt_touch/mixins/has_event_listeners').HasEventListeners;
var View              = require('bolt_touch/view').View;

var TABLE_VIEW_ACTION_TYPE_RELOAD_ROW = 'reloadRow';
var TABLE_VIEW_ACTION_TYPE_INSERT_ROW = 'insertRow';
var TABLE_VIEW_ACTION_TYPE_INSERT_SECTION = 'insertSection';
var TABLE_VIEW_ACTION_TYPE_REMOVE_ROW = 'removeRow';
var TABLE_VIEW_ACTION_TYPE_REMOVE_SECTION = 'removeSection';

var TABLE_VIEW_CELL_TYPE_HEADER = 'header';
var TABLE_VIEW_CELL_TYPE_ROW = 'row';

var TABLE_VIEW_EVENTS = "";
var TABLE_VIEW_LISTENERS = {};

if (!defaultEventDispatcher.getEnabled()) {
  TABLE_VIEW_EVENTS = View.touchEvents.TOUCHSTART + ',' +
                      View.touchEvents.TOUCHEND + ',' +
                      View.touchEvents.TOUCHMOVE + ' .bt-table-view-cell';

  TABLE_VIEW_LISTENERS[TABLE_VIEW_EVENTS] = '_deprecatedNonDelegationEventFired';
}


var TABLE_VIEW_ANIMATION_MODES = {
  NONE: undefined,
  FADE: 'fade',
  RIGHT: 'right',
  LEFT: 'left',
  TOP: 'top',
  BOTTOM: 'bottom',
  MIDDLE: 'middle'
};

var queuedIndex = {'item-index': 'queued'};

var queuedPosition = 'translate3d(-5000px,0,0)';

// ### TableView
// TableView provides an efficient mechanism for progressively
// rendering from a data source provided by the owner object.
// Cells are queued for reuse when they go offscreen and then
// translated back into position with updated content as they
// are reused.
var TableView = exports.TableView = core.createClass({
  name: 'TableView',
  extend: View,

  mixins: [HasEventListeners],

  statics: {
    ANIMATION_MODES: TABLE_VIEW_ANIMATION_MODES,
    CELL_HIGHLIGHT_TIME: 50 // in ms
  },

  properties: {
    bufferSize: 1,
    dataSource: null,
    debug: false,
    delegate: null,
    fixedRowHeight: undefined,
    fixedSectionHeaderHeight: undefined,
    loading: false,
    multiSelectionEnabled: false,
    stickySectionHeaders: false,
    sectioned: true,
    useNativeScroll: false,
    customScroller: null,
    reloadCellOnResize: false
  },

  declare: function(options) {
    console.warn('THIS VERSION OF TableView IS DEPRECATED!!! YOU SHOULD BE USING THE ONE');
    console.warn('UNDER bolt_touch/views/table_view');

    var scroller = options.customScroller || this.getCustomScroller();
    if (!scroller) {
      scroller = (!options.useNativeScroll ?
        require('bolt_touch/views/scroll_view') : require('bolt_touch/views/scroll_view_lite')).ScrollView;
    }

    return {
      eventListeners: TABLE_VIEW_LISTENERS,
      bufferSize: 1,
      flex: 1,
      boxOrientation: 'vertical',

      // Stick a header to the top of the list
      stickySectionHeaders: false,

      childViews: [
        {
          ref: 'floatingSection',
          additionalClasses: 'bolt-table-view-floating-section'
        },
        {
          view: scroller,
          ref: 'scrollView',
          flex: 1
        },
        {
          additionalClasses: 'bt-table-loading-view',
          ref: 'loadingView',
          style: {display: 'none'},
          childViews: [
            {
              content: 'Loading...',
              additionalClasses: 'bt-loading-view-text'
            }
          ]
        }
      ]
    };
  },

  // ## Properties

  getBufferSize: function() {
    return this._bufferSize;
  },

  setBufferSize: function(value) {
    value = parseInt(value, 10);
    this._bufferSize = (isNaN(value) ? 0 : value);
    this._renderCells();
  },

  setShowScrollbar: function(show) {
    // When using native scrolling, this function has no effect.
    var scrollView = this.refs.scrollView;
    scrollView.setUseScrollbar && scrollView.setUseScrollbar(show);
  },

  getShowScrollbar: function() {
    // If using native scrolling, this function always returns true, as
    // scrollbars are always enabled.
    var scrollView = this.refs.scrollView;
    if (scrollView.setUseScrollbar) {
      return scrollView.getUseScrollbar();
    }
    return true;
  },

  getContentSize: function() {
    var size = {
      width: 0,
      height: 0
    };
    if (this._cacheData) {
      size.width = this._getViewPort().width;
      size.height = this._cacheData.contentHeight;
    }
    return size;
  },

  getDataSource: function() {
    return this._dataSource;
  },

  setDataSource: function(value) {
    this._dataSource = value;
    this._dataSourceCellForRowInSection = (value.cellForRowInSection ||
      this._null);
    this._dataSourceNumberOfRowsInSection = (value.numberOfRowsInSection ||
      this._zero);
    this._dataSourceNumberOfSections = (value.numberOfSections || this._one);
    this._dataSourceViewForHeaderInSection = (value.viewForHeaderInSection ||
      this._null);
  },

  getDelegate: function() {
    return this._delegate;
  },

  setDelegate: function(value) {
    this._delegate = value;
    this._delegateCellDeselectedAtRowInSection = (
      value.cellDeselectedAtRowInSection || this._null);
    this._delegateCellSelectedAtRowInSection = (
      value.cellSelectedAtRowInSection || this._null);
    this._delegateDidScrollEnd = (value.didScrollEnd || this._null);
    this._delegateDidScrollStart =
      (value !== this ? value.didScrollStart || this._null : this._null);
    this._delegateHeightForRowInSection = (value.heightForRowInSection ||
      this._zero);
    this._delegateHeightForSectionHeader = (value.heightForSectionHeader ||
      this._zero);
    this._delegateViewForHeaderInSection = (value.viewForHeaderInSection ||
      this._null);
  },

  getLoading: function() {
    return this._loading;
  },

  setLoading: function(value) {
    value = !!value;
    this._loading = value;
    if (value) {
      this._loadingView && this._loadingView.show();
    } else {
      this._loadingView && this._loadingView.hide();
    }
  },

  getScrollOffset: function() {
    return {
      x: 0,
      y: this._getViewPort().y
    };
  },

  getSelectedRowAndSection: function() {
    return this.getSelectedRowsAndSections()[0];
  },

  getSelectedRowsAndSections: function() {
    var cells = this._cacheData && this._cacheData.selectedCells;
    return cells ? util.map(cells, this._rowAndSectionForCell) : [];
  },

  // ## View Lifecycle

  clear: function() {
    if (this._cacheData) {
      util.forEach(this._cacheData.cells, this._reapCell, this);
      delete this._cacheData;
    }
    delete this._viewPort;
  },

  destroy: function() {
    this.clearEventListeners();
    View.prototype.destroy.call(this);
  },

  // after the setup method is invoked we cache a few references for
  // later use.
  ready: function() {
    // use the owner as the dataSource and delegate if nothing else is provided
    var owner = this.getOwner();
    if (!this.getDataSource()) {
      this.setDataSource(owner);
    }
    if (!this.getDelegate()) {
      this.setDelegate(owner);
    }

    // cache the subview references
    this._floatingSection = this.findRef('floatingSection');
    this._loadingView = this.findRef('loadingView');
    this._scrollView = this.findRef('scrollView');

    this.setLoading(this.getLoading());

    // create the debug view if necessary
    if (this.getDebug()) {
      this._debugView = this.build({
        style: {
          position: 'absolute', bottom: '0px',
          right: '0px', background: '#000',
          width: '100px', opacity: '0.5',
          color: '#fff', paddingLeft: '6px',
          fontSize: '16px', zIndex: '99',
          lineHeight: '30px', whiteSpace: 'nowrap',
          overflow: 'hidden'
        }
      });
    }
  },

  refresh: function() {
    this.clear();
    this._loadData();
  },

  scrollTo: function(y, time) {
    this._scrollView && this._scrollView.scrollTo(0, y, time || 0, false);
  },

  scrollToEnd: function(time) {
    // If the height of the scroll view is less than or equal to the viewport,
    // then just scroll to top. If the height of the scroll view is greater than
    // the viewport, then the position to scroll to is scrollHeight -
    // viewportHeight - 1. Since if the height of the screen is n, the pixel
    // number range is actually [0, n-1]
    var y = 0;
    var viewPort = this._getViewPort();
    if (this._cacheData.contentHeight > viewPort.height) {
      y = this._cacheData.contentHeight - viewPort.height - 1;
    }
    this.scrollTo(y, time);
  },

  scrollToSection: function(section, time) {
    if (this._cacheData) {
      var cell = this._cellAtOrAfterRowInSection(undefined, section);
      if (cell) {
        this.scrollTo(
          cell.y,
          time
        );
      }
    }
  },

  scrollToTop: function(time) {
    this.scrollTo(0, time);
  },

  scrollToRowInSection: function(row, section, time) {
    if (this._cacheData) {
      var cell = this._cellAtOrAfterRowInSection(row, section);
      if (cell) {
        this.scrollTo(
          cell.y,
          time
        );
      }
    }
  },

  show: function() {
    this.setStyle('display', '-webkit-box');
    setTimeout(this._tableViewRefresh, 100, this);
  },

  // ## Content Management

  dequeueReusableCellWithIdentifier: function(identifier) {
    return (this._reusableCells[identifier] || []).shift();
  },

  enqueueReusableCellWithIdentifier: function(view, identifier) {
    view.getNode().style.webkitTransform = queuedPosition;
    view.setSelected(false);
    view.cleanForReuse();
    view.setMetadata(queuedIndex);
    this._reusableCells[identifier] =
      (this._reusableCells[identifier] || []);
    this._reusableCells[identifier].push(view);
  },

  // measure the height of a cell at a given index taking advantage of reusable
  // cells if possible
  measureCellForRowInSection: function(row, section) {
    var view = this._dataSourceCellForRowInSection.call(
      this.getDataSource(),
      this,
      row,
      section
    );
    this._setCellViewY(view, -5000);
    this._addToScrollView(view);
    var height = view.getRect().height;
    this._enqueueReusableCell(view);
    return height;
  },

  // measure the height of a section header taking advantage of a reuseable
  // header if possible
  measureViewForSection: function(section) {
    var view = this._delegateViewForHeaderInSection.call(
      this.getDelegate(),
      this,
      section
    );
    this._setCellViewY(view, -5000);
    this._addToScrollView(view);
    var height = view.getRect().height;
    this._enqueueReusableCell(view);
    return height;
  },

  // ## Actions

  beginUpdates: function() {
    if (this._cacheData) {
      this._cacheData.batchFlag = true;
    }
  },

  clearSelection: function() {
    var cacheData = this._cacheData;
    if (cacheData) {
      var cells = util.clone(cacheData.selectedCells);
      var cell;
      for (var i = 0, l = cells.length; i < l; ++i) {
        cell = cells[i];
        this.deselectRowInSection(cell.row, cell.section);
      }
    }
  },

  deselectRowInSection: function(row, section) {
    var cell = this._cellForRowInSection(row, section);
    if (cell) {
      cell.selected = false;
      cell.view && cell.view.setSelected(false);
      var selectedCells = this._cacheData.selectedCells;
      var index = selectedCells.indexOf(cell);
      if (-1 !== index) {
        selectedCells.splice(index, 1);
      }
    }
  },

  endUpdates: function() {
    if (this._cacheData && this._cacheData.actionFlag) {
      this._postProcessUpdateActions();
    }
  },

  reloadRowInSection: function(row, section) {
    this._beginAction();
    this._processUpdateAction({
      action: TABLE_VIEW_ACTION_TYPE_RELOAD_ROW,
      section: section,
      row: row
    });
    this._endAction();
  },

  insertRowInSection: function(row, section, animationMode) {
    this._beginAction();
    this._processUpdateAction({
      action: TABLE_VIEW_ACTION_TYPE_INSERT_ROW,
      section: section,
      row: row,
      animationMode: animationMode || TABLE_VIEW_ANIMATION_MODES.FADE
    });
    this._endAction();
  },

  insertSection: function(section, animationMode) {
    this._beginAction();
    this._processUpdateAction({
      action: TABLE_VIEW_ACTION_TYPE_INSERT_SECTION,
      section: section,
      animationMode: animationMode
    });
    this._endAction();
  },

  removeRowInSection: function(row, section, animationMode) {
    this._beginAction();
    this._processUpdateAction({
      action: TABLE_VIEW_ACTION_TYPE_REMOVE_ROW,
      section: section,
      row: row,
      animationMode: animationMode
    });
    this._endAction();
  },

  removeSection: function(row, section, animationMode) {
    this._beginAction();
    this._processUpdateAction({
      action: TABLE_VIEW_ACTION_TYPE_REMOVE_SECTION,
      section: section,
      animationMode: animationMode
    });
    this._endAction();
  },

  selectRowInSection: function(row, section) {
    var cell = this._cellForRowInSection(row, section);
    if (cell) {
      cell.selected = true;
      cell.view && cell.view.setSelected(true);
      var selectedCells = this._cacheData.selectedCells;
      var index = selectedCells.indexOf(cell);
      if (-1 === index) {
        selectedCells.push(cell);
      }
    }
  },

  // ## DOM event handlers

  // Fired by the baseview. We set the initial Y coordinate of the TableView
  // and invalidate it, which forces buffering to occur
  onDocumentInsertion: function() {
    delete this._viewPort;
    setTimeout(this._tableViewLoadData, 10, this);
    this._resizeHandler = this._resizeHandler ||
      util.debounce(util.bind(this._onResize, this), 200);
    window.addEventListener('resize', this._resizeHandler, true);
  },

  _deprecatedNonDelegationEventFired: function(e, elem) {
    var index = elem.getAttribute('data-item-index');
    switch (e.type) {
      case View.touchEvents.TOUCHSTART:
        this.cellTapStarted(index);
      break;
      case View.touchEvents.TOUCHMOVE:
        this.cellTapMoved(index);
      break;
      case View.touchEvents.TOUCHEND:
        this.cellTapEnded(index);
      break;
    }
  },

  //TODO: wbailey revisit the right way to handle cell activation
  //      after touchstart. We've added a touched boolean flag to
  //      separate highlighting logic from selection logic.
  cellTapStarted: function(index) {
    var cacheData = this._cacheData;
    var cell = cacheData && cacheData.cells[index];
    var view = cell && cell.view;
    // If there's no view or it's not selectable, move along
    if (!view || !view.getSelectable()) return;
    if (this.get('editMode')) return;

    clearTimeout(this._cellHighlightTimer);
    this._touched = true;
    this._cellHighlightTimer = setTimeout(
      this._tableViewHighlightCell,
      this.klass.CELL_HIGHLIGHT_TIME,
      this,
      cell,
      true
    );
  },

  cellTapEnded: function(index) {
    var cacheData = this._cacheData;
    var cell = cacheData && cacheData.cells[index];
    var view = cell && cell.view;
    // If there's no view or it's not selectable, move along
    if (!view || !view.getSelectable()) return;
    if (this.get('editMode')) return;

    clearTimeout(this._cellHighlightTimer);
    delete this._cellHighlightTimer;
    if (this._touched) {
      delete this._touched;
      this._selectCell(cell);
    } else {
      this._tableViewHighlightCell(this, cell, false);
    }
  },

  cellTapMoved: function(index) {
    var cacheData = this._cacheData;
    var cell = cacheData && cacheData.cells[index];
    var view = cell && cell.view;
    // If there's no view or it's not selectable, move along
    if (!view || !view.getSelectable()) return;
    if (this.get('editMode')) return;

    clearTimeout(this._cellHighlightTimer);
    cell.view && cell.view.setHighlighted(cell.view.getSelected());
    delete this._cellHighlightTimer;
    delete this._touched;
  },

  _onResize: function() {
    delete this._viewPort;
    this._renderCells();
  },

  // ## ScrollView delegate callbacks

  // Delegate callback from the scrollview when scrolling ends
  // TODO (toddkrabach): update ScrollView to change the arg order to this
  didScrollTo: function(x, y, scrollView) {
    var viewPort = this._getViewPort();
    viewPort.y = y;
    viewPort.lastY = y;
    this._renderCells();
    this._delegateDidScrollEnd.call(this.getDelegate(), this);
  },

  // Delegate callback from the scrollview when scrolling begins
  didScrollStart: function(scrollView) {
    var delegate = this.getDelegate();
    this._delegateDidScrollStart.call(delegate, this);
  },

  // Delegate callback from the scrollview indicating that it scrolled to the
  // current x, y coordinates from user interaction
  scrollViewDidScrollTo: function(scrollView, x, y) {
    this._touched = false;
    var viewPort = this._getViewPort();
    viewPort.y = y;
    if (this._debugView) {
      var content = 'y:' + (viewPort ? viewPort.y : 'undefined');
      this._debugView.setContent(content);
    }
    var deltaY = Math.abs(viewPort.y - viewPort.lastY);
    var threshold = (
      Math.abs(viewPort.y) < 10 && this.getStickySectionHeaders() ?
      0 :
      20
    );
    if (deltaY > threshold) {
      viewPort.lastY = y;
      this._renderCells();
    }
  },

  // ## Private Helper Methods

  _addToScrollView: function(view) {
    if (view && this._scrollView) {
      var parentNode = view.getNode().parentNode;
      if (!parentNode || parentNode === this._floatingSection.getNode()) {
        this._scrollView.appendChild(view);
      }
    }
  },

  _addToFloatingSection: function(view) {
    if (view && this._floatingSection) {
      var parentNode= view.getNode().parentNode;
      if (!parentNode || parentNode !== this._floatingSection.getNode()) {
        this._floatingSection.appendChild(view);
      }
    }
  },

  _beginAction: function() {
    if (this._cacheData) {
      this._cacheData.actionFlag = true;
    }
  },

  _buildCellForRowInSection: function(row, section, cellIndex, y, heightOrNull) {
    var cell = null;
    var cacheData = this._cacheData;
    var sectionData = cacheData && cacheData.sections[section];
    if (sectionData) {
      cell = {
        section: section,
        selected: false,
        y: y,
        cellIndex: cellIndex
      };
      var height = heightOrNull;
      if (util.isUndefined(row)) {
        cell.type = TABLE_VIEW_CELL_TYPE_HEADER;

        if (util.isUndefined(height)) {
          height = this.getFixedSectionHeaderHeight();
        }
        cell.height = (
          isNaN(height) ?
          this._delegateHeightForSectionHeader.call(
            this.getDelegate(),
            this,
            section
          ) :
          height
        );
      } else {
        cell.type = TABLE_VIEW_CELL_TYPE_ROW;
        cell.row = row;

        if (util.isUndefined(height)) {
          height = this.getFixedRowHeight();
        }
        cell.height = (
          isNaN(height) ?
          this._delegateHeightForRowInSection.call(
            this.getDelegate(),
            this,
            row,
            section,
            false
          ) :
          height
        );
      }
    }
    return cell;
  },

  // return the cell that is after the specified row and section (or null)
  _cellAfterRowInSection: function(row, section) {
    return (
      this._cellForRowInSection(row + 1, section) ||
      this._cellForRowInSection(undefined, section + 1) ||
      this._cellForRowInSection(0, section + 1)
    );
  },

  // return the cell that is in the specified row and section or the next cell
  // if there is none at that position
  _cellAtOrAfterRowInSection: function(row, section) {
    return (
      this._cellForRowInSection(row, section) ||
      this._cellAfterRowInSection(row, section)
    );
  },

  // return the cell that is in the specified row and section (or null)
  _cellForRowInSection: function(row, section) {
    var sections = this._cacheData.sections;
    if (sections.length <= section) {
      // return null if this section is out of range
      return null;
    }

    if (isNaN(row)) {
      return sections[section].header;
    }

    // return null if this row is out of range
    return sections[section].rows[row];
  },

  // Use binary search to find the item in the itemList that wraps the
  // requested coordinate.
  _cellIndexForRowAtY: function(y) {
    var cacheData = this._cacheData;
    var cells = cacheData.cells;
    if (0 >= y) {
      return Math.min(0, cells.length - 1);
    }
    if (cacheData.contentHeight <= y) {
      return cells.length - 1;
    }
    var low = 0;
    var high = cells.length;
    var cell;
    var mid;
    while (low < high) {
      mid = (low + high) >> 1;
      cell = cells[mid];
      // A cell's area is specified by the "edges".
      // E.g., cell.y = 0, cell.height = 50
      // then the pixels covered by this item is
      // actually 0 - 49.
      // viewPort.y is in terms of pixel, hence
      // there is no "equal" on the end side.
      if (cell.y + cell.height > y) {
        if (cell.y <= y) return mid;
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    return mid;
  },

  _cellIndexForRowInSection: function(row, section) {
    // return NaN if this row is out of range
    var cell = this._cellForRowInSection(row, section);
    return cell ? cell.cellIndex : NaN;
  },

  // decrement the update count and process any updates
  _endAction: function() {
    if (this._cacheData && !this._cacheData.batchFlag) {
      this._postProcessUpdateActions();
    }
  },

  _enqueueReusableCell: function(view) {
    if (view) {
      var reuseIdentifier = view.getReuseIdentifier();
      if (reuseIdentifier) {
        this.enqueueReusableCellWithIdentifier(view, reuseIdentifier);
      } else if (view.getNode().parentNode) {
        view.getNode().parentNode.removeChild(view);
      }
    }
  },

  _getSelectedAtRowInSection: function(row, section) {
    var cell = this._cellForRowInSection(row, section);
    return cell && cell.selected;
  },

  _getViewPort: function() {
    var viewPort = this._viewPort;
    if (!viewPort) {
      var scrollView = this._scrollView;
      if (scrollView) {
        viewPort = scrollView.getRect();
        var coords = scrollView.coords();
        viewPort = {
          y: coords[1],
          lastY: coords[1],
          width: viewPort.width,
          height: viewPort.height
        };
      } else {
        viewPort = {y:0, lastY:0, width:0, height:0};
      }
      this._viewPort = viewPort;
    }
    return viewPort;
  },

  _initializeCacheData: function() {
    this._reusableCells = this._reusableCells || {};
    var cacheData = this._cacheData;
    if (cacheData) {
      util.forEach(cacheData.cells, this._reapCell, this);
    }
    cacheData = this._cacheData = {
      actionFlag: false,
      batchFlag: false,
      cells: [],
      sections: [],
      selectedCells: [],
      visibleCellIndexEnd: NaN,
      visibleCellIndexStart: NaN
    };
    var cells = cacheData.cells;
    var sections = cacheData.sections;
    var numberOfSections = this._dataSourceNumberOfSections.call(
      this.getDataSource()
    );
    var sectionData;
    var fixedSectionHeaderHeight = this.getFixedSectionHeaderHeight();
    var isSectionHeaderHeightFixed = !isNaN(fixedSectionHeaderHeight);
    var fixedRowHeight = this.getFixedRowHeight();
    var isRowHeightFixed = !isNaN(fixedRowHeight);
    var cell;
    var cellIndex = 0;
    var y = 0;

    // store 2 types of data for the sections/rows
    // 1. this._cacheData.cells will hold a flat array of meta data for all
    //    cells that are renderable.  These objects are in the form of:
    //    {
    //      type: TABLE_VIEW_CELL_TYPE_HEADER | TABLE_VIEW_CELL_TYPE_ROW,
    //      section: int,
    //      row: int | undefined, // undefined for section headers
    //      height: float,
    //      y: float,
    //      cellIndex: int
    //    }
    //
    // 2. this._cacheData.sections will hold a hierarchical collection of
    //    sections and rows.  The sections are in the form of:
    //    {
    //      header: cell,
    //      rows: array of cells
    //    }
    //
    // TODO: extend this storage with a sparse option when row heights are fixed
    //
    for (var s = 0; s < numberOfSections; ++s) {
      var height = (
        isSectionHeaderHeightFixed ?
        fixedSectionHeaderHeight :
        this._delegateHeightForSectionHeader.call(this.getDelegate(), this, s)
      );
      sectionData = {
        rows: []
      };
      sections.push(sectionData);
      if (this.getSectioned()) {
        cell = this._buildCellForRowInSection(
          undefined,
          s,
          cellIndex++,
          y,
          height
        );
        sectionData.header = cell;
        cells.push(cell);
        y += height;
      }
      var numberOfRows = this._dataSourceNumberOfRowsInSection.call(
        this.getDataSource(),
        this,
        s
      );
      var rows = sectionData.rows;
      for (var r = 0; r < numberOfRows; ++r) {
        cell = this._buildCellForRowInSection(
          r,
          s,
          cellIndex++,
          y,
          fixedRowHeight
        );
        rows.push(cell);
        cells.push(cell);
        y += cell.height;
      }
    }
    cacheData.contentHeight = y;
  },

  _loadData: function() {
    this._initializeCacheData();
    var cacheData = this._cacheData;
    if (this._scrollView) {
      this._scrollView.setContentHeight(cacheData.contentHeight);
      this._scrollView.refresh && this._scrollView.refresh();
    }
    this._renderCells();
  },

/**
 * Moves a cell to a new index, and moves the cells between the old and new
 * positions to the correct places around it.
 */
  _moveCellToIndex: function(cell, index) {
    var cacheData = this._cacheData;
    var cells = cacheData && cacheData.cells;
    var sectionData = cacheData.sections[cell.section];

    var oldIndex = cell.cellIndex;
    var indexShift = index - oldIndex;
    var heightShift = indexShift * cell.height;

    // remove cell from cacheData
    this._uncacheCell(cell);

    // move the cell to the correct position
    cell.y += heightShift;
    cell.cellIndex += indexShift;
    cell.view && cell.view.setMetadata({'item-index': cell.cellIndex});
    cell.row += indexShift;
    this._setCellY(cell);

    // move cells around it to the correct positions
    var shiftSign = -1 * indexShift / Math.abs(indexShift);
    var i;
    heightShift = cell.height * shiftSign;
    var currentCell;
    if (cells) {
      if (shiftSign === -1) {
        // cells move down
        for (i = oldIndex; i < index; i -= shiftSign) {
          currentCell = cells[i];
          currentCell.y += heightShift;
          currentCell.cellIndex += shiftSign;
          currentCell.view && currentCell.view.setMetadata({'item-index': currentCell.cellIndex});
          currentCell.row += shiftSign;
          this._setCellY(currentCell);
        }
      } else {
        // cells move up
        for (i = oldIndex - 1; i >= index; i -= shiftSign) {
          currentCell = cells[i];
          currentCell.y += heightShift;
          currentCell.cellIndex += shiftSign;
          currentCell.view && currentCell.view.setMetadata({'item-index': currentCell.cellIndex});
          currentCell.row += shiftSign;
          this._setCellY(currentCell);
        }
      }
    }

    // add cell back in to cacheData
    sectionData.rows.splice(cell.row, 0, cell);
    cells.splice(cell.cellIndex, 0, cell);
  },

  _moveCellsForCell: function(cell, indexShift) {
    var cellIndex = cell.cellIndex;
    var section = cell.section;
    var heightShift = cell.height * indexShift / Math.abs(indexShift);
    var cells = this._cacheData && this._cacheData.cells;
    if (cells) {
      for (var i = cellIndex, l = cells.length; i < l; ++i) {
        cell = cells[i];
        cell.y += heightShift;
        cell.cellIndex += indexShift;
        cell.view && cell.view.setMetadata({'item-index': cell.cellIndex});
        if (section === cell.section) cell.row += indexShift;
        this._setCellY(cell);
      }
    }
    return heightShift;
  },

  // used as a placeholder for unimplemented delegate/dataSource methods
  // returning null
  _null: function() { return null; },

  _processUpdateAction: function(updateAction) {
    var cacheData = this._cacheData;
    var cells = cacheData.cells;
    var sections = cacheData.sections;
    var section = updateAction.section;
    var row = updateAction.row;
    var sectionData = sections[section];
    var cell;
    var heightShift = 0;
    switch (updateAction.action) {
      case TABLE_VIEW_ACTION_TYPE_RELOAD_ROW:
        cell = this._cellForRowInSection(row, section);
        heightShift += this._reloadCell(cell);
        break;
      case TABLE_VIEW_ACTION_TYPE_INSERT_ROW:
        if (util.isUndefined(row) && sectionData.header) {
          heightShift += this._reloadCell(sectionData.header);
        } else {
          cell = this._cellAtOrAfterRowInSection(row, section);
          if (!cell) {
            // create a mock to properly position the cell if it is the last
            // cell in the list
            cell = {
              cellIndex: cells.length,
              y: cacheData.contentHeight + heightShift
            };
          }
          cell = this._buildCellForRowInSection(
            row,
            section,
            cell.cellIndex,
            cell.y
          );
          heightShift += this._moveCellsForCell(cell, 1);
          sectionData.rows.splice(cell.row, 0, cell);
          cells.splice(cell.cellIndex, 0, cell);
        }
        break;
      case TABLE_VIEW_ACTION_TYPE_INSERT_SECTION:
        console.error('TODO: implement insert section');
        break;
      case TABLE_VIEW_ACTION_TYPE_REMOVE_ROW:
        cell = this._cellForRowInSection(row, section);
        this.deselectRowInSection(row, section);
        this._uncacheCell(cell);
        heightShift += this._moveCellsForCell(cell, -1);
        this._reapCell(cell);
        break;
      case TABLE_VIEW_ACTION_TYPE_REMOVE_SECTION:
        console.error('TODO: implement remove section');
        break;
    }
    cacheData.contentHeight += heightShift;
  },

  _postProcessUpdateActions: function() {
    // processing pending updates
    // TODO: once we have an animation framework in place, move these actions
    // to use the appropriate animations.  actions should be taken in order wrt
    // index management, but animations should happen with removes first
    // followed by inserts
    var cacheData = this._cacheData;
    cacheData.visibleCellIndexStart = NaN;
    cacheData.visibleCellIndexEnd = NaN;
    var scrollView = this._scrollView;
    if (scrollView) {
      scrollView.setContentHeight(cacheData.contentHeight);
      scrollView.refresh && scrollView.refresh();
    }
    this._renderCells();
    cacheData.actionFlag = false;
    cacheData.batchFlag = false;
  },

  _reapCell: function(cell) {
    var view = cell.view;
    // support doNotReap for reorderable cells; when reordering, cell floats
    // above table while scrolling, and should not be reaped.
    if (view && view.getDoNotReap()) {
      return;
    }
    if (cell.resizeToken) {
      cell.resizeToken.remove();
      delete cell.resizeToken;
    }
    if (view) {
      delete cell.view;
      this._enqueueReusableCell(view);
    }
  },

  _reapCellAt: function(index) {
    if (this._cacheData) {
      this._reapCell(this._cacheData.cells[index]);
    }
  },

  _reloadCellHandler: function(cell) {
    this.reloadRowInSection(cell.row, cell.section);
  },

  _reloadCell: function(cell) {
    var heightShift = 0;
    if (cell) {
      var cacheData = this._cacheData;
      if (cacheData) {
        var oldHeight = cell.height;
        var height;
        if (cell.type === TABLE_VIEW_CELL_TYPE_HEADER) {
          height = this.getFixedSectionHeaderHeight();
          height = (
            isNaN(height) ?
            this._delegateHeightForSectionHeader.call(
              this.getDelegate(),
              this,
              cell.section
            ) :
            height
          );
        } else if (cell.type === TABLE_VIEW_CELL_TYPE_ROW) {
          height = this.getFixedRowHeight();
          height = (
            isNaN(height) ?
            this._delegateHeightForRowInSection.call(
              this.getDelegate(),
              this,
              cell.row,
              cell.section,
              true
            ) :
            height
          );
        }
        if (oldHeight !== height) {
          cell.height = height;
          heightShift = height - oldHeight;
          var cells = cacheData.cells;
          for (var i = cell.cellIndex + 1, l = cells.length; i < l; ++i) {
            cells[i].y += heightShift;
            this._setCellY(cells[i]);
          }

          // If we're changing the size of a cell above the viewport, scroll to
          // stay within the viewport.
          if (cell.y < this._getViewPort().y) {
            this._scrollView.scrollTo(0, heightShift, 0, true);
          }
        }
      }

      if (cell.view) {
        this._reapCell(cell);
        this._renderCellAtIndex(cell.cellIndex);
      }
    }
    return heightShift;
  },

  _renderCellAtIndex: function(index) {
    var cell = this._cacheData && this._cacheData.cells[index];

    // the view is already there, skip
    if (!cell || cell.view) {
      return;
    }

    var view;
    switch (cell.type) {
      case TABLE_VIEW_CELL_TYPE_HEADER:
        // get the header view from the delegate
        view = this._delegateViewForHeaderInSection.call(
          this.getDelegate(),
          this,
          cell.section
        );
        break;
      case TABLE_VIEW_CELL_TYPE_ROW:
        // get the row view from the data source
        view = this._dataSourceCellForRowInSection.call(
          this.getDataSource(),
          this,
          cell.row,
          cell.section
        );

        var fixedRowHeight = this.getFixedRowHeight();

        if (fixedRowHeight && view.setHeight) {
          view.setHeight(fixedRowHeight);
        }

        var numRows = this._dataSourceNumberOfRowsInSection.call(
                        this.getDataSource(),
                        this,
                        cell.section
                      );

        view.toggleClass('first', cell.row === 0);
        view.toggleClass('last', cell.row === numRows - 1);
        break;
    }
    if (this.getReloadCellOnResize()) {
      cell.resizeToken = view.listen(
        'resize',
        this._reloadCellHandler,
        this,
        cell
      );
    }
    cell.view = view;

    view.addListener('cellTapStarted', this.cellTapStarted, this);
    view.addListener('cellTapMoved', this.cellTapMoved, this);
    view.addListener('cellTapEnded', this.cellTapEnded, this);
    view.setMetadata({'item-index': index});

    this._renderCellViewForRowInSection(
      cell.row,
      cell.section,
      view,
      cell.y
    );
    this._addToScrollView(view);
  },

  _renderCellViewForRowInSection: function(row, section, view, y) {
    this._setCellViewY(view, y);
    if (this._getSelectedAtRowInSection(row, section)) {
      view.setSelected(true);
    }
  },

  _renderCells: function() {
    var cacheData = this._cacheData;
    if (cacheData && this._scrollView) {
      var viewPort = this._getViewPort();
      var start = this._cellIndexForRowAtY(viewPort.y);
      var end = start;
      var y = viewPort.y + viewPort.height;
      var cells = cacheData.cells;
      for (var l = cells.length; 0 <= end && end < l; ++end) {
        if (cells[end].y > y) {
          end--;
          break;
        }
      }
      end = Math.min(end, cells.length - 1);
      if (0 <= start && 0 <= end) {
        this._renderCellsInRange(
          start,
          end
        );
      }
    }
  },

  // renders the cells in the specified range, INCLUSIVELY - this function will
  // also reap items that were visible that are outside of this range
  _renderCellsInRange: function(start, end) {
    var cacheData = this._cacheData;
    var cells = cacheData.cells;
    var cellCount = cells.length;
    var bufferSize = this.getBufferSize();
    var firstVisible = start;
    var lastVisible = end;
    start = Math.min(start, cellCount - 1);
    end = Math.min(end + bufferSize, cellCount - 1);
    var first = start;
    start = Math.max(0, start - bufferSize);
    var lastStart = cacheData.visibleCellIndexStart;
    var lastEnd = cacheData.visibleCellIndexEnd;
    if (isNaN(lastStart)) lastStart = cellCount - 1;
    if (isNaN(lastEnd)) lastEnd = -1;
    if (lastStart > start || lastEnd < end) {
      var headerCellIndex = -1;
      // update the sticky header
      if (this.getStickySectionHeaders()) {
        if (-1 === first) {
          var view = cacheData.visibleSectionHeaderView;
          delete cacheData.visibleSectionHeaderView;
          delete cacheData.visibleSectionHeader;
          this._enqueueReusableCell(view);
        } else {
          var section = cells[first].section;
          var lastSection = cacheData.visibleSectionHeader;
          if (lastSection !== section) {
            // TODO: recycle sticky section headers instead of getting a new one
            // (this requires moving the section headers to/from the scrollview)
            // it also currently leaves 2 overlapping section headers and
            // doesn't quite switch headers at the right time
            this._enqueueReusableCell(cacheData.visibleSectionHeaderView);
            var sectionHeaderView = this._delegateViewForHeaderInSection.call(
              this.getDelegate(),
              this,
              section
            );
            this._renderCellViewForRowInSection(
              undefined,
              section,
              sectionHeaderView,
              0
            );
            this._addToFloatingSection(sectionHeaderView);
            cacheData.visibleSectionHeaderView = sectionHeaderView;
            cacheData.visibleSectionHeader = section;
          }
        }
      }
      // reap the cells that are no longer visible
      for (; lastStart < start && lastStart < lastEnd; ++lastStart) {
        this._reapCellAt(lastStart);
      }
      // reap the cells that are no longer visible
      for (; lastEnd > end && lastEnd > lastStart; --lastEnd) {
        this._reapCellAt(lastEnd);
      }
      for (var i = start; i <= end; ++i) {
        if ((lastStart > i || lastEnd < i) && headerCellIndex !== i) {
          this._renderCellAtIndex(i);
        }
      }
      this._cacheData.visibleCellIndexStart = start;
      this._cacheData.visibleCellIndexEnd = end;
    }
  },

  _rowAndSectionForCell: function(cell) {
    return {
      row: cell.row,
      section: cell.section
    };
  },

  _rowAndSectionForCellIndex: function(cellIndex) {
    var section = NaN;
    var row = NaN;
    var currentIndex = 0;
    var sections = this._cacheData.sections;
    var numberOfSections = sections.length;
    var sectionData;
    var numberOfRows;

    // loop through the sections
    for (var s = 0; s < numberOfSections; ++s) {
      sectionData = sections[s];
      numberOfRows = (sectionData.header ? 1 : 0) + sectionData.rows.length;

      // check if the section include the specified cell index
      if (currentIndex + numberOfRows > cellIndex) {
        section = s;
        row = cellIndex - currentIndex;
        break;
      }

      // advance past the rows in this section
      currentIndex += numberOfRows;
    }

    // return whatever we found
    return {
      section: section,
      row: row
    };
  },

  _selectCell: function(cell) {
    delete this._touched;
    var selectionFunction;
    var delegateFunction;
    if (this._getSelectedAtRowInSection(cell.row, cell.section)) {
      this.deselectRowInSection(cell.row, cell.section);
      this._delegateCellDeselectedAtRowInSection.call(
        this.getDelegate(),
        this,
        cell.row,
        cell.section,
        cell.view
      );
    } else {
      if (!cell.selected && !this.getMultiSelectionEnabled()) {
        // if multi-select is not enabled, deselect all cells first
        this.clearSelection();
      }
      this.selectRowInSection(cell.row, cell.section);
      this._delegateCellSelectedAtRowInSection.call(
        this.getDelegate(),
        this,
        cell.row,
        cell.section,
        cell.view
      );
    }
  },

  _setCellViewY: function(view, y) {
    if (view) {
      view.getNode().style.webkitTransform = 'translate3d(0,' + y + 'px,0)';
    }
  },

  _setCellY: function(cell) {
    cell && cell.view && this._setCellViewY(cell.view, cell.y);
  },

  _tableViewHighlightCell: function(tableView, cell, value) {
    cell.view && cell.view.setHighlighted(cell.view.getSelected() || value);
  },

  _tableViewLoadData: function(tableView) {
    tableView._loadData();
  },

  _tableViewRefresh: function(tableView) {
    tableView.refresh();
    // TODO: do we really want to move to top here, or just make sure the
    // viewport is accurate?
    tableView.scrollToTop();
  },

  _uncacheCell: function(cell) {
    var cacheData = this._cacheData;
    var sectionData = cacheData && cacheData.sections[cell.section];
    if (sectionData) {
      if (util.isUndefined(cell.row)) {
        delete sectionData.header;
      } else {
        sectionData.rows.splice(cell.row, 1)[0];
      }
      cacheData.cells.splice(cell.cellIndex, 1);
    }
  },

  // used as a placeholder for unimplemented delegate/dataSource methods
  // returning 0
  _zero: function() { return 0; },

  // used as a placeholder for unimplemented delegate/dataSource methods
  // returning 1
  _one: function() { return 1; },

  // ## DEPRECATED - the functions below are for backward compatibility only and
  // should be deleted, remove all references to them

  _deprecated: function(oldMethod, newMethod) {
    var message = 'DEPRECATED - TableView.' + oldMethod;
    if (newMethod) {
      message += ' (replace with ' + newMethod + ')';
    }
    console.warn(message);
  },

  dequeueReusableSectionHeaderWithIdentifier: function(identifier) {
    this._deprecated(
      'dequeueReusableSectionHeaderWithIdentifier',
      'dequeueReusableCellWithIdentifier'
    );
    return this.dequeueReusableCellWithIdentifier(identifier);
  },

  enqueueReusableSectionHeaderWithIdentifier: function(view, identifier) {
    this._deprecated(
      'enqueueReusableSectionHeaderWithIdentifier',
      'enqueueReusableCellWithIdentifier'
    );
  },

  moveToEnd: function(time) {
    this._deprecated('moveToEnd', 'scrollToEnd');
    this.moveToEnd(time);
  },

  moveToSection: function(section, time) {
    this._deprecated('moveToSection', 'scrollToSection');
    this.scrollToSection(section, time);
  },

  moveToTop: function(time) {
    this._deprecated('moveToTop', 'scrollToTop');
    this.scrollToTop(time);
  },

  setScrollbar: function(value) {
    this._deprecated('setScrollbar', 'setShowScrollbar');
    this.setShowScrollbar(value);
  }
});

// ### TableViewCell
// TableViews are populated with TableViewCell instances.
// Cells should generally not be subclassed, you should instead provide the
// cell with its content by specifying childViews in the builder.
var TableViewCell = exports.TableViewCell = core.createClass({
  name: 'TableViewCell',
  extend: View,
  mixins: [TableViewItem],

  properties: {
    highlighted: false,
    selectable: true,
    selected: false,
    // in edit mode, can this cell be reordered?
    reorderable: false,
    reuseIdentifier: 'cell',
    // don't reap the cell; for instance, in edit mode when a cell is
    // being reordered and floating above the table view.
    doNotReap: false,

    height: null,

    icon: '',

    title: '',

    accessoryType: '',
    accessoryTitle: null,
    accessoryView: null
  },

  touchstart: function(e) {
    this.invoke('cellTapStarted', this.getMetadata()['item-index']);
  },

  touchmove: function(e) {
    this.invoke('cellTapMoved', this.getMetadata()['item-index']);
  },

  touchend: function(e) {
    this.invoke('cellTapEnded', this.getMetadata()['item-index']);
  },

  touchcancel: function(e) {
    this.invoke('cellTapEnded', this.getMetadata()['item-index']);
  },

  declare: function() {
    return {
      childViews: [{
        ref: 'icon',
        className: 'bt-table-view-cell--icon'
      },
      {
        ref: 'title',
        className: 'bt-table-view-cell--title'
      },
      {
        ref: 'accessory',
        className: 'bt-table-view-cell--accessory',

        childViews: [{
          ref: 'accessory_text',
          className: 'bt-table-view-cell--accessory-text'
        },{
          ref: 'accessory_type',
          className: 'bt-table-view-cell--accessory-type'
        }]
      }]
    };
  },

  setIcon: function(value) {
    var icon = this.findRef('icon');

    // Only set these styles if an icon has been set.
    icon.setStyle({
      height: '100%',
      width: '75px',
      'background': "url('"+value+"') center center no-repeat"
    });
  },

  setTitle: function(value) {
    this.set('title',value);
    this.refs.title.setContent(value);
  },

  setAccessoryType: function(value) {
    var accessory = this.refs.accessory_type;
    accessory.addClass('bt-table-view--accessory-'+value);

    this.set('accessoryType', value);
  },

  setAccessoryTitle: function(value) {
    this.refs.accessory_text.setContent(value);

    this.set('accessoryTitle', value);
  },

  setAccessoryView: function(value) {
    var accessory = this.refs.accessory;
    var height = 55;

    accessory.appendChild(value);
    accessory.setStyle({
      height: height + 'px',
      top: '50%',
      'margin-top': '-' + Math.floor(height / 2) + 'px'
    });

    this.set('accessoryView', value);
  },

  setHighlighted: function(value) {
    this.set('highlighted', value);
    if (this.getSelectable()) {
      this.toggleClass('bt-active', value);
    }
  },

  setHeight: function(fixedRowHeight) {
    this.setStyle('height', fixedRowHeight + 'px');

    var title = this.refs.title;

    if (title) {
      title.setStyle('lineHeight', fixedRowHeight + 'px');
    }

    var accessoryTitle = this.refs.accessory_text;

    if (accessoryTitle) {
      accessoryTitle.setStyle('lineHeight', fixedRowHeight + 'px');
    }
  },

  setSelected: function(value) {
    // cells can be highlighted while they are not selected - synchronize the
    // state when selection changes
    if (this.getSelected() !== value) {
      this.set('selected', value);
      this.setHighlighted(value);
    }
  },

  setReorderable: function(value) {
    this.toggleClass('bt-reorderable', value);
    this.set('reorderable', value);
  },

  // Called when a cell is enqueued. Use this to remove event listeners or to
  // clean up the contents of a cell and return it to a blank state.
  cleanForReuse: function() {}
});

// ### TableViewSectionHeader
// Tables may optionally include section headers
var TableViewSectionHeader = exports.TableViewSectionHeader =
core.createClass({
  name: 'TableViewSectionHeader',
  extend: TableViewCell,
  mixins: [TableViewItem],

  properties: {
    reuseIdentifier: 'section'
  }
});
});

// module: third-party/libphonenumber/compiled_formatter
// file:   ../../third-party/libphonenumber/compiled_formatter.js
define("third-party/libphonenumber/compiled_formatter", "var COMPILED=!0,goog=goog||{};goog.global=this;goog.DEBUG=!0;goog.LOCALE=\"en\";goog.provide=function(a){if(!COMPILED){if(goog.isProvided_(a))throw Error('Namespace \"'+a+'\" already declared.');delete goog.implicitNamespaces_[a];for(var b=a;(b=b.substring(0,b.lastIndexOf(\".\")))&&!goog.getObjectByName(b);)goog.implicitNamespaces_[b]=!0}goog.exportPath_(a)};goog.setTestOnly=function(a){if(COMPILED&&!goog.DEBUG)throw a=a||\"\",Error(\"Importing test-only code into non-debug environment\"+a?\": \"+a:\".\");};\nCOMPILED||(goog.isProvided_=function(a){return!goog.implicitNamespaces_[a]&&!!goog.getObjectByName(a)},goog.implicitNamespaces_={});goog.exportPath_=function(a,b,c){a=a.split(\".\");c=c||goog.global;!(a[0]in c)&&c.execScript&&c.execScript(\"var \"+a[0]);for(var d;a.length&&(d=a.shift());)!a.length&&goog.isDef(b)?c[d]=b:c=c[d]?c[d]:c[d]={}};goog.getObjectByName=function(a,b){for(var c=a.split(\".\"),d=b||goog.global,e;e=c.shift();)if(goog.isDefAndNotNull(d[e]))d=d[e];else return null;return d};\ngoog.globalize=function(a,b){var c=b||goog.global,d;for(d in a)c[d]=a[d]};goog.addDependency=function(a,b,c){if(!COMPILED){for(var d,a=a.replace(/\\\\/g,\"/\"),e=goog.dependencies_,f=0;d=b[f];f++){e.nameToPath[d]=a;a in e.pathToNames||(e.pathToNames[a]={});e.pathToNames[a][d]=true}for(d=0;b=c[d];d++){a in e.requires||(e.requires[a]={});e.requires[a][b]=true}}};goog.ENABLE_DEBUG_LOADER=!0;\ngoog.require=function(a){if(!COMPILED&&!goog.isProvided_(a)){if(goog.ENABLE_DEBUG_LOADER){var b=goog.getPathFromDeps_(a);if(b){goog.included_[b]=true;goog.writeScripts_();return}}a=\"goog.require could not find: \"+a;goog.global.console&&goog.global.console.error(a);throw Error(a);}};goog.basePath=\"\";goog.nullFunction=function(){};goog.identityFunction=function(a){return a};goog.abstractMethod=function(){throw Error(\"unimplemented abstract method\");};\ngoog.addSingletonGetter=function(a){a.getInstance=function(){if(a.instance_)return a.instance_;goog.DEBUG&&(goog.instantiatedSingletons_[goog.instantiatedSingletons_.length]=a);return a.instance_=new a}};goog.instantiatedSingletons_=[];\n!COMPILED&&goog.ENABLE_DEBUG_LOADER&&(goog.included_={},goog.dependencies_={pathToNames:{},nameToPath:{},requires:{},visited:{},written:{}},goog.inHtmlDocument_=function(){var a=goog.global.document;return typeof a!=\"undefined\"&&\"write\"in a},goog.findBasePath_=function(){if(goog.global.CLOSURE_BASE_PATH)goog.basePath=goog.global.CLOSURE_BASE_PATH;else if(goog.inHtmlDocument_())for(var a=goog.global.document.getElementsByTagName(\"script\"),b=a.length-1;b>=0;--b){var c=a[b].src,d=c.lastIndexOf(\"?\"),\nd=d==-1?c.length:d;if(c.substr(d-7,7)==\"base.js\"){goog.basePath=c.substr(0,d-7);break}}},goog.importScript_=function(a){var b=goog.global.CLOSURE_IMPORT_SCRIPT||goog.writeScriptTag_;!goog.dependencies_.written[a]&&b(a)&&(goog.dependencies_.written[a]=true)},goog.writeScriptTag_=function(a){if(goog.inHtmlDocument_()){goog.global.document.write('<script type=\"text/javascript\" src=\"'+a+'\"><\\/script>');return true}return false},goog.writeScripts_=function(){function a(e){if(!(e in d.written)){if(!(e in\nd.visited)){d.visited[e]=true;if(e in d.requires)for(var g in d.requires[e])if(!goog.isProvided_(g))if(g in d.nameToPath)a(d.nameToPath[g]);else throw Error(\"Undefined nameToPath for \"+g);}if(!(e in c)){c[e]=true;b.push(e)}}}var b=[],c={},d=goog.dependencies_,e;for(e in goog.included_)d.written[e]||a(e);for(e=0;e<b.length;e++)if(b[e])goog.importScript_(goog.basePath+b[e]);else throw Error(\"Undefined script input\");},goog.getPathFromDeps_=function(a){return a in goog.dependencies_.nameToPath?goog.dependencies_.nameToPath[a]:\nnull},goog.findBasePath_(),goog.global.CLOSURE_NO_DEPS||goog.importScript_(goog.basePath+\"deps.js\"));\ngoog.typeOf=function(a){var b=typeof a;if(b==\"object\")if(a){if(a instanceof Array)return\"array\";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if(c==\"[object Window]\")return\"object\";if(c==\"[object Array]\"||typeof a.length==\"number\"&&typeof a.splice!=\"undefined\"&&typeof a.propertyIsEnumerable!=\"undefined\"&&!a.propertyIsEnumerable(\"splice\"))return\"array\";if(c==\"[object Function]\"||typeof a.call!=\"undefined\"&&typeof a.propertyIsEnumerable!=\"undefined\"&&!a.propertyIsEnumerable(\"call\"))return\"function\"}else return\"null\";\nelse if(b==\"function\"&&typeof a.call==\"undefined\")return\"object\";return b};goog.isDef=function(a){return a!==void 0};goog.isNull=function(a){return a===null};goog.isDefAndNotNull=function(a){return a!=null};goog.isArray=function(a){return goog.typeOf(a)==\"array\"};goog.isArrayLike=function(a){var b=goog.typeOf(a);return b==\"array\"||b==\"object\"&&typeof a.length==\"number\"};goog.isDateLike=function(a){return goog.isObject(a)&&typeof a.getFullYear==\"function\"};\ngoog.isString=function(a){return typeof a==\"string\"};goog.isBoolean=function(a){return typeof a==\"boolean\"};goog.isNumber=function(a){return typeof a==\"number\"};goog.isFunction=function(a){return goog.typeOf(a)==\"function\"};goog.isObject=function(a){var b=typeof a;return b==\"object\"&&a!=null||b==\"function\"};goog.getUid=function(a){return a[goog.UID_PROPERTY_]||(a[goog.UID_PROPERTY_]=++goog.uidCounter_)};goog.removeUid=function(a){\"removeAttribute\"in a&&a.removeAttribute(goog.UID_PROPERTY_);try{delete a[goog.UID_PROPERTY_]}catch(b){}};\ngoog.UID_PROPERTY_=\"closure_uid_\"+Math.floor(2147483648*Math.random()).toString(36);goog.uidCounter_=0;goog.getHashCode=goog.getUid;goog.removeHashCode=goog.removeUid;goog.cloneObject=function(a){var b=goog.typeOf(a);if(b==\"object\"||b==\"array\"){if(a.clone)return a.clone();var b=b==\"array\"?[]:{},c;for(c in a)b[c]=goog.cloneObject(a[c]);return b}return a};goog.bindNative_=function(a,b,c){return a.call.apply(a.bind,arguments)};\ngoog.bindJs_=function(a,b,c){if(!a)throw Error();if(arguments.length>2){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}};goog.bind=function(a,b,c){goog.bind=Function.prototype.bind&&Function.prototype.bind.toString().indexOf(\"native code\")!=-1?goog.bindNative_:goog.bindJs_;return goog.bind.apply(null,arguments)};\ngoog.partial=function(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=Array.prototype.slice.call(arguments);b.unshift.apply(b,c);return a.apply(this,b)}};goog.mixin=function(a,b){for(var c in b)a[c]=b[c]};goog.now=Date.now||function(){return+new Date};\ngoog.globalEval=function(a){if(goog.global.execScript)goog.global.execScript(a,\"JavaScript\");else if(goog.global.eval){if(goog.evalWorksForGlobals_==null){goog.global.eval(\"var _et_ = 1;\");if(typeof goog.global._et_!=\"undefined\"){delete goog.global._et_;goog.evalWorksForGlobals_=true}else goog.evalWorksForGlobals_=false}if(goog.evalWorksForGlobals_)goog.global.eval(a);else{var b=goog.global.document,c=b.createElement(\"script\");c.type=\"text/javascript\";c.defer=false;c.appendChild(b.createTextNode(a));\nb.body.appendChild(c);b.body.removeChild(c)}}else throw Error(\"goog.globalEval not available\");};goog.evalWorksForGlobals_=null;goog.getCssName=function(a,b){var c=function(a){return goog.cssNameMapping_[a]||a},d;d=goog.cssNameMapping_?goog.cssNameMappingStyle_==\"BY_WHOLE\"?c:function(a){for(var a=a.split(\"-\"),b=[],d=0;d<a.length;d++)b.push(c(a[d]));return b.join(\"-\")}:function(a){return a};return b?a+\"-\"+d(b):d(a)};\ngoog.setCssNameMapping=function(a,b){goog.cssNameMapping_=a;goog.cssNameMappingStyle_=b};!COMPILED&&goog.global.CLOSURE_CSS_NAME_MAPPING&&(goog.cssNameMapping_=goog.global.CLOSURE_CSS_NAME_MAPPING);goog.getMsg=function(a,b){var c=b||{},d;for(d in c)var e=(\"\"+c[d]).replace(/\\$/g,\"$$$$\"),a=a.replace(RegExp(\"\\\\{\\\\$\"+d+\"\\\\}\",\"gi\"),e);return a};goog.exportSymbol=function(a,b,c){goog.exportPath_(a,b,c)};goog.exportProperty=function(a,b,c){a[b]=c};\ngoog.inherits=function(a,b){function c(){}c.prototype=b.prototype;a.superClass_=b.prototype;a.prototype=new c;a.prototype.constructor=a};\ngoog.base=function(a,b,c){var d=arguments.callee.caller;if(d.superClass_)return d.superClass_.constructor.apply(a,Array.prototype.slice.call(arguments,1));for(var e=Array.prototype.slice.call(arguments,2),f=false,g=a.constructor;g;g=g.superClass_&&g.superClass_.constructor)if(g.prototype[b]===d)f=true;else if(f)return g.prototype[b].apply(a,e);if(a[b]===d)return a.constructor.prototype[b].apply(a,e);throw Error(\"goog.base called from a method of one name to a method of a different name\");};\ngoog.scope=function(a){a.call(goog.global)};goog.string={};goog.string.Unicode={NBSP:\"\\u00a0\"};goog.string.startsWith=function(a,b){return 0==a.lastIndexOf(b,0)};goog.string.endsWith=function(a,b){var c=a.length-b.length;return 0<=c&&a.indexOf(b,c)==c};goog.string.caseInsensitiveStartsWith=function(a,b){return 0==goog.string.caseInsensitiveCompare(b,a.substr(0,b.length))};goog.string.caseInsensitiveEndsWith=function(a,b){return 0==goog.string.caseInsensitiveCompare(b,a.substr(a.length-b.length,b.length))};\ngoog.string.subs=function(a,b){for(var c=1;c<arguments.length;c++)var d=(\"\"+arguments[c]).replace(/\\$/g,\"$$$$\"),a=a.replace(/\\%s/,d);return a};goog.string.collapseWhitespace=function(a){return a.replace(/[\\s\\xa0]+/g,\" \").replace(/^\\s+|\\s+$/g,\"\")};goog.string.isEmpty=function(a){return/^[\\s\\xa0]*$/.test(a)};goog.string.isEmptySafe=function(a){return goog.string.isEmpty(goog.string.makeSafe(a))};goog.string.isBreakingWhitespace=function(a){return!/[^\\t\\n\\r ]/.test(a)};goog.string.isAlpha=function(a){return!/[^a-zA-Z]/.test(a)};\ngoog.string.isNumeric=function(a){return!/[^0-9]/.test(a)};goog.string.isAlphaNumeric=function(a){return!/[^a-zA-Z0-9]/.test(a)};goog.string.isSpace=function(a){return\" \"==a};goog.string.isUnicodeChar=function(a){return 1==a.length&&\" \"<=a&&\"~\">=a||\"\\u0080\"<=a&&\"\\ufffd\">=a};goog.string.stripNewlines=function(a){return a.replace(/(\\r\\n|\\r|\\n)+/g,\" \")};goog.string.canonicalizeNewlines=function(a){return a.replace(/(\\r\\n|\\r|\\n)/g,\"\\n\")};\ngoog.string.normalizeWhitespace=function(a){return a.replace(/\\xa0|\\s/g,\" \")};goog.string.normalizeSpaces=function(a){return a.replace(/\\xa0|[ \\t]+/g,\" \")};goog.string.collapseBreakingSpaces=function(a){return a.replace(/[\\t\\r\\n ]+/g,\" \").replace(/^[\\t\\r\\n ]+|[\\t\\r\\n ]+$/g,\"\")};goog.string.trim=function(a){return a.replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g,\"\")};goog.string.trimLeft=function(a){return a.replace(/^[\\s\\xa0]+/,\"\")};goog.string.trimRight=function(a){return a.replace(/[\\s\\xa0]+$/,\"\")};\ngoog.string.caseInsensitiveCompare=function(a,b){var c=(\"\"+a).toLowerCase(),d=(\"\"+b).toLowerCase();return c<d?-1:c==d?0:1};goog.string.numerateCompareRegExp_=/(\\.\\d+)|(\\d+)|(\\D+)/g;\ngoog.string.numerateCompare=function(a,b){if(a==b)return 0;if(!a)return-1;if(!b)return 1;for(var c=a.toLowerCase().match(goog.string.numerateCompareRegExp_),d=b.toLowerCase().match(goog.string.numerateCompareRegExp_),e=Math.min(c.length,d.length),f=0;f<e;f++){var g=c[f],h=d[f];if(g!=h)return c=parseInt(g,10),!isNaN(c)&&(d=parseInt(h,10),!isNaN(d)&&c-d)?c-d:g<h?-1:1}return c.length!=d.length?c.length-d.length:a<b?-1:1};goog.string.encodeUriRegExp_=/^[a-zA-Z0-9\\-_.!~*'()]*$/;\ngoog.string.urlEncode=function(a){a=\"\"+a;return!goog.string.encodeUriRegExp_.test(a)?encodeURIComponent(a):a};goog.string.urlDecode=function(a){return decodeURIComponent(a.replace(/\\+/g,\" \"))};goog.string.newLineToBr=function(a,b){return a.replace(/(\\r\\n|\\r|\\n)/g,b?\"<br />\":\"<br>\")};\ngoog.string.htmlEscape=function(a,b){if(b)return a.replace(goog.string.amperRe_,\"&amp;\").replace(goog.string.ltRe_,\"&lt;\").replace(goog.string.gtRe_,\"&gt;\").replace(goog.string.quotRe_,\"&quot;\");if(!goog.string.allRe_.test(a))return a;-1!=a.indexOf(\"&\")&&(a=a.replace(goog.string.amperRe_,\"&amp;\"));-1!=a.indexOf(\"<\")&&(a=a.replace(goog.string.ltRe_,\"&lt;\"));-1!=a.indexOf(\">\")&&(a=a.replace(goog.string.gtRe_,\"&gt;\"));-1!=a.indexOf('\"')&&(a=a.replace(goog.string.quotRe_,\"&quot;\"));return a};\ngoog.string.amperRe_=/&/g;goog.string.ltRe_=/</g;goog.string.gtRe_=/>/g;goog.string.quotRe_=/\\\"/g;goog.string.allRe_=/[&<>\\\"]/;goog.string.unescapeEntities=function(a){return goog.string.contains(a,\"&\")?\"document\"in goog.global?goog.string.unescapeEntitiesUsingDom_(a):goog.string.unescapePureXmlEntities_(a):a};\ngoog.string.unescapeEntitiesUsingDom_=function(a){var b={\"&amp;\":\"&\",\"&lt;\":\"<\",\"&gt;\":\">\",\"&quot;\":'\"'},c=document.createElement(\"div\");return a.replace(goog.string.HTML_ENTITY_PATTERN_,function(a,e){var f=b[a];if(f)return f;if(\"#\"==e.charAt(0)){var g=Number(\"0\"+e.substr(1));isNaN(g)||(f=String.fromCharCode(g))}f||(c.innerHTML=a+\" \",f=c.firstChild.nodeValue.slice(0,-1));return b[a]=f})};\ngoog.string.unescapePureXmlEntities_=function(a){return a.replace(/&([^;]+);/g,function(a,c){switch(c){case \"amp\":return\"&\";case \"lt\":return\"<\";case \"gt\":return\">\";case \"quot\":return'\"';default:if(\"#\"==c.charAt(0)){var d=Number(\"0\"+c.substr(1));if(!isNaN(d))return String.fromCharCode(d)}return a}})};goog.string.HTML_ENTITY_PATTERN_=/&([^;\\s<&]+);?/g;goog.string.whitespaceEscape=function(a,b){return goog.string.newLineToBr(a.replace(/  /g,\" &#160;\"),b)};\ngoog.string.stripQuotes=function(a,b){for(var c=b.length,d=0;d<c;d++){var e=1==c?b:b.charAt(d);if(a.charAt(0)==e&&a.charAt(a.length-1)==e)return a.substring(1,a.length-1)}return a};goog.string.truncate=function(a,b,c){c&&(a=goog.string.unescapeEntities(a));a.length>b&&(a=a.substring(0,b-3)+\"...\");c&&(a=goog.string.htmlEscape(a));return a};\ngoog.string.truncateMiddle=function(a,b,c,d){c&&(a=goog.string.unescapeEntities(a));if(d&&a.length>b){d>b&&(d=b);var e=a.length-d,a=a.substring(0,b-d)+\"...\"+a.substring(e)}else a.length>b&&(d=Math.floor(b/2),e=a.length-d,a=a.substring(0,d+b%2)+\"...\"+a.substring(e));c&&(a=goog.string.htmlEscape(a));return a};goog.string.specialEscapeChars_={\"\\x00\":\"\\\\0\",\"\\u0008\":\"\\\\b\",\"\\u000c\":\"\\\\f\",\"\\n\":\"\\\\n\",\"\\r\":\"\\\\r\",\"\\t\":\"\\\\t\",\"\\x0B\":\"\\\\x0B\",'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\"};goog.string.jsEscapeCache_={\"'\":\"\\\\'\"};\ngoog.string.quote=function(a){a=\"\"+a;if(a.quote)return a.quote();for(var b=['\"'],c=0;c<a.length;c++){var d=a.charAt(c),e=d.charCodeAt(0);b[c+1]=goog.string.specialEscapeChars_[d]||(31<e&&127>e?d:goog.string.escapeChar(d))}b.push('\"');return b.join(\"\")};goog.string.escapeString=function(a){for(var b=[],c=0;c<a.length;c++)b[c]=goog.string.escapeChar(a.charAt(c));return b.join(\"\")};\ngoog.string.escapeChar=function(a){if(a in goog.string.jsEscapeCache_)return goog.string.jsEscapeCache_[a];if(a in goog.string.specialEscapeChars_)return goog.string.jsEscapeCache_[a]=goog.string.specialEscapeChars_[a];var b=a,c=a.charCodeAt(0);if(31<c&&127>c)b=a;else{if(256>c){if(b=\"\\\\x\",16>c||256<c)b+=\"0\"}else b=\"\\\\u\",4096>c&&(b+=\"0\");b+=c.toString(16).toUpperCase()}return goog.string.jsEscapeCache_[a]=b};goog.string.toMap=function(a){for(var b={},c=0;c<a.length;c++)b[a.charAt(c)]=!0;return b};\ngoog.string.contains=function(a,b){return-1!=a.indexOf(b)};goog.string.countOf=function(a,b){return a&&b?a.split(b).length-1:0};goog.string.removeAt=function(a,b,c){var d=a;0<=b&&b<a.length&&0<c&&(d=a.substr(0,b)+a.substr(b+c,a.length-b-c));return d};goog.string.remove=function(a,b){var c=RegExp(goog.string.regExpEscape(b),\"\");return a.replace(c,\"\")};goog.string.removeAll=function(a,b){var c=RegExp(goog.string.regExpEscape(b),\"g\");return a.replace(c,\"\")};\ngoog.string.regExpEscape=function(a){return(\"\"+a).replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g,\"\\\\$1\").replace(/\\x08/g,\"\\\\x08\")};goog.string.repeat=function(a,b){return Array(b+1).join(a)};goog.string.padNumber=function(a,b,c){a=goog.isDef(c)?a.toFixed(c):\"\"+a;c=a.indexOf(\".\");-1==c&&(c=a.length);return goog.string.repeat(\"0\",Math.max(0,b-c))+a};goog.string.makeSafe=function(a){return null==a?\"\":\"\"+a};goog.string.buildString=function(a){return Array.prototype.join.call(arguments,\"\")};\ngoog.string.getRandomString=function(){return Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^goog.now()).toString(36)};\ngoog.string.compareVersions=function(a,b){for(var c=0,d=goog.string.trim(\"\"+a).split(\".\"),e=goog.string.trim(\"\"+b).split(\".\"),f=Math.max(d.length,e.length),g=0;0==c&&g<f;g++){var h=d[g]||\"\",i=e[g]||\"\",j=RegExp(\"(\\\\d*)(\\\\D*)\",\"g\"),l=RegExp(\"(\\\\d*)(\\\\D*)\",\"g\");do{var k=j.exec(h)||[\"\",\"\",\"\"],m=l.exec(i)||[\"\",\"\",\"\"];if(0==k[0].length&&0==m[0].length)break;var c=0==k[1].length?0:parseInt(k[1],10),n=0==m[1].length?0:parseInt(m[1],10),c=goog.string.compareElements_(c,n)||goog.string.compareElements_(0==\nk[2].length,0==m[2].length)||goog.string.compareElements_(k[2],m[2])}while(0==c)}return c};goog.string.compareElements_=function(a,b){return a<b?-1:a>b?1:0};goog.string.HASHCODE_MAX_=4294967296;goog.string.hashCode=function(a){for(var b=0,c=0;c<a.length;++c)b=31*b+a.charCodeAt(c),b%=goog.string.HASHCODE_MAX_;return b};goog.string.uniqueStringCounter_=2147483648*Math.random()|0;goog.string.createUniqueString=function(){return\"goog_\"+goog.string.uniqueStringCounter_++};\ngoog.string.toNumber=function(a){var b=Number(a);return 0==b&&goog.string.isEmpty(a)?NaN:b};goog.string.toCamelCaseCache_={};goog.string.toCamelCase=function(a){return goog.string.toCamelCaseCache_[a]||(goog.string.toCamelCaseCache_[a]=(\"\"+a).replace(/\\-([a-z])/g,function(a,c){return c.toUpperCase()}))};goog.string.toSelectorCaseCache_={};goog.string.toSelectorCase=function(a){return goog.string.toSelectorCaseCache_[a]||(goog.string.toSelectorCaseCache_[a]=(\"\"+a).replace(/([A-Z])/g,\"-$1\").toLowerCase())};goog.userAgent={};goog.userAgent.jscript={};goog.userAgent.jscript.ASSUME_NO_JSCRIPT=!1;goog.userAgent.jscript.init_=function(){goog.userAgent.jscript.DETECTED_HAS_JSCRIPT_=\"ScriptEngine\"in goog.global&&\"JScript\"==goog.global.ScriptEngine();goog.userAgent.jscript.DETECTED_VERSION_=goog.userAgent.jscript.DETECTED_HAS_JSCRIPT_?goog.global.ScriptEngineMajorVersion()+\".\"+goog.global.ScriptEngineMinorVersion()+\".\"+goog.global.ScriptEngineBuildVersion():\"0\"};goog.userAgent.jscript.ASSUME_NO_JSCRIPT||goog.userAgent.jscript.init_();\ngoog.userAgent.jscript.HAS_JSCRIPT=goog.userAgent.jscript.ASSUME_NO_JSCRIPT?!1:goog.userAgent.jscript.DETECTED_HAS_JSCRIPT_;goog.userAgent.jscript.VERSION=goog.userAgent.jscript.ASSUME_NO_JSCRIPT?\"0\":goog.userAgent.jscript.DETECTED_VERSION_;goog.userAgent.jscript.isVersion=function(a){return 0<=goog.string.compareVersions(goog.userAgent.jscript.VERSION,a)};goog.string.StringBuffer=function(a,b){this.buffer_=goog.userAgent.jscript.HAS_JSCRIPT?[]:\"\";null!=a&&this.append.apply(this,arguments)};goog.string.StringBuffer.prototype.set=function(a){this.clear();this.append(a)};\ngoog.userAgent.jscript.HAS_JSCRIPT?(goog.string.StringBuffer.prototype.bufferLength_=0,goog.string.StringBuffer.prototype.append=function(a,b,c){null==b?this.buffer_[this.bufferLength_++]=a:(this.buffer_.push.apply(this.buffer_,arguments),this.bufferLength_=this.buffer_.length);return this}):goog.string.StringBuffer.prototype.append=function(a,b,c){this.buffer_+=a;if(null!=b)for(var d=1;d<arguments.length;d++)this.buffer_+=arguments[d];return this};\ngoog.string.StringBuffer.prototype.clear=function(){if(goog.userAgent.jscript.HAS_JSCRIPT)this.bufferLength_=this.buffer_.length=0;else this.buffer_=\"\"};goog.string.StringBuffer.prototype.getLength=function(){return this.toString().length};goog.string.StringBuffer.prototype.toString=function(){if(goog.userAgent.jscript.HAS_JSCRIPT){var a=this.buffer_.join(\"\");this.clear();a&&this.append(a);return a}return this.buffer_};goog.debug={};goog.debug.Error=function(a){this.stack=Error().stack||\"\";a&&(this.message=\"\"+a)};goog.inherits(goog.debug.Error,Error);goog.debug.Error.prototype.name=\"CustomError\";goog.asserts={};goog.asserts.ENABLE_ASSERTS=goog.DEBUG;goog.asserts.AssertionError=function(a,b){b.unshift(a);goog.debug.Error.call(this,goog.string.subs.apply(null,b));b.shift();this.messagePattern=a};goog.inherits(goog.asserts.AssertionError,goog.debug.Error);goog.asserts.AssertionError.prototype.name=\"AssertionError\";goog.asserts.doAssertFailure_=function(a,b,c,d){var e=\"Assertion failed\";if(c)var e=e+(\": \"+c),f=d;else a&&(e+=\": \"+a,f=b);throw new goog.asserts.AssertionError(\"\"+e,f||[]);};\ngoog.asserts.assert=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!a&&goog.asserts.doAssertFailure_(\"\",null,b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.fail=function(a,b){if(goog.asserts.ENABLE_ASSERTS)throw new goog.asserts.AssertionError(\"Failure\"+(a?\": \"+a:\"\"),Array.prototype.slice.call(arguments,1));};\ngoog.asserts.assertNumber=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isNumber(a)&&goog.asserts.doAssertFailure_(\"Expected number but got %s: %s.\",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertString=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isString(a)&&goog.asserts.doAssertFailure_(\"Expected string but got %s: %s.\",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};\ngoog.asserts.assertFunction=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isFunction(a)&&goog.asserts.doAssertFailure_(\"Expected function but got %s: %s.\",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertObject=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isObject(a)&&goog.asserts.doAssertFailure_(\"Expected object but got %s: %s.\",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};\ngoog.asserts.assertArray=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isArray(a)&&goog.asserts.doAssertFailure_(\"Expected array but got %s: %s.\",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertBoolean=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isBoolean(a)&&goog.asserts.doAssertFailure_(\"Expected boolean but got %s: %s.\",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};\ngoog.asserts.assertInstanceof=function(a,b,c,d){goog.asserts.ENABLE_ASSERTS&&!(a instanceof b)&&goog.asserts.doAssertFailure_(\"instanceof check failed.\",null,c,Array.prototype.slice.call(arguments,3))};goog.proto2={};goog.proto2.Util={};goog.proto2.Util.PBCHECK=!COMPILED;goog.proto2.Util.assert=function(a,b){goog.proto2.Util.PBCHECK&&goog.asserts.assert(a,b)};goog.proto2.Util.conductChecks=function(){return goog.proto2.Util.PBCHECK};goog.proto2.FieldDescriptor=function(a,b,c){this.parent_=a;goog.proto2.Util.assert(goog.string.isNumeric(b));this.tag_=b;this.name_=c.name;this.isRepeated_=!!c.repeated;this.isRequired_=!!c.required;this.fieldType_=c.fieldType;this.nativeType_=c.type;this.deserializationConversionPermitted_=!1;switch(this.fieldType_){case goog.proto2.FieldDescriptor.FieldType.INT64:case goog.proto2.FieldDescriptor.FieldType.UINT64:case goog.proto2.FieldDescriptor.FieldType.FIXED64:case goog.proto2.FieldDescriptor.FieldType.SFIXED64:case goog.proto2.FieldDescriptor.FieldType.SINT64:this.deserializationConversionPermitted_=\n!0}this.defaultValue_=c.defaultValue};goog.proto2.FieldDescriptor.FieldType={DOUBLE:1,FLOAT:2,INT64:3,UINT64:4,INT32:5,FIXED64:6,FIXED32:7,BOOL:8,STRING:9,GROUP:10,MESSAGE:11,BYTES:12,UINT32:13,ENUM:14,SFIXED32:15,SFIXED64:16,SINT32:17,SINT64:18};goog.proto2.FieldDescriptor.prototype.getTag=function(){return this.tag_};goog.proto2.FieldDescriptor.prototype.getContainingType=function(){return this.parent_.descriptor_};goog.proto2.FieldDescriptor.prototype.getName=function(){return this.name_};\ngoog.proto2.FieldDescriptor.prototype.getDefaultValue=function(){if(void 0===this.defaultValue_){var a=this.nativeType_;this.defaultValue_=a===Boolean?!1:a===Number?0:a===String?\"\":new a}return this.defaultValue_};goog.proto2.FieldDescriptor.prototype.getFieldType=function(){return this.fieldType_};goog.proto2.FieldDescriptor.prototype.getNativeType=function(){return this.nativeType_};goog.proto2.FieldDescriptor.prototype.deserializationConversionPermitted=function(){return this.deserializationConversionPermitted_};\ngoog.proto2.FieldDescriptor.prototype.getFieldMessageType=function(){goog.proto2.Util.assert(this.isCompositeType(),\"Expected message or group\");return this.nativeType_.descriptor_};goog.proto2.FieldDescriptor.prototype.isCompositeType=function(){return this.fieldType_==goog.proto2.FieldDescriptor.FieldType.MESSAGE||this.fieldType_==goog.proto2.FieldDescriptor.FieldType.GROUP};goog.proto2.FieldDescriptor.prototype.isRepeated=function(){return this.isRepeated_};\ngoog.proto2.FieldDescriptor.prototype.isRequired=function(){return this.isRequired_};goog.proto2.FieldDescriptor.prototype.isOptional=function(){return!this.isRepeated_&&!this.isRequired_};goog.object={};goog.object.forEach=function(a,b,c){for(var d in a)b.call(c,a[d],d,a)};goog.object.filter=function(a,b,c){var d={},e;for(e in a)b.call(c,a[e],e,a)&&(d[e]=a[e]);return d};goog.object.map=function(a,b,c){var d={},e;for(e in a)d[e]=b.call(c,a[e],e,a);return d};goog.object.some=function(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return!0;return!1};goog.object.every=function(a,b,c){for(var d in a)if(!b.call(c,a[d],d,a))return!1;return!0};\ngoog.object.getCount=function(a){var b=0,c;for(c in a)b++;return b};goog.object.getAnyKey=function(a){for(var b in a)return b};goog.object.getAnyValue=function(a){for(var b in a)return a[b]};goog.object.contains=function(a,b){return goog.object.containsValue(a,b)};goog.object.getValues=function(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b};goog.object.getKeys=function(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b};\ngoog.object.getValueByKeys=function(a,b){for(var c=goog.isArrayLike(b),d=c?b:arguments,c=c?0:1;c<d.length&&!(a=a[d[c]],!goog.isDef(a));c++);return a};goog.object.containsKey=function(a,b){return b in a};goog.object.containsValue=function(a,b){for(var c in a)if(a[c]==b)return!0;return!1};goog.object.findKey=function(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return d};goog.object.findValue=function(a,b,c){return(b=goog.object.findKey(a,b,c))&&a[b]};\ngoog.object.isEmpty=function(a){for(var b in a)return!1;return!0};goog.object.clear=function(a){for(var b in a)delete a[b]};goog.object.remove=function(a,b){var c;(c=b in a)&&delete a[b];return c};goog.object.add=function(a,b,c){if(b in a)throw Error('The object already contains the key \"'+b+'\"');goog.object.set(a,b,c)};goog.object.get=function(a,b,c){return b in a?a[b]:c};goog.object.set=function(a,b,c){a[b]=c};goog.object.setIfUndefined=function(a,b,c){return b in a?a[b]:a[b]=c};\ngoog.object.clone=function(a){var b={},c;for(c in a)b[c]=a[c];return b};goog.object.unsafeClone=function(a){var b=goog.typeOf(a);if(\"object\"==b||\"array\"==b){if(a.clone)return a.clone();var b=\"array\"==b?[]:{},c;for(c in a)b[c]=goog.object.unsafeClone(a[c]);return b}return a};goog.object.transpose=function(a){var b={},c;for(c in a)b[a[c]]=c;return b};goog.object.PROTOTYPE_FIELDS_=\"constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf\".split(\",\");\ngoog.object.extend=function(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<goog.object.PROTOTYPE_FIELDS_.length;f++)c=goog.object.PROTOTYPE_FIELDS_[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};\ngoog.object.create=function(a){var b=arguments.length;if(1==b&&goog.isArray(arguments[0]))return goog.object.create.apply(null,arguments[0]);if(b%2)throw Error(\"Uneven number of arguments\");for(var c={},d=0;d<b;d+=2)c[arguments[d]]=arguments[d+1];return c};goog.object.createSet=function(a){var b=arguments.length;if(1==b&&goog.isArray(arguments[0]))return goog.object.createSet.apply(null,arguments[0]);for(var c={},d=0;d<b;d++)c[arguments[d]]=!0;return c};goog.array={};goog.NATIVE_ARRAY_PROTOTYPES=!0;goog.array.peek=function(a){return a[a.length-1]};goog.array.ARRAY_PROTOTYPE_=Array.prototype;\ngoog.array.indexOf=goog.NATIVE_ARRAY_PROTOTYPES&&goog.array.ARRAY_PROTOTYPE_.indexOf?function(a,b,c){goog.asserts.assert(null!=a.length);return goog.array.ARRAY_PROTOTYPE_.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(goog.isString(a))return!goog.isString(b)||1!=b.length?-1:a.indexOf(b,c);for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1};\ngoog.array.lastIndexOf=goog.NATIVE_ARRAY_PROTOTYPES&&goog.array.ARRAY_PROTOTYPE_.lastIndexOf?function(a,b,c){goog.asserts.assert(null!=a.length);return goog.array.ARRAY_PROTOTYPE_.lastIndexOf.call(a,b,null==c?a.length-1:c)}:function(a,b,c){c=null==c?a.length-1:c;0>c&&(c=Math.max(0,a.length+c));if(goog.isString(a))return!goog.isString(b)||1!=b.length?-1:a.lastIndexOf(b,c);for(;0<=c;c--)if(c in a&&a[c]===b)return c;return-1};\ngoog.array.forEach=goog.NATIVE_ARRAY_PROTOTYPES&&goog.array.ARRAY_PROTOTYPE_.forEach?function(a,b,c){goog.asserts.assert(null!=a.length);goog.array.ARRAY_PROTOTYPE_.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(\"\"):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)};goog.array.forEachRight=function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(\"\"):a,d=d-1;0<=d;--d)d in e&&b.call(c,e[d],d,a)};\ngoog.array.filter=goog.NATIVE_ARRAY_PROTOTYPES&&goog.array.ARRAY_PROTOTYPE_.filter?function(a,b,c){goog.asserts.assert(null!=a.length);return goog.array.ARRAY_PROTOTYPE_.filter.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,g=goog.isString(a)?a.split(\"\"):a,h=0;h<d;h++)if(h in g){var i=g[h];b.call(c,i,h,a)&&(e[f++]=i)}return e};\ngoog.array.map=goog.NATIVE_ARRAY_PROTOTYPES&&goog.array.ARRAY_PROTOTYPE_.map?function(a,b,c){goog.asserts.assert(null!=a.length);return goog.array.ARRAY_PROTOTYPE_.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=goog.isString(a)?a.split(\"\"):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e};goog.array.reduce=function(a,b,c,d){if(a.reduce)return d?a.reduce(goog.bind(b,d),c):a.reduce(b,c);var e=c;goog.array.forEach(a,function(c,g){e=b.call(d,e,c,g,a)});return e};\ngoog.array.reduceRight=function(a,b,c,d){if(a.reduceRight)return d?a.reduceRight(goog.bind(b,d),c):a.reduceRight(b,c);var e=c;goog.array.forEachRight(a,function(c,g){e=b.call(d,e,c,g,a)});return e};\ngoog.array.some=goog.NATIVE_ARRAY_PROTOTYPES&&goog.array.ARRAY_PROTOTYPE_.some?function(a,b,c){goog.asserts.assert(null!=a.length);return goog.array.ARRAY_PROTOTYPE_.some.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(\"\"):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return!0;return!1};\ngoog.array.every=goog.NATIVE_ARRAY_PROTOTYPES&&goog.array.ARRAY_PROTOTYPE_.every?function(a,b,c){goog.asserts.assert(null!=a.length);return goog.array.ARRAY_PROTOTYPE_.every.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(\"\"):a,f=0;f<d;f++)if(f in e&&!b.call(c,e[f],f,a))return!1;return!0};goog.array.find=function(a,b,c){b=goog.array.findIndex(a,b,c);return 0>b?null:goog.isString(a)?a.charAt(b):a[b]};\ngoog.array.findIndex=function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(\"\"):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return f;return-1};goog.array.findRight=function(a,b,c){b=goog.array.findIndexRight(a,b,c);return 0>b?null:goog.isString(a)?a.charAt(b):a[b]};goog.array.findIndexRight=function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(\"\"):a,d=d-1;0<=d;d--)if(d in e&&b.call(c,e[d],d,a))return d;return-1};goog.array.contains=function(a,b){return 0<=goog.array.indexOf(a,b)};\ngoog.array.isEmpty=function(a){return 0==a.length};goog.array.clear=function(a){if(!goog.isArray(a))for(var b=a.length-1;0<=b;b--)delete a[b];a.length=0};goog.array.insert=function(a,b){goog.array.contains(a,b)||a.push(b)};goog.array.insertAt=function(a,b,c){goog.array.splice(a,c,0,b)};goog.array.insertArrayAt=function(a,b,c){goog.partial(goog.array.splice,a,c,0).apply(null,b)};\ngoog.array.insertBefore=function(a,b,c){var d;2==arguments.length||0>(d=goog.array.indexOf(a,c))?a.push(b):goog.array.insertAt(a,b,d)};goog.array.remove=function(a,b){var c=goog.array.indexOf(a,b),d;(d=0<=c)&&goog.array.removeAt(a,c);return d};goog.array.removeAt=function(a,b){goog.asserts.assert(null!=a.length);return 1==goog.array.ARRAY_PROTOTYPE_.splice.call(a,b,1).length};goog.array.removeIf=function(a,b,c){b=goog.array.findIndex(a,b,c);return 0<=b?(goog.array.removeAt(a,b),!0):!1};\ngoog.array.concat=function(a){return goog.array.ARRAY_PROTOTYPE_.concat.apply(goog.array.ARRAY_PROTOTYPE_,arguments)};goog.array.clone=function(a){if(goog.isArray(a))return goog.array.concat(a);for(var b=[],c=0,d=a.length;c<d;c++)b[c]=a[c];return b};goog.array.toArray=function(a){return goog.isArray(a)?goog.array.concat(a):goog.array.clone(a)};\ngoog.array.extend=function(a,b){for(var c=1;c<arguments.length;c++){var d=arguments[c],e;if(goog.isArray(d)||(e=goog.isArrayLike(d))&&d.hasOwnProperty(\"callee\"))a.push.apply(a,d);else if(e)for(var f=a.length,g=d.length,h=0;h<g;h++)a[f+h]=d[h];else a.push(d)}};goog.array.splice=function(a,b,c,d){goog.asserts.assert(null!=a.length);return goog.array.ARRAY_PROTOTYPE_.splice.apply(a,goog.array.slice(arguments,1))};\ngoog.array.slice=function(a,b,c){goog.asserts.assert(null!=a.length);return 2>=arguments.length?goog.array.ARRAY_PROTOTYPE_.slice.call(a,b):goog.array.ARRAY_PROTOTYPE_.slice.call(a,b,c)};goog.array.removeDuplicates=function(a,b){for(var c=b||a,d={},e=0,f=0;f<a.length;){var g=a[f++],h=goog.isObject(g)?\"o\"+goog.getUid(g):(typeof g).charAt(0)+g;Object.prototype.hasOwnProperty.call(d,h)||(d[h]=!0,c[e++]=g)}c.length=e};\ngoog.array.binarySearch=function(a,b,c){return goog.array.binarySearch_(a,c||goog.array.defaultCompare,!1,b)};goog.array.binarySelect=function(a,b,c){return goog.array.binarySearch_(a,b,!0,void 0,c)};goog.array.binarySearch_=function(a,b,c,d,e){for(var f=0,g=a.length,h;f<g;){var i=f+g>>1,j;j=c?b.call(e,a[i],i,a):b(d,a[i]);0<j?f=i+1:(g=i,h=!j)}return h?f:~f};goog.array.sort=function(a,b){goog.asserts.assert(null!=a.length);goog.array.ARRAY_PROTOTYPE_.sort.call(a,b||goog.array.defaultCompare)};\ngoog.array.stableSort=function(a,b){for(var c=0;c<a.length;c++)a[c]={index:c,value:a[c]};var d=b||goog.array.defaultCompare;goog.array.sort(a,function(a,b){return d(a.value,b.value)||a.index-b.index});for(c=0;c<a.length;c++)a[c]=a[c].value};goog.array.sortObjectsByKey=function(a,b,c){var d=c||goog.array.defaultCompare;goog.array.sort(a,function(a,c){return d(a[b],c[b])})};\ngoog.array.isSorted=function(a,b,c){for(var b=b||goog.array.defaultCompare,d=1;d<a.length;d++){var e=b(a[d-1],a[d]);if(0<e||0==e&&c)return!1}return!0};goog.array.equals=function(a,b,c){if(!goog.isArrayLike(a)||!goog.isArrayLike(b)||a.length!=b.length)return!1;for(var d=a.length,c=c||goog.array.defaultCompareEquality,e=0;e<d;e++)if(!c(a[e],b[e]))return!1;return!0};goog.array.compare=function(a,b,c){return goog.array.equals(a,b,c)};\ngoog.array.compare3=function(a,b,c){for(var c=c||goog.array.defaultCompare,d=Math.min(a.length,b.length),e=0;e<d;e++){var f=c(a[e],b[e]);if(0!=f)return f}return goog.array.defaultCompare(a.length,b.length)};goog.array.defaultCompare=function(a,b){return a>b?1:a<b?-1:0};goog.array.defaultCompareEquality=function(a,b){return a===b};goog.array.binaryInsert=function(a,b,c){c=goog.array.binarySearch(a,b,c);return 0>c?(goog.array.insertAt(a,b,-(c+1)),!0):!1};\ngoog.array.binaryRemove=function(a,b,c){b=goog.array.binarySearch(a,b,c);return 0<=b?goog.array.removeAt(a,b):!1};goog.array.bucket=function(a,b){for(var c={},d=0;d<a.length;d++){var e=a[d],f=b(e,d,a);goog.isDef(f)&&(c[f]||(c[f]=[])).push(e)}return c};goog.array.repeat=function(a,b){for(var c=[],d=0;d<b;d++)c[d]=a;return c};goog.array.flatten=function(a){for(var b=[],c=0;c<arguments.length;c++){var d=arguments[c];goog.isArray(d)?b.push.apply(b,goog.array.flatten.apply(null,d)):b.push(d)}return b};\ngoog.array.rotate=function(a,b){goog.asserts.assert(null!=a.length);a.length&&(b%=a.length,0<b?goog.array.ARRAY_PROTOTYPE_.unshift.apply(a,a.splice(-b,b)):0>b&&goog.array.ARRAY_PROTOTYPE_.push.apply(a,a.splice(0,-b)));return a};goog.array.zip=function(a){if(!arguments.length)return[];for(var b=[],c=0;;c++){for(var d=[],e=0;e<arguments.length;e++){var f=arguments[e];if(c>=f.length)return b;d.push(f[c])}b.push(d)}};\ngoog.array.shuffle=function(a,b){for(var c=b||Math.random,d=a.length-1;0<d;d--){var e=Math.floor(c()*(d+1)),f=a[d];a[d]=a[e];a[e]=f}};goog.proto2.Descriptor=function(a,b,c){this.messageType_=a;this.name_=b.name||null;this.fullName_=b.fullName||null;this.containingType_=b.containingType;this.fields_={};for(a=0;a<c.length;a++)b=c[a],this.fields_[b.getTag()]=b};goog.proto2.Descriptor.prototype.getName=function(){return this.name_};goog.proto2.Descriptor.prototype.getFullName=function(){return this.fullName_};goog.proto2.Descriptor.prototype.getContainingType=function(){return!this.containingType_?null:this.containingType_.getDescriptor()};\ngoog.proto2.Descriptor.prototype.getFields=function(){var a=goog.object.getValues(this.fields_);goog.array.sort(a,function(a,c){return a.getTag()-c.getTag()});return a};goog.proto2.Descriptor.prototype.getFieldsMap=function(){return this.fields_};goog.proto2.Descriptor.prototype.findFieldByName=function(a){return goog.object.findValue(this.fields_,function(b){return b.getName()==a})||null};\ngoog.proto2.Descriptor.prototype.findFieldByTag=function(a){goog.proto2.Util.assert(goog.string.isNumeric(a));return this.fields_[parseInt(a,10)]||null};goog.proto2.Descriptor.prototype.createMessageInstance=function(){return new this.messageType_};goog.proto2.Message=function(){this.values_={};this.descriptor_=this.constructor.descriptor_;this.fields_=this.descriptor_.getFieldsMap();this.deserializedFields_=this.lazyDeserializer_=null};goog.proto2.Message.FieldType={DOUBLE:1,FLOAT:2,INT64:3,UINT64:4,INT32:5,FIXED64:6,FIXED32:7,BOOL:8,STRING:9,GROUP:10,MESSAGE:11,BYTES:12,UINT32:13,ENUM:14,SFIXED32:15,SFIXED64:16,SINT32:17,SINT64:18};\ngoog.proto2.Message.prototype.initializeForLazyDeserializer=function(a,b){this.lazyDeserializer_=a;this.values_=b;this.deserializedFields_={}};goog.proto2.Message.prototype.setUnknown=function(a,b){goog.proto2.Util.assert(!this.fields_[a],\"Field is not unknown in this message\");goog.proto2.Util.assert(1<=a,\"Tag is not valid\");goog.proto2.Util.assert(null!==b,\"Value cannot be null\");this.values_[a]=b;this.deserializedFields_&&delete this.deserializedFields_[a]};\ngoog.proto2.Message.prototype.forEachUnknown=function(a,b){var c=b||this,d;for(d in this.values_)this.fields_[d]||a.call(c,Number(d),this.values_[d])};goog.proto2.Message.prototype.getDescriptor=function(){return this.descriptor_};goog.proto2.Message.prototype.has=function(a){goog.proto2.Util.assert(a.getContainingType()==this.descriptor_,\"The current message does not contain the given field\");return this.has$Value(a.getTag())};\ngoog.proto2.Message.prototype.arrayOf=function(a){goog.proto2.Util.assert(a.getContainingType()==this.descriptor_,\"The current message does not contain the given field\");return this.array$Values(a.getTag())};goog.proto2.Message.prototype.countOf=function(a){goog.proto2.Util.assert(a.getContainingType()==this.descriptor_,\"The current message does not contain the given field\");return this.count$Values(a.getTag())};\ngoog.proto2.Message.prototype.get=function(a,b){goog.proto2.Util.assert(a.getContainingType()==this.descriptor_,\"The current message does not contain the given field\");return this.get$Value(a.getTag(),b)};goog.proto2.Message.prototype.getOrDefault=function(a,b){goog.proto2.Util.assert(a.getContainingType()==this.descriptor_,\"The current message does not contain the given field\");return this.get$ValueOrDefault(a.getTag(),b)};\ngoog.proto2.Message.prototype.set=function(a,b){goog.proto2.Util.assert(a.getContainingType()==this.descriptor_,\"The current message does not contain the given field\");this.set$Value(a.getTag(),b)};goog.proto2.Message.prototype.add=function(a,b){goog.proto2.Util.assert(a.getContainingType()==this.descriptor_,\"The current message does not contain the given field\");this.add$Value(a.getTag(),b)};\ngoog.proto2.Message.prototype.clear=function(a){goog.proto2.Util.assert(a.getContainingType()==this.descriptor_,\"The current message does not contain the given field\");this.clear$Field(a.getTag())};\ngoog.proto2.Message.prototype.equals=function(a){if(!a||this.constructor!=a.constructor)return!1;for(var b=this.getDescriptor().getFields(),c=0;c<b.length;c++){var d=b[c];if(this.has(d)!=a.has(d))return!1;if(this.has(d)){var e=d.isCompositeType(),f=this.getValueForField_(d),g=a.getValueForField_(d);if(d.isRepeated()){if(f.length!=g.length)return!1;for(d=0;d<f.length;d++)if(!(e?f[d].equals(g[d]):f[d]==g[d]))return!1}else if(!(e?f.equals(g):f==g))return!1}}return!0};\ngoog.proto2.Message.prototype.copyFrom=function(a){goog.proto2.Util.assert(this.constructor==a.constructor,\"The source message must have the same type.\");this.values_={};this.deserializedFields_&&(this.deserializedFields_={});this.mergeFrom(a)};\ngoog.proto2.Message.prototype.mergeFrom=function(a){goog.proto2.Util.assert(this.constructor==a.constructor,\"The source message must have the same type.\");for(var b=this.getDescriptor().getFields(),c=0;c<b.length;c++){var d=b[c];if(a.has(d)){this.deserializedFields_&&delete this.deserializedFields_[d.getTag()];var e=d.isCompositeType();if(d.isRepeated())for(var f=a.arrayOf(d),g=0;g<f.length;g++)this.add(d,e?f[g].clone():f[g]);else f=a.getValueForField_(d),e?(e=this.getValueForField_(d))?e.mergeFrom(f):\nthis.set(d,f.clone()):this.set(d,f)}}};goog.proto2.Message.prototype.clone=function(){var a=new this.constructor;a.copyFrom(this);return a};goog.proto2.Message.prototype.initDefaults=function(a){for(var b=this.getDescriptor().getFields(),c=0;c<b.length;c++){var d=b[c],e=d.getTag(),f=d.isCompositeType();!this.has(d)&&!d.isRepeated()&&(f?this.values_[e]=new (d.getNativeType()):a&&(this.values_[e]=d.getDefaultValue()));if(f)if(d.isRepeated()){d=this.array$Values(e);for(e=0;e<d.length;e++)d[e].initDefaults(a)}else this.get$Value(e).initDefaults(a)}};\ngoog.proto2.Message.prototype.getFieldByTag_=function(a){goog.proto2.Util.assert(this.fields_[a],\"No field found for the given tag\");return this.fields_[a]};goog.proto2.Message.prototype.has$Value=function(a){goog.proto2.Util.assert(this.fields_[a],\"No field found for the given tag\");return a in this.values_&&goog.isDef(this.values_[a])&&null!==this.values_[a]};\ngoog.proto2.Message.prototype.getValueForField_=function(a){var b=a.getTag();if(!b in this.values_)return null;var c=this.values_[b];return null==c?null:this.lazyDeserializer_?!(b in this.deserializedFields_)?(a=this.lazyDeserializer_.deserializeField(this,a,c),this.deserializedFields_[b]=a):this.deserializedFields_[b]:c};\ngoog.proto2.Message.prototype.get$Value=function(a,b){var c=this.getFieldByTag_(a),d=this.getValueForField_(c);if(c.isRepeated())return goog.proto2.Util.assert(goog.isArray(d)),c=b||0,goog.proto2.Util.assert(0<=c&&c<d.length,\"Given index is out of bounds\"),d[c];goog.proto2.Util.assert(!goog.isArray(d));return d};goog.proto2.Message.prototype.get$ValueOrDefault=function(a,b){return!this.has$Value(a)?this.getFieldByTag_(a).getDefaultValue():this.get$Value(a,b)};\ngoog.proto2.Message.prototype.array$Values=function(a){goog.proto2.Util.assert(this.getFieldByTag_(a).isRepeated(),\"Cannot call fieldArray on a non-repeated field\");a=this.getValueForField_(this.getFieldByTag_(a));goog.proto2.Util.assert(null==a||goog.isArray(a));return a||[]};\ngoog.proto2.Message.prototype.count$Values=function(a){return this.getFieldByTag_(a).isRepeated()?(this.has$Value(a)&&goog.proto2.Util.assert(goog.isArray(this.values_[a])),this.has$Value(a)?this.values_[a].length:0):this.has$Value(a)?1:0};\ngoog.proto2.Message.prototype.set$Value=function(a,b){if(goog.proto2.Util.conductChecks()){var c=this.getFieldByTag_(a);goog.proto2.Util.assert(!c.isRepeated(),\"Cannot call set on a repeated field\");this.checkFieldType_(c,b)}this.values_[a]=b;this.deserializedFields_&&(this.deserializedFields_[a]=b)};\ngoog.proto2.Message.prototype.add$Value=function(a,b){if(goog.proto2.Util.conductChecks()){var c=this.getFieldByTag_(a);goog.proto2.Util.assert(c.isRepeated(),\"Cannot call add on a non-repeated field\");this.checkFieldType_(c,b)}this.values_[a]||(this.values_[a]=[]);this.values_[a].push(b);this.deserializedFields_&&delete this.deserializedFields_[a]};\ngoog.proto2.Message.prototype.checkFieldType_=function(a,b){goog.proto2.Util.assert(null!==b);var c=a.getNativeType();c===String?goog.proto2.Util.assert(\"string\"===typeof b,\"Expected value of type string\"):c===Boolean?goog.proto2.Util.assert(\"boolean\"===typeof b,\"Expected value of type boolean\"):c===Number?goog.proto2.Util.assert(\"number\"===typeof b,\"Expected value of type number\"):a.getFieldType()==goog.proto2.FieldDescriptor.FieldType.ENUM?goog.proto2.Util.assert(\"number\"===typeof b,\"Expected an enum value, which is a number\"):\ngoog.proto2.Util.assert(b instanceof c,\"Expected a matching message type\")};goog.proto2.Message.prototype.clear$Field=function(a){goog.proto2.Util.assert(this.getFieldByTag_(a),\"Unknown field\");delete this.values_[a];this.deserializedFields_&&delete this.deserializedFields_[a]};\ngoog.proto2.Message.set$Metadata=function(a,b){var c=[],d,e;for(e in b)b.hasOwnProperty(e)&&(goog.proto2.Util.assert(goog.string.isNumeric(e),\"Keys must be numeric\"),0==e?d=b[0]:c.push(new goog.proto2.FieldDescriptor(a,e,b[e])));goog.proto2.Util.assert(d);a.descriptor_=new goog.proto2.Descriptor(a,d,c);a.getDescriptor=function(){return a.descriptor_}};/*\n\n Protocol Buffer 2 Copyright 2008 Google Inc.\n All other code copyright its respective owners.\n Copyright (C) 2010 The Libphonenumber Authors\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\nvar i18n= exports.i18n ={phonenumbers:{}};i18n.phonenumbers.NumberFormat=function(){goog.proto2.Message.apply(this)};goog.inherits(i18n.phonenumbers.NumberFormat,goog.proto2.Message);i18n.phonenumbers.NumberFormat.prototype.getPattern=function(){return this.get$Value(1)};i18n.phonenumbers.NumberFormat.prototype.getPatternOrDefault=function(){return this.get$ValueOrDefault(1)};i18n.phonenumbers.NumberFormat.prototype.setPattern=function(a){this.set$Value(1,a)};\ni18n.phonenumbers.NumberFormat.prototype.hasPattern=function(){return this.has$Value(1)};i18n.phonenumbers.NumberFormat.prototype.patternCount=function(){return this.count$Values(1)};i18n.phonenumbers.NumberFormat.prototype.clearPattern=function(){this.clear$Field(1)};i18n.phonenumbers.NumberFormat.prototype.getFormat=function(){return this.get$Value(2)};i18n.phonenumbers.NumberFormat.prototype.getFormatOrDefault=function(){return this.get$ValueOrDefault(2)};\ni18n.phonenumbers.NumberFormat.prototype.setFormat=function(a){this.set$Value(2,a)};i18n.phonenumbers.NumberFormat.prototype.hasFormat=function(){return this.has$Value(2)};i18n.phonenumbers.NumberFormat.prototype.formatCount=function(){return this.count$Values(2)};i18n.phonenumbers.NumberFormat.prototype.clearFormat=function(){this.clear$Field(2)};i18n.phonenumbers.NumberFormat.prototype.getLeadingDigitsPattern=function(a){return this.get$Value(3,a)};\ni18n.phonenumbers.NumberFormat.prototype.getLeadingDigitsPatternOrDefault=function(a){return this.get$ValueOrDefault(3,a)};i18n.phonenumbers.NumberFormat.prototype.addLeadingDigitsPattern=function(a){this.add$Value(3,a)};i18n.phonenumbers.NumberFormat.prototype.leadingDigitsPatternArray=function(){return this.array$Values(3)};i18n.phonenumbers.NumberFormat.prototype.hasLeadingDigitsPattern=function(){return this.has$Value(3)};i18n.phonenumbers.NumberFormat.prototype.leadingDigitsPatternCount=function(){return this.count$Values(3)};\ni18n.phonenumbers.NumberFormat.prototype.clearLeadingDigitsPattern=function(){this.clear$Field(3)};i18n.phonenumbers.NumberFormat.prototype.getNationalPrefixFormattingRule=function(){return this.get$Value(4)};i18n.phonenumbers.NumberFormat.prototype.getNationalPrefixFormattingRuleOrDefault=function(){return this.get$ValueOrDefault(4)};i18n.phonenumbers.NumberFormat.prototype.setNationalPrefixFormattingRule=function(a){this.set$Value(4,a)};\ni18n.phonenumbers.NumberFormat.prototype.hasNationalPrefixFormattingRule=function(){return this.has$Value(4)};i18n.phonenumbers.NumberFormat.prototype.nationalPrefixFormattingRuleCount=function(){return this.count$Values(4)};i18n.phonenumbers.NumberFormat.prototype.clearNationalPrefixFormattingRule=function(){this.clear$Field(4)};i18n.phonenumbers.NumberFormat.prototype.getNationalPrefixOptionalWhenFormatting=function(){return this.get$Value(6)};\ni18n.phonenumbers.NumberFormat.prototype.getNationalPrefixOptionalWhenFormattingOrDefault=function(){return this.get$ValueOrDefault(6)};i18n.phonenumbers.NumberFormat.prototype.setNationalPrefixOptionalWhenFormatting=function(a){this.set$Value(6,a)};i18n.phonenumbers.NumberFormat.prototype.hasNationalPrefixOptionalWhenFormatting=function(){return this.has$Value(6)};i18n.phonenumbers.NumberFormat.prototype.nationalPrefixOptionalWhenFormattingCount=function(){return this.count$Values(6)};\ni18n.phonenumbers.NumberFormat.prototype.clearNationalPrefixOptionalWhenFormatting=function(){this.clear$Field(6)};i18n.phonenumbers.NumberFormat.prototype.getDomesticCarrierCodeFormattingRule=function(){return this.get$Value(5)};i18n.phonenumbers.NumberFormat.prototype.getDomesticCarrierCodeFormattingRuleOrDefault=function(){return this.get$ValueOrDefault(5)};i18n.phonenumbers.NumberFormat.prototype.setDomesticCarrierCodeFormattingRule=function(a){this.set$Value(5,a)};\ni18n.phonenumbers.NumberFormat.prototype.hasDomesticCarrierCodeFormattingRule=function(){return this.has$Value(5)};i18n.phonenumbers.NumberFormat.prototype.domesticCarrierCodeFormattingRuleCount=function(){return this.count$Values(5)};i18n.phonenumbers.NumberFormat.prototype.clearDomesticCarrierCodeFormattingRule=function(){this.clear$Field(5)};i18n.phonenumbers.PhoneNumberDesc=function(){goog.proto2.Message.apply(this)};goog.inherits(i18n.phonenumbers.PhoneNumberDesc,goog.proto2.Message);\ni18n.phonenumbers.PhoneNumberDesc.prototype.getNationalNumberPattern=function(){return this.get$Value(2)};i18n.phonenumbers.PhoneNumberDesc.prototype.getNationalNumberPatternOrDefault=function(){return this.get$ValueOrDefault(2)};i18n.phonenumbers.PhoneNumberDesc.prototype.setNationalNumberPattern=function(a){this.set$Value(2,a)};i18n.phonenumbers.PhoneNumberDesc.prototype.hasNationalNumberPattern=function(){return this.has$Value(2)};\ni18n.phonenumbers.PhoneNumberDesc.prototype.nationalNumberPatternCount=function(){return this.count$Values(2)};i18n.phonenumbers.PhoneNumberDesc.prototype.clearNationalNumberPattern=function(){this.clear$Field(2)};i18n.phonenumbers.PhoneNumberDesc.prototype.getPossibleNumberPattern=function(){return this.get$Value(3)};i18n.phonenumbers.PhoneNumberDesc.prototype.getPossibleNumberPatternOrDefault=function(){return this.get$ValueOrDefault(3)};\ni18n.phonenumbers.PhoneNumberDesc.prototype.setPossibleNumberPattern=function(a){this.set$Value(3,a)};i18n.phonenumbers.PhoneNumberDesc.prototype.hasPossibleNumberPattern=function(){return this.has$Value(3)};i18n.phonenumbers.PhoneNumberDesc.prototype.possibleNumberPatternCount=function(){return this.count$Values(3)};i18n.phonenumbers.PhoneNumberDesc.prototype.clearPossibleNumberPattern=function(){this.clear$Field(3)};i18n.phonenumbers.PhoneNumberDesc.prototype.getExampleNumber=function(){return this.get$Value(6)};\ni18n.phonenumbers.PhoneNumberDesc.prototype.getExampleNumberOrDefault=function(){return this.get$ValueOrDefault(6)};i18n.phonenumbers.PhoneNumberDesc.prototype.setExampleNumber=function(a){this.set$Value(6,a)};i18n.phonenumbers.PhoneNumberDesc.prototype.hasExampleNumber=function(){return this.has$Value(6)};i18n.phonenumbers.PhoneNumberDesc.prototype.exampleNumberCount=function(){return this.count$Values(6)};i18n.phonenumbers.PhoneNumberDesc.prototype.clearExampleNumber=function(){this.clear$Field(6)};\ni18n.phonenumbers.PhoneMetadata=function(){goog.proto2.Message.apply(this)};goog.inherits(i18n.phonenumbers.PhoneMetadata,goog.proto2.Message);i18n.phonenumbers.PhoneMetadata.prototype.getGeneralDesc=function(){return this.get$Value(1)};i18n.phonenumbers.PhoneMetadata.prototype.getGeneralDescOrDefault=function(){return this.get$ValueOrDefault(1)};i18n.phonenumbers.PhoneMetadata.prototype.setGeneralDesc=function(a){this.set$Value(1,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasGeneralDesc=function(){return this.has$Value(1)};\ni18n.phonenumbers.PhoneMetadata.prototype.generalDescCount=function(){return this.count$Values(1)};i18n.phonenumbers.PhoneMetadata.prototype.clearGeneralDesc=function(){this.clear$Field(1)};i18n.phonenumbers.PhoneMetadata.prototype.getFixedLine=function(){return this.get$Value(2)};i18n.phonenumbers.PhoneMetadata.prototype.getFixedLineOrDefault=function(){return this.get$ValueOrDefault(2)};i18n.phonenumbers.PhoneMetadata.prototype.setFixedLine=function(a){this.set$Value(2,a)};\ni18n.phonenumbers.PhoneMetadata.prototype.hasFixedLine=function(){return this.has$Value(2)};i18n.phonenumbers.PhoneMetadata.prototype.fixedLineCount=function(){return this.count$Values(2)};i18n.phonenumbers.PhoneMetadata.prototype.clearFixedLine=function(){this.clear$Field(2)};i18n.phonenumbers.PhoneMetadata.prototype.getMobile=function(){return this.get$Value(3)};i18n.phonenumbers.PhoneMetadata.prototype.getMobileOrDefault=function(){return this.get$ValueOrDefault(3)};\ni18n.phonenumbers.PhoneMetadata.prototype.setMobile=function(a){this.set$Value(3,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasMobile=function(){return this.has$Value(3)};i18n.phonenumbers.PhoneMetadata.prototype.mobileCount=function(){return this.count$Values(3)};i18n.phonenumbers.PhoneMetadata.prototype.clearMobile=function(){this.clear$Field(3)};i18n.phonenumbers.PhoneMetadata.prototype.getTollFree=function(){return this.get$Value(4)};\ni18n.phonenumbers.PhoneMetadata.prototype.getTollFreeOrDefault=function(){return this.get$ValueOrDefault(4)};i18n.phonenumbers.PhoneMetadata.prototype.setTollFree=function(a){this.set$Value(4,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasTollFree=function(){return this.has$Value(4)};i18n.phonenumbers.PhoneMetadata.prototype.tollFreeCount=function(){return this.count$Values(4)};i18n.phonenumbers.PhoneMetadata.prototype.clearTollFree=function(){this.clear$Field(4)};\ni18n.phonenumbers.PhoneMetadata.prototype.getPremiumRate=function(){return this.get$Value(5)};i18n.phonenumbers.PhoneMetadata.prototype.getPremiumRateOrDefault=function(){return this.get$ValueOrDefault(5)};i18n.phonenumbers.PhoneMetadata.prototype.setPremiumRate=function(a){this.set$Value(5,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasPremiumRate=function(){return this.has$Value(5)};i18n.phonenumbers.PhoneMetadata.prototype.premiumRateCount=function(){return this.count$Values(5)};\ni18n.phonenumbers.PhoneMetadata.prototype.clearPremiumRate=function(){this.clear$Field(5)};i18n.phonenumbers.PhoneMetadata.prototype.getSharedCost=function(){return this.get$Value(6)};i18n.phonenumbers.PhoneMetadata.prototype.getSharedCostOrDefault=function(){return this.get$ValueOrDefault(6)};i18n.phonenumbers.PhoneMetadata.prototype.setSharedCost=function(a){this.set$Value(6,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasSharedCost=function(){return this.has$Value(6)};\ni18n.phonenumbers.PhoneMetadata.prototype.sharedCostCount=function(){return this.count$Values(6)};i18n.phonenumbers.PhoneMetadata.prototype.clearSharedCost=function(){this.clear$Field(6)};i18n.phonenumbers.PhoneMetadata.prototype.getPersonalNumber=function(){return this.get$Value(7)};i18n.phonenumbers.PhoneMetadata.prototype.getPersonalNumberOrDefault=function(){return this.get$ValueOrDefault(7)};i18n.phonenumbers.PhoneMetadata.prototype.setPersonalNumber=function(a){this.set$Value(7,a)};\ni18n.phonenumbers.PhoneMetadata.prototype.hasPersonalNumber=function(){return this.has$Value(7)};i18n.phonenumbers.PhoneMetadata.prototype.personalNumberCount=function(){return this.count$Values(7)};i18n.phonenumbers.PhoneMetadata.prototype.clearPersonalNumber=function(){this.clear$Field(7)};i18n.phonenumbers.PhoneMetadata.prototype.getVoip=function(){return this.get$Value(8)};i18n.phonenumbers.PhoneMetadata.prototype.getVoipOrDefault=function(){return this.get$ValueOrDefault(8)};\ni18n.phonenumbers.PhoneMetadata.prototype.setVoip=function(a){this.set$Value(8,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasVoip=function(){return this.has$Value(8)};i18n.phonenumbers.PhoneMetadata.prototype.voipCount=function(){return this.count$Values(8)};i18n.phonenumbers.PhoneMetadata.prototype.clearVoip=function(){this.clear$Field(8)};i18n.phonenumbers.PhoneMetadata.prototype.getPager=function(){return this.get$Value(21)};i18n.phonenumbers.PhoneMetadata.prototype.getPagerOrDefault=function(){return this.get$ValueOrDefault(21)};\ni18n.phonenumbers.PhoneMetadata.prototype.setPager=function(a){this.set$Value(21,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasPager=function(){return this.has$Value(21)};i18n.phonenumbers.PhoneMetadata.prototype.pagerCount=function(){return this.count$Values(21)};i18n.phonenumbers.PhoneMetadata.prototype.clearPager=function(){this.clear$Field(21)};i18n.phonenumbers.PhoneMetadata.prototype.getUan=function(){return this.get$Value(25)};i18n.phonenumbers.PhoneMetadata.prototype.getUanOrDefault=function(){return this.get$ValueOrDefault(25)};\ni18n.phonenumbers.PhoneMetadata.prototype.setUan=function(a){this.set$Value(25,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasUan=function(){return this.has$Value(25)};i18n.phonenumbers.PhoneMetadata.prototype.uanCount=function(){return this.count$Values(25)};i18n.phonenumbers.PhoneMetadata.prototype.clearUan=function(){this.clear$Field(25)};i18n.phonenumbers.PhoneMetadata.prototype.getEmergency=function(){return this.get$Value(27)};\ni18n.phonenumbers.PhoneMetadata.prototype.getEmergencyOrDefault=function(){return this.get$ValueOrDefault(27)};i18n.phonenumbers.PhoneMetadata.prototype.setEmergency=function(a){this.set$Value(27,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasEmergency=function(){return this.has$Value(27)};i18n.phonenumbers.PhoneMetadata.prototype.emergencyCount=function(){return this.count$Values(27)};i18n.phonenumbers.PhoneMetadata.prototype.clearEmergency=function(){this.clear$Field(27)};\ni18n.phonenumbers.PhoneMetadata.prototype.getVoicemail=function(){return this.get$Value(28)};i18n.phonenumbers.PhoneMetadata.prototype.getVoicemailOrDefault=function(){return this.get$ValueOrDefault(28)};i18n.phonenumbers.PhoneMetadata.prototype.setVoicemail=function(a){this.set$Value(28,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasVoicemail=function(){return this.has$Value(28)};i18n.phonenumbers.PhoneMetadata.prototype.voicemailCount=function(){return this.count$Values(28)};\ni18n.phonenumbers.PhoneMetadata.prototype.clearVoicemail=function(){this.clear$Field(28)};i18n.phonenumbers.PhoneMetadata.prototype.getNoInternationalDialling=function(){return this.get$Value(24)};i18n.phonenumbers.PhoneMetadata.prototype.getNoInternationalDiallingOrDefault=function(){return this.get$ValueOrDefault(24)};i18n.phonenumbers.PhoneMetadata.prototype.setNoInternationalDialling=function(a){this.set$Value(24,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasNoInternationalDialling=function(){return this.has$Value(24)};\ni18n.phonenumbers.PhoneMetadata.prototype.noInternationalDiallingCount=function(){return this.count$Values(24)};i18n.phonenumbers.PhoneMetadata.prototype.clearNoInternationalDialling=function(){this.clear$Field(24)};i18n.phonenumbers.PhoneMetadata.prototype.getId=function(){return this.get$Value(9)};i18n.phonenumbers.PhoneMetadata.prototype.getIdOrDefault=function(){return this.get$ValueOrDefault(9)};i18n.phonenumbers.PhoneMetadata.prototype.setId=function(a){this.set$Value(9,a)};\ni18n.phonenumbers.PhoneMetadata.prototype.hasId=function(){return this.has$Value(9)};i18n.phonenumbers.PhoneMetadata.prototype.idCount=function(){return this.count$Values(9)};i18n.phonenumbers.PhoneMetadata.prototype.clearId=function(){this.clear$Field(9)};i18n.phonenumbers.PhoneMetadata.prototype.getCountryCode=function(){return this.get$Value(10)};i18n.phonenumbers.PhoneMetadata.prototype.getCountryCodeOrDefault=function(){return this.get$ValueOrDefault(10)};\ni18n.phonenumbers.PhoneMetadata.prototype.setCountryCode=function(a){this.set$Value(10,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasCountryCode=function(){return this.has$Value(10)};i18n.phonenumbers.PhoneMetadata.prototype.countryCodeCount=function(){return this.count$Values(10)};i18n.phonenumbers.PhoneMetadata.prototype.clearCountryCode=function(){this.clear$Field(10)};i18n.phonenumbers.PhoneMetadata.prototype.getInternationalPrefix=function(){return this.get$Value(11)};\ni18n.phonenumbers.PhoneMetadata.prototype.getInternationalPrefixOrDefault=function(){return this.get$ValueOrDefault(11)};i18n.phonenumbers.PhoneMetadata.prototype.setInternationalPrefix=function(a){this.set$Value(11,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasInternationalPrefix=function(){return this.has$Value(11)};i18n.phonenumbers.PhoneMetadata.prototype.internationalPrefixCount=function(){return this.count$Values(11)};i18n.phonenumbers.PhoneMetadata.prototype.clearInternationalPrefix=function(){this.clear$Field(11)};\ni18n.phonenumbers.PhoneMetadata.prototype.getPreferredInternationalPrefix=function(){return this.get$Value(17)};i18n.phonenumbers.PhoneMetadata.prototype.getPreferredInternationalPrefixOrDefault=function(){return this.get$ValueOrDefault(17)};i18n.phonenumbers.PhoneMetadata.prototype.setPreferredInternationalPrefix=function(a){this.set$Value(17,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasPreferredInternationalPrefix=function(){return this.has$Value(17)};\ni18n.phonenumbers.PhoneMetadata.prototype.preferredInternationalPrefixCount=function(){return this.count$Values(17)};i18n.phonenumbers.PhoneMetadata.prototype.clearPreferredInternationalPrefix=function(){this.clear$Field(17)};i18n.phonenumbers.PhoneMetadata.prototype.getNationalPrefix=function(){return this.get$Value(12)};i18n.phonenumbers.PhoneMetadata.prototype.getNationalPrefixOrDefault=function(){return this.get$ValueOrDefault(12)};\ni18n.phonenumbers.PhoneMetadata.prototype.setNationalPrefix=function(a){this.set$Value(12,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasNationalPrefix=function(){return this.has$Value(12)};i18n.phonenumbers.PhoneMetadata.prototype.nationalPrefixCount=function(){return this.count$Values(12)};i18n.phonenumbers.PhoneMetadata.prototype.clearNationalPrefix=function(){this.clear$Field(12)};i18n.phonenumbers.PhoneMetadata.prototype.getPreferredExtnPrefix=function(){return this.get$Value(13)};\ni18n.phonenumbers.PhoneMetadata.prototype.getPreferredExtnPrefixOrDefault=function(){return this.get$ValueOrDefault(13)};i18n.phonenumbers.PhoneMetadata.prototype.setPreferredExtnPrefix=function(a){this.set$Value(13,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasPreferredExtnPrefix=function(){return this.has$Value(13)};i18n.phonenumbers.PhoneMetadata.prototype.preferredExtnPrefixCount=function(){return this.count$Values(13)};i18n.phonenumbers.PhoneMetadata.prototype.clearPreferredExtnPrefix=function(){this.clear$Field(13)};\ni18n.phonenumbers.PhoneMetadata.prototype.getNationalPrefixForParsing=function(){return this.get$Value(15)};i18n.phonenumbers.PhoneMetadata.prototype.getNationalPrefixForParsingOrDefault=function(){return this.get$ValueOrDefault(15)};i18n.phonenumbers.PhoneMetadata.prototype.setNationalPrefixForParsing=function(a){this.set$Value(15,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasNationalPrefixForParsing=function(){return this.has$Value(15)};\ni18n.phonenumbers.PhoneMetadata.prototype.nationalPrefixForParsingCount=function(){return this.count$Values(15)};i18n.phonenumbers.PhoneMetadata.prototype.clearNationalPrefixForParsing=function(){this.clear$Field(15)};i18n.phonenumbers.PhoneMetadata.prototype.getNationalPrefixTransformRule=function(){return this.get$Value(16)};i18n.phonenumbers.PhoneMetadata.prototype.getNationalPrefixTransformRuleOrDefault=function(){return this.get$ValueOrDefault(16)};\ni18n.phonenumbers.PhoneMetadata.prototype.setNationalPrefixTransformRule=function(a){this.set$Value(16,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasNationalPrefixTransformRule=function(){return this.has$Value(16)};i18n.phonenumbers.PhoneMetadata.prototype.nationalPrefixTransformRuleCount=function(){return this.count$Values(16)};i18n.phonenumbers.PhoneMetadata.prototype.clearNationalPrefixTransformRule=function(){this.clear$Field(16)};\ni18n.phonenumbers.PhoneMetadata.prototype.getSameMobileAndFixedLinePattern=function(){return this.get$Value(18)};i18n.phonenumbers.PhoneMetadata.prototype.getSameMobileAndFixedLinePatternOrDefault=function(){return this.get$ValueOrDefault(18)};i18n.phonenumbers.PhoneMetadata.prototype.setSameMobileAndFixedLinePattern=function(a){this.set$Value(18,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasSameMobileAndFixedLinePattern=function(){return this.has$Value(18)};\ni18n.phonenumbers.PhoneMetadata.prototype.sameMobileAndFixedLinePatternCount=function(){return this.count$Values(18)};i18n.phonenumbers.PhoneMetadata.prototype.clearSameMobileAndFixedLinePattern=function(){this.clear$Field(18)};i18n.phonenumbers.PhoneMetadata.prototype.getNumberFormat=function(a){return this.get$Value(19,a)};i18n.phonenumbers.PhoneMetadata.prototype.getNumberFormatOrDefault=function(a){return this.get$ValueOrDefault(19,a)};\ni18n.phonenumbers.PhoneMetadata.prototype.addNumberFormat=function(a){this.add$Value(19,a)};i18n.phonenumbers.PhoneMetadata.prototype.numberFormatArray=function(){return this.array$Values(19)};i18n.phonenumbers.PhoneMetadata.prototype.hasNumberFormat=function(){return this.has$Value(19)};i18n.phonenumbers.PhoneMetadata.prototype.numberFormatCount=function(){return this.count$Values(19)};i18n.phonenumbers.PhoneMetadata.prototype.clearNumberFormat=function(){this.clear$Field(19)};\ni18n.phonenumbers.PhoneMetadata.prototype.getIntlNumberFormat=function(a){return this.get$Value(20,a)};i18n.phonenumbers.PhoneMetadata.prototype.getIntlNumberFormatOrDefault=function(a){return this.get$ValueOrDefault(20,a)};i18n.phonenumbers.PhoneMetadata.prototype.addIntlNumberFormat=function(a){this.add$Value(20,a)};i18n.phonenumbers.PhoneMetadata.prototype.intlNumberFormatArray=function(){return this.array$Values(20)};i18n.phonenumbers.PhoneMetadata.prototype.hasIntlNumberFormat=function(){return this.has$Value(20)};\ni18n.phonenumbers.PhoneMetadata.prototype.intlNumberFormatCount=function(){return this.count$Values(20)};i18n.phonenumbers.PhoneMetadata.prototype.clearIntlNumberFormat=function(){this.clear$Field(20)};i18n.phonenumbers.PhoneMetadata.prototype.getMainCountryForCode=function(){return this.get$Value(22)};i18n.phonenumbers.PhoneMetadata.prototype.getMainCountryForCodeOrDefault=function(){return this.get$ValueOrDefault(22)};\ni18n.phonenumbers.PhoneMetadata.prototype.setMainCountryForCode=function(a){this.set$Value(22,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasMainCountryForCode=function(){return this.has$Value(22)};i18n.phonenumbers.PhoneMetadata.prototype.mainCountryForCodeCount=function(){return this.count$Values(22)};i18n.phonenumbers.PhoneMetadata.prototype.clearMainCountryForCode=function(){this.clear$Field(22)};i18n.phonenumbers.PhoneMetadata.prototype.getLeadingDigits=function(){return this.get$Value(23)};\ni18n.phonenumbers.PhoneMetadata.prototype.getLeadingDigitsOrDefault=function(){return this.get$ValueOrDefault(23)};i18n.phonenumbers.PhoneMetadata.prototype.setLeadingDigits=function(a){this.set$Value(23,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasLeadingDigits=function(){return this.has$Value(23)};i18n.phonenumbers.PhoneMetadata.prototype.leadingDigitsCount=function(){return this.count$Values(23)};i18n.phonenumbers.PhoneMetadata.prototype.clearLeadingDigits=function(){this.clear$Field(23)};\ni18n.phonenumbers.PhoneMetadata.prototype.getLeadingZeroPossible=function(){return this.get$Value(26)};i18n.phonenumbers.PhoneMetadata.prototype.getLeadingZeroPossibleOrDefault=function(){return this.get$ValueOrDefault(26)};i18n.phonenumbers.PhoneMetadata.prototype.setLeadingZeroPossible=function(a){this.set$Value(26,a)};i18n.phonenumbers.PhoneMetadata.prototype.hasLeadingZeroPossible=function(){return this.has$Value(26)};i18n.phonenumbers.PhoneMetadata.prototype.leadingZeroPossibleCount=function(){return this.count$Values(26)};\ni18n.phonenumbers.PhoneMetadata.prototype.clearLeadingZeroPossible=function(){this.clear$Field(26)};i18n.phonenumbers.PhoneMetadataCollection=function(){goog.proto2.Message.apply(this)};goog.inherits(i18n.phonenumbers.PhoneMetadataCollection,goog.proto2.Message);i18n.phonenumbers.PhoneMetadataCollection.prototype.getMetadata=function(a){return this.get$Value(1,a)};i18n.phonenumbers.PhoneMetadataCollection.prototype.getMetadataOrDefault=function(a){return this.get$ValueOrDefault(1,a)};\ni18n.phonenumbers.PhoneMetadataCollection.prototype.addMetadata=function(a){this.add$Value(1,a)};i18n.phonenumbers.PhoneMetadataCollection.prototype.metadataArray=function(){return this.array$Values(1)};i18n.phonenumbers.PhoneMetadataCollection.prototype.hasMetadata=function(){return this.has$Value(1)};i18n.phonenumbers.PhoneMetadataCollection.prototype.metadataCount=function(){return this.count$Values(1)};i18n.phonenumbers.PhoneMetadataCollection.prototype.clearMetadata=function(){this.clear$Field(1)};\ngoog.proto2.Message.set$Metadata(i18n.phonenumbers.NumberFormat,{\"0\":{name:\"NumberFormat\",fullName:\"i18n.phonenumbers.NumberFormat\"},1:{name:\"pattern\",required:!0,fieldType:goog.proto2.Message.FieldType.STRING,type:String},2:{name:\"format\",required:!0,fieldType:goog.proto2.Message.FieldType.STRING,type:String},3:{name:\"leading_digits_pattern\",repeated:!0,fieldType:goog.proto2.Message.FieldType.STRING,type:String},4:{name:\"national_prefix_formatting_rule\",fieldType:goog.proto2.Message.FieldType.STRING,\ntype:String},6:{name:\"national_prefix_optional_when_formatting\",fieldType:goog.proto2.Message.FieldType.BOOL,type:Boolean},5:{name:\"domestic_carrier_code_formatting_rule\",fieldType:goog.proto2.Message.FieldType.STRING,type:String}});\ngoog.proto2.Message.set$Metadata(i18n.phonenumbers.PhoneNumberDesc,{\"0\":{name:\"PhoneNumberDesc\",fullName:\"i18n.phonenumbers.PhoneNumberDesc\"},2:{name:\"national_number_pattern\",fieldType:goog.proto2.Message.FieldType.STRING,type:String},3:{name:\"possible_number_pattern\",fieldType:goog.proto2.Message.FieldType.STRING,type:String},6:{name:\"example_number\",fieldType:goog.proto2.Message.FieldType.STRING,type:String}});\ngoog.proto2.Message.set$Metadata(i18n.phonenumbers.PhoneMetadata,{\"0\":{name:\"PhoneMetadata\",fullName:\"i18n.phonenumbers.PhoneMetadata\"},1:{name:\"general_desc\",required:!0,fieldType:goog.proto2.Message.FieldType.MESSAGE,type:i18n.phonenumbers.PhoneNumberDesc},2:{name:\"fixed_line\",required:!0,fieldType:goog.proto2.Message.FieldType.MESSAGE,type:i18n.phonenumbers.PhoneNumberDesc},3:{name:\"mobile\",required:!0,fieldType:goog.proto2.Message.FieldType.MESSAGE,type:i18n.phonenumbers.PhoneNumberDesc},4:{name:\"toll_free\",\nrequired:!0,fieldType:goog.proto2.Message.FieldType.MESSAGE,type:i18n.phonenumbers.PhoneNumberDesc},5:{name:\"premium_rate\",required:!0,fieldType:goog.proto2.Message.FieldType.MESSAGE,type:i18n.phonenumbers.PhoneNumberDesc},6:{name:\"shared_cost\",required:!0,fieldType:goog.proto2.Message.FieldType.MESSAGE,type:i18n.phonenumbers.PhoneNumberDesc},7:{name:\"personal_number\",required:!0,fieldType:goog.proto2.Message.FieldType.MESSAGE,type:i18n.phonenumbers.PhoneNumberDesc},8:{name:\"voip\",required:!0,fieldType:goog.proto2.Message.FieldType.MESSAGE,\ntype:i18n.phonenumbers.PhoneNumberDesc},21:{name:\"pager\",required:!0,fieldType:goog.proto2.Message.FieldType.MESSAGE,type:i18n.phonenumbers.PhoneNumberDesc},25:{name:\"uan\",required:!0,fieldType:goog.proto2.Message.FieldType.MESSAGE,type:i18n.phonenumbers.PhoneNumberDesc},27:{name:\"emergency\",required:!0,fieldType:goog.proto2.Message.FieldType.MESSAGE,type:i18n.phonenumbers.PhoneNumberDesc},28:{name:\"voicemail\",required:!0,fieldType:goog.proto2.Message.FieldType.MESSAGE,type:i18n.phonenumbers.PhoneNumberDesc},\n24:{name:\"no_international_dialling\",required:!0,fieldType:goog.proto2.Message.FieldType.MESSAGE,type:i18n.phonenumbers.PhoneNumberDesc},9:{name:\"id\",required:!0,fieldType:goog.proto2.Message.FieldType.STRING,type:String},10:{name:\"country_code\",required:!0,fieldType:goog.proto2.Message.FieldType.INT32,type:Number},11:{name:\"international_prefix\",required:!0,fieldType:goog.proto2.Message.FieldType.STRING,type:String},17:{name:\"preferred_international_prefix\",fieldType:goog.proto2.Message.FieldType.STRING,\ntype:String},12:{name:\"national_prefix\",fieldType:goog.proto2.Message.FieldType.STRING,type:String},13:{name:\"preferred_extn_prefix\",fieldType:goog.proto2.Message.FieldType.STRING,type:String},15:{name:\"national_prefix_for_parsing\",fieldType:goog.proto2.Message.FieldType.STRING,type:String},16:{name:\"national_prefix_transform_rule\",fieldType:goog.proto2.Message.FieldType.STRING,type:String},18:{name:\"same_mobile_and_fixed_line_pattern\",fieldType:goog.proto2.Message.FieldType.BOOL,defaultValue:!1,\ntype:Boolean},19:{name:\"number_format\",repeated:!0,fieldType:goog.proto2.Message.FieldType.MESSAGE,type:i18n.phonenumbers.NumberFormat},20:{name:\"intl_number_format\",repeated:!0,fieldType:goog.proto2.Message.FieldType.MESSAGE,type:i18n.phonenumbers.NumberFormat},22:{name:\"main_country_for_code\",fieldType:goog.proto2.Message.FieldType.BOOL,defaultValue:!1,type:Boolean},23:{name:\"leading_digits\",fieldType:goog.proto2.Message.FieldType.STRING,type:String},26:{name:\"leading_zero_possible\",fieldType:goog.proto2.Message.FieldType.BOOL,\ndefaultValue:!1,type:Boolean}});goog.proto2.Message.set$Metadata(i18n.phonenumbers.PhoneMetadataCollection,{\"0\":{name:\"PhoneMetadataCollection\",fullName:\"i18n.phonenumbers.PhoneMetadataCollection\"},1:{name:\"metadata\",repeated:!0,fieldType:goog.proto2.Message.FieldType.MESSAGE,type:i18n.phonenumbers.PhoneMetadata}});/*\n\n Copyright (C) 2010 The Libphonenumber Authors\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\ni18n.phonenumbers.metadata={};\ni18n.phonenumbers.metadata.countryCodeToRegionCodeMap={1:\"US,AG,AI,AS,BB,BM,BS,CA,DM,DO,GD,GU,JM,KN,KY,LC,MP,MS,PR,SX,TC,TT,VC,VG,VI\".split(\",\"),7:[\"RU\",\"KZ\"],20:[\"EG\"],27:[\"ZA\"],30:[\"GR\"],31:[\"NL\"],32:[\"BE\"],33:[\"FR\"],34:[\"ES\"],36:[\"HU\"],39:[\"IT\"],40:[\"RO\"],41:[\"CH\"],43:[\"AT\"],44:[\"GB\",\"GG\",\"IM\",\"JE\"],45:[\"DK\"],46:[\"SE\"],47:[\"NO\",\"SJ\"],48:[\"PL\"],49:[\"DE\"],51:[\"PE\"],52:[\"MX\"],53:[\"CU\"],54:[\"AR\"],55:[\"BR\"],56:[\"CL\"],57:[\"CO\"],58:[\"VE\"],60:[\"MY\"],61:[\"AU\",\"CC\",\"CX\"],62:[\"ID\"],63:[\"PH\"],64:[\"NZ\"],65:[\"SG\"],\n66:[\"TH\"],81:[\"JP\"],82:[\"KR\"],84:[\"VN\"],86:[\"CN\"],90:[\"TR\"],91:[\"IN\"],92:[\"PK\"],93:[\"AF\"],94:[\"LK\"],95:[\"MM\"],98:[\"IR\"],212:[\"MA\"],213:[\"DZ\"],216:[\"TN\"],218:[\"LY\"],220:[\"GM\"],221:[\"SN\"],222:[\"MR\"],223:[\"ML\"],224:[\"GN\"],225:[\"CI\"],226:[\"BF\"],227:[\"NE\"],228:[\"TG\"],229:[\"BJ\"],230:[\"MU\"],231:[\"LR\"],232:[\"SL\"],233:[\"GH\"],234:[\"NG\"],235:[\"TD\"],236:[\"CF\"],237:[\"CM\"],238:[\"CV\"],239:[\"ST\"],240:[\"GQ\"],241:[\"GA\"],242:[\"CG\"],243:[\"CD\"],244:[\"AO\"],245:[\"GW\"],246:[\"IO\"],247:[\"AC\"],248:[\"SC\"],249:[\"SD\"],250:[\"RW\"],\n251:[\"ET\"],252:[\"SO\"],253:[\"DJ\"],254:[\"KE\"],255:[\"TZ\"],256:[\"UG\"],257:[\"BI\"],258:[\"MZ\"],260:[\"ZM\"],261:[\"MG\"],262:[\"RE\",\"YT\"],263:[\"ZW\"],264:[\"NA\"],265:[\"MW\"],266:[\"LS\"],267:[\"BW\"],268:[\"SZ\"],269:[\"KM\"],290:[\"SH\"],291:[\"ER\"],297:[\"AW\"],298:[\"FO\"],299:[\"GL\"],350:[\"GI\"],351:[\"PT\"],352:[\"LU\"],353:[\"IE\"],354:[\"IS\"],355:[\"AL\"],356:[\"MT\"],357:[\"CY\"],358:[\"FI\",\"AX\"],359:[\"BG\"],370:[\"LT\"],371:[\"LV\"],372:[\"EE\"],373:[\"MD\"],374:[\"AM\"],375:[\"BY\"],376:[\"AD\"],377:[\"MC\"],378:[\"SM\"],379:[\"VA\"],380:[\"UA\"],381:[\"RS\"],\n382:[\"ME\"],385:[\"HR\"],386:[\"SI\"],387:[\"BA\"],389:[\"MK\"],420:[\"CZ\"],421:[\"SK\"],423:[\"LI\"],500:[\"FK\"],501:[\"BZ\"],502:[\"GT\"],503:[\"SV\"],504:[\"HN\"],505:[\"NI\"],506:[\"CR\"],507:[\"PA\"],508:[\"PM\"],509:[\"HT\"],590:[\"GP\",\"BL\",\"MF\"],591:[\"BO\"],592:[\"GY\"],593:[\"EC\"],594:[\"GF\"],595:[\"PY\"],596:[\"MQ\"],597:[\"SR\"],598:[\"UY\"],599:[\"AN\"],670:[\"TL\"],672:[\"NF\"],673:[\"BN\"],674:[\"NR\"],675:[\"PG\"],676:[\"TO\"],677:[\"SB\"],678:[\"VU\"],679:[\"FJ\"],680:[\"PW\"],681:[\"WF\"],682:[\"CK\"],683:[\"NU\"],685:[\"WS\"],686:[\"KI\"],687:[\"NC\"],688:[\"TV\"],\n689:[\"PF\"],690:[\"TK\"],691:[\"FM\"],692:[\"MH\"],800:[\"001\"],808:[\"001\"],850:[\"KP\"],852:[\"HK\"],853:[\"MO\"],855:[\"KH\"],856:[\"LA\"],880:[\"BD\"],883:[\"001\"],886:[\"TW\"],888:[\"001\"],960:[\"MV\"],961:[\"LB\"],962:[\"JO\"],963:[\"SY\"],964:[\"IQ\"],965:[\"KW\"],966:[\"SA\"],967:[\"YE\"],968:[\"OM\"],970:[\"PS\"],971:[\"AE\"],972:[\"IL\"],973:[\"BH\"],974:[\"QA\"],975:[\"BT\"],976:[\"MN\"],977:[\"NP\"],979:[\"001\"],992:[\"TJ\"],993:[\"TM\"],994:[\"AZ\"],995:[\"GE\"],996:[\"KG\"],998:[\"UZ\"]};\ni18n.phonenumbers.metadata.countryToMetadata={AC:[,[,,\"[2-46]\\\\d{3}\",\"\\\\d{4}\"],[,,\"(?:3[0-5]|4[4-6]|[26]\\\\d)\\\\d{2}\",\"\\\\d{4}\",,,\"6889\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"AC\",247,\"00\",,,,,,,,,,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],AD:[,[,,\"(?:[346-9]|180)\\\\d{5}\",\"\\\\d{6,8}\"],[,,\"[78]\\\\d{5}\",\"\\\\d{6}\",,,\"712345\"],[,,\"[346]\\\\d{5}\",\"\\\\d{6}\",,,\"312345\"],[,,\"180[02]\\\\d{4}\",\"\\\\d{8}\",,,\"18001234\"],[,,\"9\\\\d{5}\",\n\"\\\\d{6}\",,,\"912345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"AD\",376,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{3})\",\"$1 $2\",[\"[346-9]\"],\"\",\"\",0],[,\"(180[02])(\\\\d{4})\",\"$1 $2\",[\"1\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[0268]\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],AE:[,[,,\"[2-79]\\\\d{7,8}|800\\\\d{2,9}\",\"\\\\d{5,12}\"],[,,\"(?:[2-4679][2-8]\\\\d|600[25])\\\\d{5}\",\"\\\\d{7,9}\",,,\"22345678\"],[,,\"5[056]\\\\d{7}\",\"\\\\d{9}\",,,\"501234567\"],[,,\"400\\\\d{6}|800\\\\d{2,9}\",\"\\\\d{5,12}\",,,\"800123456\"],[,,\"900[02]\\\\d{5}\",\n\"\\\\d{9}\",,,\"900234567\"],[,,\"700[05]\\\\d{5}\",\"\\\\d{9}\",,,\"700012345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"AE\",971,\"00\",\"0\",,,\"0\",,,,[[,\"([2-4679])(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[2-4679][2-8]\"],\"0$1\",\"\",0],[,\"(5[056])(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"5\"],\"0$1\",\"\",0],[,\"([4679]00)(\\\\d)(\\\\d{5})\",\"$1 $2 $3\",[\"[4679]0\"],\"$1\",\"\",0],[,\"(800)(\\\\d{2,9})\",\"$1 $2\",[\"8\"],\"$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112|99[789]\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],AF:[,[,,\"[2-7]\\\\d{8}\",\"\\\\d{7,9}\"],[,,\"(?:[25][0-8]|[34][0-4]|6[0-5])[2-9]\\\\d{6}\",\n\"\\\\d{7,9}\",,,\"234567890\"],[,,\"7[057-9]\\\\d{7}\",\"\\\\d{9}\",,,\"701234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"AF\",93,\"00\",\"0\",,,\"0\",,,,[[,\"([2-7]\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",,\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:02|19)\",\"\\\\d{3}\",,,\"119\"],[,,\"NA\",\"NA\"]],AG:[,[,,\"[2589]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"268(?:4(?:6[0-38]|84)|56[0-2])\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"2684601234\"],[,,\"268(?:464|7(?:2[0-9]|64|7[0-689]|8[02-68]))\\\\d{4}\",\"\\\\d{10}\",\n,,\"2684641234\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002123456\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002123456\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"26848[01]\\\\d{4}\",\"\\\\d{10}\",,,\"2684801234\"],\"AG\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"26840[69]\\\\d{4}\",\"\\\\d{10}\",,,\"2684061234\"],,\"268\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"9(?:11|99)\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],AI:[,[,,\"[2589]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"2644(?:6[12]|9[78])\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"2644612345\"],\n[,,\"264(?:235|476|5(?:3[6-9]|8[1-4])|7(?:29|72))\\\\d{4}\",\"\\\\d{10}\",,,\"2642351234\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002123456\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002123456\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"AI\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,\"264\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],AL:[,[,,\"[2-57]\\\\d{7}|6\\\\d{8}|8\\\\d{5,7}|9\\\\d{5}\",\"\\\\d{5,9}\"],[,,\"(?:2(?:[168][1-9]|[247]\\\\d|9[1-7])|3(?:1[1-3]|[2-6]\\\\d|[79][1-8]|8[1-9])|4\\\\d{2}|5(?:1[1-4]|[2-578]\\\\d|6[1-5]|9[1-7])|8(?:[19][1-5]|[2-6]\\\\d|[78][1-7]))\\\\d{5}\",\n\"\\\\d{5,8}\",,,\"22345678\"],[,,\"6[6-9]\\\\d{7}\",\"\\\\d{9}\",,,\"661234567\"],[,,\"800\\\\d{4}\",\"\\\\d{7}\",,,\"8001234\"],[,,\"900\\\\d{3}\",\"\\\\d{6}\",,,\"900123\"],[,,\"808\\\\d{3}\",\"\\\\d{6}\",,,\"808123\"],[,,\"700\\\\d{5}\",\"\\\\d{8}\",,,\"70012345\"],[,,\"NA\",\"NA\"],\"AL\",355,\"00\",\"0\",,,\"0\",,,,[[,\"(4)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"4[0-6]\"],\"0$1\",\"\",0],[,\"(6[6-9])(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"6\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[2358][2-5]|4[7-9]\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{3,5})\",\"$1 $2\",[\"[235][16-9]|8[016-9]|[79]\"],\n\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"12[789]\",\"\\\\d{3}\",,,\"129\"],[,,\"NA\",\"NA\"]],AM:[,[,,\"[1-35-9]\\\\d{7}\",\"\\\\d{5,8}\"],[,,\"(?:10\\\\d|2(?:2[2-46]|3[1-8]|4[2-69]|5[2-7]|6[1-9]|8[1-7])|3[12]2)\\\\d{5}\",\"\\\\d{5,8}\",,,\"10123456\"],[,,\"(?:55|77|9[1-9])\\\\d{6}\",\"\\\\d{8}\",,,\"77123456\"],[,,\"800\\\\d{5}\",\"\\\\d{8}\",,,\"80012345\"],[,,\"90[016]\\\\d{5}\",\"\\\\d{8}\",,,\"90012345\"],[,,\"80[1-4]\\\\d{5}\",\"\\\\d{8}\",,,\"80112345\"],[,,\"NA\",\"NA\"],[,,\"6027\\\\d{4}\",\"\\\\d{8}\",,,\"60271234\"],\"AM\",374,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d{2})(\\\\d{6})\",\n\"$1 $2\",[\"1\"],\"(0$1)\",\"\",0],[,\"(\\\\d{2})(\\\\d{6})\",\"$1 $2\",[\"[5-7]|9[1-9]\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{5})\",\"$1 $2\",[\"[23]\"],\"(0$1)\",\"\",0],[,\"(\\\\d{3})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"8|90\"],\"0 $1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"10[123]\",\"\\\\d{3}\",,,\"102\"],[,,\"NA\",\"NA\"]],AN:[,[,,\"[13-79]\\\\d{6,7}\",\"\\\\d{7,8}\"],[,,\"(?:318|5(?:25|4\\\\d|8[239])|7(?:1[578]|50)|9(?:[48]\\\\d{2}|50\\\\d|7(?:2[0-2]|[34]\\\\d|6[35-7]|77)))\\\\d{4}|416[0239]\\\\d{3}\",\"\\\\d{7,8}\",,,\"7151234\"],[,,\"(?:318|5(?:1[01]|2[0-7]|5\\\\d|8[016-8])|7(?:0[01]|[89]\\\\d)|9(?:5(?:[1246]\\\\d|3[01])|6(?:[1679]\\\\d|3[01])))\\\\d{4}|416[15-8]\\\\d{3}\",\n\"\\\\d{7,8}\",,,\"3181234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"(?:10|69)\\\\d{5}\",\"\\\\d{7,8}\",,,\"1011234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"AN\",599,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[13-7]\"],\"\",\"\",0],[,\"(9)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"9\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112|911\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],AO:[,[,,\"[29]\\\\d{8}\",\"\\\\d{9}\"],[,,\"2\\\\d(?:[26-9]\\\\d|\\\\d[26-9])\\\\d{5}\",\"\\\\d{9}\",,,\"222123456\"],[,,\"9[1-3]\\\\d{7}\",\"\\\\d{9}\",,,\"923123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\n[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"AO\",244,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[235]\",\"\\\\d{3}\",,,\"113\"],[,,\"NA\",\"NA\"]],AR:[,[,,\"[1-368]\\\\d{9}|9\\\\d{10}\",\"\\\\d{6,11}\"],[,,\"11\\\\d{8}|(?:2(?:2(?:[0139]\\\\d|2[13-79]|4[1-6]|5[2457]|6[124-8]|7[1-4]|8[13-6])|3(?:1[467]|2[02-6]|3[13-8]|[49][2-6]|5[2-8]|[067]\\\\d)|47[3-8]|6(?:[013-6]\\\\d|2[2-7])|80\\\\d|9(?:[0124789]\\\\d|3[1-6]|5[234]|6[2-46]))|3(?:3(?:2[79]|8[2578])|4(?:[78]\\\\d|0[0124-9]|[1-356]\\\\d|4[24-7]|9[123678])|5(?:[138]\\\\d|2[1245]|4[1-9]|6[2-4]|7[1-6])|6[24]\\\\d|7(?:[124689]\\\\d|3[1245]|5[14-8]|7[2-57])|8(?:[123578]\\\\d|4[13-6]|6[1-357-9]|9[124]))|670\\\\d)\\\\d{6}\",\n\"\\\\d{6,10}\",,,\"1123456789\"],[,,\"675\\\\d{7}|9(?:11[2-9]\\\\d{7}|(?:2(?:2[013]|37|6[01346]|80|9[147-9])|3(?:4[1235]|5[138]|6[24]|7[69]|8[1578]))[2-9]\\\\d{6}|\\\\d{4}[2-9]\\\\d{5})\",\"\\\\d{6,11}\",,,\"91123456789\"],[,,\"800\\\\d{7}\",\"\\\\d{10}\",,,\"8001234567\"],[,,\"60[04579]\\\\d{7}\",\"\\\\d{10}\",,,\"6001234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"AR\",54,\"00\",\"0\",,,\"0(?:(11|2(?:2(?:02?|[13]|2[13-79]|4[1-6]|5[2457]|6[124-8]|7[1-4]|8[13-6]|9[1-367])|3(?:[06]2|1[467]|2[02-6]|3[13-8]|[49][2-6]|5[2-8]|7)|47[3-578]|6(?:[0136]|2[2-7]|4[6-8]?|5[15-8])|80|9(?:0[1-3]|[19]|2\\\\d|3[1-6]|4[024-68]?|5[2-4]|6[2-46]|72?|8[23]?))|3(?:3(?:2[79]|8[2578])|4(?:0[124-9]|[12]|3[5-8]?|4[24-7]|5[4-68]?|6\\\\d|7[126]|8[237-9]|9[1-36-8])|5(?:1|2[1245]|3[2-47]?|4[1-46-9]|6[2-4]|7[1-6]|8[2-5]?)|6[24]|7(?:1[15-8]|2[125]|3[1245]|4[13]|5[14-8]|[69]|7[2-57]|8[1-36])|8(?:1|2[125-7]|3[23578]|4[13-6]|5[4-8]?|6[1-357-9]|7[36-8]?|8[5-8]?|9[124])))15)?\",\n\"9$1\",,,[[,\"([68]\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\",[\"[68]\"],\"0$1\",\"\",0],[,\"(9)(11)(\\\\d{4})(\\\\d{4})\",\"$2 15-$3-$4\",[\"911\"],\"0$1\",\"\",0],[,\"(9)(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$2 15-$3-$4\",[\"9(?:2[23689]|3[4-8])\",\"9(?:2(?:2[013]|37|6[01346]|80|9[147-9])|3(?:4[1235]|5[138]|6[24]|7[69]|8[1578]))\",\"9(?:2(?:2[013]|37|6[01346]|80|9(?:[17-9]|4[1379]))|3(?:4[1235]|5(?:[18]|3[0-35689])|6[24]|7[69]|8(?:[15]|7[0-24-9]|8[0-79])))\"],\"0$1\",\"\",0],[,\"(9)(\\\\d{4})(\\\\d{3})(\\\\d{3})\",\"$2 15-$3-$4\",[\"93[58]\",\"9(?:3(?:53|8[78]))\",\n\"9(?:3(?:537|8(?:73|88)))\"],\"0$1\",\"\",0],[,\"(9)(\\\\d{4})(\\\\d{2})(\\\\d{4})\",\"$2 15-$3-$4\",[\"9[23]\"],\"0$1\",\"\",0],[,\"(11)(\\\\d{4})(\\\\d{4})\",\"$1 $2-$3\",[\"1\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2-$3\",[\"2(?:2[013]|37|6[01346]|80|9[147-9])|3(?:4[1235]|5[138]|6[24]|7[69]|8[1578])\",\"2(?:2[013]|37|6[01346]|80|9(?:[17-9]|4[1379]))|3(?:4[1235]|5(?:[18]|3[0-35689])|6[24]|7[69]|8(?:[15]|7[0-24-9]|8[0-79]))\"],\"0$1\",\"\",0],[,\"(\\\\d{4})(\\\\d{3})(\\\\d{3})\",\"$1 $2-$3\",[\"3(?:53|8[78])\",\"3(?:537|8(?:73|88))\"],\"0$1\",\n\"\",0],[,\"(\\\\d{4})(\\\\d{2})(\\\\d{4})\",\"$1 $2-$3\",[\"[23]\"],\"0$1\",\"\",0]],[[,\"([68]\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\",[\"[68]\"]],[,\"(9)(11)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3-$4\",[\"911\"]],[,\"(9)(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3-$4\",[\"9(?:2[23689]|3[4-8])\",\"9(?:2(?:2[013]|37|6[01346]|80|9[147-9])|3(?:4[1235]|5[138]|6[24]|7[69]|8[1578]))\",\"9(?:2(?:2[013]|37|6[01346]|80|9(?:[17-9]|4[1379]))|3(?:4[1235]|5(?:[18]|3[0-35689])|6[24]|7[69]|8(?:[15]|7[0-24-9]|8[0-79])))\"]],[,\"(9)(\\\\d{4})(\\\\d{3})(\\\\d{3})\",\"$2 15-$3-$4\",\n[\"93[58]\",\"9(?:3(?:53|8[78]))\",\"9(?:3(?:537|8(?:73|88)))\"]],[,\"(9)(\\\\d{4})(\\\\d{2})(\\\\d{4})\",\"$1 $2 $3-$4\",[\"9[23]\"]],[,\"(11)(\\\\d{4})(\\\\d{4})\",\"$1 $2-$3\",[\"1\"]],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2-$3\",[\"2(?:2[013]|37|6[01346]|80|9[147-9])|3(?:4[1235]|5[138]|6[24]|7[69]|8[1578])\",\"2(?:2[013]|37|6[01346]|80|9(?:[17-9]|4[1379]))|3(?:4[1235]|5(?:[18]|3[0-35689])|6[24]|7[69]|8(?:[15]|7[0-24-9]|8[0-79]))\"]],[,\"(\\\\d{4})(\\\\d{3})(\\\\d{3})\",\"$1 $2-$3\",[\"3(?:53|8[78])\",\"3(?:537|8(?:73|88))\"]],[,\"(\\\\d{4})(\\\\d{2})(\\\\d{4})\",\n\"$1 $2-$3\",[\"[23]\"]]],[,,\"NA\",\"NA\"],,,[,,\"810\\\\d{7}\",\"\\\\d{10}\",,,\"8101234567\"],[,,\"810\\\\d{7}\",\"\\\\d{10}\",,,\"8101234567\"],,[,,\"1(?:0[017]|28)\",\"\\\\d{3}\",,,\"101\"],[,,\"NA\",\"NA\"]],AS:[,[,,\"[5689]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"6846(?:22|33|44|55|77|88|9[19])\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"6846221234\"],[,,\"684(?:733|258)\\\\d{4}\",\"\\\\d{10}\",,,\"6847331234\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002123456\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002123456\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\n\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"AS\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,\"684\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],AT:[,[,,\"[1-9]\\\\d{3,12}\",\"\\\\d{3,13}\"],[,,\"1\\\\d{3,12}|(?:2(?:1[467]|2[134-8]|5[2357]|6[1-46-8]|7[1-8]|8[124-7]|9[1458])|3(?:1[1-8]|3[23568]|4[5-7]|5[1378]|6[1-38]|8[3-68])|4(?:2[1-8]|35|63|7[1368]|8[2457])|5(?:12|2[1-8]|3[357]|4[147]|5[12578]|6[37])|6(?:13|2[1-47]|4[1-35-8]|5[468]|62)|7(?:2[1-8]|3[25]|4[13478]|5[68]|6[16-8]|7[1-6]|9[45]))\\\\d{3,10}\",\n\"\\\\d{3,13}\",,,\"1234567890\"],[,,\"6(?:44|5[0-3579]|6[013-9]|[7-9]\\\\d)\\\\d{4,10}\",\"\\\\d{7,13}\",,,\"644123456\"],[,,\"80[02]\\\\d{6,10}\",\"\\\\d{9,13}\",,,\"800123456\"],[,,\"(?:711|9(?:0[01]|3[019]))\\\\d{6,10}\",\"\\\\d{9,13}\",,,\"900123456\"],[,,\"8(?:10|2[018])\\\\d{6,10}\",\"\\\\d{9,13}\",,,\"810123456\"],[,,\"NA\",\"NA\"],[,,\"780\\\\d{6,10}\",\"\\\\d{9,13}\",,,\"780123456\"],\"AT\",43,\"00\",\"0\",,,\"0\",,,,[[,\"([15])(\\\\d{3,12})\",\"$1 $2\",[\"1|5[079]\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{3,10})\",\"$1 $2\",[\"316|46|51|732|6(?:44|5[0-3579]|[6-9])|7(?:1|[28]0)|[89]\"],\n\"0$1\",\"\",0],[,\"(\\\\d{4})(\\\\d{3,9})\",\"$1 $2\",[\"2|3(?:1[1-578]|[3-8])|4[2378]|5[2-6]|6(?:[12]|4[1-35-9]|5[468])|7(?:2[1-8]|35|4[1-8]|[57-9])\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"5(?:(?:0[1-9]|17)\\\\d{2,10}|[79]\\\\d{3,11})|720\\\\d{6,10}\",\"\\\\d{5,13}\",,,\"50123\"],,[,,\"1(?:[12]2|33|44)\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],AU:[,[,,\"[1-578]\\\\d{5,9}\",\"\\\\d{6,10}\"],[,,\"[237]\\\\d{8}|8(?:[68]\\\\d{3}|7[0-6]\\\\d{2}|9(?:[02-9]\\\\d{2}|1(?:[0-57-9]\\\\d|6[0135-9])))\\\\d{4}\",\"\\\\d{8,9}\",,,\"212345678\"],[,,\"14(?:5\\\\d|71)\\\\d{5}|4(?:[0-2]\\\\d|3[0-57-9]|4[46-9]|5[0-37-9]|6[6-9]|7[07-9]|8[7-9]|9[89])\\\\d{6}\",\n\"\\\\d{9}\",,,\"412345678\"],[,,\"180(?:0\\\\d{3}|2)\\\\d{3}\",\"\\\\d{7,10}\",,,\"1800123456\"],[,,\"19(?:0[0126]\\\\d{6}|[13-5]\\\\d{3}|[679]\\\\d{5})\",\"\\\\d{6,10}\",,,\"1900123456\"],[,,\"13(?:00\\\\d{2})?\\\\d{4}\",\"\\\\d{6,10}\",,,\"1300123456\"],[,,\"500\\\\d{6}\",\"\\\\d{9}\",,,\"500123456\"],[,,\"550\\\\d{6}\",\"\\\\d{9}\",,,\"550123456\"],\"AU\",61,\"(?:14(?:1[14]|34|4[17]|[56]6|7[47]|88))?001[14-689]\",\"0\",,,\"0\",,\"0011\",,[[,\"([2378])(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"[2378]\"],\"(0$1)\",\"\",0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[45]|14\"],\"0$1\",\"\",0],\n[,\"(16)(\\\\d{3})(\\\\d{2,4})\",\"$1 $2 $3\",[\"16\"],\"0$1\",\"\",0],[,\"(1[389]\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"1(?:[38]0|90)\",\"1(?:[38]00|90)\"],\"$1\",\"\",0],[,\"(180)(2\\\\d{3})\",\"$1 $2\",[\"180\",\"1802\"],\"$1\",\"\",0],[,\"(19\\\\d)(\\\\d{3})\",\"$1 $2\",[\"19[13]\"],\"$1\",\"\",0],[,\"(19\\\\d{2})(\\\\d{4})\",\"$1 $2\",[\"19[67]\"],\"$1\",\"\",0],[,\"(13)(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",[\"13[1-9]\"],\"$1\",\"\",0]],,[,,\"16\\\\d{3,7}\",\"\\\\d{5,9}\",,,\"1612345\"],1,,[,,\"1(?:3(?:\\\\d{4}|00\\\\d{6})|80(?:0\\\\d{6}|2\\\\d{3}))\",\"\\\\d{6,10}\",,,\"1300123456\"],[,,\"NA\",\"NA\"],\n,[,,\"000|112\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],AW:[,[,,\"[25-9]\\\\d{6}\",\"\\\\d{7}\"],[,,\"5(?:2\\\\d|8[1-9])\\\\d{4}\",\"\\\\d{7}\",,,\"5212345\"],[,,\"(?:5(?:6\\\\d|9[2-478])|6(?:[039]0|22|[46][01])|7[34]\\\\d|9(?:6[45]|9[4-8]))\\\\d{4}\",\"\\\\d{7}\",,,\"5601234\"],[,,\"800\\\\d{4}\",\"\\\\d{7}\",,,\"8001234\"],[,,\"900\\\\d{4}\",\"\\\\d{7}\",,,\"9001234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"28\\\\d{5}|501\\\\d{4}\",\"\\\\d{7}\",,,\"5011234\"],\"AW\",297,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"100|911\",\n\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],AX:[,[,,\"[135]\\\\d{5,9}|[27]\\\\d{4,9}|4\\\\d{5,10}|6\\\\d{7,8}|8\\\\d{6,9}\",\"\\\\d{5,12}\"],[,,\"18[1-8]\\\\d{3,9}\",\"\\\\d{6,12}\",,,\"1812345678\"],[,,\"4\\\\d{5,10}|50\\\\d{4,8}\",\"\\\\d{6,11}\",,,\"412345678\"],[,,\"800\\\\d{4,7}\",\"\\\\d{7,10}\",,,\"8001234567\"],[,,\"[67]00\\\\d{5,6}\",\"\\\\d{8,9}\",,,\"600123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"AX\",358,\"00|99[049]\",\"0\",,,\"0\",,,,,,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"10[1-9]\\\\d{3,7}|2(?:0(?:[16-8]\\\\d{3,7}|2[14-9]\\\\d{1,6}|[3-5]\\\\d{2,7}|9[0-7]\\\\d{1,6})|9\\\\d{4,8})|30[1-9]\\\\d{3,7}|7(?:1\\\\d{7}|3\\\\d{8}|5[03-9]\\\\d{2,7})\",\n\"\\\\d{5,10}\",,,\"10112345\"],,[,,\"112\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],AZ:[,[,,\"[1-9]\\\\d{7,8}\",\"\\\\d{5,9}\"],[,,\"(?:1(?:(?:[28]\\\\d|9)\\\\d|02|1[0-589]|3[358]|4[013-79]|5[0-479]|6[02346-9]|7[0-24-8])|2(?:02\\\\d|1(?:2[0-8]|42|6)|2(?:2[0-79]|3[0-35]|42|[1-35-9]|)|3(?:3[0-58]|[0-24])|4(?:2[0124579]|[1468])|5(?:2[0124579]|5)|6(?:2\\\\d|3[0128]|[56])|79)|365?\\\\d|44\\\\d{2})\\\\d{5}\",\"\\\\d{5,9}\",,,\"123123456\"],[,,\"(?:[46]0|5[015]|7[07])\\\\d{7}\",\"\\\\d{9}\",,,\"401234567\"],[,,\"88\\\\d{7}\",\"\\\\d{9}\",,,\"881234567\"],[,,\"900200\\\\d{3}\",\n\"\\\\d{9}\",,,\"900200123\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"AZ\",994,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"(?:1[28]|2(?:[45]2|[0-36])|365)\"],\"(0$1)\",\"\",0],[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"22\"],\"(0$1)\",\"\",0],[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"36[0-46-9]\"],\"(0$1)\",\"\",0],[,\"(\\\\d{3})(\\\\d)(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"1[013-79]|2(?:[45][13-9]|[7-9])\"],\"(0$1)\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[4-8]\"],\n\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"9\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:0[123]|12)\",\"\\\\d{3}\",,,\"101\"],[,,\"NA\",\"NA\"]],BA:[,[,,\"[3-689]\\\\d{7}\",\"\\\\d{6,8}\"],[,,\"(?:[35]\\\\d|49)\\\\d{6}\",\"\\\\d{6,8}\",,,\"30123456\"],[,,\"6[1-356]\\\\d{6}\",\"\\\\d{8}\",,,\"61123456\"],[,,\"8[08]\\\\d{6}\",\"\\\\d{8}\",,,\"80123456\"],[,,\"9[0246]\\\\d{6}\",\"\\\\d{8}\",,,\"90123456\"],[,,\"82\\\\d{6}\",\"\\\\d{8}\",,,\"82123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"BA\",387,\"00\",\"0\",,,\"0\",,,,[[,\"([3-689]\\\\d)(\\\\d{3})(\\\\d{3})\",\n\"$1 $2-$3\",,\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"81\\\\d{6}\",\"\\\\d{8}\",,,\"81123456\"],,[,,\"12[234]\",\"\\\\d{3}\",,,\"122\"],[,,\"NA\",\"NA\"]],BB:[,[,,\"[2589]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"246[2-9]\\\\d{6}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"2462345678\"],[,,\"246(?:(?:2[346]|45|82)\\\\d|25[0-4])\\\\d{4}\",\"\\\\d{10}\",,,\"2462501234\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002123456\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002123456\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\n\"BB\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,\"246\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"[235]11\",\"\\\\d{3}\",,,\"211\"],[,,\"NA\",\"NA\"]],BD:[,[,,\"[2-79]\\\\d{5,9}|1\\\\d{9}|8[0-7]\\\\d{4,8}\",\"\\\\d{6,10}\"],[,,\"2(?:7(?:1[0-267]|2[0-289]|3[0-29]|[46][01]|5[1-3]|7[017]|91)|8(?:0[125]|[139][1-6]|2[0157-9]|6[1-35]|7[1-5]|8[1-8])|9(?:0[0-2]|1[1-4]|2[568]|3[3-6]|5[5-7]|6[0167]|7[15]|8[016-8]))\\\\d{4}|3(?:[6-8]1|(?:0[23]|[25][12]|82|416)\\\\d|(?:31|12?[5-7])\\\\d{2})\\\\d{3}|4(?:(?:02|[49]6|[68]1)|(?:0[13]|21\\\\d?|[23]2|[457][12]|6[28])\\\\d|(?:23|[39]1)\\\\d{2}|1\\\\d{3})\\\\d{3}|5(?:(?:[457-9]1|62)|(?:1\\\\d?|2[12]|3[1-3]|52)\\\\d|61{2})|6(?:[45]1|(?:11|2[15]|[39]1)\\\\d|(?:[06-8]1|62)\\\\d{2})|7(?:(?:32|91)|(?:02|31|[67][12])\\\\d|[458]1\\\\d{2}|21\\\\d{3})\\\\d{3}|8(?:(?:4[12]|[5-7]2|1\\\\d?)|(?:0|3[12]|[5-7]1|217)\\\\d)\\\\d{4}|9(?:[35]1|(?:[024]2|81)\\\\d|(?:1|[24]1)\\\\d{2})\\\\d{3}\",\n\"\\\\d{6,9}\",,,\"27111234\"],[,,\"(?:1[13-9]\\\\d|(?:3[78]|44)[02-9]|6(?:44|6[02-9]))\\\\d{7}\",\"\\\\d{10}\",,,\"1812345678\"],[,,\"80[03]\\\\d{7}\",\"\\\\d{10}\",,,\"8001234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"BD\",880,\"00[12]?\",\"0\",,,\"0\",,\"00\",,[[,\"(2)(\\\\d{7})\",\"$1 $2\",[\"2\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{4,6})\",\"$1 $2\",[\"[3-79]1\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{3,7})\",\"$1 $2\",[\"[3-79][2-9]|8\"],\"0$1\",\"\",0],[,\"(\\\\d{4})(\\\\d{6})\",\"$1 $2\",[\"1\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,\n[,,\"10[0-2]|999\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],BE:[,[,,\"[1-9]\\\\d{7,8}\",\"\\\\d{8,9}\"],[,,\"(?:1[0-69]|[23][2-8]|[49][23]|5\\\\d|6[013-57-9]|7[18])\\\\d{6}|8(?:0[1-9]|[1-69]\\\\d)\\\\d{5}\",\"\\\\d{8}\",,,\"12345678\"],[,,\"4(?:[67]\\\\d|8[3-9]|9[1-9])\\\\d{6}\",\"\\\\d{9}\",,,\"470123456\"],[,,\"800\\\\d{5}\",\"\\\\d{8}\",,,\"80012345\"],[,,\"(?:90|7[07])\\\\d{6}\",\"\\\\d{8}\",,,\"90123456\"],[,,\"87\\\\d{6}\",\"\\\\d{8}\",,,\"87123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"BE\",32,\"00\",\"0\",,,\"0\",,,,[[,\"(4[6-9]\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"4[6-9]\"],\n\"0$1\",\"\",0],[,\"([2-49])(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[23]|[49][23]\"],\"0$1\",\"\",0],[,\"([15-8]\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[156]|7[0178]|8(?:0[1-9]|[1-79])\"],\"0$1\",\"\",0],[,\"([89]\\\\d{2})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"(?:80|9)0\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:0[01]|12)\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],BF:[,[,,\"[2457]\\\\d{7}\",\"\\\\d{8}\"],[,,\"(?:20(?:49|5[23]|9[016-9])|40(?:4[569]|55|7[0179])|50[34]\\\\d)\\\\d{4}\",\"\\\\d{8}\",,,\"20491234\"],[,,\"7(?:[02-68]\\\\d|1[0-4689]|7[0-6]|9[0-689])\\\\d{5}\",\n\"\\\\d{8}\",,,\"70123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"BF\",226,\"00\",,,,,,,,[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1[78]\",\"\\\\d{2}\",,,\"17\"],[,,\"NA\",\"NA\"]],BG:[,[,,\"[23567]\\\\d{5,7}|[489]\\\\d{6,8}\",\"\\\\d{5,9}\"],[,,\"2(?:[0-8]\\\\d{5,6}|9\\\\d{4,6})|(?:[36]\\\\d|5[1-9]|8[1-6]|9[1-7])\\\\d{5,6}|(?:4(?:[124-7]\\\\d|3[1-6])|7(?:0[1-9]|[1-9]\\\\d))\\\\d{4,5}\",\"\\\\d{5,8}\",,,\"2123456\"],[,,\"(?:8[7-9]|98)\\\\d{7}|4(?:3[0789]|8\\\\d)\\\\d{5}\",\n\"\\\\d{8,9}\",,,\"48123456\"],[,,\"800\\\\d{5}\",\"\\\\d{8}\",,,\"80012345\"],[,,\"90\\\\d{6}\",\"\\\\d{8}\",,,\"90123456\"],[,,\"NA\",\"NA\"],[,,\"700\\\\d{5}\",\"\\\\d{5,9}\",,,\"70012345\"],[,,\"NA\",\"NA\"],\"BG\",359,\"00\",\"0\",,,\"0\",,,,[[,\"(2)(\\\\d{5})\",\"$1/$2\",[\"29\"],\"0$1\",\"\",0],[,\"(2)(\\\\d{3})(\\\\d{3,4})\",\"$1/$2 $3\",[\"2\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{4})\",\"$1/$2\",[\"43[124-7]|70[1-9]\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{2})\",\"$1/$2 $3\",[\"43[124-7]|70[1-9]\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"[78]00\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{2,3})\",\n\"$1/$2 $3\",[\"[356]|7[1-9]|8[1-6]|9[1-7]\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"48|8[7-9]|9[08]\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:12|50|6[06])\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],BH:[,[,,\"[136-9]\\\\d{7}\",\"\\\\d{8}\"],[,,\"(?:1(?:3[3-6]|6[0156]|7\\\\d)\\\\d|6(?:1[16]\\\\d|6(?:0\\\\d|3[12]|44)|9(?:69|9[6-9]))|77\\\\d{2})\\\\d{4}\",\"\\\\d{8}\",,,\"17001234\"],[,,\"(?:3(?:[23469]\\\\d|77|8[348])\\\\d|6(?:1[16]\\\\d|6(?:[06]\\\\d|3[03-9]|44)|9(?:69|9[6-9]))|77\\\\d{2})\\\\d{4}\",\"\\\\d{8}\",\n,,\"36001234\"],[,,\"80\\\\d{6}\",\"\\\\d{8}\",,,\"80123456\"],[,,\"(?:87|9[014578])\\\\d{6}\",\"\\\\d{8}\",,,\"90123456\"],[,,\"84\\\\d{6}\",\"\\\\d{8}\",,,\"84123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"BH\",973,\"00\",,,,,,,,[[,\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"999\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],BI:[,[,,\"[27]\\\\d{7}\",\"\\\\d{8}\"],[,,\"22(?:2[0-7]|[3-5]0)\\\\d{4}\",\"\\\\d{8}\",,,\"22201234\"],[,,\"(?:29\\\\d|7(?:1[1-3]|[4-9]\\\\d))\\\\d{5}\",\"\\\\d{8}\",,,\"79561234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\n\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"BI\",257,\"00\",,,,,,,,[[,\"([27]\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[78]\",\"\\\\d{3}\",,,\"117\"],[,,\"NA\",\"NA\"]],BJ:[,[,,\"[2689]\\\\d{7}|7\\\\d{3}\",\"\\\\d{4,8}\"],[,,\"2(?:02|1[037]|2[45]|3[68])\\\\d{5}\",\"\\\\d{8}\",,,\"20211234\"],[,,\"(?:6[46]|9[03-8])\\\\d{6}\",\"\\\\d{8}\",,,\"90011234\"],[,,\"7[3-5]\\\\d{2}\",\"\\\\d{4}\",,,\"7312\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"857[58]\\\\d{4}\",\"\\\\d{8}\",,,\"85751234\"],\"BJ\",229,\"00\",\n,,,,,,,[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[78]\",\"\\\\d{3}\",,,\"117\"],[,,\"NA\",\"NA\"]],BL:[,[,,\"[56]\\\\d{8}\",\"\\\\d{9}\"],[,,\"590(?:2[7-9]|5[12]|87)\\\\d{4}\",\"\\\\d{9}\",,,\"590271234\"],[,,\"690(?:10|2[27]|66|77|8[78])\\\\d{4}\",\"\\\\d{9}\",,,\"690221234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"BL\",590,\"00\",\"0\",,,\"0\",,,,,,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"18\",\"\\\\d{2}\",,,\"18\"],[,,\"NA\",\"NA\"]],BM:[,\n[,,\"[4589]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"441(?:2(?:02|23|61|[3479]\\\\d)|[46]\\\\d{2}|5(?:4\\\\d|60|89)|824)\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"4412345678\"],[,,\"441(?:[37]\\\\d|5[0-39])\\\\d{5}\",\"\\\\d{10}\",,,\"4413701234\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002123456\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002123456\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"BM\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,\"441\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"911\",\"\\\\d{3}\",,,\"911\"],\n[,,\"NA\",\"NA\"]],BN:[,[,,\"[2-578]\\\\d{6}\",\"\\\\d{7}\"],[,,\"[2-5]\\\\d{6}\",\"\\\\d{7}\",,,\"2345678\"],[,,\"[78]\\\\d{6}\",\"\\\\d{7}\",,,\"7123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"BN\",673,\"00\",,,,,,,,[[,\"([2-578]\\\\d{2})(\\\\d{4})\",\"$1 $2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"99[135]\",\"\\\\d{3}\",,,\"991\"],[,,\"NA\",\"NA\"]],BO:[,[,,\"[23467]\\\\d{7}\",\"\\\\d{7,8}\"],[,,\"(?:2(?:2\\\\d{2}|5(?:11|[258]\\\\d|9[67])|6(?:12|2\\\\d|9[34])|8(?:2[34]|39|62))|3(?:3\\\\d{2}|4(?:6\\\\d|8[24])|8(?:25|42|5[257]|86|9[25])|9(?:2\\\\d|3[234]|4[248]|5[24]|6[2-6]|7\\\\d))|4(?:4\\\\d{2}|6(?:11|[24689]\\\\d|72)))\\\\d{4}\",\n\"\\\\d{7,8}\",,,\"22123456\"],[,,\"[67]\\\\d{7}\",\"\\\\d{8}\",,,\"71234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"BO\",591,\"00(1\\\\d)?\",\"0\",,,\"0(1\\\\d)?\",,,,[[,\"([234])(\\\\d{7})\",\"$1 $2\",[\"[234]\"],\"\",\"0$CC $1\",0],[,\"([67]\\\\d{7})\",\"$1\",[\"[67]\"],\"\",\"0$CC $1\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[089]\",\"\\\\d{3}\",,,\"110\"],[,,\"NA\",\"NA\"]],BR:[,[,,\"[1-9]\\\\d{7,9}\",\"\\\\d{8,10}\"],[,,\"1[1-9][2-5]\\\\d{7}|(?:[4689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])[2-5]\\\\d{7}\",\"\\\\d{8,10}\",\n,,\"1123456789\"],[,,\"1(?:1(?:[6-9]\\\\d|5[347])|[2-9][6-9]\\\\d)\\\\d{6}|(?:[4689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])[6-9]\\\\d{7}\",\"\\\\d{10}\",,,\"1161234567\"],[,,\"800\\\\d{6,7}\",\"\\\\d{8,10}\",,,\"800123456\"],[,,\"[359]00\\\\d{6,7}\",\"\\\\d{8,10}\",,,\"300123456\"],[,,\"(?:400\\\\d|3003)\\\\d{4}\",\"\\\\d{8}\",,,\"40041234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"BR\",55,\"00(?:1[45]|2[135]|[34]1|43)\",\"0\",,,\"0(?:(1[245]|2[135]|[34]1)(\\\\d{10}))?\",\"$2\",,,[[,\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1 $2-$3\",[\"[1-9][1-9]\"],\"($1)\",\"0 $CC ($1)\",0],[,\"([34]00\\\\d)(\\\\d{4})\",\n\"$1-$2\",[\"[34]00\",\"400|3003\"],\"\",\"\",0],[,\"([3589]00)(\\\\d{2,3})(\\\\d{4})\",\"$1 $2 $3\",[\"[3589]00\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"(?:400\\\\d|3003)\\\\d{4}\",\"\\\\d{8}\",,,\"40041234\"],[,,\"NA\",\"NA\"],,[,,\"1(?:12|28|9[023])|911\",\"\\\\d{3}\",,,\"190\"],[,,\"NA\",\"NA\"]],BS:[,[,,\"[2589]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"242(?:3(?:02|[236][1-9]|4[0-24-9]|5[0-68]|7[3467]|8[0-4]|9[2-467])|461|502|6(?:12|7[67]|8[78]|9[89])|702)\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"2423456789\"],[,,\"242(?:3(?:5[79]|[79]5)|4(?:[2-4][1-9]|5[1-8]|6[2-8]|7\\\\d|81)|5(?:2[34]|3[35]|44|5[1-9]|65|77)|6[34]6|727)\\\\d{4}\",\n\"\\\\d{10}\",,,\"2423591234\"],[,,\"242300\\\\d{4}|8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002123456\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002123456\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"BS\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,\"242\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"91[19]\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],BT:[,[,,\"[1-8]\\\\d{6,7}\",\"\\\\d{6,8}\"],[,,\"(?:2[3-6]|[34][5-7]|5[236]|6[2-46]|7[246]|8[2-4])\\\\d{5}\",\"\\\\d{6,7}\",,,\"2345678\"],[,,\"[17]7\\\\d{6}\",\"\\\\d{8}\",\n,,\"17123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"BT\",975,\"00\",,,,,,,,[[,\"([17]7)(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"1|77\"],\"\",\"\",0],[,\"([2-8])(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[2-68]|7[246]\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[023]\",\"\\\\d{3}\",,,\"113\"],[,,\"NA\",\"NA\"]],BW:[,[,,\"[2-79]\\\\d{6,7}\",\"\\\\d{7,8}\"],[,,\"(?:2(?:4[0-48]|6[0-24]|9[0578])|3(?:1[0235-9]|55|6\\\\d|7[01]|9[0-57])|4(?:6[03]|7[1267]|9[0-5])|5(?:3[0389]|4[0489]|7[1-47]|88|9[0-49])|6(?:2[1-35]|5[149]|8[067]))\\\\d{4}\",\n\"\\\\d{7}\",,,\"2401234\"],[,,\"7(?:[1-35]\\\\d{6}|[46][0-7]\\\\d{5})\",\"\\\\d{8}\",,,\"71123456\"],[,,\"NA\",\"NA\"],[,,\"90\\\\d{5}\",\"\\\\d{7}\",,,\"9012345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"79[12][01]\\\\d{4}\",\"\\\\d{8}\",,,\"79101234\"],\"BW\",267,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[2-6]\"],\"\",\"\",0],[,\"(7\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"7\"],\"\",\"\",0],[,\"(90)(\\\\d{5})\",\"$1 $2\",[\"9\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"99[789]\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],BY:[,[,,\"[12-4]\\\\d{8}|[89]\\\\d{9,10}\",\"\\\\d{7,11}\"],\n[,,\"(?:1(?:5(?:1[1-5]|2\\\\d|6[1-4]|9[1-7])|6(?:[235]\\\\d|4[1-7])|7\\\\d{2})|2(?:1(?:[246]\\\\d|3[0-35-9]|5[1-9])|2(?:[235]\\\\d|4[0-8])|3(?:2\\\\d|3[02-79]|4[024-7]|5[0-7])))\\\\d{5}\",\"\\\\d{7,9}\",,,\"152450911\"],[,,\"(?:2(?:5[5679]|9[1-9])|33\\\\d|44\\\\d)\\\\d{6}\",\"\\\\d{9}\",,,\"294911911\"],[,,\"8(?:0[13]|20\\\\d)\\\\d{7}\",\"\\\\d{10,11}\",,,\"8011234567\"],[,,\"(?:810|902)\\\\d{7}\",\"\\\\d{10}\",,,\"9021234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"BY\",375,\"810\",\"8\",,,\"80?\",,\"8~10\",,[[,\"([1-4]\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[1-4]\"],\n\"8 0$1\",\"\",0],[,\"([89]\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"8[01]|9\"],\"8 $1\",\"\",0],[,\"(8\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"82\"],\"8 $1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"8(?:[01]|20)\\\\d{8}|902\\\\d{7}\",\"\\\\d{10,11}\",,,\"82012345678\"],[,,\"NA\",\"NA\"],,[,,\"1(?:0[123]|12)\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],BZ:[,[,,\"[2-8]\\\\d{6}|0\\\\d{10}\",\"\\\\d{7}(?:\\\\d{4})?\"],[,,\"[234578][02]\\\\d{5}\",\"\\\\d{7}\",,,\"2221234\"],[,,\"6(?:[0-3]\\\\d|[67][01])\\\\d{4}\",\"\\\\d{7}\",,,\"6221234\"],[,,\"0800\\\\d{7}\",\"\\\\d{11}\",,,\"08001234123\"],[,,\"NA\",\"NA\"],\n[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"BZ\",501,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1-$2\",[\"[2-8]\"],\"\",\"\",0],[,\"(0)(800)(\\\\d{4})(\\\\d{3})\",\"$1-$2-$3-$4\",[\"0\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],1,[,,\"9(?:0|11)\",\"\\\\d{2,3}\",,,\"911\"],[,,\"NA\",\"NA\"]],CA:[,[,,\"[2-9]\\\\d{9}|3\\\\d{6}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"(?:2(?:04|26|[48]9|50)|3(?:06|43)|4(?:03|1[68]|38|5[06])|5(?:0[06]|1[49]|79|8[17])|6(?:0[04]|13|47)|7(?:0[059]|80|78)|8(?:[06]7|19|)|90[25])[2-9]\\\\d{6}|310\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",\n,,\"2042345678\"],[,,\"(?:2(?:04|26|[48]9|50)|3(?:06|43)|4(?:03|1[68]|38|5[06])|5(?:0[06]|1[49]|79|8[17])|6(?:0[04]|13|47)|7(?:0[059]|80|78)|8(?:[06]7|19|)|90[25])[2-9]\\\\d{6}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"2042345678\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}|310\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"8002123456\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002123456\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"CA\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112|911\",\n\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],CC:[,[,,\"[1458]\\\\d{5,9}\",\"\\\\d{6,10}\"],[,,\"89162\\\\d{4}\",\"\\\\d{8,9}\",,,\"891621234\"],[,,\"4(?:[0-2]\\\\d|3[0-57-9]|4[47-9]|5[0-37-9]|6[6-9]|7[07-9]|8[7-9])\\\\d{6}\",\"\\\\d{9}\",,,\"412345678\"],[,,\"1(?:80(?:0\\\\d{2})?|3(?:00\\\\d{2})?)\\\\d{4}\",\"\\\\d{6,10}\",,,\"1800123456\"],[,,\"190[0126]\\\\d{6}\",\"\\\\d{10}\",,,\"1900123456\"],[,,\"NA\",\"NA\"],[,,\"500\\\\d{6}\",\"\\\\d{9}\",,,\"500123456\"],[,,\"550\\\\d{6}\",\"\\\\d{9}\",,,\"550123456\"],\"CC\",61,\"(?:14(?:1[14]|34|4[17]|[56]6|7[47]|88))?001[14-689]\",\"0\",,,\"0\",,\"0011\",\n,,,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"000|112\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],CD:[,[,,\"[89]\\\\d{8}|[1-6]\\\\d{6}\",\"\\\\d{7,9}\"],[,,\"[1-6]\\\\d{6}\",\"\\\\d{7}\",,,\"1234567\"],[,,\"(?:8[0-2489]|9[7-9])\\\\d{7}\",\"\\\\d{9}\",,,\"991234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"CD\",243,\"00\",\"0\",,,\"0\",,,,[[,\"([89]\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[89]\"],\"0$1\",\"\",0],[,\"([1-6]\\\\d)(\\\\d{5})\",\"$1 $2\",[\"[1-6]\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"NA\",\n\"NA\"],[,,\"NA\",\"NA\"]],CF:[,[,,\"[278]\\\\d{7}\",\"\\\\d{8}\"],[,,\"2[12]\\\\d{6}\",\"\\\\d{8}\",,,\"21612345\"],[,,\"7[0257]\\\\d{6}\",\"\\\\d{8}\",,,\"70012345\"],[,,\"NA\",\"NA\"],[,,\"8776\\\\d{4}\",\"\\\\d{8}\",,,\"87761234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"CF\",236,\"00\",,,,,,,,[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"]],CG:[,[,,\"[028]\\\\d{8}\",\"\\\\d{9}\"],[,,\"222[1-589]\\\\d{5}\",\"\\\\d{9}\",,,\"222123456\"],[,,\"0[14-6]\\\\d{7}\",\"\\\\d{9}\",,,\"061234567\"],\n[,,\"800\\\\d{6}\",\"\\\\d{9}\",,,\"800123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"CG\",242,\"00\",,,,,,,,[[,\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[02]\"],\"\",\"\",0],[,\"(\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"8\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],1,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"]],CH:[,[,,\"[2-9]\\\\d{8}|860\\\\d{9}\",\"\\\\d{9}(?:\\\\d{3})?\"],[,,\"(?:2[12467]|3[1-4]|4[134]|5[12568]|6[12]|[7-9]1)\\\\d{7}\",\"\\\\d{9}\",,,\"212345678\"],[,,\"7[46-9]\\\\d{7}\",\"\\\\d{9}\",,,\"741234567\"],[,,\"800\\\\d{6}\",\"\\\\d{9}\",\n,,\"800123456\"],[,,\"90[016]\\\\d{6}\",\"\\\\d{9}\",,,\"900123456\"],[,,\"84[0248]\\\\d{6}\",\"\\\\d{9}\",,,\"840123456\"],[,,\"878\\\\d{6}\",\"\\\\d{9}\",,,\"878123456\"],[,,\"NA\",\"NA\"],\"CH\",41,\"00\",\"0\",,,\"0\",,,,[[,\"([2-9]\\\\d)(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[2-7]|[89]1\"],\"0$1\",\"\",0],[,\"([89]\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"8[047]|90\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4 $5\",[\"860\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:1[278]|44)\",\"\\\\d{3}\",,,\"112\"],[,\n,\"860\\\\d{9}\",\"\\\\d{12}\",,,\"860123456789\"]],CI:[,[,,\"[02-6]\\\\d{7}\",\"\\\\d{8}\"],[,,\"(?:2(?:0[023]|1[02357]|[23][045]|4[03-5])|3(?:0[06]|1[069]|[2-4][07]|5[09]|6[08]))\\\\d{5}\",\"\\\\d{8}\",,,\"21234567\"],[,,\"(?:0[1-9]|4[04-9]|5[057-9]|6[05679])\\\\d{6}\",\"\\\\d{8}\",,,\"01234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"CI\",225,\"00\",,,,,,,,[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],1,[,,\"1(?:1[01]|[78]0)\",\"\\\\d{3}\",,,\"110\"],\n[,,\"NA\",\"NA\"]],CK:[,[,,\"[2-57]\\\\d{4}\",\"\\\\d{5}\"],[,,\"(?:2\\\\d|3[13-7]|4[1-5])\\\\d{3}\",\"\\\\d{5}\",,,\"21234\"],[,,\"(?:5[0-68]|7\\\\d)\\\\d{3}\",\"\\\\d{5}\",,,\"71234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"CK\",682,\"00\",,,,,,,,[[,\"(\\\\d{2})(\\\\d{3})\",\"$1 $2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"99[689]\",\"\\\\d{3}\",,,\"998\"],[,,\"NA\",\"NA\"]],CL:[,[,,\"(?:[2-9]|600|123)\\\\d{7,8}\",\"\\\\d{6,11}\"],[,,\"(?:2|32|41)\\\\d{7}|(?:3[3-5]|4[235]|5[1-3578]|6[13-57]|7[1-35])\\\\d{6,7}\",\"\\\\d{6,9}\",\n,,\"21234567\"],[,,\"9[6-9]\\\\d{7}\",\"\\\\d{8,9}\",,,\"961234567\"],[,,\"800\\\\d{6}|1230\\\\d{7}\",\"\\\\d{9,11}\",,,\"800123456\"],[,,\"NA\",\"NA\"],[,,\"600\\\\d{7,8}\",\"\\\\d{10,11}\",,,\"6001234567\"],[,,\"NA\",\"NA\"],[,,\"44\\\\d{7}\",\"\\\\d{9}\",,,\"441234567\"],\"CL\",56,\"(?:0|1(?:1[0-69]|2[0-57]|5[13-58]|69|7[0167]|8[018]))0\",\"0\",,,\"0|(1(?:1[0-69]|2[0-57]|5[13-58]|69|7[0167]|8[018]))\",,,,[[,\"(2)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"2\"],\"($1)\",\"$CC ($1)\",0],[,\"(\\\\d{2})(\\\\d{2,3})(\\\\d{4})\",\"$1 $2 $3\",[\"[357]|4[1-35]|6[13-57]\"],\"($1)\",\"$CC ($1)\",\n0],[,\"(9)([6-9]\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"9\"],\"0$1\",\"\",0],[,\"(44)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"44\"],\"0$1\",\"\",0],[,\"([68]00)(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"60|8\"],\"$1\",\"\",0],[,\"(600)(\\\\d{3})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"60\"],\"$1\",\"\",0],[,\"(1230)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"],\"$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"600\\\\d{7,8}\",\"\\\\d{10,11}\",,,\"6001234567\"],[,,\"NA\",\"NA\"],,[,,\"13[123]\",\"\\\\d{3}\",,,\"133\"],[,,\"NA\",\"NA\"]],CM:[,[,,\"[237-9]\\\\d{7}\",\"\\\\d{8}\"],[,,\"(?:22|33)\\\\d{6}\",\"\\\\d{8}\",,,\"22123456\"],\n[,,\"[79]\\\\d{7}\",\"\\\\d{8}\",,,\"71234567\"],[,,\"800\\\\d{5}\",\"\\\\d{8}\",,,\"80012345\"],[,,\"88\\\\d{6}\",\"\\\\d{8}\",,,\"88012345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"CM\",237,\"00\",,,,,,,,[[,\"([237-9]\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[2379]|88\"],\"\",\"\",0],[,\"(800)(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"80\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1?1[37]\",\"\\\\d{2,3}\",,,\"113\"],[,,\"NA\",\"NA\"]],CN:[,[,,\"[1-79]\\\\d{7,11}|8[0-357-9]\\\\d{6,9}\",\"\\\\d{4,12}\"],[,,\"21\\\\d{8,10}|(?:10|2[02-57-9]|3(?:11|7[179])|4(?:[15]1|3[12])|5(?:1\\\\d|2[37]|3[12]|7[13-79]|9[15])|7(?:31|5[457]|6[09]|91)|898)\\\\d{8}|(?:3(?:1[02-9]|35|49|5\\\\d|7[02-68]|9[1-68])|4(?:1[02-9]|2[179]|3[3-9]|5[2-9]|6[4789]|7\\\\d|8[23])|5(?:3[03-9]|4[36]|5\\\\d|6[1-6]|7[028]|80|9[2-46-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[17]\\\\d|2[248]|3[04-9]|4[3-6]|5[0-3689]|6[2368]|9[02-9])|8(?:1[236-8]|2[5-7]|[37]\\\\d|5[1-9]|8[3678]|9[1-7])|9(?:0[1-3689]|1[1-79]|[379]\\\\d|4[13]|5[1-5]))\\\\d{7}|80(?:29|6[03578]|7[018]|81)\\\\d{4}\",\n\"\\\\d{4,12}\",,,\"1012345678\"],[,,\"1(?:3\\\\d|4[57]|5[0-35-9]|8[0235-9])\\\\d{8}\",\"\\\\d{11}\",,,\"13123456789\"],[,,\"(?:10)?800\\\\d{7}\",\"\\\\d{10,12}\",,,\"8001234567\"],[,,\"16[08]\\\\d{5}\",\"\\\\d{8}\",,,\"16812345\"],[,,\"400\\\\d{7}\",\"\\\\d{10}\",,,\"4001234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"CN\",86,\"00\",\"0\",,,\"0\",,,,[[,\"(80\\\\d{2})(\\\\d{4})\",\"$1 $2\",[\"80[2678]\"],\"0$1\",\"\",1],[,\"([48]00)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[48]00\"],\"\",\"\",0],[,\"(\\\\d{3,4})(\\\\d{4})\",\"$1 $2\",[\"[2-9]\"],\"\",\"\",0],[,\"(21)(\\\\d{4})(\\\\d{4,6})\",\"$1 $2 $3\",[\"21\"],\n\"0$1\",\"\",1],[,\"([12]\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"10[1-9]|2[02-9]\",\"10[1-9]|2[02-9]\",\"10(?:[1-79]|8(?:[1-9]|0[1-9]))|2[02-9]\"],\"0$1\",\"\",1],[,\"(\\\\d{3})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"3(?:11|7[179])|4(?:[15]1|3[12])|5(?:1|2[37]|3[12]|7[13-79]|9[15])|7(?:31|5[457]|6[09]|91)|898\"],\"0$1\",\"\",1],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"3(?:1[02-9]|35|49|5|7[02-68]|9[1-68])|4(?:1[02-9]|2[179]|[35][2-9]|6[4789]|7\\\\d|8[23])|5(?:3[03-9]|4[36]|5|6[1-6]|7[028]|80|9[2-46-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[04-9]|4[3-6]|6[2368])|8(?:1[236-8]|2[5-7]|[37]|5[1-9]|8[3678]|9[1-7])|9(?:0[1-3689]|1[1-79]|[379]|4[13]|5[1-5])\"],\n\"0$1\",\"\",1],[,\"(1[3-58]\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"1[3-58]\"],\"\",\"\",0],[,\"(10800)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"108\",\"1080\",\"10800\"],\"\",\"\",0]],[[,\"(80\\\\d{2})(\\\\d{4})\",\"$1 $2\",[\"80[2678]\"]],[,\"([48]00)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[48]00\"]],[,\"(21)(\\\\d{4})(\\\\d{4,6})\",\"$1 $2 $3\",[\"21\"]],[,\"([12]\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"10[1-9]|2[02-9]\",\"10[1-9]|2[02-9]\",\"10(?:[1-79]|8(?:[1-9]|0[1-9]))|2[02-9]\"]],[,\"(\\\\d{3})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"3(?:11|7[179])|4(?:[15]1|3[12])|5(?:1|2[37]|3[12]|7[13-79]|9[15])|7(?:31|5[457]|6[09]|91)|898\"]],\n[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"3(?:1[02-9]|35|49|5|7[02-68]|9[1-68])|4(?:1[02-9]|2[179]|[35][2-9]|6[4789]|7\\\\d|8[23])|5(?:3[03-9]|4[36]|5|6[1-6]|7[028]|80|9[2-46-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[04-9]|4[3-6]|6[2368])|8(?:1[236-8]|2[5-7]|[37]|5[1-9]|8[3678]|9[1-7])|9(?:0[1-3689]|1[1-79]|[379]|4[13]|5[1-5])\"]],[,\"(1[3-58]\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"1[3-58]\"]],[,\"(10800)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"108\",\"1080\",\"10800\"]]],[,,\"NA\",\"NA\"],,,[,,\"(?:4|(?:10)?8)00\\\\d{7}\",\n\"\\\\d{10,12}\",,,\"4001234567\"],[,,\"NA\",\"NA\"],,[,,\"1(?:1[09]|20)\",\"\\\\d{3}\",,,\"119\"],[,,\"NA\",\"NA\"]],CO:[,[,,\"(?:[13]\\\\d{0,3}|[24-8])\\\\d{7}\",\"\\\\d{7,11}\"],[,,\"[124-8][2-9]\\\\d{6}\",\"\\\\d{8}\",,,\"12345678\"],[,,\"3(?:0[0-24]|1[0-8]|2[01])\\\\d{7}\",\"\\\\d{10}\",,,\"3211234567\"],[,,\"1800\\\\d{7}\",\"\\\\d{11}\",,,\"18001234567\"],[,,\"19(?:0[01]|4[78])\\\\d{7}\",\"\\\\d{11}\",,,\"19001234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"CO\",57,\"00[579]|#555|#999\",\"0\",,,\"0([3579]|4(?:44|56))?\",,,,[[,\"(\\\\d)(\\\\d{7})\",\"$1 $2\",[\"1(?:8[2-9]|9[0-3]|[2-7])|[24-8]\",\n\"1(?:8[2-9]|9(?:09|[1-3])|[2-7])|[24-8]\"],\"($1)\",\"0$CC $1\",0],[,\"(\\\\d{3})(\\\\d{7})\",\"$1 $2\",[\"3\"],\"\",\"0$CC $1\",0],[,\"(1)(\\\\d{3})(\\\\d{7})\",\"$1-$2-$3\",[\"1(?:80|9[04])\",\"1(?:800|9(?:0[01]|4[78]))\"],\"0$1\",\"\",0]],[[,\"(\\\\d)(\\\\d{7})\",\"$1 $2\",[\"1(?:8[2-9]|9[0-3]|[2-7])|[24-8]\",\"1(?:8[2-9]|9(?:09|[1-3])|[2-7])|[24-8]\"]],[,\"(\\\\d{3})(\\\\d{7})\",\"$1 $2\",[\"3\"]],[,\"(1)(\\\\d{3})(\\\\d{7})\",\"$1 $2 $3\",[\"1(?:80|9[04])\",\"1(?:800|9(?:0[01]|4[78]))\"]]],[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:1[29]|23|32|56)\",\n\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],CR:[,[,,\"[24-9]\\\\d{7,9}\",\"\\\\d{8,10}\"],[,,\"2[24-7]\\\\d{6}\",\"\\\\d{8}\",,,\"22123456\"],[,,\"5(?:0[0-4]|7[01])\\\\d{5}|[67][01]\\\\d{6}|8[36-9]\\\\d{6}\",\"\\\\d{8}\",,,\"83123456\"],[,,\"800\\\\d{7}\",\"\\\\d{10}\",,,\"8001234567\"],[,,\"90[059]\\\\d{7}\",\"\\\\d{10}\",,,\"9001234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"40(?:00\\\\d{4}|10[0-3]\\\\d{3}|2(?:00\\\\d|900)\\\\d{2}|3[01]\\\\d{4}|5\\\\d{5})\",\"\\\\d{8}\",,,\"40001234\"],\"CR\",506,\"00\",,,,\"(19(?:0[0-2]|19|77))\",,,,[[,\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[24-7]|8[3-9]\"],\"\",\"$CC $1\",\n0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\",[\"[89]0\"],\"\",\"$CC $1\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112|911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],CU:[,[,,\"[2-57]\\\\d{5,7}\",\"\\\\d{4,8}\"],[,,\"2[1-4]\\\\d{5,6}|3(?:1\\\\d{6}|[23]\\\\d{4,6})|4(?:[125]\\\\d{5,6}|[36]\\\\d{6}|[78]\\\\d{4,6})|7\\\\d{6,7}\",\"\\\\d{4,8}\",,,\"71234567\"],[,,\"5\\\\d{7}\",\"\\\\d{8}\",,,\"51234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"CU\",53,\"119\",\"0\",,,\"0\",,,,[[,\"(\\\\d)(\\\\d{6,7})\",\"$1 $2\",[\"7\"],\"(0$1)\",\"\",\n0],[,\"(\\\\d{2})(\\\\d{4,6})\",\"$1 $2\",[\"[2-4]\"],\"(0$1)\",\"\",0],[,\"(\\\\d)(\\\\d{7})\",\"$1 $2\",[\"5\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"10[56]\",\"\\\\d{3}\",,,\"106\"],[,,\"NA\",\"NA\"]],CV:[,[,,\"[259]\\\\d{6}\",\"\\\\d{7}\"],[,,\"2(?:2[1-7]|3[0-8]|4[12]|5[1256]|6\\\\d|7[1-3]|8[1-5])\\\\d{4}\",\"\\\\d{7}\",,,\"2211234\"],[,,\"(?:9\\\\d|59)\\\\d{5}\",\"\\\\d{7}\",,,\"9911234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"CV\",238,\"0\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",,\"\",\"\",0]],,[,\n,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"13[012]\",\"\\\\d{3}\",,,\"132\"],[,,\"NA\",\"NA\"]],CY:[,[,,\"[257-9]\\\\d{7}\",\"\\\\d{8}\"],[,,\"2[2-6]\\\\d{6}\",\"\\\\d{8}\",,,\"22345678\"],[,,\"9[5-79]\\\\d{6}\",\"\\\\d{8}\",,,\"96123456\"],[,,\"800\\\\d{5}\",\"\\\\d{8}\",,,\"80001234\"],[,,\"90[09]\\\\d{5}\",\"\\\\d{8}\",,,\"90012345\"],[,,\"80[1-9]\\\\d{5}\",\"\\\\d{8}\",,,\"80112345\"],[,,\"700\\\\d{5}\",\"\\\\d{8}\",,,\"70012345\"],[,,\"NA\",\"NA\"],\"CY\",357,\"00\",,,,,,,,[[,\"(\\\\d{2})(\\\\d{6})\",\"$1 $2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"(?:50|77)\\\\d{6}\",\"\\\\d{8}\",\n,,\"77123456\"],,[,,\"1(?:12|99)\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],CX:[,[,,\"[1458]\\\\d{5,9}\",\"\\\\d{6,10}\"],[,,\"89164\\\\d{4}\",\"\\\\d{8,9}\",,,\"891641234\"],[,,\"4(?:[0-2]\\\\d|3[0-57-9]|4[47-9]|5[0-37-9]|6[6-9]|7[07-9]|8[7-9])\\\\d{6}\",\"\\\\d{9}\",,,\"412345678\"],[,,\"1(?:80(?:0\\\\d{2})?|3(?:00\\\\d{2})?)\\\\d{4}\",\"\\\\d{6,10}\",,,\"1800123456\"],[,,\"190[0126]\\\\d{6}\",\"\\\\d{10}\",,,\"1900123456\"],[,,\"NA\",\"NA\"],[,,\"500\\\\d{6}\",\"\\\\d{9}\",,,\"500123456\"],[,,\"550\\\\d{6}\",\"\\\\d{9}\",,,\"550123456\"],\"CX\",61,\"(?:14(?:1[14]|34|4[17]|[56]6|7[47]|88))?001[14-689]\",\n\"0\",,,\"0\",,\"0011\",,,,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"000|112\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],CZ:[,[,,\"[2-9]\\\\d{8}\",\"\\\\d{9}\"],[,,\"2\\\\d{8}|(?:3[1257-9]|4[16-9]|5[13-9])\\\\d{7}\",\"\\\\d{9}\",,,\"212345678\"],[,,\"(?:60[1-8]|7(?:0[25]|[2379]\\\\d))\\\\d{6}\",\"\\\\d{9}\",,,\"601123456\"],[,,\"800\\\\d{6}\",\"\\\\d{9}\",,,\"800123456\"],[,,\"9(?:0[05689]|76)\\\\d{6}\",\"\\\\d{9}\",,,\"900123456\"],[,,\"8[134]\\\\d{7}\",\"\\\\d{9}\",,,\"811234567\"],[,,\"70[01]\\\\d{6}\",\"\\\\d{9}\",,,\"700123456\"],[,,\"9[17]0\\\\d{6}\",\"\\\\d{9}\",,,\"910123456\"],\n\"CZ\",420,\"00\",,,,,,,,[[,\"([2-9]\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"9(?:5[056]|7[234])\\\\d{6}\",\"\\\\d{9}\",,,\"972123456\"],,[,,\"1(?:12|5[058])\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],DE:[,[,,\"[1-35-9]\\\\d{3,14}|4(?:[0-8]\\\\d{4,12}|9(?:4[1-8]|[0-35-7]\\\\d)\\\\d{2,7})\",\"\\\\d{2,15}\"],[,,\"[246]\\\\d{5,13}|3(?:[03-9]\\\\d{4,13}|2\\\\d{9})|5(?:0[2-8]|[1256]\\\\d|[38][0-8]|4\\\\d{0,2}|[79][0-7])\\\\d{3,11}|7(?:0[2-8]|[1-9]\\\\d)\\\\d{3,10}|8(?:0[2-9]|[1-9]\\\\d)\\\\d{3,10}|9(?:0[6-9]|[1-9]\\\\d)\\\\d{3,10}\",\n\"\\\\d{2,15}\",,,\"30123456\"],[,,\"1(?:5[0-2579]\\\\d{8}|6[023]\\\\d{7,8}|7(?:[0-57-9]\\\\d?|6\\\\d)\\\\d{7})\",\"\\\\d{10,11}\",,,\"15123456789\"],[,,\"800\\\\d{7,9}\",\"\\\\d{10,12}\",,,\"8001234567\"],[,,\"900(?:[135]\\\\d{6}|9\\\\d{7})\",\"\\\\d{10,11}\",,,\"9001234567\"],[,,\"180\\\\d{5,11}\",\"\\\\d{8,14}\",,,\"18012345\"],[,,\"700\\\\d{8}\",\"\\\\d{11}\",,,\"70012345678\"],[,,\"NA\",\"NA\"],\"DE\",49,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d{2})(\\\\d{4,11})\",\"$1/$2\",[\"3[02]|40|[68]9\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{3,11})\",\"$1/$2\",[\"2(?:\\\\d1|0[2389]|1[24]|28|34)|3(?:[3-9][15]|40)|[4-8][1-9]1|9(?:06|[1-9]1)\"],\n\"0$1\",\"\",0],[,\"(\\\\d{4})(\\\\d{2,11})\",\"$1/$2\",[\"[24-6]|[7-9](?:\\\\d[1-9]|[1-9]\\\\d)|3(?:[3569][02-46-9]|4[2-4679]|7[2-467]|8[2-46-8])\",\"[24-6]|[7-9](?:\\\\d[1-9]|[1-9]\\\\d)|3(?:3(?:0[1-467]|2[127-9]|3[124578]|[46][1246]|7[1257-9]|8[1256]|9[145])|4(?:2[135]|3[1357]|4[13578]|6[1246]|7[1356]|9[1346])|5(?:0[14]|2[1-3589]|3[1357]|4[1246]|6[1-4]|7[1346]|8[13568]|9[1246])|6(?:0[356]|2[1-489]|3[124-6]|4[1347]|6[13]|7[12579]|8[1-356]|9[135])|7(?:2[1-7]|3[1357]|4[145]|6[1-5]|7[1-4])|8(?:21|3[1468]|4[1347]|6[0135-9]|7[1467]|8[136])|9(?:0[12479]|2[1358]|3[1357]|4[134679]|6[1-9]|7[136]|8[147]|9[1468]))\"],\n\"0$1\",\"\",0],[,\"(\\\\d{5})(\\\\d{1,10})\",\"$1/$2\",[\"3\"],\"0$1\",\"\",0],[,\"([18]\\\\d{2})(\\\\d{7,9})\",\"$1 $2\",[\"1[5-7]|800\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d)(\\\\d{4,10})\",\"$1 $2 $3\",[\"(?:18|90)0\",\"180|900[1359]\"],\"0$1\",\"\",0],[,\"(700)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"700\"],\"0$1\",\"\",0]],,[,,\"16(?:4\\\\d{1,10}|[89]\\\\d{1,11})\",\"\\\\d{4,14}\",,,\"16412345\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[02]\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],DJ:[,[,,\"[1-8]\\\\d{5}\",\"\\\\d{6}\"],[,,\"(?:1[05]|[2-5]\\\\d)\\\\d{4}\",\"\\\\d{6}\",,,\"251234\"],[,,\"[6-8]\\\\d{5}\",\n\"\\\\d{6}\",,,\"601234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"DJ\",253,\"00\",,,,,,,,[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1[78]\",\"\\\\d{2}\",,,\"17\"],[,,\"NA\",\"NA\"]],DK:[,[,,\"[2-9]\\\\d{7}\",\"\\\\d{8}\"],[,,\"(?:[2-7]\\\\d|8[126-9]|9[6-9])\\\\d{6}\",\"\\\\d{8}\",,,\"32123456\"],[,,\"(?:[2-7]\\\\d|8[126-9]|9[6-9])\\\\d{6}\",\"\\\\d{8}\",,,\"20123456\"],[,,\"80\\\\d{6}\",\"\\\\d{8}\",,,\"80123456\"],[,,\"90\\\\d{6}\",\"\\\\d{8}\",,,\"90123456\"],[,,\"NA\",\"NA\"],[,\n,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"DK\",45,\"00\",,,,,,,1,[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],DM:[,[,,\"[57-9]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"767(?:2(?:55|66)|4(?:2[01]|4[0-25-9])|50[0-4])\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"7674201234\"],[,,\"767(?:2(?:[234689]5|7[5-7])|31[5-7]|61[2-7])\\\\d{4}\",\"\\\\d{10}\",,,\"7672251234\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002123456\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",\n,,\"9002123456\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"DM\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,\"767\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"333|9(?:11|99)\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],DO:[,[,,\"[589]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"8(?:[04]9[2-9]\\\\d{6}|29(?:2(?:[0-59]\\\\d|6[04-9]|7[0-27]|8[0237-9])|3(?:[0-35-9]\\\\d|4[7-9])|[45]\\\\d{2}|6(?:[0-27-9]\\\\d|[3-5][1-9]|6[0135-8])|7(?:0[013-9]|[1-37]\\\\d|4[1-35689]|5[1-4689]|6[1-57-9]|8[1-79]|9[1-8])|8(?:0[146-9]|1[0-48]|[248]\\\\d|3[1-79]|5[01589]|6[013-68]|7[124-8]|9[0-8])|9(?:[0-24]\\\\d|3[02-46-9]|5[0-79]|60|7[0169]|8[57-9]|9[02-9]))\\\\d{4})\",\n\"\\\\d{7}(?:\\\\d{3})?\",,,\"8092345678\"],[,,\"8[024]9[2-9]\\\\d{6}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"8092345678\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002123456\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002123456\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"DO\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,\"8[024]9\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112|911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],DZ:[,[,,\"(?:[1-4]|[5-9]\\\\d)\\\\d{7}\",\"\\\\d{8,9}\"],[,,\"(?:1\\\\d|2[014-79]|3[0-8]|4[0135689])\\\\d{6}|9619\\\\d{5}\",\n\"\\\\d{8,9}\",,,\"12345678\"],[,,\"(?:5[56]|6[569]|7[7-9])\\\\d{7}\",\"\\\\d{9}\",,,\"551234567\"],[,,\"800\\\\d{6}\",\"\\\\d{9}\",,,\"800123456\"],[,,\"80[3-689]1\\\\d{5}\",\"\\\\d{9}\",,,\"808123456\"],[,,\"80[12]1\\\\d{5}\",\"\\\\d{9}\",,,\"801123456\"],[,,\"NA\",\"NA\"],[,,\"98[23]\\\\d{6}\",\"\\\\d{9}\",,,\"983123456\"],\"DZ\",213,\"00\",\"0\",,,\"0\",,,,[[,\"([1-4]\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[1-4]\"],\"0$1\",\"\",0],[,\"([5-8]\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[5-8]\"],\"0$1\",\"\",0],[,\"(9\\\\d)(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"9\"],\n\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1[47]\",\"\\\\d{2}\",,,\"17\"],[,,\"NA\",\"NA\"]],EC:[,[,,\"[2-9]\\\\d{7}|1\\\\d{9,10}\",\"\\\\d{7,11}\"],[,,\"[2-7][2-7]\\\\d{6}\",\"\\\\d{7,8}\",,,\"22123456\"],[,,\"(?:69|[89]\\\\d)\\\\d{6}\",\"\\\\d{8}\",,,\"99123456\"],[,,\"1800\\\\d{6,7}\",\"\\\\d{10,11}\",,,\"18001234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"EC\",593,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2-$3\",[\"[2-57]|6[2-7]\"],\"(0$1)\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"69|[89]\"],\"0$1\",\n\"\",0],[,\"(1800)(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"1\"],\"$1\",\"\",0]],[[,\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\",[\"[2-57]|6[2-7]\"]],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"69|[89]\"]],[,\"(1800)(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"1\"]]],[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:0[12]|12)|911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],EE:[,[,,\"[3-9]\\\\d{6,7}|800\\\\d{6,7}\",\"\\\\d{7,10}\"],[,,\"(?:3[23589]|4(?:0\\\\d|[3-8])|6\\\\d|7[1-9]|88)\\\\d{5}\",\"\\\\d{7,8}\",,,\"3212345\"],[,,\"(?:5\\\\d|8[1-5])\\\\d{6}|5(?:[02]\\\\d{2}|1(?:[0-8]\\\\d|95)|5[0-478]\\\\d|64[0-4]|65[1-589])\\\\d{3}\",\n\"\\\\d{7,8}\",,,\"51234567\"],[,,\"800(?:0\\\\d{3}|1\\\\d|[2-9])\\\\d{3}\",\"\\\\d{7,10}\",,,\"80012345\"],[,,\"900\\\\d{4}\",\"\\\\d{7}\",,,\"9001234\"],[,,\"NA\",\"NA\"],[,,\"70[0-2]\\\\d{5}\",\"\\\\d{8}\",,,\"70012345\"],[,,\"NA\",\"NA\"],\"EE\",372,\"00\",,,,,,,,[[,\"([34-79]\\\\d{2})(\\\\d{4})\",\"$1 $2\",[\"[369]|4[3-8]|5(?:[0-2]|5[0-478]|6[45])|7[1-9]\",\"[369]|4[3-8]|5(?:[02]|1(?:[0-8]|95)|5[0-478]|6(?:4[0-4]|5[1-589]))|7[1-9]\"],\"\",\"\",0],[,\"(70)(\\\\d{2})(\\\\d{4})\",\"$1 $2 $3\",[\"70\"],\"\",\"\",0],[,\"(8000)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"800\",\"8000\"],\"\",\"\",0],\n[,\"([458]\\\\d{3})(\\\\d{3,4})\",\"$1 $2\",[\"40|5|8(?:00|[1-5])\",\"40|5|8(?:00[1-9]|[1-5])\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"800[2-9]\\\\d{3}\",\"\\\\d{7}\",,,\"8002123\"],[,,\"NA\",\"NA\"],,[,,\"11[02]\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],EG:[,[,,\"1\\\\d{4,9}|[2456]\\\\d{8}|3\\\\d{7}|[89]\\\\d{8,9}\",\"\\\\d{5,10}\"],[,,\"(?:1[35][23]|2[23]\\\\d|3\\\\d|4(?:0[2-4]|[578][23]|64)|5(?:0[234]|[57][23])|6[24-689]3|8(?:[28][2-4]|42|6[23])|9(?:[25]2|3[24]|6[23]|7[2-4]))\\\\d{6}|1[69]\\\\d{3}\",\"\\\\d{5,9}\",,,\"234567890\"],[,,\"1(?:[0-246-9]|5[0-2])\\\\d{7}|1(?:0[0169]|1[124]|2[0278])\\\\d{7}\",\n\"\\\\d{9,10}\",,,\"1001234567\"],[,,\"800\\\\d{7}\",\"\\\\d{10}\",,,\"8001234567\"],[,,\"900\\\\d{7}\",\"\\\\d{10}\",,,\"9001234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"EG\",20,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d)(\\\\d{7,8})\",\"$1 $2\",[\"[23]\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1(?:0[0169]|1[124]|2[0278]|5[0-2])|[89]00\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1(?:[0-246-9]|5[3-9])\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{7})\",\"$1 $2\",[\"13|[4-6]|[89][2-9]\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,\n,\"NA\",\"NA\"],,[,,\"1(?:2[23]|80)\",\"\\\\d{3}\",,,\"122\"],[,,\"NA\",\"NA\"]],ER:[,[,,\"[178]\\\\d{6}\",\"\\\\d{6,7}\"],[,,\"1(?:1[12568]|20|40|55|6[146])\\\\d{4}|8\\\\d{6}\",\"\\\\d{6,7}\",,,\"8370362\"],[,,\"17[1-3]\\\\d{4}|7\\\\d{6}\",\"\\\\d{7}\",,,\"7123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"ER\",291,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",,\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"]],ES:[,[,,\"[5-9]\\\\d{8}\",\"\\\\d{9}\"],[,,\"(?:8(?:[13]0|[28][0-8]|[47][1-9]|5[01346-9]|6[0457-9])|9(?:[1238][0-8]|[47][1-9]|[56]\\\\d))\\\\d{6}\",\n\"\\\\d{9}\",,,\"810123456\"],[,,\"(?:6\\\\d|7[1-4])\\\\d{7}\",\"\\\\d{9}\",,,\"612345678\"],[,,\"[89]00\\\\d{6}\",\"\\\\d{9}\",,,\"800123456\"],[,,\"80[367]\\\\d{6}\",\"\\\\d{9}\",,,\"803123456\"],[,,\"90[12]\\\\d{6}\",\"\\\\d{9}\",,,\"901123456\"],[,,\"70\\\\d{7}\",\"\\\\d{9}\",,,\"701234567\"],[,,\"NA\",\"NA\"],\"ES\",34,\"00\",,,,,,,,[[,\"([5-9]\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"51\\\\d{7}\",\"\\\\d{9}\",,,\"511234567\"],,[,,\"0(?:61|8[05]|9[12])|112\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],ET:[,[,,\"[1-59]\\\\d{8}\",\"\\\\d{7,9}\"],\n[,,\"(?:11(?:1(?:1[124]|2[2-57]|3[1-5]|5[5-8]|8[6-8])|2(?:13|3[6-8]|5[89]|7[05-9]|8[2-6])|3(?:2[01]|3[0-289]|4[1289]|7[1-4]|87)|4(?:1[69]|3[2-49]|4[0-23]|6[5-8])|5(?:1[57]|44|5[0-4])|6(?:18|2[69]|4[5-7]|5[1-5]|6[0-59]|8[015-8]))|2(?:2(?:11[1-9]|22[0-7]|33\\\\d|44[1467]|66[1-68])|5(?:11[124-6]|33[2-8]|44[1467]|55[14]|66[1-3679]|77[124-79]|880))|3(?:3(?:11[0-46-8]|22[0-6]|33[0134689]|44[04]|55[0-6]|66[01467])|4(?:44[0-8]|55[0-69]|66[0-3]|77[1-5]))|4(?:6(?:22[0-24-7]|33[1-5]|44[13-69]|55[14-689]|660|88[1-4])|7(?:11[1-9]|22[1-9]|33[13-7]|44[13-6]|55[1-689]))|5(?:7(?:227|55[05]|(?:66|77)[14-8])|8(?:11[149]|22[013-79]|33[0-68]|44[013-8]|550|66[1-5]|77\\\\d)))\\\\d{4}\",\n\"\\\\d{7,9}\",,,\"111112345\"],[,,\"9[12]\\\\d{7}\",\"\\\\d{9}\",,,\"911234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"ET\",251,\"00\",\"0\",,,\"0\",,,,[[,\"([1-59]\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",,\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"9(?:11?|[23]|9[17])\",\"\\\\d{2,3}\",,,\"991\"],[,,\"NA\",\"NA\"]],FI:[,[,,\"1\\\\d{4,11}|[2-9]\\\\d{4,10}\",\"\\\\d{5,12}\"],[,,\"1(?:[3569][1-8]\\\\d{3,9}|[47]\\\\d{5,10})|2[1-8]\\\\d{3,9}|3(?:[1-8]\\\\d{3,9}|9\\\\d{4,8})|[5689][1-8]\\\\d{3,9}\",\"\\\\d{5,12}\",,,\"1312345678\"],\n[,,\"4\\\\d{5,10}|50\\\\d{4,8}\",\"\\\\d{6,11}\",,,\"412345678\"],[,,\"800\\\\d{4,7}\",\"\\\\d{7,10}\",,,\"8001234567\"],[,,\"[67]00\\\\d{5,6}\",\"\\\\d{8,9}\",,,\"600123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"FI\",358,\"00|99[049]\",\"0\",,,\"0\",,,,[[,\"(\\\\d{2})(\\\\d{4,10})\",\"$1 $2\",[\"2[09]|[14]|50|7[135]\"],\"0$1\",\"\",0],[,\"(\\\\d)(\\\\d{4,11})\",\"$1 $2\",[\"[25689][1-8]|3\"],\"0$1\",\"\",0],[,\"([6-8]00)(\\\\d{4,7})\",\"$1 $2\",[\"[6-8]0\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],1,,[,,\"NA\",\"NA\"],[,,\"10[1-9]\\\\d{3,7}|2(?:0(?:[16-8]\\\\d{3,7}|2[14-9]\\\\d{1,6}|[3-5]\\\\d{2,7}|9[0-7]\\\\d{1,6})|9\\\\d{4,8})|30[1-9]\\\\d{3,7}|7(?:1\\\\d{7}|3\\\\d{8}|5[03-9]\\\\d{2,7})\",\n\"\\\\d{5,10}\",,,\"10112345\"],,[,,\"112\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],FJ:[,[,,\"[36-9]\\\\d{6}|0\\\\d{10}\",\"\\\\d{7}(?:\\\\d{4})?\"],[,,\"(?:3[0-5]|6[25-7]|8[58])\\\\d{5}\",\"\\\\d{7}\",,,\"3212345\"],[,,\"(?:7[0-467]|8[367]|9[02346-9])\\\\d{5}\",\"\\\\d{7}\",,,\"7012345\"],[,,\"0800\\\\d{7}\",\"\\\\d{11}\",,,\"08001234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"FJ\",679,\"0(?:0|52)\",,,,,,\"00\",,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[36-9]\"],\"\",\"\",0],[,\"(\\\\d{4})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"0\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\n\"NA\",\"NA\"],[,,\"NA\",\"NA\"],1,[,,\"91[17]\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],FK:[,[,,\"[2-7]\\\\d{4}\",\"\\\\d{5}\"],[,,\"[2-47]\\\\d{4}\",\"\\\\d{5}\",,,\"31234\"],[,,\"[56]\\\\d{4}\",\"\\\\d{5}\",,,\"51234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"FK\",500,\"00\",,,,,,,,,,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"999\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],FM:[,[,,\"[39]\\\\d{6}\",\"\\\\d{7}\"],[,,\"3[2357]0[1-9]\\\\d{3}|9[2-6]\\\\d{5}\",\"\\\\d{7}\",,,\"3201234\"],[,,\"3[2357]0[1-9]\\\\d{3}|9[2-7]\\\\d{5}\",\"\\\\d{7}\",,,\"3501234\"],\n[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"FM\",691,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"911|320221\",\"\\\\d{3}(?:\\\\d{3})?\",,,\"911\"],[,,\"NA\",\"NA\"]],FO:[,[,,\"[2-9]\\\\d{5}\",\"\\\\d{6}\"],[,,\"(?:20|[3-4]\\\\d|8[19])\\\\d{4}\",\"\\\\d{6}\",,,\"201234\"],[,,\"(?:2[1-9]|5\\\\d|7[1-79])\\\\d{4}\",\"\\\\d{6}\",,,\"211234\"],[,,\"80[257-9]\\\\d{3}\",\"\\\\d{6}\",,,\"802123\"],[,,\"90(?:[1345][15-7]|2[125-7]|99)\\\\d{2}\",\"\\\\d{6}\",,,\"901123\"],[,,\"NA\",\"NA\"],[,\n,\"NA\",\"NA\"],[,,\"(?:6[0-36]|88)\\\\d{4}\",\"\\\\d{6}\",,,\"601234\"],\"FO\",298,\"00\",,,,\"(10(?:01|[12]0|88))\",,,,[[,\"(\\\\d{6})\",\"$1\",,\"\",\"$CC $1\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],FR:[,[,,\"[124-9]\\\\d{8}|3\\\\d{3}(?:\\\\d{5})?\",\"\\\\d{4}(?:\\\\d{5})?\"],[,,\"[1-5]\\\\d{8}\",\"\\\\d{9}\",,,\"123456789\"],[,,\"6\\\\d{8}|7[5-9]\\\\d{7}\",\"\\\\d{9}\",,,\"612345678\"],[,,\"80\\\\d{7}\",\"\\\\d{9}\",,,\"801234567\"],[,,\"3\\\\d{3}|89[1-37-9]\\\\d{6}\",\"\\\\d{4}(?:\\\\d{5})?\",,,\"891123456\"],[,,\"8(?:1[019]|2[0156]|84|90)\\\\d{6}\",\n\"\\\\d{9}\",,,\"810123456\"],[,,\"NA\",\"NA\"],[,,\"9\\\\d{8}\",\"\\\\d{9}\",,,\"912345678\"],\"FR\",33,\"[04579]0\",\"0\",,,\"0\",,\"00\",,[[,\"([1-79])(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4 $5\",[\"[1-79]\"],\"0$1\",\"\",0],[,\"(8\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"8\"],\"0 $1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"3\\\\d{3}\",\"\\\\d{4}\",,,\"3123\"],[,,\"NA\",\"NA\"],,[,,\"1(?:[578]|12)\",\"\\\\d{2,3}\",,,\"112\"],[,,\"NA\",\"NA\"]],GA:[,[,,\"[12]\\\\d{6}|0\\\\d{7}\",\"\\\\d{6,8}\"],[,,\"(?:1(?:4[4-8]|7\\\\d)|2(?:4[02]|5[04-689]|6[024-79]|8[236]|9[02368]))\\\\d{4}\",\n\"\\\\d{6,7}\",,,\"1441234\"],[,,\"0(?:5(?:0[89]|3[0-4]|8[0-26]|9[238])|6(?:0[3-7]|1[01]|2[0-7]|6[0-589]|71|83|9[57])|7(?:1[2-5]|2[89]|3[35-9]|4[01]|5[0-347-9]|[67]\\\\d|8[457-9]|9[0146]))\\\\d{4}\",\"\\\\d{8}\",,,\"06031234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"GA\",241,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[12]\"],\"0$1\",\"\",0],[,\"(0\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"0\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],1,[,,\"1730|18|13\\\\d{2}\",\n\"\\\\d{2,4}\",,,\"1730\"],[,,\"NA\",\"NA\"]],GB:[,[,,\"\\\\d{7,10}\",\"\\\\d{4,10}\"],[,,\"2(?:0[01378]|3[0189]|4[017]|8[0-46-9]|9[012])\\\\d{7}|1(?:(?:1(?:3[0-48]|[46][0-4]|5[012789]|7[0-39]|8[01349])|21[0-7]|31[0-8]|[459]1\\\\d|61[0-46-9]))\\\\d{6}|1(?:2(?:0[024-9]|2[3-9]|3[3-79]|4[1-689]|[58][02-9]|6[0-4789]|7[013-9]|9\\\\d)|3(?:0\\\\d|[25][02-9]|3[02-579]|[468][0-46-9]|7[1235679]|9[24578])|4(?:0[03-9]|[28][02-5789]|[37]\\\\d|4[02-69]|5[0-8]|[69][0-79])|5(?:0[1235-9]|2[024-9]|3[015689]|4[02-9]|5[03-9]|6\\\\d|7[0-35-9]|8[0-468]|9[0-5789])|6(?:0[034689]|2[0-35689]|[38][013-9]|4[1-467]|5[0-69]|6[13-9]|7[0-8]|9[0124578])|7(?:0[0246-9]|2\\\\d|3[023678]|4[03-9]|5[0-46-9]|6[013-9]|7[0-35-9]|8[024-9]|9[02-9])|8(?:0[35-9]|2[1-5789]|3[02-578]|4[0-578]|5[124-9]|6[2-69]|7\\\\d|8[02-9]|9[02569])|9(?:0[02-589]|2[02-689]|3[1-5789]|4[2-9]|5[0-579]|6[234789]|7[0124578]|8\\\\d|9[2-57]))\\\\d{6}|1(?:2(?:0(?:46[1-4]|87[2-9])|545[1-79]|76(?:2\\\\d|3[1-8]|6[1-6])|9(?:7(?:2[0-4]|3[2-5])|8(?:2[2-8]|7[0-4789]|8[345])))|3(?:638[2-5]|647[23]|8(?:47[04-9]|64[015789]))|4(?:044[1-7]|20(?:2[23]|8\\\\d)|6(?:0(?:30|5[2-57]|6[1-8]|7[2-8])|140)|8(?:052|87[123]))|5(?:24(?:3[2-79]|6\\\\d)|276\\\\d|6(?:26[06-9]|686))|6(?:06(?:4\\\\d|7[4-79])|295[567]|35[34]\\\\d|47(?:24|61)|59(?:5[08]|6[67]|74)|955[0-4])|7(?:26(?:6[13-9]|7[0-7])|442\\\\d|50(?:2[0-3]|[3-68]2|76))|8(?:27[56]\\\\d|37(?:5[2-5]|8[239])|84(?:3[2-58]))|9(?:0(?:0(?:6[1-8]|85)|52\\\\d)|3583|4(?:66[1-8]|9(?:2[01]|81))|63(?:23|3[1-4])|9561))\\\\d{3}|176888[234678]\\\\d{2}|16977[23]\\\\d{3}\",\n\"\\\\d{4,10}\",,,\"1212345678\"],[,,\"7(?:[1-4]\\\\d\\\\d|5(?:0[0-8]|[13-9]\\\\d|2[0-35-9])|7(?:0[1-9]|[1-7]\\\\d|8[02-9]|9[0-689])|8(?:[014-9]\\\\d|[23][0-8])|9(?:[04-9]\\\\d|1[02-9]|2[0-35-9]|3[0-689]))\\\\d{6}\",\"\\\\d{10}\",,,\"7400123456\"],[,,\"80(?:0(?:1111|\\\\d{6,7})|8\\\\d{7})|500\\\\d{6}\",\"\\\\d{7}(?:\\\\d{2,3})?\",,,\"8001234567\"],[,,\"(?:87[123]|9(?:[01]\\\\d|8[0-3]))\\\\d{7}\",\"\\\\d{10}\",,,\"9012345678\"],[,,\"8(?:4(?:5464\\\\d|[2-5]\\\\d{7})|70\\\\d{7})\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"8431234567\"],[,,\"70\\\\d{8}\",\"\\\\d{10}\",,,\"7012345678\"],[,,\"56\\\\d{8}\",\n\"\\\\d{10}\",,,\"5612345678\"],\"GB\",44,\"00\",\"0\",\" x\",,\"0\",,,,[[,\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"2|5[56]|7(?:0|6[013-9])\",\"2|5[56]|7(?:0|6(?:[013-9]|2[0-35-9]))\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1(?:1|\\\\d1)|3|9[018]\"],\"0$1\",\"\",0],[,\"(\\\\d{5})(\\\\d{4,5})\",\"$1 $2\",[\"1(?:38|5[23]|69|76|94)\",\"1(?:387|5(?:24|39)|697|768|946)\",\"1(?:3873|5(?:242|39[456])|697[347]|768[347]|9467)\"],\"0$1\",\"\",0],[,\"(1\\\\d{3})(\\\\d{5,6})\",\"$1 $2\",[\"1\"],\"0$1\",\"\",0],[,\"(7\\\\d{3})(\\\\d{6})\",\"$1 $2\",[\"7(?:[1-5789]|62)\",\n\"7(?:[1-5789]|624)\"],\"0$1\",\"\",0],[,\"(800)(\\\\d{4})\",\"$1 $2\",[\"800\",\"8001\",\"80011\",\"800111\",\"8001111\"],\"0$1\",\"\",0],[,\"(845)(46)(4\\\\d)\",\"$1 $2 $3\",[\"845\",\"8454\",\"84546\",\"845464\"],\"0$1\",\"\",0],[,\"(8\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"8(?:4[2-5]|7[0-3])\"],\"0$1\",\"\",0],[,\"(80\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"80\"],\"0$1\",\"\",0],[,\"([58]00)(\\\\d{6})\",\"$1 $2\",[\"[58]00\"],\"0$1\",\"\",0]],,[,,\"76(?:0[012]|2[356]|4[0134]|5[49]|6[0-369]|77|81|9[39])\\\\d{6}\",\"\\\\d{10}\",,,\"7640123456\"],1,,[,,\"NA\",\"NA\"],[,,\"(?:3[0347]|55)\\\\d{8}\",\n\"\\\\d{10}\",,,\"5512345678\"],,[,,\"112|999\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],GD:[,[,,\"[4589]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"473(?:2(?:3[0-2]|69)|3(?:2[89]|86)|4(?:[06]8|3[5-9]|4[0-49]|5[5-79]|68|73|90)|63[68]|7(?:58|84)|938)\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"4732691234\"],[,,\"473(?:4(?:0[3-79]|1[04-9]|20|58)|53[3-8])\\\\d{4}\",\"\\\\d{10}\",,,\"4734031234\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002123456\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002123456\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",\n,,\"5002345678\"],[,,\"NA\",\"NA\"],\"GD\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,\"473\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],GE:[,[,,\"[3458]\\\\d{8}\",\"\\\\d{6,9}\"],[,,\"(?:3(?:[256]\\\\d|4[124-9]|7[0-4])|4(?:1\\\\d|2[2-7]|3[1-79]|4[2-8]|7[239]|9[1-7]))\\\\d{6}\",\"\\\\d{6,9}\",,,\"322123456\"],[,,\"5(?:14|5[01578]|68|7[0147-9]|9[0-35-9])\\\\d{6}\",\"\\\\d{9}\",,,\"555123456\"],[,,\"800\\\\d{6}\",\"\\\\d{9}\",,,\"800123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"GE\",995,\"810\",\"8\",,,\"8\",,\"8~10\",\n,[[,\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[348]\"],\"8 $1\",\"\",0],[,\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"5\"],\"$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"0(?:11|22|33)|1(?:1[123]|22)\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],GF:[,[,,\"[56]\\\\d{8}\",\"\\\\d{9}\"],[,,\"594(?:10|2[012457-9]|3[0-57-9]|4[3-9]|5[7-9]|6[0-3]|9[014])\\\\d{4}\",\"\\\\d{9}\",,,\"594101234\"],[,,\"694(?:[04][0-7]|1[0-5]|2[0-46-9]|38|9\\\\d)\\\\d{4}\",\"\\\\d{9}\",,,\"694201234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\n[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"GF\",594,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",,\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1[578]\",\"\\\\d{2}\",,,\"15\"],[,,\"NA\",\"NA\"]],GG:[,[,,\"[135789]\\\\d{6,9}\",\"\\\\d{6,10}\"],[,,\"1481\\\\d{6}\",\"\\\\d{6,10}\",,,\"1481456789\"],[,,\"7(?:781|839|911)\\\\d{6}\",\"\\\\d{10}\",,,\"7781123456\"],[,,\"80(?:0(?:1111|\\\\d{6,7})|8\\\\d{7})|500\\\\d{6}\",\"\\\\d{7}(?:\\\\d{2,3})?\",,,\"8001234567\"],[,,\"(?:87[123]|9(?:[01]\\\\d|8[0-3]))\\\\d{7}\",\"\\\\d{10}\",,,\"9012345678\"],\n[,,\"8(?:4(?:5464\\\\d|[2-5]\\\\d{7})|70\\\\d{7})\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"8431234567\"],[,,\"70\\\\d{8}\",\"\\\\d{10}\",,,\"7012345678\"],[,,\"56\\\\d{8}\",\"\\\\d{10}\",,,\"5612345678\"],\"GG\",44,\"00\",\"0\",\" x\",,\"0\",,,,,,[,,\"76(?:0[012]|2[356]|4[0134]|5[49]|6[0-369]|77|81|9[39])\\\\d{6}\",\"\\\\d{10}\",,,\"7640123456\"],,,[,,\"NA\",\"NA\"],[,,\"(?:3[0347]|55)\\\\d{8}\",\"\\\\d{10}\",,,\"5512345678\"],,[,,\"112|999\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],GH:[,[,,\"[235]\\\\d{6,8}\",\"\\\\d{7,9}\"],[,,\"3(?:0[237]\\\\d|[167](?:2[0-6]|7\\\\d)|2(?:2[0-5]|7\\\\d)|3(?:2[0-37]|7\\\\d)|4(?:[27]\\\\d|30)|5(?:2[0-7]|7\\\\d)|8(?:2[0-2]|7\\\\d)|9(?:20|7\\\\d))\\\\d{5}\",\n\"\\\\d{7,9}\",,,\"302345678\"],[,,\"(?:2[034678]|5[47])\\\\d{7}\",\"\\\\d{9}\",,,\"231234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"GH\",233,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",,\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"19[123]|999\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],GI:[,[,,\"[2568]\\\\d{7}\",\"\\\\d{8}\"],[,,\"2(?:00\\\\d|16[0-7]|22[2457])\\\\d{4}\",\"\\\\d{8}\",,,\"20012345\"],[,,\"(?:5[4-8]|60)\\\\d{6}\",\"\\\\d{8}\",,,\"57123456\"],[,,\"80\\\\d{6}\",\"\\\\d{8}\",,,\"80123456\"],\n[,,\"8[1-689]\\\\d{6}\",\"\\\\d{8}\",,,\"88123456\"],[,,\"87\\\\d{6}\",\"\\\\d{8}\",,,\"87123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"GI\",350,\"00\",,,,,,,,,,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:12|9[09])\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],GL:[,[,,\"[1-689]\\\\d{5}\",\"\\\\d{6}\"],[,,\"(?:19|3[1-6]|6[14689]|8[14-79]|9\\\\d)\\\\d{4}\",\"\\\\d{6}\",,,\"321000\"],[,,\"[245][2-9]\\\\d{4}\",\"\\\\d{6}\",,,\"221234\"],[,,\"80\\\\d{4}\",\"\\\\d{6}\",,,\"801234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"3[89]\\\\d{4}\",\"\\\\d{6}\",,,\"381234\"],\"GL\",299,\"00\",\n,,,,,,,[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],GM:[,[,,\"[3-9]\\\\d{6}\",\"\\\\d{7}\"],[,,\"(?:4(?:[23]\\\\d{2}|4(?:1[024679]|[6-9]\\\\d))|5(?:54[0-7]|6(?:[67]\\\\d)|7(?:1[04]|2[035]|3[58]|48))|8\\\\d{3})\\\\d{3}\",\"\\\\d{7}\",,,\"5661234\"],[,,\"[3679]\\\\d{6}\",\"\\\\d{7}\",,,\"3012345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"GM\",220,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],\n,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1?1[678]\",\"\\\\d{2,3}\",,,\"117\"],[,,\"NA\",\"NA\"]],GN:[,[,,\"[3567]\\\\d{7}\",\"\\\\d{8}\"],[,,\"30(?:24|3[12]|4[1-35-7]|5[13]|6[189]|[78]1|9[1478])\\\\d{4}\",\"\\\\d{8}\",,,\"30241234\"],[,,\"55\\\\d{6}|6(?:0(?:2[0-35-9]|3[3467]|5[2457-9])|[24578]\\\\d{2}|3(?:[14]0|35))\\\\d{4}\",\"\\\\d{8}\",,,\"60201234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"78\\\\d{6}\",\"\\\\d{8}\",,,\"78123456\"],\"GN\",224,\"00\",,,,,,,,[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,\n,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"]],GP:[,[,,\"[56]\\\\d{8}\",\"\\\\d{9}\"],[,,\"590(?:1[12]|2[0-68]|3[28]|4[126-8]|5[067]|6[018]|[89]\\\\d)\\\\d{4}\",\"\\\\d{9}\",,,\"590201234\"],[,,\"690(?:00|1[1-9]|2[013-5]|[3-5]\\\\d|6[0-57-9]|7[1-6]|8[0-6]|9[09])\\\\d{4}\",\"\\\\d{9}\",,,\"690301234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"GP\",590,\"00\",\"0\",,,\"0\",,,,[[,\"([56]90)(\\\\d{2})(\\\\d{4})\",\"$1 $2-$3\",,\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],1,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1[578]\",\"\\\\d{2}\",\n,,\"18\"],[,,\"NA\",\"NA\"]],GQ:[,[,,\"[23589]\\\\d{8}\",\"\\\\d{9}\"],[,,\"3(?:3(?:3\\\\d[7-9]|[0-24-9]\\\\d[46])|5\\\\d{2}[7-9])\\\\d{4}\",\"\\\\d{9}\",,,\"333091234\"],[,,\"(?:222|551)\\\\d{6}\",\"\\\\d{9}\",,,\"222123456\"],[,,\"80\\\\d[1-9]\\\\d{5}\",\"\\\\d{9}\",,,\"800123456\"],[,,\"90\\\\d[1-9]\\\\d{5}\",\"\\\\d{9}\",,,\"900123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"GQ\",240,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[235]\"],\"\",\"\",0],[,\"(\\\\d{3})(\\\\d{6})\",\"$1 $2\",[\"[89]\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"NA\",\n\"NA\"],[,,\"NA\",\"NA\"]],GR:[,[,,\"[26-9]\\\\d{9}\",\"\\\\d{10}\"],[,,\"2(?:1\\\\d{2}|2(?:3[1-8]|4[1-7]|5[1-4]|6[1-8]|7[1-5]|[289][1-9])|3(?:1\\\\d|2[1-5]|3[1-4]|[45][1-3]|7[1-7]|8[1-6]|9[1-79])|4(?:1\\\\d|2[1-8]|3[1-4]|4[13-5]|6[1-578]|9[1-5])|5(?:1\\\\d|2[1-3]|4[124]|5[1-6]|[39][1-4])|6(?:1\\\\d|3[124]|4[1-7]|5[13-9]|[269][1-6]|7[14]|8[1-5])|7(?:1\\\\d|2[1-5]|3[1-6]|4[1-7]|5[1-57]|6[134]|9[15-7])|8(?:1\\\\d|2[1-5]|[34][1-4]|9[1-7]))\\\\d{6}\",\"\\\\d{10}\",,,\"2123456789\"],[,,\"69\\\\d{8}\",\"\\\\d{10}\",,,\"6912345678\"],[,,\"800\\\\d{7}\",\"\\\\d{10}\",\n,,\"8001234567\"],[,,\"90[19]\\\\d{7}\",\"\\\\d{10}\",,,\"9091234567\"],[,,\"8(?:0[16]|12|25)\\\\d{7}\",\"\\\\d{10}\",,,\"8011234567\"],[,,\"70\\\\d{8}\",\"\\\\d{10}\",,,\"7012345678\"],[,,\"NA\",\"NA\"],\"GR\",30,\"00\",,,,,,,,[[,\"([27]\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"21|7\"],\"\",\"\",0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"2[2-9]1|[689]\"],\"\",\"\",0],[,\"(2\\\\d{3})(\\\\d{6})\",\"$1 $2\",[\"2[2-9][02-9]\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:00|12|66|99)\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],GT:[,[,,\"[2-7]\\\\d{7}|1[89]\\\\d{9}\",\n\"\\\\d{8}(?:\\\\d{3})?\"],[,,\"[267][2-9]\\\\d{6}\",\"\\\\d{8}\",,,\"22456789\"],[,,\"[345]\\\\d{7}\",\"\\\\d{8}\",,,\"51234567\"],[,,\"18[01]\\\\d{8}\",\"\\\\d{11}\",,,\"18001112222\"],[,,\"19\\\\d{9}\",\"\\\\d{11}\",,,\"19001112222\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"GT\",502,\"00\",,,,,,,,[[,\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[2-7]\"],\"\",\"\",0],[,\"(\\\\d{4})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:10|2[03])\",\"\\\\d{3}\",,,\"110\"],[,,\"NA\",\"NA\"]],GU:[,[,,\"[5689]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],\n[,,\"671(?:3(?:00|3[39]|4[349]|55|6[26])|4(?:56|7[1-9]|8[23678])|5(?:55|6[2-5]|88)|6(?:3[2-578]|4[24-9]|5[34]|78|8[5-9])|7(?:[079]7|2[0167]|3[45]|8[789])|8(?:[2-5789]8|6[48])|9(?:2[29]|6[79]|7[179]|8[789]|9[78]))\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"6713001234\"],[,,\"671(?:3(?:00|3[39]|4[349]|55|6[26])|4(?:56|7[1-9]|8[23678])|5(?:55|6[2-5]|88)|6(?:3[2-578]|4[24-9]|5[34]|78|8[5-9])|7(?:[079]7|2[0167]|3[45]|8[789])|8(?:[2-5789]8|6[48])|9(?:2[29]|6[79]|7[179]|8[789]|9[78]))\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"6713001234\"],\n[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002123456\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002123456\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"GU\",1,\"011\",\"1\",,,\"1\",,,1,,,[,,\"NA\",\"NA\"],,\"671\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],GW:[,[,,\"[3567]\\\\d{6}\",\"\\\\d{7}\"],[,,\"3(?:2[0125]|3[1245]|4[12]|5[1-4]|70|9[1-467])\\\\d{4}\",\"\\\\d{7}\",,,\"3201234\"],[,,\"[5-7]\\\\d{6}\",\"\\\\d{7}\",,,\"5012345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\n[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"GW\",245,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[378]\",\"\\\\d{3}\",,,\"113\"],[,,\"NA\",\"NA\"]],GY:[,[,,\"[2-4679]\\\\d{6}\",\"\\\\d{7}\"],[,,\"(?:2(?:1[6-9]|2[0-35-9]|3[1-4]|5[3-9]|6\\\\d|7[0-24-79])|3(?:2[25-9]|3\\\\d)|4(?:4[0-24]|5[56])|77[1-57])\\\\d{4}\",\"\\\\d{7}\",,,\"2201234\"],[,,\"6\\\\d{6}\",\"\\\\d{7}\",,,\"6091234\"],[,,\"(?:289|862)\\\\d{4}\",\"\\\\d{7}\",,,\"2891234\"],[,,\"9008\\\\d{3}\",\"\\\\d{7}\",,,\"9008123\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\n\"NA\",\"NA\"],\"GY\",592,\"001\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"91[123]\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],HK:[,[,,\"[235-7]\\\\d{7}|8\\\\d{7,8}|9\\\\d{7,10}\",\"\\\\d{8,11}\"],[,,\"[23]\\\\d{7}\",\"\\\\d{8}\",,,\"21234567\"],[,,\"[5-79]\\\\d{7}\",\"\\\\d{8}\",,,\"51234567\"],[,,\"800\\\\d{6}\",\"\\\\d{9}\",,,\"800123456\"],[,,\"900\\\\d{8}\",\"\\\\d{11}\",,,\"90012345678\"],[,,\"NA\",\"NA\"],[,,\"8[1-3]\\\\d{6}\",\"\\\\d{8}\",,,\"81123456\"],[,,\"NA\",\"NA\"],\"HK\",852,\"00\",,,,,,,,[[,\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",\n[\"[235-7]|[89](?:0[1-9]|[1-9])\"],\"\",\"\",0],[,\"(800)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"800\"],\"\",\"\",0],[,\"(900)(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"900\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112|99[29]\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],HN:[,[,,\"[237-9]\\\\d{7}\",\"\\\\d{8}\"],[,,\"2(?:2(?:0[019]|1[1-36]|[23]\\\\d|4[056]|5[57]|9[01])|4(?:2|3-59]|3[13-689]|4[0-68]|5[1-35])|5(?:4[3-5]|5\\\\d|6[56]|74)|6(?:4[0-378]|[56]\\\\d|[78][0-8]|9[01])|7(?:6[46-9]|7[02-9]|8[34])|8(?:79|8[0-35789]|9[1-57-9]))\\\\d{4}\",\n\"\\\\d{8}\",,,\"22123456\"],[,,\"[37-9]\\\\d{7}\",\"\\\\d{8}\",,,\"91234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"HN\",504,\"00\",,,,,,,,[[,\"(\\\\d{4})(\\\\d{4})\",\"$1-$2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"199\",\"\\\\d{3}\",,,\"199\"],[,,\"NA\",\"NA\"]],HR:[,[,,\"[1-7]\\\\d{5,8}|[89]\\\\d{6,11}\",\"\\\\d{6,12}\"],[,,\"(?:1|6[029])\\\\d{7}|(?:2[0-3]|3[1-5]|4[02-47-9]|5[1-3])\\\\d{6}\",\"\\\\d{6,9}\",,,\"12345678\"],[,,\"9[1257-9]\\\\d{6,10}\",\"\\\\d{8,12}\",,,\"912345678\"],[,,\"80[01]\\\\d{4,7}\",\"\\\\d{7,10}\",\n,,\"8001234567\"],[,,\"6[145]\\\\d{4,7}\",\"\\\\d{6,9}\",,,\"611234\"],[,,\"NA\",\"NA\"],[,,\"7[45]\\\\d{4,7}\",\"\\\\d{6,9}\",,,\"741234567\"],[,,\"NA\",\"NA\"],\"HR\",385,\"00\",\"0\",,,\"0\",,,,[[,\"(1)(\\\\d{4})(\\\\d{3})\",\"$1 $2 $3\",[\"1\"],\"0$1\",\"\",0],[,\"(6[029])(\\\\d{4})(\\\\d{3})\",\"$1 $2 $3\",[\"6[029]\"],\"0$1\",\"\",0],[,\"([2-5]\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[2-5]\"],\"0$1\",\"\",0],[,\"(9\\\\d)(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"9\"],\"0$1\",\"\",0],[,\"(9\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"9\"],\"0$1\",\"\",0],[,\"(9\\\\d)(\\\\d{3,4})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3 $4\",\n[\"9\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2,3})\",\"$1 $2 $3\",[\"6[145]|7\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{3,4})(\\\\d{3})\",\"$1 $2 $3\",[\"6[145]|7\"],\"0$1\",\"\",0],[,\"(80[01])(\\\\d{2})(\\\\d{2,3})\",\"$1 $2 $3\",[\"8\"],\"0$1\",\"\",0],[,\"(80[01])(\\\\d{3,4})(\\\\d{3})\",\"$1 $2 $3\",[\"8\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:12|92)|9[34]\",\"\\\\d{2,3}\",,,\"112\"],[,,\"NA\",\"NA\"]],HT:[,[,,\"[2-489]\\\\d{7}\",\"\\\\d{8}\"],[,,\"2(?:[24]\\\\d|5[1-5]|94)\\\\d{5}\",\"\\\\d{8}\",,,\"22453300\"],[,,\"(?:3[1-9]|4\\\\d)\\\\d{6}\",\"\\\\d{8}\",\n,,\"34101234\"],[,,\"8\\\\d{7}\",\"\\\\d{8}\",,,\"80012345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"98[89]\\\\d{5}\",\"\\\\d{8}\",,,\"98901234\"],\"HT\",509,\"00\",,,,,,,,[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{4})\",\"$1 $2 $3\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[48]\",\"\\\\d{3}\",,,\"118\"],[,,\"NA\",\"NA\"]],HU:[,[,,\"[1-9]\\\\d{7,8}\",\"\\\\d{6,9}\"],[,,\"(?:1\\\\d|2(?:1\\\\d|[2-9])|3[2-7]|4[24-9]|5[2-79]|6[23689]|7(?:1\\\\d|[2-9])|8[2-57-9]|9[2-69])\\\\d{6}\",\"\\\\d{6,9}\",,,\"12345678\"],[,,\"(?:[27]0|3[01])\\\\d{7}\",\"\\\\d{9}\",,,\"201234567\"],\n[,,\"80\\\\d{6}\",\"\\\\d{8}\",,,\"80123456\"],[,,\"9[01]\\\\d{6}\",\"\\\\d{8}\",,,\"90123456\"],[,,\"40\\\\d{6}\",\"\\\\d{8}\",,,\"40123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"HU\",36,\"00\",\"06\",,,\"06\",,,,[[,\"(1)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"],\"($1)\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[2-9]\"],\"($1)\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:0[457]|12)\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],ID:[,[,,\"[1-9]\\\\d{6,10}\",\"\\\\d{5,11}\"],[,,\"2[124]\\\\d{7,8}|(?:2(?:[35][1-4]|6[0-8]|7[1-6]|8\\\\d|9[1-8])|3(?:1|2[1-578]|3[1-68]|4[1-3]|5[1-8]|6[1-3568]|7[0-46]|8\\\\d)|4(?:0[1-589]|1[01347-9]|2[0-36-8]|3[0-24-68]|5[1-378]|6[1-5]|7[134]|8[1245])|5(?:1[1-35-9]|2[25-8]|3[1246-9]|4[1-3589]|5[1-46]|6[1-8])|6(?:19?|[25]\\\\d|3[1-469]|4[1-6])|7(?:1[1-46-9]|2[14-9]|[36]\\\\d|4[1-8]|5[1-9]|7[0-36-9])|9(?:0[12]|1[0134-8]|2[0-479]|5[125-8]|6[23679]|7[159]|8[01346]))\\\\d{5,8}\",\n\"\\\\d{5,10}\",,,\"612345678\"],[,,\"8[1-35-9]\\\\d{7,9}\",\"\\\\d{9,11}\",,,\"812345678\"],[,,\"177\\\\d{6,8}|800\\\\d{5,7}\",\"\\\\d{8,11}\",,,\"8001234567\"],[,,\"809\\\\d{7}\",\"\\\\d{10}\",,,\"8091234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"ID\",62,\"0(?:0[1789]|10(?:00|1[67]))\",\"0\",,,\"0\",,,,[[,\"(\\\\d{2})(\\\\d{7,8})\",\"$1 $2\",[\"2[124]|[36]1\"],\"(0$1)\",\"\",0],[,\"(\\\\d{3})(\\\\d{5,7})\",\"$1 $2\",[\"[4579]|2[035-9]|[36][02-9]\"],\"(0$1)\",\"\",0],[,\"(8\\\\d{2})(\\\\d{3,4})(\\\\d{3,4})\",\"$1-$2-$3\",[\"8[1-35-9]\"],\"0$1\",\"\",0],[,\"(177)(\\\\d{6,8})\",\"$1 $2\",\n[\"1\"],\"0$1\",\"\",0],[,\"(800)(\\\\d{5,7})\",\"$1 $2\",[\"800\"],\"0$1\",\"\",0],[,\"(809)(\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"809\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[02389]\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],IE:[,[,,\"[124-9]\\\\d{6,9}\",\"\\\\d{5,10}\"],[,,\"1\\\\d{7,8}|2(?:1\\\\d{6,7}|[24-9]\\\\d{5}|3\\\\d{5,7})|4(?:0[24]\\\\d{5}|[1269]\\\\d{7}|[34]\\\\d{5,7}|5\\\\d{6}|7\\\\d{5}|8[0-46-9]\\\\d{7})|5(?:0[45]\\\\d{5}|1\\\\d{6}|2\\\\d{5,7}|[3679]\\\\d{7}|8\\\\d{5})|6(?:1\\\\d{6}|4\\\\d{5,7}|[237-9]\\\\d{5}|[56]\\\\d{7})|7[14]\\\\d{7}|9(?:1\\\\d{6}|[04]\\\\d{7}|[3-9]\\\\d{5})\",\n\"\\\\d{5,10}\",,,\"2212345\"],[,,\"8(?:22\\\\d{6}|[35-9]\\\\d{7,8})\",\"\\\\d{9,10}\",,,\"850123456\"],[,,\"1800\\\\d{6}\",\"\\\\d{10}\",,,\"1800123456\"],[,,\"15(?:1[2-9]|[2-8]0|59|9[089])\\\\d{6}\",\"\\\\d{10}\",,,\"1520123456\"],[,,\"18[59]0\\\\d{6}\",\"\\\\d{10}\",,,\"1850123456\"],[,,\"700\\\\d{6}\",\"\\\\d{9}\",,,\"700123456\"],[,,\"76\\\\d{7}\",\"\\\\d{9}\",,,\"761234567\"],\"IE\",353,\"00\",\"0\",,,\"0\",,,,[[,\"(1)(\\\\d{3,4})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"],\"(0$1)\",\"\",0],[,\"(\\\\d{2})(\\\\d{5})\",\"$1 $2\",[\"2[2-9]|4[347]|5[2-58]|6[2-47-9]|9[3-9]\"],\"(0$1)\",\"\",0],[,\"(\\\\d{3})(\\\\d{5})\",\n\"$1 $2\",[\"40[24]|50[45]\"],\"(0$1)\",\"\",0],[,\"(48)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"48\"],\"(0$1)\",\"\",0],[,\"(818)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"81\"],\"(0$1)\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[24-69]|7[14]\"],\"(0$1)\",\"\",0],[,\"([78]\\\\d)(\\\\d{3,4})(\\\\d{4})\",\"$1 $2 $3\",[\"76|8[35-9]\"],\"0$1\",\"\",0],[,\"(700)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"70\"],\"0$1\",\"\",0],[,\"(\\\\d{4})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"1(?:8[059]|5)\",\"1(?:8[059]0|5)\"],\"$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"18[59]0\\\\d{6}\",\"\\\\d{10}\",,,\"1850123456\"],\n[,,\"818\\\\d{6}\",\"\\\\d{9}\",,,\"818123456\"],,[,,\"112|999\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],IL:[,[,,\"[17]\\\\d{6,9}|[2-589]\\\\d{3}(?:\\\\d{3,6})?|6\\\\d{3}\",\"\\\\d{4,10}\"],[,,\"(?:[2-489]|7[2-46-8])\\\\d{7}\",\"\\\\d{7,9}\",,,\"21234567\"],[,,\"5(?:[0246-9]\\\\d{2}|5(?:22|33|44|5[58]|66|77|88))\\\\d{5}\",\"\\\\d{9}\",,,\"501234567\"],[,,\"1(?:80[019]\\\\d{3}|255)\\\\d{3}\",\"\\\\d{7,10}\",,,\"1800123456\"],[,,\"1(?:212|(?:919|200)\\\\d{2})\\\\d{4}\",\"\\\\d{8,10}\",,,\"1919123456\"],[,,\"1700\\\\d{6}\",\"\\\\d{10}\",,,\"1700123456\"],[,,\"NA\",\"NA\"],[,,\"77\\\\d{7}\",\"\\\\d{9}\",\n,,\"771234567\"],\"IL\",972,\"0(?:0|1[2-48])\",\"0\",,,\"0\",,,,[[,\"([2-489])(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\",[\"[2-489]\"],\"0$1\",\"\",0],[,\"([57]\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\",[\"[57]\"],\"0$1\",\"\",0],[,\"(1)([7-9]\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1-$2-$3-$4\",[\"1[7-9]\"],\"$1\",\"\",0],[,\"(1255)(\\\\d{3})\",\"$1-$2\",[\"125\"],\"$1\",\"\",0],[,\"(1200)(\\\\d{3})(\\\\d{3})\",\"$1-$2-$3\",[\"120\"],\"$1\",\"\",0],[,\"(1212)(\\\\d{2})(\\\\d{2})\",\"$1-$2-$3\",[\"121\"],\"$1\",\"\",0],[,\"(1599)(\\\\d{6})\",\"$1-$2\",[\"15\"],\"$1\",\"\",0],[,\"(\\\\d{4})\",\"*$1\",[\"[2-689]\"],\"$1\",\"\",0]],\n,[,,\"NA\",\"NA\"],,,[,,\"1700\\\\d{6}|[2-689]\\\\d{3}\",\"\\\\d{4,10}\",,,\"1700123456\"],[,,\"[2-689]\\\\d{3}\",\"\\\\d{4}\",,,\"2250\"],,[,,\"1(?:0[012]|12)\",\"\\\\d{3}\",,,\"112\"],[,,\"1599\\\\d{6}\",\"\\\\d{10}\",,,\"1599123456\"]],IM:[,[,,\"[135789]\\\\d{6,9}\",\"\\\\d{6,10}\"],[,,\"1624\\\\d{6}\",\"\\\\d{6,10}\",,,\"1624456789\"],[,,\"7[569]24\\\\d{6}\",\"\\\\d{10}\",,,\"7924123456\"],[,,\"808162\\\\d{4}\",\"\\\\d{10}\",,,\"8081624567\"],[,,\"(?:872299|90[0167]624)\\\\d{4}\",\"\\\\d{10}\",,,\"9016247890\"],[,,\"8(?:4(?:40[49]06|5624\\\\d)|70624\\\\d)\\\\d{3}\",\"\\\\d{10}\",,,\"8456247890\"],\n[,,\"70\\\\d{8}\",\"\\\\d{10}\",,,\"7012345678\"],[,,\"56\\\\d{8}\",\"\\\\d{10}\",,,\"5612345678\"],\"IM\",44,\"00\",\"0\",\" x\",,\"0\",,,,,,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"3(?:08162\\\\d|3\\\\d{5}|4(?:40[49]06|5624\\\\d)|7(?:0624\\\\d|2299\\\\d))\\\\d{3}|55\\\\d{8}\",\"\\\\d{10}\",,,\"5512345678\"],,[,,\"999\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],IN:[,[,,\"1\\\\d{7,12}|[2-9]\\\\d{9,10}\",\"\\\\d{6,13}\"],[,,\"(?:11|2[02]|33|4[04]|79)[2-6]\\\\d{7}|80[2-46]\\\\d{7}|(?:1(?:2[0-249]|3[0-25]|4[145]|[59][14]|6[014]|7[1257]|8[01346])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[126-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:[136][25]|22|4[28]|5[12]|[78]1|9[15])|6(?:12|[2345]1|57|6[13]|7[14]|80)|7(?:12|2[14]|3[134]|4[47]|5[15]|[67]1|88)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91))[2-6]\\\\d{6}|(?:(?:1(?:2[35-8]|3[346-9]|4[236-9]|[59][0235-9]|6[235-9]|7[34689]|8[257-9])|2(?:1[134689]|3[24-8]|4[2-8]|5[25689]|6[2-4679]|7[13-79]|8[2-479]|9[235-9])|3(?:01|1[79]|2[1-5]|4[25-8]|5[125689]|6[235-7]|7[157-9]|8[2-467])|4(?:1[14578]|2[5689]|3[2-467]|5[4-7]|6[35]|73|8[2689]|9[2389])|5(?:[16][146-9]|2[14-8]|3[1346]|4[14-69]|5[46]|7[2-4]|8[2-8]|9[246])|6(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24-58]|7[23-689]|8[1-6])|8(?:1[1357-9]|2[235-8]|3[03-57-9]|4[0-24-9]|5\\\\d|6[2457-9]|7[1-6]|8[1256]|9[2-4]))\\\\d|7(?:(?:1[013-9]|2[0235-9]|3[2679]|4[1-35689]|5[2-46-9]|[67][02-9]|9\\\\d)\\\\d|8(?:2[0-6]|[013-8]\\\\d)))[2-6]\\\\d{5}\",\n\"\\\\d{6,10}\",,,\"1123456789\"],[,,\"(?:7(?:2(?:0[04-9]|5[09]|7[5-8]|9[389])|3(?:0[13-9]|5[0-4789]|7[3679]|8[1-9]|9[689])|4(?:0[245789]|1[15-9]|[29][89]|39|8[389])|5(?:0[0-5789]|[47]9|[25]0|6[6-9]|[89][7-9])|6(?:0[027]|12|20|3[19]|5[45]|6[5-9]|7[679]|9[6-9])|7(?:0[27-9]|[39][5-9]|42|60)|8(?:[03][07-9]|14|2[7-9]|4[25]|6[09]|7\\\\d|9[013-9]))|8(?:0(?:[01589]\\\\d|66)|1(?:[024]\\\\d|1[56]|30|7[19]|97)|2(?:[2369]\\\\d|52|7[01357]|8[567])|3(?:0[235-8]|4[14789]|74|90)|4(?:[02-58]\\\\d|10|6[09])|5(?:0[079]|11|2\\\\d|30|4[47]|53|7[45]|9[015])|6(?:[0589]\\\\d|7[09])|7(?:1[24]|[2569]\\\\d)|8(?:[07-9]\\\\d|17|2[024-8]|44|5[389]|6[0167])|9(?:[057-9]\\\\d|2[35-9]|3[09]|4[036-8]|6[0-46-9]))|9\\\\d{3})\\\\d{6}\",\n\"\\\\d{10}\",,,\"9123456789\"],[,,\"1(?:600\\\\d{6}|80(?:0\\\\d{4,8}|3\\\\d{9}))\",\"\\\\d{8,13}\",,,\"1800123456\"],[,,\"186[12]\\\\d{9}\",\"\\\\d{13}\",,,\"1861123456789\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"IN\",91,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{6})\",\"$1 $2 $3\",[\"7(?:2[0579]|3[057-9]|4[0-389]|5[024-9]|6[0-35-9]|7[03469]|8[0-4679])|8(?:0[01589]|1[0-479]|2[236-9]|3[0479]|4[0-68]|5[0-579]6[05789]7[12569]|8[0124-9]|9[02-9])|9\",\"7(?:2(?:0[04-9]|5[09]|7[5-8]|9[389])|3(?:0[13-9]|5[0-4789]|7[3679]|8[1-9]|9[689])|4(?:0[245789]|1[15-9]|[29][89]|39|8[389])|5(?:0[0-5789]|[47]9|[25]0|6[6-9]|[89][7-9])|6(?:0[027]|12|20|3[19]|5[45]|6[5-9]|7[679]|9[6-9])|7(?:0[27-9]|3[5-9]|42|60|9[5-9])|8(?:[03][07-9]|14|2[7-9]|4[25]|6[09]|7|9[013-9]))|8(?:0[01589]|1(?:[024]|1[56]|30|7[19]|97)|2(?:[2369]|7[01357]|8[567])|3(?:0[235-8]|4[14789]|74|90)|4(?:[02-58]|10|6[09])|5(?:0[079]|11|2|30|4[47]|53|7[45]|9[015])|6(?:[0589]|70)|7(?:1[24]|[2569])|8(?:[07-9]|17|2[024-8]|44|5[389]|6[0167])|9(?:[057-9]|2[35-9]|3[09]|4[03678]|6[0-46-9]))|9\"],\n\"0$1\",\"\",1],[,\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"11|2[02]|33|4[04]|79|80[2-46]\"],\"0$1\",\"\",1],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1(?:2[0-249]|3[0-25]|4[145]|[569][14]|7[1257]|8[1346]|[68][1-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[126-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:[136][25]|22|4[28]|5[12]|[78]1|9[15])|6(?:12|[2345]1|57|6[13]|7[14]|80)\"],\"0$1\",\"\",1],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",\n[\"7(?:12|2[14]|3[134]|4[47]|5[15]|[67]1|88)\",\"7(?:12|2[14]|3[134]|4[47]|5(?:1|5[2-6])|[67]1|88)\"],\"0$1\",\"\",1],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91)\"],\"0$1\",\"\",1],[,\"(\\\\d{4})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"1(?:[2-579]|[68][1-9])|[2-8]\"],\"0$1\",\"\",1],[,\"(1600)(\\\\d{2})(\\\\d{4})\",\"$1 $2 $3\",[\"160\",\"1600\"],\"$1\",\"\",0],[,\"(1800)(\\\\d{4,5})\",\"$1 $2\",[\"180\",\"1800\"],\"$1\",\"\",0],[,\"(18[06]0)(\\\\d{2,4})(\\\\d{4})\",\"$1 $2 $3\",[\"18[06]\",\"18[06]0\"],\"$1\",\"\",0],[,\"(\\\\d{4})(\\\\d{3})(\\\\d{4})(\\\\d{2})\",\n\"$1 $2 $3 $4\",[\"18[06]\",\"18(?:03|6[12])\"],\"$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"1(?:600\\\\d{6}|8(?:0(?:0\\\\d{4,8}|3\\\\d{9})|6(?:0\\\\d{7}|[12]\\\\d{9})))\",\"\\\\d{8,13}\",,,\"1800123456\"],[,,\"1860\\\\d{7}\",\"\\\\d{11}\",,,\"18603451234\"],,[,,\"1(?:0[0128]|12|298)|2611\",\"\\\\d{3,4}\",,,\"108\"],[,,\"NA\",\"NA\"]],IO:[,[,,\"3\\\\d{6}\",\"\\\\d{7}\"],[,,\"37\\\\d{5}\",\"\\\\d{7}\",,,\"3709100\"],[,,\"38\\\\d{5}\",\"\\\\d{7}\",,,\"3801234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"IO\",246,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",\n,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"]],IQ:[,[,,\"[1-7]\\\\d{7,9}\",\"\\\\d{6,10}\"],[,,\"1\\\\d{7}|(?:2[13-5]|3[02367]|4[023]|5[03]|6[026])\\\\d{6,7}\",\"\\\\d{6,9}\",,,\"12345678\"],[,,\"7[3-9]\\\\d{8}\",\"\\\\d{10}\",,,\"7912345678\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"IQ\",964,\"00\",\"0\",,,\"0\",,,,[[,\"(1)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"],\"0$1\",\"\",0],[,\"([2-6]\\\\d)(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[2-6]\"],\"0$1\",\"\",0],[,\"(7\\\\d{2})(\\\\d{3})(\\\\d{4})\",\n\"$1 $2 $3\",[\"7\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"]],IR:[,[,,\"[2-6]\\\\d{4,9}|9(?:[134]\\\\d{8}|9\\\\d{2,8})|[178]\\\\d{9}\",\"\\\\d{4,10}\"],[,,\"2(?:1[2-9]\\\\d{2,7}|51\\\\d{3,7})|(?:241|3(?:11|51)|441|5[14]1)\\\\d{4,7}|(?:3(?:34|41)|6(?:11|52))\\\\d{6,7}|(?:1(?:[134589][12]|[27][1-4])|2(?:2[189]|[3689][12]|42|5[256]|7[34])|3(?:12|2[1-4]|3[125]|4[24-9]|5[23]|[6-9][12])|4(?:[135-9][12]|2[1-467]|4[2-4])|5(?:12|2[89]|3[1-5]|4[2-8]|[5-7][12]|8[1245])|6(?:12|[347-9][12]|51|6[1-6])|7(?:[13589][12]|2[1289]|4[1-4]|6[1-6]|7[1-3])|8(?:[145][12]|3[124578]|6[1256]|7[1245]))\\\\d{7}\",\n\"\\\\d{5,10}\",,,\"2123456789\"],[,,\"9(?:1\\\\d|3[124-9])\\\\d{7}\",\"\\\\d{10}\",,,\"9123456789\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"993[12]\\\\d{6}\",\"\\\\d{10}\",,,\"9932123456\"],\"IR\",98,\"00\",\"0\",,,\"0\",,,,[[,\"(21)(\\\\d{3,5})\",\"$1 $2\",[\"21\"],\"0$1\",\"\",0],[,\"(21)(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"21\"],\"0$1\",\"\",0],[,\"(21)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"21\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[13-9]|2[02-9]\"],\"0$1\",\"\",0]],,[,,\"943[24678]\\\\d{6}\",\"\\\\d{10}\",,,\"9432123456\"],,,[,,\"NA\",\n\"NA\"],[,,\"9990\\\\d{0,6}\",\"\\\\d{4,10}\",,,\"9990123456\"],,[,,\"1(?:1[025]|25)\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],IS:[,[,,\"[4-9]\\\\d{6}|38\\\\d{7}\",\"\\\\d{7,9}\"],[,,\"(?:4(?:1[0-245]|2[0-7]|[37][0-8]|4[0245]|5[0-356]|6\\\\d|8[0-46-8]|9[013-79])|5(?:05|[156]\\\\d|2[02578]|3[013-6]|4[03-6]|7[0-2578]|8[0-25-9]|9[013-689])|87[23])\\\\d{4}\",\"\\\\d{7}\",,,\"4101234\"],[,,\"38[59]\\\\d{6}|(?:6(?:1[0-8]|3[0-27-9]|4[0-27]|5[0-29]|[67][0-69]|9\\\\d)|7(?:5[057]|7[0-7])|8(?:2[0-5]|[469]\\\\d|5[1-9]))\\\\d{4}\",\"\\\\d{7,9}\",,,\"6101234\"],[,,\"800\\\\d{4}\",\n\"\\\\d{7}\",,,\"8001234\"],[,,\"90\\\\d{5}\",\"\\\\d{7}\",,,\"9011234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"49[013-79]\\\\d{4}\",\"\\\\d{7}\",,,\"4931234\"],\"IS\",354,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[4-9]\"],\"\",\"\",0],[,\"(3\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"3\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112\",\"\\\\d{3}\",,,\"112\"],[,,\"388\\\\d{6}|(?:6(?:2[0-8]|49|8\\\\d)|8(?:2[6-9]|[38]\\\\d|50|7[014-9])|95[48])\\\\d{4}\",\"\\\\d{7,9}\",,,\"388123456\"]],IT:[,[,,\"[0189]\\\\d{5,10}|3(?:[12457-9]\\\\d{8}|[36]\\\\d{7,9})\",\n\"\\\\d{6,11}\"],[,,\"0(?:[26]\\\\d{4,9}|[13-57-9](?:[0159]\\\\d{4,8}|[2-46-8]\\\\d{5,8}))\",\"\\\\d{6,11}\",,,\"0212345678\"],[,,\"3(?:[12457-9]\\\\d{8}|6\\\\d{7,8}|3\\\\d{7,9})\",\"\\\\d{9,11}\",,,\"3123456789\"],[,,\"80(?:0\\\\d{6}|3\\\\d{3})\",\"\\\\d{6,9}\",,,\"800123456\"],[,,\"0878\\\\d{5}|1(?:44|6[346])\\\\d{6}|89(?:2\\\\d{3}|9\\\\d{6})\",\"\\\\d{6,9}\",,,\"899123456\"],[,,\"84[78]\\\\d{6,7}\",\"\\\\d{9,10}\",,,\"8481234567\"],[,,\"178\\\\d{6,7}\",\"\\\\d{9,10}\",,,\"1781234567\"],[,,\"NA\",\"NA\"],\"IT\",39,\"00\",,,,,,,,[[,\"(0[26])(\\\\d{3,4})(\\\\d{4})\",\"$1 $2 $3\",[\"0[26]\"],\"\",\n\"\",0],[,\"(0[26])(\\\\d{4})(\\\\d{5})\",\"$1 $2 $3\",[\"0[26]\"],\"\",\"\",0],[,\"(0[26])(\\\\d{4,6})\",\"$1 $2\",[\"0[26]\"],\"\",\"\",0],[,\"(0\\\\d{2})(\\\\d{3,4})(\\\\d{4})\",\"$1 $2 $3\",[\"0[13-57-9][0159]\"],\"\",\"\",0],[,\"(0\\\\d{2})(\\\\d{4,6})\",\"$1 $2\",[\"0[13-57-9][0159]\"],\"\",\"\",0],[,\"(0\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"0[13-57-9][2-46-8]\"],\"\",\"\",0],[,\"(0\\\\d{3})(\\\\d{4,6})\",\"$1 $2\",[\"0[13-57-9][2-46-8]\"],\"\",\"\",0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[13]|8(?:00|4[78]|99)\"],\"\",\"\",0],[,\"(\\\\d{3})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",\n[\"3\"],\"\",\"\",0],[,\"(\\\\d{3})(\\\\d{3,6})\",\"$1 $2\",[\"8(?:03|92)\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],1,[,,\"11[2358]\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],JE:[,[,,\"[135789]\\\\d{6,9}\",\"\\\\d{6,10}\"],[,,\"1534\\\\d{6}\",\"\\\\d{6,10}\",,,\"1534456789\"],[,,\"7(?:509|7(?:00|97)|829|937)\\\\d{6}\",\"\\\\d{10}\",,,\"7797123456\"],[,,\"80(?:07(?:35|81)|8901)\\\\d{4}\",\"\\\\d{10}\",,,\"8007354567\"],[,,\"(?:871206|90(?:066[59]|1810|71(?:07|55)))\\\\d{4}\",\"\\\\d{10}\",,,\"9018105678\"],[,,\"8(?:4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|70002)\\\\d{4}\",\n\"\\\\d{10}\",,,\"8447034567\"],[,,\"701511\\\\d{4}\",\"\\\\d{10}\",,,\"7015115678\"],[,,\"56\\\\d{8}\",\"\\\\d{10}\",,,\"5612345678\"],\"JE\",44,\"00\",\"0\",\" x\",,\"0\",,,,,,[,,\"76(?:0[012]|2[356]|4[0134]|5[49]|6[0-369]|77|81|9[39])\\\\d{6}\",\"\\\\d{10}\",,,\"7640123456\"],,,[,,\"NA\",\"NA\"],[,,\"3(?:0(?:07(?:35|81)|8901)|3\\\\d{4}|4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))\\\\d{4}|55\\\\d{8}\",\"\\\\d{10}\",,,\"5512345678\"],,[,,\"112|999\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],JM:[,[,,\"[589]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"876(?:5(?:0[12]|1[0-468]|2[35]|63)|6(?:0[1-3579]|1[027-9]|[23]\\\\d|40|5[06]|6[2-489]|7[05]|8[04]|9[4-9])|7(?:0[2-689]|[1-6]\\\\d|8[056]|9[45])|9(?:0[1-8]|1[02378]|[2-8]\\\\d|9[2-468]))\\\\d{4}\",\n\"\\\\d{7}(?:\\\\d{3})?\",,,\"8765123456\"],[,,\"876(?:2[1789]\\\\d|[348]\\\\d{2}|5(?:08|27|6[0-24-9]|[3-578]\\\\d)|7(?:0[07]|7\\\\d|8[1-47-9]|9[0-36-9])|9(?:[01]9|9[0579]))\\\\d{4}\",\"\\\\d{10}\",,,\"8762101234\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002123456\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002123456\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"JM\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,\"876\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[09]\",\"\\\\d{3}\",,,\"119\"],[,,\"NA\",\"NA\"]],\nJO:[,[,,\"[235-9]\\\\d{7,8}\",\"\\\\d{7,9}\"],[,,\"(?:2[67]|32|53|6[2-5]|87)\\\\d{6}\",\"\\\\d{7,8}\",,,\"62001234\"],[,,\"7(?:45|5\\\\d|7[2-79]|8[5-8]|9[035-9])\\\\d{6}\",\"\\\\d{9}\",,,\"790123456\"],[,,\"80\\\\d{6}\",\"\\\\d{8}\",,,\"80012345\"],[,,\"900\\\\d{5}\",\"\\\\d{8}\",,,\"90012345\"],[,,\"85\\\\d{6}\",\"\\\\d{8}\",,,\"85012345\"],[,,\"70\\\\d{7}\",\"\\\\d{9}\",,,\"700123456\"],[,,\"NA\",\"NA\"],\"JO\",962,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[2356]|87\"],\"(0$1)\",\"\",0],[,\"(7)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"7[457-9]\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{5,6})\",\n\"$1 $2\",[\"70|8[0158]|9\"],\"0$1\",\"\",0]],,[,,\"74(?:66|77)\\\\d{5}\",\"\\\\d{9}\",,,\"746612345\"],,,[,,\"NA\",\"NA\"],[,,\"8(?:10|8\\\\d)\\\\d{5}\",\"\\\\d{8}\",,,\"88101234\"],,[,,\"1(?:12|91)|911\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],JP:[,[,,\"[1-9]\\\\d{8,9}|0(?:3\\\\d{9}|7\\\\d{5,7}|8\\\\d{7})\",\"\\\\d{7,11}\"],[,,\"(?:1(?:1[235-8]|2[3-6]|3[3-9]|4[2-6]|[58][2-8]|6[2-7]|7[2-9]|9[1-9])|2[2-9]\\\\d|[36][1-9]\\\\d|4(?:6[02-8]|[2-578]\\\\d|9[2-59])|5(?:6[1-9]|7[2-8]|[2-589]\\\\d)|7(?:3[4-9]|4[02-9]|[25-9]\\\\d)|8(?:3[2-9]|4[5-9]|5[1-9]|8[03-9]|[2679]\\\\d)|9(?:[679][1-9]|[2-58]\\\\d))\\\\d{6}\",\n\"\\\\d{9}\",,,\"312345678\"],[,,\"(?:[79]0\\\\d|80[1-9])\\\\d{7}\",\"\\\\d{10}\",,,\"7012345678\"],[,,\"120\\\\d{6}|800\\\\d{7}|0(?:777(?:[01]\\\\d{2}|5\\\\d{3}|8\\\\d{4})|882[1245]\\\\d{4})\",\"\\\\d{7,10}\",,,\"120123456\"],[,,\"990\\\\d{6}\",\"\\\\d{9}\",,,\"990123456\"],[,,\"NA\",\"NA\"],[,,\"60\\\\d{7}\",\"\\\\d{9}\",,,\"601234567\"],[,,\"(?:037|50)\\\\d{8}\",\"\\\\d{10,11}\",,,\"5012345678\"],\"JP\",81,\"010\",\"0\",,,\"0\",,,,[[,\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1-$2-$3\",[\"(?:12|57|99)0\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\",[\"800\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{4})\",\n\"$1-$2\",[\"077\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{2})(\\\\d{3,4})\",\"$1-$2-$3\",[\"077\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{2})(\\\\d{4})\",\"$1-$2-$3\",[\"088\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{4})(\\\\d{4})\",\"$1-$2-$3\",[\"037\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1-$2-$3\",[\"[2579]0|80[1-9]\"],\"0$1\",\"\",0],[,\"(\\\\d{4})(\\\\d)(\\\\d{4})\",\"$1-$2-$3\",[\"1(?:26|3[79]|4[56]|5[4-68]|6[3-5])|5(?:76|97)|499|746|8(?:3[89]|63|47|51)|9(?:49|80|9[16])\",\"1(?:267|3(?:7[247]|9[278])|4(?:5[67]|66)|5(?:47|58|64|8[67])|6(?:3[245]|48|5[4-68]))|5(?:76|97)9|499[2468]|7468|8(?:3(?:8[78]|96)|636|477|51[24])|9(?:496|802|9(?:1[23]|69))\",\n\"1(?:267|3(?:7[247]|9[278])|4(?:5[67]|66)|5(?:47|58|64|8[67])|6(?:3[245]|48|5[4-68]))|5(?:769|979[2-69])|499[2468]|7468|8(?:3(?:8[78]|96[2457-9])|636[2-57-9]|477|51[24])|9(?:496|802|9(?:1[23]|69))\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{2})(\\\\d{4})\",\"$1-$2-$3\",[\"1(?:2[3-6]|3[3-9]|4[2-6]|5[2-8]|[68][2-7]|7[2-689]|9[1-578])|2(?:2[034-9]|3[3-58]|4[0-468]|5[04-8]|6[013-8]|7[06-9]|8[02-57-9]|9[13])|4(?:2[28]|3[689]|6[035-7]|7[05689]|80|9[3-5])|5(?:3[1-36-9]|4[4578]|5[013-8]|6[1-9]|7[2-8]|8[14-7]|9[4-9])|7(?:2[15]|3[5-9]|4[02-9]|6[135-8]|7[0-4689]|9[014-9])|8(?:2[49]|3[3-8]|4[5-8]|5[2-9]|6[35-9]|7[579]|8[03-579]|9[2-8])|9(?:[23]0|4[02-46-9]|5[0245-79]|6[4-9]|7[2-47-9]|8[02-7]|9[3-7])\",\n\"1(?:2[3-6]|3[3-9]|4[2-6]|5(?:[236-8]|[45][2-69])|[68][2-7]|7[2-689]|9[1-578])|2(?:2(?:[04-9]|3[23])|3[3-58]|4[0-468]|5(?:5[78]|7[2-4]|[0468][2-9])|6(?:[0135-8]|4[2-5])|7(?:[0679]|8[2-7])|8(?:[024578]|3[25-9]|9[6-9])|9(?:11|3[2-4]))|4(?:2(?:2[2-9]|8[237-9])|3[689]|6[035-7]|7(?:[059][2-8]|[68])|80|9[3-5])|5(?:3[1-36-9]|4[4578]|5[013-8]|6[1-9]|7[2-8]|8[14-7]|9(?:[89][2-8]|[4-7]))|7(?:2[15]|3[5-9]|4[02-9]|6[135-8]|7[0-4689]|9(?:[017-9]|4[6-8]|5[2-478]|6[2-589]))|8(?:2(?:4[4-8]|9[2-8])|3(?:7[2-56]|[3-6][2-9]|8[2-5])|4[5-8]|5[2-9]|6(?:[37]|5[4-7]|6[2-9]|8[2-8]|9[236-9])|7[579]|8[03-579]|9[2-8])|9(?:[23]0|4[02-46-9]|5[0245-79]|6[4-9]|7[2-47-9]|8[02-7]|9(?:3[34]|[4-7]))\",\n\"1(?:2[3-6]|3[3-9]|4[2-6]|5(?:[236-8]|[45][2-69])|[68][2-7]|7[2-689]|9[1-578])|2(?:2(?:[04-9]|3[23])|3[3-58]|4[0-468]|5(?:5[78]|7[2-4]|[0468][2-9])|6(?:[0135-8]|4[2-5])|7(?:[0679]|8[2-7])|8(?:[024578]|3[25-9]|9[6-9])|9(?:11|3[2-4]))|4(?:2(?:2[2-9]|8[237-9])|3[689]|6[035-7]|7(?:[059][2-8]|[68])|80|9[3-5])|5(?:3[1-36-9]|4[4578]|5[013-8]|6[1-9]|7[2-8]|8[14-7]|9(?:[89][2-8]|[4-7]))|7(?:2[15]|3[5-9]|4[02-9]|6[135-8]|7[0-4689]|9(?:[017-9]|4[6-8]|5[2-478]|6[2-589]))|8(?:2(?:4[4-8]|9(?:[3578]|20|4[04-9]|6[56]))|3(?:7(?:[2-5]|6[0-59])|[3-6][2-9]|8[2-5])|4[5-8]|5[2-9]|6(?:[37]|5(?:[467]|5[014-9])|6(?:[2-8]|9[02-69])|8[2-8]|9(?:[236-8]|9[23]))|7[579]|8[03-579]|9[2-8])|9(?:[23]0|4[02-46-9]|5[0245-79]|6[4-9]|7[2-47-9]|8[02-7]|9(?:3(?:3[02-9]|4[0-24689])|4[2-69]|[5-7]))\",\n\"1(?:2[3-6]|3[3-9]|4[2-6]|5(?:[236-8]|[45][2-69])|[68][2-7]|7[2-689]|9[1-578])|2(?:2(?:[04-9]|3[23])|3[3-58]|4[0-468]|5(?:5[78]|7[2-4]|[0468][2-9])|6(?:[0135-8]|4[2-5])|7(?:[0679]|8[2-7])|8(?:[024578]|3[25-9]|9[6-9])|9(?:11|3[2-4]))|4(?:2(?:2[2-9]|8[237-9])|3[689]|6[035-7]|7(?:[059][2-8]|[68])|80|9[3-5])|5(?:3[1-36-9]|4[4578]|5[013-8]|6[1-9]|7[2-8]|8[14-7]|9(?:[89][2-8]|[4-7]))|7(?:2[15]|3[5-9]|4[02-9]|6[135-8]|7[0-4689]|9(?:[017-9]|4[6-8]|5[2-478]|6[2-589]))|8(?:2(?:4[4-8]|9(?:[3578]|20|4[04-9]|6(?:5[25]|60)))|3(?:7(?:[2-5]|6[0-59])|[3-6][2-9]|8[2-5])|4[5-8]|5[2-9]|6(?:[37]|5(?:[467]|5[014-9])|6(?:[2-8]|9[02-69])|8[2-8]|9(?:[236-8]|9[23]))|7[579]|8[03-579]|9[2-8])|9(?:[23]0|4[02-46-9]|5[0245-79]|6[4-9]|7[2-47-9]|8[02-7]|9(?:3(?:3[02-9]|4[0-24689])|4[2-69]|[5-7]))\"],\n\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\",[\"1|2(?:23|5[5-89]|64|78|8[39]|91)|4(?:2[2689]|64|7[347])|5(?:[2-589]|39)|60|8(?:[46-9]|3[279]|2[124589])|9(?:[235-8]|93)\",\"1|2(?:23|5(?:[57]|[68]0|9[19])|64|78|8[39]|917)|4(?:2(?:[68]|20|9[178])|64|7[347])|5(?:[2-589]|39[67])|60|8(?:[46-9]|3[279]|2[124589])|9(?:[235-8]|93[34])\",\"1|2(?:23|5(?:[57]|[68]0|9(?:17|99))|64|78|8[39]|917)|4(?:2(?:[68]|20|9[178])|64|7[347])|5(?:[2-589]|39[67])|60|8(?:[46-9]|3[279]|2[124589])|9(?:[235-8]|93(?:31|4))\"],\"0$1\",\n\"\",0],[,\"(\\\\d{3})(\\\\d{2})(\\\\d{4})\",\"$1-$2-$3\",[\"2(?:9[14-79]|74|[34]7|[56]9)|82|993\"],\"0$1\",\"\",0],[,\"(\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1-$2-$3\",[\"3|4(?:2[09]|7[01])|6[1-9]\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\",[\"[2479][1-9]\"],\"0$1\",\"\",0]],,[,,\"20\\\\d{8}\",\"\\\\d{10}\",,,\"2012345678\"],,,[,,\"0(?:37\\\\d{8}|777(?:[01]\\\\d{2}|5\\\\d{3}|8\\\\d{4})|882[1245]\\\\d{4})\",\"\\\\d{7,11}\",,,\"0777012\"],[,,\"570\\\\d{6}\",\"\\\\d{9}\",,,\"570123456\"],1,[,,\"11[09]\",\"\\\\d{3}\",,,\"110\"],[,,\"NA\",\"NA\"]],KE:[,[,,\"20\\\\d{4,7}|[4-9]\\\\d{5,9}\",\n\"\\\\d{4,10}\"],[,,\"(?:20|4[0-6]|5\\\\d|6[0-24-9])\\\\d{4,7}\",\"\\\\d{4,9}\",,,\"202012345\"],[,,\"7(?:0[0-5]|[123]\\\\d|5[0-4]|7[0-5]|8[6-9])\\\\d{6}\",\"\\\\d{9}\",,,\"712123456\"],[,,\"800[245-8]\\\\d{5,6}\",\"\\\\d{9,10}\",,,\"800223456\"],[,,\"9(?:00[2-578]|11\\\\d)\\\\d{5}\",\"\\\\d{9}\",,,\"900223456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"KE\",254,\"000\",\"0\",,,\"0\",,,,[[,\"(\\\\d{2})(\\\\d{4,7})\",\"$1 $2\",[\"[24-6]\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{6,7})\",\"$1 $2\",[\"7\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[89]\"],\"0$1\",\"\",0]],\n,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112|999\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],KG:[,[,,\"[356-8]\\\\d{8,9}\",\"\\\\d{5,10}\"],[,,\"(?:3(?:1(?:2\\\\d|3[1-9]|47|5[02]|6[1-8])|2(?:22|3[0-479]|6[0-7])|4(?:22|5[6-9]|6[0-4])|5(?:22|3[4-7]|59|6[0-5])|6(?:22|5[35-7]|6[0-3])|7(?:22|3[468]|4[1-9]|59|6\\\\d|7[5-7])|9(?:22|4[1-8]|6[0-8]))|6(?:09|12|2[2-4])\\\\d)\\\\d{5}\",\"\\\\d{5,10}\",,,\"312123456\"],[,,\"5[124-7]\\\\d{7}|7(?:0[0-357-9]|7\\\\d)\\\\d{6}\",\"\\\\d{9}\",,,\"700123456\"],[,,\"800\\\\d{6,7}\",\"\\\\d{9,10}\",,,\"800123456\"],[,\n,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"KG\",996,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"31[25]|[5-7]\"],\"0$1\",\"\",0],[,\"(\\\\d{4})(\\\\d{5})\",\"$1 $2\",[\"3(?:1[36]|[2-9])\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d)(\\\\d{3})\",\"$1 $2 $3 $4\",[\"8\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"10[123]\",\"\\\\d{3}\",,,\"101\"],[,,\"NA\",\"NA\"]],KH:[,[,,\"[1-9]\\\\d{7,9}\",\"\\\\d{6,10}\"],[,,\"(?:2[3-6]|3[2-6]|4[2-4]|[567][2-5])[2-46-9]\\\\d{5}\",\"\\\\d{6,8}\",,,\"23456789\"],[,,\"(?:(?:1[0-35-9]|6[6-9]|7[06-89])[1-9]|8(?:0[89]|5[2-689]|8\\\\d{2}|[13469]\\\\d|)|9(?:[0-689][1-9]|7[1-9]\\\\d?))\\\\d{5}\",\n\"\\\\d{8,9}\",,,\"91234567\"],[,,\"1800(?:1\\\\d|2[019])\\\\d{4}\",\"\\\\d{10}\",,,\"1800123456\"],[,,\"1900(?:1\\\\d|2[09])\\\\d{4}\",\"\\\\d{10}\",,,\"1900123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"KH\",855,\"00[178]\",\"0\",,,\"0\",,,,[[,\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"1\\\\d[1-9]|[2-9]\"],\"0$1\",\"\",0],[,\"(1[89]00)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"1[89]0\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[789]|666\",\"\\\\d{3}\",,,\"117\"],[,,\"NA\",\"NA\"]],KI:[,[,,\"[2-689]\\\\d{4}\",\"\\\\d{5}\"],[,,\"(?:[234]\\\\d|50|8[1-5])\\\\d{3}\",\n\"\\\\d{5}\",,,\"31234\"],[,,\"6\\\\d{4}|9(?:[0-8]\\\\d|9[015-8])\\\\d{2}\",\"\\\\d{5}\",,,\"61234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"KI\",686,\"00\",,,,\"0\",,,,,,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"99[2349]\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],KM:[,[,,\"[379]\\\\d{6}\",\"\\\\d{7}\"],[,,\"7(?:6[0-37-9]|7[0-57-9])\\\\d{4}\",\"\\\\d{7}\",,,\"7712345\"],[,,\"3[234]\\\\d{5}\",\"\\\\d{7}\",,,\"3212345\"],[,,\"NA\",\"NA\"],[,,\"(?:39[01]|9[01]0)\\\\d{4}\",\"\\\\d{7}\",,,\"9001234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\n\"NA\"],\"KM\",269,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1[78]\",\"\\\\d{2}\",,,\"17\"],[,,\"NA\",\"NA\"]],KN:[,[,,\"[589]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"869(?:2(?:29|36)|302|4(?:6[5-9]|70))\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"8692361234\"],[,,\"869(?:5(?:5[6-8]|6[5-7])|66\\\\d|76[02-6])\\\\d{4}\",\"\\\\d{10}\",,,\"8695561234\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002123456\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002123456\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\n\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"KN\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,\"869\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"333|9(?:11|99)\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],KP:[,[,,\"1\\\\d{9}|[28]\\\\d{7}\",\"\\\\d{6,8}|\\\\d{10}\"],[,,\"2\\\\d{7}|85\\\\d{6}\",\"\\\\d{6,8}\",,,\"21234567\"],[,,\"19[123]\\\\d{7}\",\"\\\\d{10}\",,,\"1921234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"KP\",850,\"00|99\",\"0\",,,\"0\",,,,[[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"],\"0$1\",\"\",0],[,\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",\n[\"2\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"8\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"2(?:[0-24-9]\\\\d{2}|3(?:[0-79]\\\\d|8[02-9]))\\\\d{4}\",\"\\\\d{8}\",,,\"23821234\"],[,,\"NA\",\"NA\"],,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"]],KR:[,[,,\"[1-7]\\\\d{3,9}|8\\\\d{8}\",\"\\\\d{4,10}\"],[,,\"(?:2|[34][1-3]|5[1-5]|6[1-4])(?:1\\\\d{2,3}|[2-9]\\\\d{6,7})\",\"\\\\d{4,10}\",,,\"22123456\"],[,,\"1[0-25-9]\\\\d{7,8}\",\"\\\\d{9,10}\",,,\"1023456789\"],[,,\"80\\\\d{7}\",\"\\\\d{9}\",,,\"801234567\"],[,,\"60[2-9]\\\\d{6}\",\"\\\\d{9}\",,,\"602345678\"],[,,\"NA\",\"NA\"],[,,\"50\\\\d{8}\",\n\"\\\\d{10}\",,,\"5012345678\"],[,,\"70\\\\d{8}\",\"\\\\d{10}\",,,\"7012345678\"],\"KR\",82,\"00(?:[124-68]|[37]\\\\d{2})\",\"0\",,,\"0(8[1-46-8]|85\\\\d{2})?\",,,,[[,\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1-$2-$3\",[\"1(?:0|1[19]|[69]9|5[458])|[57]0\",\"1(?:0|1[19]|[69]9|5(?:44|59|8))|[57]0\"],\"0$1\",\"0$CC-$1\",0],[,\"(\\\\d{2})(\\\\d{3,4})(\\\\d{4})\",\"$1-$2-$3\",[\"1(?:[169][2-8]|[78]|5[1-4])|[68]0|[3-6][1-9][2-9]\",\"1(?:[169][2-8]|[78]|5(?:[1-3]|4[56]))|[68]0|[3-6][1-9][2-9]\"],\"0$1\",\"0$CC-$1\",0],[,\"(\\\\d{3})(\\\\d)(\\\\d{4})\",\"$1-$2-$3\",[\"131\",\"1312\"],\n\"0$1\",\"0$CC-$1\",0],[,\"(\\\\d{3})(\\\\d{2})(\\\\d{4})\",\"$1-$2-$3\",[\"131\",\"131[13-9]\"],\"0$1\",\"0$CC-$1\",0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\",[\"13[2-9]\"],\"0$1\",\"0$CC-$1\",0],[,\"(\\\\d{2})(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3-$4\",[\"30\"],\"0$1\",\"0$CC-$1\",0],[,\"(\\\\d)(\\\\d{3,4})(\\\\d{4})\",\"$1-$2-$3\",[\"2[2-9]\"],\"0$1\",\"0$CC-$1\",0],[,\"(\\\\d)(\\\\d{3,4})\",\"$1-$2\",[\"21[0-46-9]\"],\"0$1\",\"0$CC-$1\",0],[,\"(\\\\d{2})(\\\\d{3,4})\",\"$1-$2\",[\"[3-6][1-9]1\",\"[3-6][1-9]1(?:[0-46-9])\"],\"0$1\",\"0$CC-$1\",0],[,\"(\\\\d{4})(\\\\d{4})\",\"$1-$2\",[\"1(?:5[46-9]|6[04678])\",\n\"1(?:5(?:44|66|77|88|99)|6(?:00|44|6[16]|70|88))\"],\"$1\",\"0$CC-$1\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"1(?:5(?:44|66|77|88|99)|6(?:00|44|6[16]|70|88))\\\\d{4}\",\"\\\\d{8}\",,,\"15441234\"],,[,,\"11[29]\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],KW:[,[,,\"[12569]\\\\d{6,7}|65816\\\\d{6}\",\"\\\\d{7,8}|\\\\d{11}\"],[,,\"(?:18\\\\d|2(?:[23]\\\\d{2}|4[1-35-9]\\\\d|5(?:0[034]|[2-46]\\\\d|5[1-3]|7[1-7])))\\\\d{4}\",\"\\\\d{7,8}\",,,\"22345678\"],[,,\"(?:5(?:0[0-26]|5\\\\d)|6(?:0[034679]|5(?:[015-79]|8(?:[02-9]|1[0-57-9]))|6\\\\d|7[067]|9[69])|9(?:0[09]|4[049]|66|[79]\\\\d))\\\\d{5}\",\n\"\\\\d{8}\",,,\"50012345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"KW\",965,\"00\",,,,,,,,[[,\"(\\\\d{4})(\\\\d{3,4})\",\"$1 $2\",[\"[1269]\"],\"\",\"\",0],[,\"(5[05]\\\\d)(\\\\d{5})\",\"$1 $2\",[\"5\"],\"\",\"\",0],[,\"(65816)(\\\\d{6})\",\"$1 $2\",[\"65816\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112\",\"\\\\d{3}\",,,\"112\"],[,,\"65816\\\\d{6}\",\"\\\\d{11}\",,,\"65816123456\"]],KY:[,[,,\"[3589]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"345(?:2(?:22|44)|444|6(?:23|38|40)|7(?:6[6-9]|77)|8(?:00|1[45]|25|4[89]|88)|9(?:14|4[035-9]))\\\\d{4}\",\n\"\\\\d{7}(?:\\\\d{3})?\",,,\"3452221234\"],[,,\"345(?:32[3-79]|5(?:1[467]|2[5-7]|4[5-9])|9(?:1[679]|2[4-9]|3[89]))\\\\d{4}\",\"\\\\d{10}\",,,\"3453231234\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002345678\"],[,,\"900[2-9]\\\\d{6}|345976\\\\d{4}\",\"\\\\d{10}\",,,\"9002345678\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"KY\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,\"345\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],KZ:[,[,,\"(?:7\\\\d{2}|80[09])\\\\d{7}\",\"\\\\d{10}\"],\n[,,\"7(?:1(?:0(?:[23]\\\\d|4[023]|59|63)|1(?:[23]\\\\d|4[0-79]|59)|2(?:[23]\\\\d|59)|3(?:2\\\\d|3[1-79]|4[0-35-9]|59)|4(?:2\\\\d|3[013-79]|4[0-8]|5[1-79])|5(?:2\\\\d|3[1-8]|4[1-7]|59)|6(?:[234]\\\\d|5[19]|61)|72\\\\d|8(?:[27]\\\\d|3[1-46-9]|4[0-5]))|2(?:1(?:[23]\\\\d|4[46-9]|5[3469])|2(?:2\\\\d|3[0679]|46|5[12679])|3(?:[234]\\\\d|5[139])|4(?:2\\\\d|3[1235-9]|59)|5(?:[23]\\\\d|4[01246-8]|59|61)|6(?:2\\\\d|3[1-9]|4[0-4]|59)|7(?:[23]\\\\d|40|5[279]|7\\\\d)|8(?:[23]\\\\d|4[0-3]|59)|9(?:2\\\\d|3[124578]|59))|3622)\\\\d{5}\",\"\\\\d{10}\",,,\"7123456789\"],\n[,,\"7(?:0[01257]|6[02-4]|7[1578])\\\\d{7}\",\"\\\\d{10}\",,,\"7710009998\"],[,,\"800\\\\d{7}\",\"\\\\d{10}\",,,\"8001234567\"],[,,\"809\\\\d{7}\",\"\\\\d{10}\",,,\"8091234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"751\\\\d{7}\",\"\\\\d{10}\",,,\"7511234567\"],\"KZ\",7,\"810\",\"8\",,,\"8\",,\"8~10\",,,,[,,\"NA\",\"NA\"],,,[,,\"751\\\\d{7}\",\"\\\\d{10}\",,,\"7511234567\"],[,,\"NA\",\"NA\"],,[,,\"1(?:0[123]|12)\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],LA:[,[,,\"[2-57]\\\\d{7,9}\",\"\\\\d{6,10}\"],[,,\"(?:[2-57]1|54)\\\\d{6}\",\"\\\\d{6,8}\",,,\"21212862\"],[,,\"20(?:2[23]|5[4-68]|7[78]|9[7-9])\\\\d{6}\",\n\"\\\\d{10}\",,,\"2023123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"LA\",856,\"00\",\"0\",,,\"0\",,,,[[,\"(20)(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"20\"],\"0$1\",\"\",0],[,\"([2-57]\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"21|[3-57]\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"19[015]\",\"\\\\d{3}\",,,\"190\"],[,,\"NA\",\"NA\"]],LB:[,[,,\"[13-9]\\\\d{6,7}\",\"\\\\d{7,8}\"],[,,\"(?:[14-6]\\\\d{2}|7(?:[2-57-9]\\\\d|62)|[89][2-9]\\\\d)\\\\d{4}\",\"\\\\d{7}\",,,\"1123456\"],[,,\"(?:3\\\\d|7(?:[01]\\\\d|6[01346-9]))\\\\d{5}\",\n\"\\\\d{7,8}\",,,\"71123456\"],[,,\"NA\",\"NA\"],[,,\"9[01]\\\\d{6}\",\"\\\\d{8}\",,,\"90123456\"],[,,\"8[01]\\\\d{6}\",\"\\\\d{8}\",,,\"80123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"LB\",961,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[13-6]|7(?:[2-57-9]|62)|[89][2-9]\"],\"0$1\",\"\",0],[,\"([7-9]\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[89][01]|7(?:[01]|6[01346-9])\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:12|40|75)|999\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],LC:[,[,,\"[5789]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"758(?:234|4(?:5[0-9]|6[2-9]|8[0-2])|638|758)\\\\d{4}\",\n\"\\\\d{7}(?:\\\\d{3})?\",,,\"7582345678\"],[,,\"758(?:28[4-7]|384|4(?:6[01]|8[4-9])|5(?:1[89]|20|84)|7(?:1[2-9]|2[0-4]))\\\\d{4}\",\"\\\\d{10}\",,,\"7582845678\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002123456\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002123456\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"LC\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,\"758\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"9(?:11|99)\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],LI:[,[,,\"(?:66|80|90)\\\\d{7}|[237-9]\\\\d{6}\",\n\"\\\\d{7,9}\"],[,,\"(?:2(?:17|3\\\\d|6[02-58]|96)|3(?:02|7[01357]|8[048]|9[0269])|870)\\\\d{4}\",\"\\\\d{7}\",,,\"2345678\"],[,,\"66(?:[0178][0-4]|2[025-9]|[36]\\\\d|4[129]|5[45]|9[019])\\\\d{5}|7(?:4[2-59]|56|[6-9]\\\\d)\\\\d{4}\",\"\\\\d{7,9}\",,,\"661234567\"],[,,\"80(?:0(?:07|2[238]|79|\\\\d{4})|9\\\\d{2})\\\\d{2}\",\"\\\\d{7,9}\",,,\"8002222\"],[,,\"NA\",\"NA\"],[,,\"90(?:0(?:2[278]|79|\\\\d{4})|1(?:23|\\\\d{4})|6(?:66|\\\\d{4}))\\\\d{2}\",\"\\\\d{7,9}\",,,\"9002222\"],[,,\"701\\\\d{4}\",\"\\\\d{7}\",,,\"7011234\"],[,,\"NA\",\"NA\"],\"LI\",423,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\n\"$1 $2 $3\",[\"[23]|7[4-9]|87\"],\"\",\"\",0],[,\"(6\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"6\"],\"\",\"\",0],[,\"([7-9]0\\\\d)(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",[\"[7-9]0\"],\"\",\"\",0],[,\"([89]0\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[89]0\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:1[278]|44)\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],LK:[,[,,\"[1-9]\\\\d{8}\",\"\\\\d{7,9}\"],[,,\"(?:[189]1|2[13-7]|3[1-8]|4[157]|5[12457]|6[35-7])[2-57]\\\\d{6}\",\"\\\\d{7,9}\",,,\"112345678\"],[,,\"7[125-8]\\\\d{7}\",\"\\\\d{9}\",,,\"712345678\"],\n[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"LK\",94,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d{2})(\\\\d{1})(\\\\d{6})\",\"$1 $2 $3\",[\"[1-689]\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"7\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[0189]\",\"\\\\d{3}\",,,\"119\"],[,,\"NA\",\"NA\"]],LR:[,[,,\"(?:[29]\\\\d|[4-6]|7\\\\d{1,2}|[38]\\\\d{2})\\\\d{6}\",\"\\\\d{7,9}\"],[,,\"2\\\\d{7}\",\"\\\\d{8}\",,,\"21234567\"],[,,\"(?:4[67]|5\\\\d|6[4-8]|7(?:7[67]\\\\d|\\\\d{2})|880\\\\d)\\\\d{5}\",\"\\\\d{7,9}\",,,\"4612345\"],\n[,,\"NA\",\"NA\"],[,,\"90\\\\d{6}\",\"\\\\d{8}\",,,\"90123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"33200\\\\d{4}\",\"\\\\d{9}\",,,\"332001234\"],\"LR\",231,\"00\",\"0\",,,\"0\",,,,[[,\"([279]\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[279]\"],\"0$1\",\"\",0],[,\"(7\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"7\"],\"0$1\",\"\",0],[,\"([4-6])(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[4-6]\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[38]\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"355|911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],LS:[,[,,\"[2568]\\\\d{7}\",\n\"\\\\d{8}\"],[,,\"2\\\\d{7}\",\"\\\\d{8}\",,,\"22123456\"],[,,\"[56]\\\\d{7}\",\"\\\\d{8}\",,,\"50123456\"],[,,\"800[256]\\\\d{4}\",\"\\\\d{8}\",,,\"80021234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"LS\",266,\"00\",,,,,,,,[[,\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[257]\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],LT:[,[,,\"[3-9]\\\\d{7}\",\"\\\\d{8}\"],[,,\"(?:3[1478]|4[124-6]|52)\\\\d{6}\",\"\\\\d{8}\",,,\"31234567\"],[,,\"6\\\\d{7}\",\"\\\\d{8}\",,,\"61234567\"],[,,\"800\\\\d{5}\",\"\\\\d{8}\",,,\"80012345\"],\n[,,\"90[0239]\\\\d{5}\",\"\\\\d{8}\",,,\"90012345\"],[,,\"NA\",\"NA\"],[,,\"700\\\\d{5}\",\"\\\\d{8}\",,,\"70012345\"],[,,\"NA\",\"NA\"],\"LT\",370,\"00\",\"8\",,,\"8\",,,,[[,\"([34]\\\\d)(\\\\d{6})\",\"$1 $2\",[\"37|4(?:1|5[45]|6[2-4])\"],\"(8-$1)\",\"\",0],[,\"([3-6]\\\\d{2})(\\\\d{5})\",\"$1 $2\",[\"3[148]|4(?:[24]|6[09])|528|6\"],\"(8-$1)\",\"\",0],[,\"([7-9]\\\\d{2})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"[7-9]\"],\"8 $1\",\"\",0],[,\"(5)(2\\\\d{2})(\\\\d{4})\",\"$1 $2 $3\",[\"52[0-79]\"],\"(8-$1)\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"0(?:11?|22?|33?)|1(?:0[123]|12)\",\n\"\\\\d{2,3}\",,,\"112\"],[,,\"NA\",\"NA\"]],LU:[,[,,\"[24-9]\\\\d{3,10}|3(?:[0-46-9]\\\\d{2,9}|5[013-9]\\\\d{1,8})\",\"\\\\d{4,11}\"],[,,\"(?:2(?:2\\\\d{1,2}|3[2-9]|[67]\\\\d|4[1-8]\\\\d?|5[1-5]\\\\d?|9[0-24-9]\\\\d?)|3(?:[059][05-9]|[13]\\\\d|[26][015-9]|4[0-26-9]|7[0-389]|8[08])\\\\d?|4\\\\d{2,3}|5(?:[01458]\\\\d|[27][0-69]|3[0-3]|[69][0-7])\\\\d?|7(?:1[019]|2[05-9]|3[05]|[45][07-9]|[679][089]|8[06-9])\\\\d?|8(?:0[2-9]|1[0-36-9]|3[3-9]|[469]9|[58][7-9]|7[89])\\\\d?|9(?:0[89]|2[0-49]|37|49|5[0-27-9]|7[7-9]|9[0-478])\\\\d?)\\\\d{1,7}\",\"\\\\d{4,11}\",\n,,\"27123456\"],[,,\"6[269][18]\\\\d{6}\",\"\\\\d{9}\",,,\"628123456\"],[,,\"800\\\\d{5}\",\"\\\\d{8}\",,,\"80012345\"],[,,\"90[01]\\\\d{5}\",\"\\\\d{8}\",,,\"90012345\"],[,,\"801\\\\d{5}\",\"\\\\d{8}\",,,\"80112345\"],[,,\"70\\\\d{6}\",\"\\\\d{8}\",,,\"70123456\"],[,,\"20\\\\d{2,8}\",\"\\\\d{4,10}\",,,\"2012345\"],\"LU\",352,\"00\",,,,\"(15(?:0[06]|1[12]|35|4[04]|55|6[26]|77|88|99)\\\\d)\",,,,[[,\"(\\\\d{2})(\\\\d{3})\",\"$1 $2\",[\"[23-5]|7[1-9]|[89](?:[1-9]|0[2-9])\"],\"\",\"$CC $1\",0],[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",[\"[23-5]|7[1-9]|[89](?:[1-9]|0[2-9])\"],\"\",\"$CC $1\",\n0],[,\"(\\\\d{2})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"20\"],\"\",\"$CC $1\",0],[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{1,2})\",\"$1 $2 $3 $4\",[\"2(?:[0367]|4[3-8])\"],\"\",\"$CC $1\",0],[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"20\"],\"\",\"$CC $1\",0],[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{1,2})\",\"$1 $2 $3 $4 $5\",[\"2(?:[0367]|4[3-8])\"],\"\",\"$CC $1\",0],[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{1,4})\",\"$1 $2 $3 $4\",[\"2(?:[12589]|4[12])|[3-5]|7[1-9]|[89](?:[1-9]|0[2-9])\"],\"\",\"$CC $1\",0],[,\"(\\\\d{3})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"[89]0[01]|70\"],\n\"\",\"$CC $1\",0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"6\"],\"\",\"$CC $1\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[23]\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],LV:[,[,,\"[2689]\\\\d{7}\",\"\\\\d{8}\"],[,,\"6\\\\d{7}\",\"\\\\d{8}\",,,\"61234567\"],[,,\"2\\\\d{7}\",\"\\\\d{8}\",,,\"21234567\"],[,,\"80\\\\d{6}\",\"\\\\d{8}\",,,\"80123456\"],[,,\"90\\\\d{6}\",\"\\\\d{8}\",,,\"90123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"LV\",371,\"00\",,,,,,,,[[,\"([2689]\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\n\"NA\"],,[,,\"0[123]|112\",\"\\\\d{2,3}\",,,\"112\"],[,,\"NA\",\"NA\"]],LY:[,[,,\"[25679]\\\\d{8}\",\"\\\\d{7,9}\"],[,,\"(?:2[1345]|5[1347]|6[123479]|71)\\\\d{7}\",\"\\\\d{7,9}\",,,\"212345678\"],[,,\"9[1-6]\\\\d{7}\",\"\\\\d{9}\",,,\"912345678\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"LY\",218,\"00\",\"0\",,,\"0\",,,,[[,\"([25679]\\\\d)(\\\\d{7})\",\"$1-$2\",,\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"19[013]\",\"\\\\d{3}\",,,\"193\"],[,,\"NA\",\"NA\"]],MA:[,[,,\"[5689]\\\\d{8}\",\"\\\\d{9}\"],[,,\"5(?:2(?:(?:[015-7]\\\\d|2[2-9]|3[2-57]|4[2-8]|8[235-9]|)\\\\d|9(?:0\\\\d|[89]0))|3(?:(?:[0-4]\\\\d|[57][2-9]|6[235-8]|9[3-9])\\\\d|8(?:0\\\\d|[89]0)))\\\\d{4}\",\n\"\\\\d{9}\",,,\"520123456\"],[,,\"6(?:0[0-36]|[14-7]\\\\d|2[236]|3[348]|99)\\\\d{6}\",\"\\\\d{9}\",,,\"650123456\"],[,,\"80\\\\d{7}\",\"\\\\d{9}\",,,\"801234567\"],[,,\"89\\\\d{7}\",\"\\\\d{9}\",,,\"891234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"MA\",212,\"00\",\"0\",,,\"0\",,,,[[,\"([56]\\\\d{2})(\\\\d{6})\",\"$1-$2\",[\"5(?:2[015-7]|3[0-4])|6\"],\"0$1\",\"\",0],[,\"([58]\\\\d{3})(\\\\d{5})\",\"$1-$2\",[\"5(?:2[2-489]|3[5-9])|892\",\"5(?:2(?:[2-48]|90)|3(?:[5-79]|80))|892\"],\"0$1\",\"\",0],[,\"(5\\\\d{4})(\\\\d{4})\",\"$1-$2\",[\"5(?:29|38)\",\"5(?:29|38)[89]\"],\"0$1\",\"\",\n0],[,\"(8[09])(\\\\d{7})\",\"$1-$2\",[\"8(?:0|9[013-9])\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:[59]|77)\",\"\\\\d{2,3}\",,,\"15\"],[,,\"NA\",\"NA\"]],MC:[,[,,\"[4689]\\\\d{7,8}\",\"\\\\d{8,9}\"],[,,\"9[2-47-9]\\\\d{6}\",\"\\\\d{8}\",,,\"99123456\"],[,,\"6\\\\d{8}|4\\\\d{7}\",\"\\\\d{8,9}\",,,\"612345678\"],[,,\"(?:8\\\\d|90)\\\\d{6}\",\"\\\\d{8}\",,,\"90123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"MC\",377,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[89]\"],\"$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\n\"$1 $2 $3\",[\"4\"],\"0$1\",\"\",0],[,\"(6)(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4 $5\",[\"6\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"8\\\\d{7}\",\"\\\\d{8}\"],[,,\"NA\",\"NA\"],,[,,\"1(?:12|[578])\",\"\\\\d{2,3}\",,,\"112\"],[,,\"NA\",\"NA\"]],MD:[,[,,\"[256-9]\\\\d{7}\",\"\\\\d{8}\"],[,,\"(?:2(?:1[0569]|2\\\\d|3[015-7]|4[1-46-9]|5[0-24689]|6[2-589]|7[1-37]|9[1347-9])|5(?:33|5[257]))\\\\d{5}\",\"\\\\d{5,8}\",,,\"22212345\"],[,,\"(?:562|6(?:50|7[1-4]|[089]\\\\d)|7(?:7[47-9]|[89]\\\\d))\\\\d{5}\",\"\\\\d{8}\",,,\"65012345\"],[,,\"800\\\\d{5}\",\"\\\\d{8}\",,,\"80012345\"],\n[,,\"90[056]\\\\d{5}\",\"\\\\d{8}\",,,\"90012345\"],[,,\"808\\\\d{5}\",\"\\\\d{8}\",,,\"80812345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"MD\",373,\"00\",\"0\",,,\"0\",,,,[[,\"(22)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"22\"],\"0$1\",\"\",0],[,\"([25-7]\\\\d{2})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"2[13-79]|[5-7]\"],\"0$1\",\"\",0],[,\"([89]\\\\d{2})(\\\\d{5})\",\"$1 $2\",[\"[89]\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"8(?:03|14)\\\\d{5}\",\"\\\\d{8}\",,,\"80312345\"],,[,,\"112|90[123]\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],ME:[,[,,\"[2-9]\\\\d{7,8}\",\"\\\\d{6,9}\"],[,,\"(?:20[2-8]|3(?:0[2-7]|1[35-7]|2[3567]|3[4-7])|4(?:0[237]|1[27])|5(?:0[47]|1[27]|2[378]))\\\\d{5}\",\n\"\\\\d{6,8}\",,,\"30234567\"],[,,\"6(?:32\\\\d|[89]\\\\d{2}|7(?:[0-8]\\\\d|9(?:[3-9]|[0-2]\\\\d)))\\\\d{4}\",\"\\\\d{8,9}\",,,\"67622901\"],[,,\"800[28]\\\\d{4}\",\"\\\\d{8}\",,,\"80080002\"],[,,\"(?:88\\\\d|9(?:4[13-8]|5[16-8]))\\\\d{5}\",\"\\\\d{8}\",,,\"94515151\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"78[134579]\\\\d{5}\",\"\\\\d{8}\",,,\"78108780\"],\"ME\",382,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[2-57-9]|6[3789]\",\"[2-57-9]|6(?:[389]|7(?:[0-8]|9[3-9]))\"],\"0$1\",\"\",0],[,\"(67)(9)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"679\",\"679[0-2]\"],\"0$1\",\n\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"77\\\\d{6}\",\"\\\\d{8}\",,,\"77273012\"],,[,,\"1(?:12|2[234])\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],MG:[,[,,\"[23]\\\\d{8}\",\"\\\\d{7,9}\"],[,,\"2(?:0(?:(?:2\\\\d|4[47]|5[3467]|6[279]|8[268]|9[245])\\\\d|7(?:2[29]|[35]\\\\d))|210\\\\d)\\\\d{4}\",\"\\\\d{7,9}\",,,\"202123456\"],[,,\"3[02-4]\\\\d{7}\",\"\\\\d{9}\",,,\"301234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"MG\",261,\"00\",\"0\",,,\"0\",,,,[[,\"([23]\\\\d)(\\\\d{2})(\\\\d{3})(\\\\d{2})\",\"$1 $2 $3 $4\",,\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],\n,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11?[78]\",\"\\\\d{2,3}\",,,\"117\"],[,,\"NA\",\"NA\"]],MF:[,[,,\"[56]\\\\d{8}\",\"\\\\d{9}\"],[,,\"590(?:10|2[79]|5[128]|[78]7)\\\\d{4}\",\"\\\\d{9}\",,,\"590271234\"],[,,\"690(?:10|2[27]|66|77|8[78])\\\\d{4}\",\"\\\\d{9}\",,,\"690221234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"MF\",590,\"00\",\"0\",,,\"0\",,,,,,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1[578]\",\"\\\\d{2}\",,,\"18\"],[,,\"NA\",\"NA\"]],MH:[,[,,\"[2-6]\\\\d{6}\",\"\\\\d{7}\"],[,,\"(?:247|528|625)\\\\d{4}\",\"\\\\d{7}\",,,\"2471234\"],\n[,,\"(?:235|329|45[56]|545)\\\\d{4}\",\"\\\\d{7}\",,,\"2351234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"635\\\\d{4}\",\"\\\\d{7}\",,,\"6351234\"],\"MH\",692,\"011\",\"1\",,,\"1\",,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1-$2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"]],MK:[,[,,\"[2-578]\\\\d{7}\",\"\\\\d{8}\"],[,,\"(?:2(?:[23]\\\\d|5[125]|61)|3(?:1[3-6]|2[2-6]|3[2-5]|4[235])|4(?:[23][2-6]|4[3-6]|5[25]|6[25-8]|7[24-6]|8[4-6]))\\\\d{5}\",\"\\\\d{6,8}\",,,\"22212345\"],[,,\"7[0-25-8]\\\\d{6}\",\"\\\\d{8}\",\n,,\"72345678\"],[,,\"800\\\\d{5}\",\"\\\\d{8}\",,,\"80012345\"],[,,\"5[02-9]\\\\d{6}\",\"\\\\d{8}\",,,\"50012345\"],[,,\"8(?:0[1-9]|[1-9]\\\\d)\\\\d{5}\",\"\\\\d{8}\",,,\"80123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"MK\",389,\"00\",\"0\",,,\"0\",,,,[[,\"(2)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"2\"],\"0$1\",\"\",0],[,\"([347]\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[347]\"],\"0$1\",\"\",0],[,\"([58]\\\\d{2})(\\\\d)(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[58]\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:12|9[234])\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],ML:[,[,\n,\"[246-8]\\\\d{7}\",\"\\\\d{8}\"],[,,\"(?:2(?:0(?:2[0-589]|7[027-9])|1(?:2[5-7]|[3-689]\\\\d))|442\\\\d)\\\\d{4}\",\"\\\\d{8}\",,,\"20212345\"],[,,\"(?:6(?:[3569]\\\\d)|7(?:[08][1-9]|[3579][0-4]|4[014-7]|[16]\\\\d))\\\\d{5}\",\"\\\\d{8}\",,,\"65012345\"],[,,\"800\\\\d{5}\",\"\\\\d{8}\",,,\"80012345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"ML\",223,\"00\",,,,,,,,[[,\"([246-8]\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1[578]\",\"\\\\d{2}\",,,\"17\"],[,,\"NA\",\"NA\"]],MM:[,[,,\"[124-8]\\\\d{5,7}|9(?:[25689]|[47]\\\\d)\\\\d{6}\",\n\"\\\\d{5,9}\"],[,,\"(?:1\\\\d|2|4[2-6]|5[2-9]|6(?:[0-689]|7\\\\d?)|7[0-5]|8(?:[2-6]|1\\\\d?))\\\\d{5}|1333\\\\d{4}\",\"\\\\d{5,8}\",,,\"1234567\"],[,,\"9(?:[25689]|[47]\\\\d)\\\\d{6}\",\"\\\\d{8,9}\",,,\"92123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"MM\",95,\"00\",\"0\",,,\"0\",,,,[[,\"(1)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"1\"],\"0$1\",\"\",0],[,\"(1)(3)(33\\\\d)(\\\\d{3})\",\"$1 $2 $3 $4\",[\"133\",\"1333\"],\"0$1\",\"\",0],[,\"(2)(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"2\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"67|81\"],\n\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"[4-8]\"],\"0$1\",\"\",0],[,\"(9)(\\\\d{3})(\\\\d{4,5})\",\"$1 $2 $3\",[\"9[24-9]\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"199\",\"\\\\d{3}\",,,\"199\"],[,,\"NA\",\"NA\"]],MN:[,[,,\"[12]\\\\d{7,9}|[57-9]\\\\d{7}\",\"\\\\d{6,10}\"],[,,\"[12](?:1\\\\d|2(?:[1-3]\\\\d?|7\\\\d)|3[2-8]\\\\d{1,2}|4[2-68]\\\\d{1,2}|5[1-4689]\\\\d{1,2})\\\\d{5}|(?:5[0568]|70)\\\\d{6}\",\"\\\\d{6,10}\",,,\"70123456\"],[,,\"(?:8[89]|9[15689])\\\\d{6}\",\"\\\\d{8}\",,,\"88123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\n\"NA\"],[,,\"NA\",\"NA\"],[,,\"7[569]\\\\d{6}\",\"\\\\d{8}\",,,\"75123456\"],\"MN\",976,\"001\",\"0\",,,\"0\",,,,[[,\"([12]\\\\d)(\\\\d{2})(\\\\d{4})\",\"$1 $2 $3\",[\"[12]1\"],\"0$1\",\"\",0],[,\"([12]2\\\\d)(\\\\d{5,6})\",\"$1 $2\",[\"[12]2[1-3]\"],\"0$1\",\"\",0],[,\"([12]\\\\d{3})(\\\\d{5})\",\"$1 $2\",[\"[12](?:27|[3-5])\",\"[12](?:27|[3-5]\\\\d)2\"],\"0$1\",\"\",0],[,\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[57-9]\"],\"$1\",\"\",0],[,\"([12]\\\\d{4})(\\\\d{4,5})\",\"$1 $2\",[\"[12](?:27|[3-5])\",\"[12](?:27|[3-5]\\\\d)[4-9]\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"10[0-3]\",\n\"\\\\d{3}\",,,\"102\"],[,,\"NA\",\"NA\"]],MO:[,[,,\"[268]\\\\d{7}\",\"\\\\d{8}\"],[,,\"(?:28[2-57-9]|8[2-57-9]\\\\d)\\\\d{5}\",\"\\\\d{8}\",,,\"28212345\"],[,,\"6[236]\\\\d{6}\",\"\\\\d{8}\",,,\"66123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"MO\",853,\"00\",,,,,,,,[[,\"([268]\\\\d{3})(\\\\d{4})\",\"$1 $2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"999\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],MP:[,[,,\"[5689]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"670(?:2(?:3[3-7]|56|8[5-8])|32[1238]|4(?:33|8[348])|5(?:32|55|88)|6(?:64|70|82)|78[589]|8[3-9]8|989)\\\\d{4}\",\n\"\\\\d{7}(?:\\\\d{3})?\",,,\"6702345678\"],[,,\"670(?:2(?:3[3-7]|56|8[5-8])|32[1238]|4(?:33|8[348])|5(?:32|55|88)|6(?:64|70|82)|78[589]|8[3-9]8|989)\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"6702345678\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002123456\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002123456\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"MP\",1,\"011\",\"1\",,,\"1\",,,1,,,[,,\"NA\",\"NA\"],,\"670\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],MQ:[,\n[,,\"[56]\\\\d{8}\",\"\\\\d{9}\"],[,,\"596(?:0[2-5]|[12]0|3[05-9]|4[024-8]|[5-7]\\\\d|89|9[4-8])\\\\d{4}\",\"\\\\d{9}\",,,\"596301234\"],[,,\"696(?:[0-479]\\\\d|5[01]|8[0-689])\\\\d{4}\",\"\\\\d{9}\",,,\"696201234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"MQ\",596,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",,\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:12|[578])\",\"\\\\d{2,3}\",,,\"15\"],[,,\"NA\",\"NA\"]],MR:[,[,,\"[2-48]\\\\d{7}\",\"\\\\d{8}\"],[,,\"25[08]\\\\d{5}|35\\\\d{6}|45[1-7]\\\\d{5}\",\n\"\\\\d{8}\",,,\"35123456\"],[,,\"(?:2(?:2\\\\d|70)|3(?:3\\\\d|6[1-36]|7[1-3])|4(?:4\\\\d|6[0457-9]|7[4-9]))\\\\d{5}\",\"\\\\d{8}\",,,\"22123456\"],[,,\"800\\\\d{5}\",\"\\\\d{8}\",,,\"80012345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"MR\",222,\"00\",,,,,,,,[[,\"([2-48]\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1[78]\",\"\\\\d{2}\",,,\"17\"],[,,\"NA\",\"NA\"]],MS:[,[,,\"[5689]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"664491\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"6644912345\"],[,,\"664492\\\\d{4}\",\n\"\\\\d{10}\",,,\"6644923456\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002123456\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002123456\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"MS\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,\"664\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"9(?:11|99)\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],MT:[,[,,\"[2579]\\\\d{7}\",\"\\\\d{8}\"],[,,\"2(?:0(?:1[0-6]|[69]\\\\d)|[1-357]\\\\d{2})\\\\d{4}\",\"\\\\d{8}\",,,\"21001234\"],[,,\"(?:7(?:210|[79]\\\\d{2}|)|9(?:2[13]\\\\d|696|8(?:1[1-3]|89|97)|9\\\\d{2}))\\\\d{4}\",\n\"\\\\d{8}\",,,\"96961234\"],[,,\"NA\",\"NA\"],[,,\"50(?:0(?:3[1679]|4\\\\d)|[169]\\\\d{2}|7[06]\\\\d)\\\\d{3}\",\"\\\\d{8}\",,,\"50031234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"MT\",356,\"00\",,,,,,,,[[,\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",,\"\",\"\",0]],,[,,\"7117\\\\d{4}\",\"\\\\d{8}\",,,\"71171234\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],MU:[,[,,\"[2-9]\\\\d{6}\",\"\\\\d{7}\"],[,,\"(?:2(?:[034789]\\\\d|1[0-7])|4(?:[013-8]\\\\d|2[4-7])|[56]\\\\d{2}|8(?:14|3[129]))\\\\d{4}\",\"\\\\d{7}\",,,\"2012345\"],[,,\"(?:25\\\\d|4(?:2[12389]|9\\\\d)|7\\\\d{2}|87[15-8]|9[1-8]\\\\d)\\\\d{4}\",\n\"\\\\d{7}\",,,\"2512345\"],[,,\"80[012]\\\\d{4}\",\"\\\\d{7}\",,,\"8001234\"],[,,\"30\\\\d{5}\",\"\\\\d{7}\",,,\"3012345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"3(?:20|9\\\\d)\\\\d{4}\",\"\\\\d{7}\",,,\"3201234\"],\"MU\",230,\"0(?:[2-7]0|33)\",,,,,,\"020\",,[[,\"([2-9]\\\\d{2})(\\\\d{4})\",\"$1 $2\",,\"\",\"\",0]],,[,,\"2(?:1[89]|2\\\\d)\\\\d{4}\",\"\\\\d{7}\",,,\"2181234\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[45]|99\\\\d\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],MV:[,[,,\"[3467]\\\\d{6}|9(?:00\\\\d{7}|\\\\d{6})\",\"\\\\d{7,10}\"],[,,\"(?:3(?:0[01]|3[0-59]|)|6(?:[567][02468]|8[024689]|90))\\\\d{4}\",\n\"\\\\d{7}\",,,\"6701234\"],[,,\"(?:46[46]|7[3-9]\\\\d|9[6-9]\\\\d)\\\\d{4}\",\"\\\\d{7}\",,,\"7712345\"],[,,\"NA\",\"NA\"],[,,\"900\\\\d{7}\",\"\\\\d{10}\",,,\"9001234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"MV\",960,\"0(?:0|19)\",,,,,,\"00\",,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1-$2\",[\"[3467]|9(?:[1-9]|0[1-9])\"],\"\",\"\",0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"900\"],\"\",\"\",0]],,[,,\"781\\\\d{4}\",\"\\\\d{7}\",,,\"7812345\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:02|19)\",\"\\\\d{3}\",,,\"102\"],[,,\"NA\",\"NA\"]],MW:[,[,,\"(?:[3-5]|[27]\\\\d{2}|[189](?:\\\\d{2})?)\\\\d{6}\",\n\"\\\\d{7,9}\"],[,,\"(?:1[2-9]|21\\\\d{2})\\\\d{5}\",\"\\\\d{7,9}\",,,\"1234567\"],[,,\"(?:111|[3-5]|77\\\\d|8(?:8\\\\d)?|9(?:9\\\\d)?)\\\\d{6}\",\"\\\\d{7,9}\",,,\"991234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"MW\",265,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[13-5]\"],\"0$1\",\"\",0],[,\"(2\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"2\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[1789]\"],\"0$1\",\"\",0],[,\"(\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[89]\"],\"0$1\",\"\",0]],,[,,\"NA\",\n\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"199|99[789]\",\"\\\\d{3}\",,,\"997\"],[,,\"NA\",\"NA\"]],MX:[,[,,\"[1-9]\\\\d{9,10}\",\"\\\\d{7,11}\"],[,,\"(?:33|55|81)\\\\d{8}|(?:2(?:2[2-9]|3[1-35-8]|4[13-9]|7[1-689]|8[1-578]|9[467])|3(?:1[1-79]|[2458][1-9]|7[1-8]|9[1-5])|4(?:1[1-57-9]|[24-6][1-9]|[37][1-8]|8[1-35-9]|9[2-689])|5(?:88|9[1-79])|6(?:1[2-68]|[234][1-9]|5[1-3689]|6[12457-9]|7[1-7]|8[67]|9[4-8])|7(?:[13467][1-9]|2[1-8]|5[13-9]|8[1-69]|9[17])|8(?:2[13-689]|3[1-6]|4[124-6]|6[1246-9]|7[1-378]|9[12479])|9(?:1[346-9]|2[1-4]|3[2-46-8]|5[1348]|[69][1-9]|7[12]|8[1-8]))\\\\d{7}\",\n\"\\\\d{7,10}\",,,\"2221234567\"],[,,\"1(?:(?:33|55|81)\\\\d{8}|(?:2(?:2[2-9]|3[1-35-8]|4[13-9]|7[1-689]|8[1-578]|9[467])|3(?:1[1-79]|[2458][1-9]|7[1-8]|9[1-5])|4(?:1[1-57-9]|[24-6][1-9]|[37][1-8]|8[1-35-9]|9[2-689])|5(?:88|9[1-79])|6(?:1[2-68]|[2-4][1-9]|5[1-3689]|6[12457-9]|7[1-7]|8[67]|9[4-8])|7(?:[13467][1-9]|2[1-8]|5[13-9]|8[1-69]|9[17])|8(?:2[13-689]|3[1-6]|4[124-6]|6[1246-9]|7[1-378]|9[12479])|9(?:1[346-9]|2[1-4]|3[2-46-8]|5[1348]|[69][1-9]|7[12]|8[1-8]))\\\\d{7})\",\"\\\\d{11}\",,,\"12221234567\"],[,,\"800\\\\d{7}\",\n\"\\\\d{10}\",,,\"8001234567\"],[,,\"900\\\\d{7}\",\"\\\\d{10}\",,,\"9001234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"MX\",52,\"0[09]\",\"01\",,,\"0[12]|04[45](\\\\d{10})\",\"1$1\",,,[[,\"([358]\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"33|55|81\"],\"01 $1\",\"\",1],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[2467]|3[12457-9]|5[89]|8[02-9]|9[0-35-9]\"],\"01 $1\",\"\",1],[,\"(1)([358]\\\\d)(\\\\d{4})(\\\\d{4})\",\"044 $2 $3 $4\",[\"1(?:33|55|81)\"],\"$1\",\"\",0],[,\"(1)(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"044 $2 $3 $4\",[\"1(?:[2467]|3[12457-9]|5[89]|8[2-9]|9[1-35-9])\"],\n\"$1\",\"\",0]],[[,\"([358]\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"33|55|81\"]],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[2467]|3[12457-9]|5[89]|8[02-9]|9[0-35-9]\"]],[,\"(1)([358]\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3 $4\",[\"1(?:33|55|81)\"]],[,\"(1)(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3 $4\",[\"1(?:[2467]|3[12457-9]|5[89]|8[2-9]|9[1-35-9])\"]]],[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"06[568]|911\",\"\\\\d{3}\",,,\"066\"],[,,\"NA\",\"NA\"]],MY:[,[,,\"[13-9]\\\\d{7,9}\",\"\\\\d{6,10}\"],[,,\"(?:3\\\\d{2}|[4-79]\\\\d|8[2-9])\\\\d{6}\",\"\\\\d{6,9}\",\n,,\"312345678\"],[,,\"1(?:[02-46-9][2-9]|11\\\\d)\\\\d{6}\",\"\\\\d{9,10}\",,,\"123456789\"],[,,\"1[38]00\\\\d{6}\",\"\\\\d{10}\",,,\"1300123456\"],[,,\"1600\\\\d{6}\",\"\\\\d{10}\",,,\"1600123456\"],[,,\"NA\",\"NA\"],[,,\"1700\\\\d{6}\",\"\\\\d{10}\",,,\"1700123456\"],[,,\"154\\\\d{7}\",\"\\\\d{10}\",,,\"1541234567\"],\"MY\",60,\"00\",\"0\",,,\"0\",,,,[[,\"([4-79])(\\\\d{3})(\\\\d{4})\",\"$1-$2 $3\",[\"[4-79]\"],\"0$1\",\"\",0],[,\"(3)(\\\\d{4})(\\\\d{4})\",\"$1-$2 $3\",[\"3\"],\"0$1\",\"\",0],[,\"([18]\\\\d)(\\\\d{3})(\\\\d{3,4})\",\"$1-$2 $3\",[\"1[02-46-9][1-9]|8\"],\"0$1\",\"\",0],[,\"(1)([36-8]00)(\\\\d{2})(\\\\d{4})\",\n\"$1-$2-$3-$4\",[\"1[36-8]0\"],\"\",\"\",0],[,\"(11)(\\\\d{4})(\\\\d{4})\",\"$1-$2 $3\",[\"11\"],\"0$1\",\"\",0],[,\"(154)(\\\\d{3})(\\\\d{4})\",\"$1-$2 $3\",[\"15\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112|999\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],MZ:[,[,,\"[28]\\\\d{7,8}\",\"\\\\d{8,9}\"],[,,\"2(?:[1346]\\\\d|5[0-2]|[78][12]|93)\\\\d{5}\",\"\\\\d{8}\",,,\"21123456\"],[,,\"8[246]\\\\d{7}\",\"\\\\d{9}\",,,\"821234567\"],[,,\"800\\\\d{6}\",\"\\\\d{9}\",,,\"800123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"MZ\",258,\"00\",,,,,,,,\n[[,\"([28]\\\\d)(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"2|8[246]\"],\"\",\"\",0],[,\"(80\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"80\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:1[79]|9[78])\",\"\\\\d{3}\",,,\"119\"],[,,\"NA\",\"NA\"]],NA:[,[,,\"[68]\\\\d{7,8}\",\"\\\\d{8,9}\"],[,,\"6(?:1(?:17|2(?:[0189]\\\\d|[23-6]|7\\\\d?)|3(?:2\\\\d|3[378])|4[01]|69|7[014])|2(?:17|25|5(?:[0-36-8]|4\\\\d?)|69|70)|3(?:17|2(?:[0237]\\\\d?|[14-689])|34|6[29]|7[01]|81)|4(?:17|2(?:[012]|7?)|4(?:[06]|1\\\\d)|5(?:[01357]|[25]\\\\d?)|69|7[01])|5(?:17|2(?:[0459]|[23678]\\\\d?)|69|7[01])|6(?:17|2(?:5|6\\\\d?)|38|42|69|7[01])|7(?:17|2(?:[569]|[234]\\\\d?)|3(?:0\\\\d?|[13])|69|7[01]))\\\\d{4}\",\n\"\\\\d{8,9}\",,,\"612012345\"],[,,\"(?:60|8[125])\\\\d{7}\",\"\\\\d{9}\",,,\"811234567\"],[,,\"NA\",\"NA\"],[,,\"8701\\\\d{5}\",\"\\\\d{9}\",,,\"870123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"8(3\\\\d{2}|86)\\\\d{5}\",\"\\\\d{8,9}\",,,\"88612345\"],\"NA\",264,\"00\",\"0\",,,\"0\",,,,[[,\"(8\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"8[1235]\"],\"0$1\",\"\",0],[,\"(6\\\\d)(\\\\d{2,3})(\\\\d{4})\",\"$1 $2 $3\",[\"6\"],\"0$1\",\"\",0],[,\"(88)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"88\"],\"0$1\",\"\",0],[,\"(870)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"870\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,\n,\"NA\",\"NA\"],,[,,\"10111\",\"\\\\d{5}\",,,\"10111\"],[,,\"NA\",\"NA\"]],NC:[,[,,\"[2-47-9]\\\\d{5}\",\"\\\\d{6}\"],[,,\"(?:2[03-9]|3[0-5]|4[1-7]|88)\\\\d{4}\",\"\\\\d{6}\",,,\"201234\"],[,,\"(?:7[3-9]|8[0-79]|9\\\\d)\\\\d{4}\",\"\\\\d{6}\",,,\"751234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"NC\",687,\"00\",,,,,,,,[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1.$2.$3\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1[5-8]\",\"\\\\d{2}\",,,\"15\"],[,,\"NA\",\"NA\"]],NE:[,[,,\"[029]\\\\d{7}\",\"\\\\d{8}\"],[,,\"2(?:0(?:20|3[1-7]|4[134]|5[14]|6[14578]|7[1-578])|1(?:4[145]|5[14]|6[14-68]|7[169]|88))\\\\d{4}\",\n\"\\\\d{8}\",,,\"20201234\"],[,,\"9[0134678]\\\\d{6}\",\"\\\\d{8}\",,,\"93123456\"],[,,\"08\\\\d{6}\",\"\\\\d{8}\",,,\"08123456\"],[,,\"09\\\\d{6}\",\"\\\\d{8}\",,,\"09123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"NE\",227,\"00\",,,,,,,,[[,\"([029]\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[29]|09\"],\"\",\"\",0],[,\"(08)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"08\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],1,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"]],NF:[,[,,\"[13]\\\\d{5}\",\"\\\\d{5,6}\"],[,,\"(?:1(?:06|17|28|39)|3[012]\\\\d)\\\\d{3}\",\"\\\\d{5,6}\",,,\"106609\"],\n[,,\"38\\\\d{4}\",\"\\\\d{5,6}\",,,\"381234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"NF\",672,\"00\",,,,,,,,[[,\"(\\\\d{2})(\\\\d{4})\",\"$1 $2\",[\"1\"],\"\",\"\",0],[,\"(\\\\d)(\\\\d{5})\",\"$1 $2\",[\"3\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"9(?:11|55|77)\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],NG:[,[,,\"[1-69]\\\\d{5,8}|[78]\\\\d{5,13}\",\"\\\\d{5,14}\"],[,,\"[12]\\\\d{6,7}|9\\\\d{7}|(?:4[023568]|5[02368]|6[02-469]|7[569]|8[2-9])\\\\d{6}|(?:4[47]|5[14579]|6[1578]|7[0-357])\\\\d{5,6}|(?:78|41)\\\\d{5}\",\n\"\\\\d{5,9}\",,,\"12345678\"],[,,\"(?:70(?:[3-9]\\\\d|2[1-9])|8(?:0[2-9]|1[0235689])\\\\d)\\\\d{6}\",\"\\\\d{10}\",,,\"8021234567\"],[,,\"800\\\\d{7,11}\",\"\\\\d{10,14}\",,,\"80017591759\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"NG\",234,\"009\",\"0\",,,\"0\",,,,[[,\"([129])(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[129]\"],\"0$1\",\"\",0],[,\"([3-8]\\\\d)(\\\\d{3})(\\\\d{2,3})\",\"$1 $2 $3\",[\"[3-6]|7(?:[1-79]|0[1-9])|8[2-9]\"],\"0$1\",\"\",0],[,\"([78]\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"70|8[01]\"],\"0$1\",\"\",0],[,\"([78]00)(\\\\d{4})(\\\\d{4,5})\",\n\"$1 $2 $3\",[\"[78]00\"],\"0$1\",\"\",0],[,\"([78]00)(\\\\d{5})(\\\\d{5,6})\",\"$1 $2 $3\",[\"[78]00\"],\"0$1\",\"\",0],[,\"(78)(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"78\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"700\\\\d{7,11}\",\"\\\\d{10,14}\",,,\"7001234567\"],,[,,\"199\",\"\\\\d{3}\",,,\"199\"],[,,\"NA\",\"NA\"]],NI:[,[,,\"[128]\\\\d{7}\",\"\\\\d{8}\"],[,,\"2\\\\d{7}\",\"\\\\d{8}\",,,\"21234567\"],[,,\"8\\\\d{7}\",\"\\\\d{8}\",,,\"81234567\"],[,,\"1800\\\\d{4}\",\"\\\\d{8}\",,,\"18001234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"NI\",505,\"00\",,,,,,,,[[,\"(\\\\d{4})(\\\\d{4})\",\n\"$1 $2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"118\",\"\\\\d{3}\",,,\"118\"],[,,\"NA\",\"NA\"]],NL:[,[,,\"1\\\\d{4,8}|[2-7]\\\\d{8}|[89]\\\\d{6,9}\",\"\\\\d{5,10}\"],[,,\"(?:1[0135-8]|2[02-69]|3[0-68]|4[0135-9]|[57]\\\\d|8[478])\\\\d{7}\",\"\\\\d{9}\",,,\"101234567\"],[,,\"6[1-58]\\\\d{7}\",\"\\\\d{9}\",,,\"612345678\"],[,,\"800\\\\d{4,7}\",\"\\\\d{7,10}\",,,\"8001234\"],[,,\"90[069]\\\\d{4,7}\",\"\\\\d{7,10}\",,,\"9001234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"85\\\\d{7}\",\"\\\\d{9}\",,,\"851234567\"],\"NL\",31,\"00\",\"0\",,,\"0\",,,,[[,\"([1-578]\\\\d)(\\\\d{3})(\\\\d{4})\",\n\"$1 $2 $3\",[\"1[035]|2[0346]|3[03568]|4[0356]|5[0358]|7|8[458]\"],\"0$1\",\"\",0],[,\"([1-5]\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"1[16-8]|2[259]|3[124]|4[17-9]|5[124679]\"],\"0$1\",\"\",0],[,\"(6)(\\\\d{8})\",\"$1 $2\",[\"6[0-57-9]\"],\"0$1\",\"\",0],[,\"(66)(\\\\d{7})\",\"$1 $2\",[\"66\"],\"0$1\",\"\",0],[,\"(14)(\\\\d{3,4})\",\"$1 $2\",[\"14\"],\"$1\",\"\",0],[,\"([89]0\\\\d)(\\\\d{4,7})\",\"$1 $2\",[\"80|9\"],\"0$1\",\"\",0]],,[,,\"66\\\\d{7}\",\"\\\\d{9}\",,,\"662345678\"],,,[,,\"14\\\\d{3,4}\",\"\\\\d{5,6}\"],[,,\"140(?:1(?:[035]|[16-8]\\\\d)|2(?:[0346]|[259]\\\\d)|3(?:[03568]|[124]\\\\d)|4(?:[0356]|[17-9]\\\\d)|5(?:[0358]|[124679]\\\\d)|7\\\\d|8[458])\",\n\"\\\\d{5,6}\",,,\"14020\"],,[,,\"112|911\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],NO:[,[,,\"0\\\\d{4}|[2-9]\\\\d{7}\",\"\\\\d{5}(?:\\\\d{3})?\"],[,,\"(?:2[1-4]|3[1-3578]|5[1-35-7]|6[1-4679]|7[0-8])\\\\d{6}\",\"\\\\d{8}\",,,\"21234567\"],[,,\"(?:4[015-8]|9\\\\d)\\\\d{6}\",\"\\\\d{8}\",,,\"41234567\"],[,,\"80[01]\\\\d{5}\",\"\\\\d{8}\",,,\"80012345\"],[,,\"82[09]\\\\d{5}\",\"\\\\d{8}\",,,\"82012345\"],[,,\"810(?:0[0-6]|[2-8]\\\\d)\\\\d{3}\",\"\\\\d{8}\",,,\"81021234\"],[,,\"880\\\\d{5}\",\"\\\\d{8}\",,,\"88012345\"],[,,\"NA\",\"NA\"],\"NO\",47,\"00\",,,,,,,,[[,\"([489]\\\\d{2})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",\n[\"[489]\"],\"\",\"\",0],[,\"([235-7]\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[235-7]\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],1,,[,,\"NA\",\"NA\"],[,,\"0\\\\d{4}|81(?:0(?:0[7-9]|1\\\\d)|5\\\\d{2})\\\\d{3}\",\"\\\\d{5}(?:\\\\d{3})?\",,,\"01234\"],1,[,,\"11[023]\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],NP:[,[,,\"[1-8]\\\\d{7}|9(?:[1-69]\\\\d{6}|7[2-6]\\\\d{5,7}|8\\\\d{8})\",\"\\\\d{6,10}\"],[,,\"(?:1[0124-6]|2[13-79]|3[135-8]|4[146-9]|5[135-7]|6[13-9]|7[15-9]|8[1-46-9]|9[1-79])\\\\d{6}\",\"\\\\d{6,8}\",,,\"14567890\"],[,,\"9(?:7[45]|8[0145])\\\\d{7}\",\"\\\\d{10}\",,,\"9841234567\"],\n[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"NP\",977,\"00\",\"0\",,,\"0\",,,,[[,\"(1)(\\\\d{7})\",\"$1-$2\",[\"1[2-6]\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{6})\",\"$1-$2\",[\"1[01]|[2-8]|9(?:[1-69]|7[15-9])\"],\"0$1\",\"\",0],[,\"(9\\\\d{2})(\\\\d{7})\",\"$1-$2\",[\"9(?:7[45]|8)\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:0[0-3]|12)\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],NR:[,[,,\"[458]\\\\d{6}\",\"\\\\d{7}\"],[,,\"(?:444|888)\\\\d{4}\",\"\\\\d{7}\",,,\"4441234\"],[,,\"55[5-9]\\\\d{4}\",\"\\\\d{7}\",,,\"5551234\"],[,\n,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"NR\",674,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[0-2]\",\"\\\\d{3}\",,,\"110\"],[,,\"NA\",\"NA\"]],NU:[,[,,\"[1-5]\\\\d{3}\",\"\\\\d{4}\"],[,,\"[34]\\\\d{3}\",\"\\\\d{4}\",,,\"4002\"],[,,\"[125]\\\\d{3}\",\"\\\\d{4}\",,,\"1234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"NU\",683,\"00\",,,,,,,,,,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"999\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],\nNZ:[,[,,\"6[235-9]\\\\d{6}|[2-57-9]\\\\d{7,10}\",\"\\\\d{7,11}\"],[,,\"(?:3[2-79]|[49][2-689]|6[235-9]|7[2-589])\\\\d{6}|24099\\\\d{3}\",\"\\\\d{7,8}\",,,\"32345678\"],[,,\"2(?:[079]\\\\d{7}|1(?:0\\\\d{5,7}|[12]\\\\d{5,6}|[3-9]\\\\d{5})|[28]\\\\d{7,8}|4[1-9]\\\\d{6})\",\"\\\\d{8,10}\",,,\"211234567\"],[,,\"508\\\\d{6,7}|80\\\\d{6,8}\",\"\\\\d{8,10}\",,,\"800123456\"],[,,\"90\\\\d{7,9}\",\"\\\\d{9,11}\",,,\"900123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"NZ\",64,\"0(?:0|161)\",\"0\",,,\"0\",,\"00\",,[[,\"([34679])(\\\\d{3})(\\\\d{4})\",\"$1-$2 $3\",[\"[3467]|9[1-9]\"],\"0$1\",\n\"\",0],[,\"(21)(\\\\d{4})(\\\\d{3,4})\",\"$1 $2 $3\",[\"21\"],\"0$1\",\"\",0],[,\"(22)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"22\"],\"0$1\",\"\",0],[,\"([2589]\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"2[0247-9]|5|[89]00\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"2[0169]|86\"],\"0$1\",\"\",0],[,\"(24099)(\\\\d{3})\",\"$1 $2\",[\"240\",\"2409\",\"24099\"],\"0$1\",\"\",0]],,[,,\"[28]6\\\\d{6,7}\",\"\\\\d{8,9}\",,,\"26123456\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"111\",\"\\\\d{3}\",,,\"111\"],[,,\"NA\",\"NA\"]],OM:[,[,,\"(?:2[3-6]|5|9[2-9])\\\\d{6}|800\\\\d{5,6}\",\"\\\\d{7,9}\"],\n[,,\"2[3-6]\\\\d{6}\",\"\\\\d{8}\",,,\"23123456\"],[,,\"9[2-9]\\\\d{6}\",\"\\\\d{8}\",,,\"92123456\"],[,,\"8007\\\\d{4,5}|500\\\\d{4}\",\"\\\\d{7,9}\",,,\"80071234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"OM\",968,\"00\",,,,,,,,[[,\"(2\\\\d)(\\\\d{6})\",\"$1 $2\",[\"2\"],\"\",\"\",0],[,\"(9\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"9\"],\"\",\"\",0],[,\"([58]00)(\\\\d{4,6})\",\"$1 $2\",[\"[58]\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"9999\",\"\\\\d{4}\",,,\"9999\"],[,,\"NA\",\"NA\"]],PA:[,[,,\"[1-9]\\\\d{6,7}\",\"\\\\d{7,8}\"],[,,\"(?:1(?:0[02-579]|19|23|3[03]|4[479]|5[57]|65|7[016-8]|8[58]|9[1-49])|2(?:[0235679]\\\\d|1[0-7]|4[04-9]|8[028])|3(?:0[0-7]|1[14-7]|2[0-3]|3[03]|4[0457]|5[56]|6[068]|7[078]|80|9[0-79])|4(?:3[013-59]|4\\\\d|7[0-689])|5(?:[01]\\\\d|2[0-7]|[56]0|79)|7(?:09|2[0-267]|[34]0|5[6-9]|7[0-24-7]|8[89]|99)|8(?:[34]\\\\d|5[0-5]|8[02])|9(?:0[78]|1[0178]|2[0378]|3[379]|40|5[0489]|6[06-9]|7[046-9]|8[36-8]|9[1-9]))\\\\d{4}\",\n\"\\\\d{7}\",,,\"2001234\"],[,,\"(?:161|21[89]|8(?:1[01]|7[23]))\\\\d{4}|6(?:[04-8]\\\\d|1[0-5]|2[0-4]|3[7-9]|9[0-8])\\\\d{5}\",\"\\\\d{7,8}\",,,\"60012345\"],[,,\"80[09]\\\\d{4}\",\"\\\\d{7}\",,,\"8001234\"],[,,\"(?:779|8(?:2[235]|60|7[578]|86|95)|9(?:0[0-2]|81))\\\\d{4}\",\"\\\\d{7}\",,,\"8601234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"PA\",507,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1-$2\",[\"[1-57-9]\"],\"\",\"\",0],[,\"(\\\\d{4})(\\\\d{4})\",\"$1-$2\",[\"6\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\n\"NA\"]],PE:[,[,,\"[14-9]\\\\d{7,8}\",\"\\\\d{6,9}\"],[,,\"(?:1\\\\d|4[1-4]|5[1-46]|6[1-7]|7[2-46]|8[2-4])\\\\d{6}\",\"\\\\d{6,8}\",,,\"11234567\"],[,,\"9\\\\d{8}\",\"\\\\d{9}\",,,\"912345678\"],[,,\"800\\\\d{5}\",\"\\\\d{8}\",,,\"80012345\"],[,,\"805\\\\d{5}\",\"\\\\d{8}\",,,\"80512345\"],[,,\"801\\\\d{5}\",\"\\\\d{8}\",,,\"80112345\"],[,,\"80[24]\\\\d{5}\",\"\\\\d{8}\",,,\"80212345\"],[,,\"NA\",\"NA\"],\"PE\",51,\"19(?:1[124]|77|90)00\",\"0\",\" Anexo \",,\"0\",,,,[[,\"(1)(\\\\d{7})\",\"$1 $2\",[\"1\"],\"(0$1)\",\"\",0],[,\"([4-8]\\\\d)(\\\\d{6})\",\"$1 $2\",[\"[4-7]|8[2-4]\"],\"(0$1)\",\"\",0],[,\"(\\\\d{3})(\\\\d{5})\",\n\"$1 $2\",[\"80\"],\"(0$1)\",\"\",0],[,\"(9\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"9\"],\"$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:05|1[67])\",\"\\\\d{3}\",,,\"105\"],[,,\"NA\",\"NA\"]],PF:[,[,,\"[2-9]\\\\d{5}\",\"\\\\d{6}\"],[,,\"(?:36\\\\d|4(?:[02-9]\\\\d|1[02-9])|[5689]\\\\d{2})\\\\d{3}\",\"\\\\d{6}\",,,\"401234\"],[,,\"(?:[27]\\\\d{3}|3[0-59]\\\\d{2}|411[3-6])\\\\d{2}\",\"\\\\d{6}\",,,\"212345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"PF\",689,\"00\",,,,,,,,[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",,\"\",\n\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"(?:36|44)\\\\d{4}\",\"\\\\d{6}\",,,\"441234\"],[,,\"NA\",\"NA\"],,[,,\"1[578]\",\"\\\\d{2}\",,,\"15\"],[,,\"NA\",\"NA\"]],PG:[,[,,\"[1-9]\\\\d{6,7}\",\"\\\\d{7,8}\"],[,,\"(?:3\\\\d{2}|4[257]\\\\d|5[34]\\\\d|6(?:29|4[1-9])|85[02-46-9]|9[78]\\\\d)\\\\d{4}\",\"\\\\d{7}\",,,\"3123456\"],[,,\"(?:68|7[1236]\\\\d)\\\\d{5}\",\"\\\\d{7,8}\",,,\"6812345\"],[,,\"180\\\\d{4}\",\"\\\\d{7}\",,,\"1801234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"275\\\\d{4}\",\"\\\\d{7}\",,,\"2751234\"],\"PG\",675,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[1-689]\"],\"\",\"\",0],\n[,\"(7[1-36]\\\\d)(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"7[1-36]\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"000\",\"\\\\d{3}\",,,\"000\"],[,,\"NA\",\"NA\"]],PH:[,[,,\"[2-9]\\\\d{7,9}|1800\\\\d{7,9}\",\"\\\\d{7,13}\"],[,,\"(?:2|3[2-68]|4[2-9]|5[2-6]|6[2-58]|7[24578]|8[2-8])\\\\d{7}\",\"\\\\d{7,9}\",,,\"21234567\"],[,,\"9(?:0[5-9]|1[025-9]|2[0-36-9]|3[02-9]|4[236-9]|7[349]|89|9[49])\\\\d{7}\",\"\\\\d{10}\",,,\"9051234567\"],[,,\"1800\\\\d{7,9}\",\"\\\\d{11,13}\",,,\"180012345678\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"PH\",\n63,\"00\",\"0\",,,\"0\",,,,[[,\"(2)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"2\"],\"(0$1)\",\"\",0],[,\"(\\\\d{4})(\\\\d{5})\",\"$1 $2\",[\"3(?:23|39|46)|4(?:2[3-6]|[35]9|4[26]|76)|5(?:22|44)|642|8(?:62|8[245])\",\"3(?:230|397|461)|4(?:2(?:35|[46]4|51)|396|4(?:22|63)|59[347]|76[15])|5(?:221|446)|642[23]|8(?:622|8(?:[24]2|5[13]))\"],\"(0$1)\",\"\",0],[,\"(\\\\d{5})(\\\\d{4})\",\"$1 $2\",[\"346|4(?:27|9[35])|883\",\"3469|4(?:279|9(?:30|56))|8834\"],\"(0$1)\",\"\",0],[,\"([3-8]\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[3-8]\"],\"(0$1)\",\"\",0],[,\"(9\\\\d{2})(\\\\d{3})(\\\\d{4})\",\n\"$1 $2 $3\",[\"9\"],\"0$1\",\"\",0],[,\"(1800)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"],\"\",\"\",0],[,\"(1800)(\\\\d{1,2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3 $4\",[\"1\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[27]|911\",\"\\\\d{3}\",,,\"117\"],[,,\"NA\",\"NA\"]],PK:[,[,,\"1\\\\d{8}|[2-8]\\\\d{5,11}|9(?:[013-9]\\\\d{4,9}|2\\\\d(?:111\\\\d{6}|\\\\d{3,7}))\",\"\\\\d{6,12}\"],[,,\"(?:21|42)[2-9]\\\\d{7}|(?:2[25]|4[0146-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]\\\\d{6}|(?:2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:1|2[2-8]|3[27-9]|4[2-6]|6[3569]|9[25-8]))[2-9]\\\\d{5,6}|58[126]\\\\d{7}\",\n\"\\\\d{6,10}\",,,\"2123456789\"],[,,\"3(?:0\\\\d|1[2-5]|2[1-5]|3[1-6]|4[1-7]|64)\\\\d{7}\",\"\\\\d{10}\",,,\"3012345678\"],[,,\"800\\\\d{5}\",\"\\\\d{8}\",,,\"80012345\"],[,,\"900\\\\d{5}\",\"\\\\d{8}\",,,\"90012345\"],[,,\"NA\",\"NA\"],[,,\"122\\\\d{6}\",\"\\\\d{9}\",,,\"122044444\"],[,,\"NA\",\"NA\"],\"PK\",92,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d{2})(111)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)1\",\"(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)11\",\"(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)111\"],\"(0$1)\",\n\"\",0],[,\"(\\\\d{3})(111)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"2[349]|45|54|60|72|8[2-5]|9[2-9]\",\"(?:2[349]|45|54|60|72|8[2-5]|9[2-9])\\\\d1\",\"(?:2[349]|45|54|60|72|8[2-5]|9[2-9])\\\\d11\",\"(?:2[349]|45|54|60|72|8[2-5]|9[2-9])\\\\d111\"],\"(0$1)\",\"\",0],[,\"(\\\\d{2})(\\\\d{7,8})\",\"$1 $2\",[\"(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]\"],\"(0$1)\",\"\",0],[,\"(\\\\d{3})(\\\\d{6,7})\",\"$1 $2\",[\"2[349]|45|54|60|72|8[2-5]|9[2-9]\",\"(?:2[349]|45|54|60|72|8[2-5]|9[2-9])\\\\d[2-9]\"],\"(0$1)\",\"\",0],[,\"(3\\\\d{2})(\\\\d{7})\",\"$1 $2\",\n[\"3\"],\"0$1\",\"\",0],[,\"([15]\\\\d{3})(\\\\d{5,6})\",\"$1 $2\",[\"58[12]|1\"],\"(0$1)\",\"\",0],[,\"(586\\\\d{2})(\\\\d{5})\",\"$1 $2\",[\"586\"],\"(0$1)\",\"\",0],[,\"([89]00)(\\\\d{3})(\\\\d{2})\",\"$1 $2 $3\",[\"[89]00\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"(?:2(?:[125]|3[2358]|4[2-4]|9[2-8])|4(?:[0-246-9]|5[3479])|5(?:[1-35-7]|4[2-467])|6(?:[1-8]|0[468])|7(?:[14]|2[236])|8(?:[16]|2[2-689]|3[23578]|4[3478]|5[2356])|9(?:1|22|3[27-9]|4[2-6]|6[3569]|9[2-7]))111\\\\d{6}\",\"\\\\d{11,12}\",,,\"21111825888\"],,[,,\"1(?:1(?:22?|5)|[56])\",\n\"\\\\d{2,4}\",,,\"112\"],[,,\"NA\",\"NA\"]],PL:[,[,,\"[1-58]\\\\d{6,8}|9\\\\d{8}|[67]\\\\d{5,8}\",\"\\\\d{6,9}\"],[,,\"(?:1[2-8]|2[2-59]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-6]|8[1-7])\\\\d{5,7}|77\\\\d{4,7}|(?:89|9[145])\\\\d{7}\",\"\\\\d{6,9}\",,,\"123456789\"],[,,\"(?:5[013]|6[069]|7[289]|88)\\\\d{7}\",\"\\\\d{9}\",,,\"512345678\"],[,,\"800\\\\d{6}\",\"\\\\d{9}\",,,\"800123456\"],[,,\"70\\\\d{7}\",\"\\\\d{9}\",,,\"701234567\"],[,,\"801\\\\d{6}\",\"\\\\d{9}\",,,\"801234567\"],[,,\"NA\",\"NA\"],[,,\"39\\\\d{7}\",\"\\\\d{9}\",,,\"391234567\"],\"PL\",48,\"00\",,,,,,,,[[,\"(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\n\"$1 $2 $3 $4\",[\"[124]|3[2-4]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145]\"],\"\",\"\",0],[,\"(\\\\d{2})(\\\\d{4,6})\",\"$1 $2\",[\"[124]|3[2-4]|5[24-689]|6[1-3578]|7[14-7]|8[1-7]\"],\"\",\"\",0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"39|5[013]|6[0469]|7[0289]|8[08]\"],\"\",\"\",0],[,\"(\\\\d{3})(\\\\d{2})(\\\\d{2,3})\",\"$1 $2 $3\",[\"64\"],\"\",\"\",0],[,\"(\\\\d{3})(\\\\d{3})\",\"$1 $2\",[\"64\"],\"\",\"\",0]],,[,,\"642\\\\d{3,6}\",\"\\\\d{6,9}\",,,\"642123456\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112|99[789]\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],PM:[,[,,\"[45]\\\\d{5}\",\n\"\\\\d{6}\"],[,,\"41\\\\d{4}\",\"\\\\d{6}\",,,\"411234\"],[,,\"55\\\\d{4}\",\"\\\\d{6}\",,,\"551234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"PM\",508,\"00\",\"0\",,,\"0\",,,,[[,\"([45]\\\\d)(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",,\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1[578]\",\"\\\\d{2}\",,,\"17\"],[,,\"NA\",\"NA\"]],PR:[,[,,\"[5789]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"(?:787|939)[2-9]\\\\d{6}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"7872345678\"],[,,\"(?:787|939)[2-9]\\\\d{6}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"7872345678\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\n\"\\\\d{10}\",,,\"8002345678\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002345678\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"PR\",1,\"011\",\"1\",,,\"1\",,,1,,,[,,\"NA\",\"NA\"],,\"787|939\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],PS:[,[,,\"[24589]\\\\d{7,8}|1(?:[78]\\\\d{8}|[49]\\\\d{2,3})\",\"\\\\d{4,10}\"],[,,\"(?:22[234789]|42[45]|82[01458]|92[369])\\\\d{5}\",\"\\\\d{7,8}\",,,\"22234567\"],[,,\"5[69]\\\\d{7}\",\"\\\\d{9}\",,,\"599123456\"],[,,\"1800\\\\d{6}\",\"\\\\d{10}\",,,\"1800123456\"],\n[,,\"1(?:4|9\\\\d)\\\\d{2}\",\"\\\\d{4,5}\",,,\"19123\"],[,,\"1700\\\\d{6}\",\"\\\\d{10}\",,,\"1700123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"PS\",970,\"00\",\"0\",,,\"0\",,,,[[,\"([2489])(2\\\\d{2})(\\\\d{4})\",\"$1 $2 $3\",[\"[2489]\"],\"0$1\",\"\",0],[,\"(5[69]\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"5\"],\"0$1\",\"\",0],[,\"(1[78]00)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"1[78]\"],\"$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"]],PT:[,[,,\"[2-46-9]\\\\d{8}\",\"\\\\d{9}\"],[,,\"2(?:[12]\\\\d|[35][1-689]|4[1-59]|6[1-35689]|7[1-9]|8[1-69]|9[1256])\\\\d{6}\",\n\"\\\\d{9}\",,,\"212345678\"],[,,\"9(?:[136]\\\\d{2}|2[124-79]\\\\d|4(?:80|9\\\\d))\\\\d{5}\",\"\\\\d{9}\",,,\"912345678\"],[,,\"4\\\\d{8}|80[02]\\\\d{6}\",\"\\\\d{9}\",,,\"800123456\"],[,,\"71\\\\d{7}\",\"\\\\d{9}\",,,\"712345678\"],[,,\"808\\\\d{6}\",\"\\\\d{9}\",,,\"808123456\"],[,,\"NA\",\"NA\"],[,,\"30\\\\d{7}\",\"\\\\d{9}\",,,\"301234567\"],\"PT\",351,\"00\",,,,,,,,[[,\"([2-46-9]\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"70(?:7\\\\d|8[147])\\\\d{5}\",\"\\\\d{9}\",,,\"707123456\"],,[,,\"112\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],PW:[,[,,\"[2-8]\\\\d{6}\",\n\"\\\\d{7}\"],[,,\"2552255|(?:277|345|488|5(?:35|44|87)|6(?:22|54|79)|7(?:33|47)|8(?:24|55|76))\\\\d{4}\",\"\\\\d{7}\",,,\"2771234\"],[,,\"(?:6[234689]0|77[45789])\\\\d{4}\",\"\\\\d{7}\",,,\"6201234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"PW\",680,\"01[12]\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],PY:[,[,,\"5[0-5]\\\\d{4,7}|[2-46-9]\\\\d{5,8}\",\"\\\\d{5,9}\"],[,,\"(?:[26]1|3[289]|4[124678]|7[123]|8[1236])\\\\d{5,7}|(?:2(?:2[4568]|7[15]|9[1-5])|3(?:18|3[167]|4[2357]|51)|4(?:18|2[45]|3[12]|5[13]|64|71|9[1-47])|5(?:[1-4]\\\\d|5[0234])|6(?:3[1-3]|44|7[1-4678])|7(?:17|4[0-4]|6[1-578]|75|8[0-8])|858)\\\\d{5,6}\",\n\"\\\\d{5,9}\",,,\"212345678\"],[,,\"9(?:61|7[1-6]|8[1-5]|9[1-5])\\\\d{6}\",\"\\\\d{9}\",,,\"961456789\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"8700[0-4]\\\\d{4}\",\"\\\\d{9}\",,,\"870012345\"],\"PY\",595,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d{2})(\\\\d{5,7})\",\"$1 $2\",[\"(?:[26]1|3[289]|4[124678]|7[123]|8[1236])\"],\"($1)\",\"\",0],[,\"(\\\\d{3})(\\\\d{3,6})\",\"$1 $2\",[\"[2-9]0\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{6})\",\"$1 $2\",[\"9[1-9]\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"8700\"],\"\",\"\",0],[,\"(\\\\d{3})(\\\\d{4,6})\",\"$1 $2\",\n[\"[2-8][1-9]\"],\"($1)\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"[2-9]0\\\\d{4,7}\",\"\\\\d{6,9}\",,,\"201234567\"],,[,,\"128|911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],QA:[,[,,\"[2-8]\\\\d{6,7}\",\"\\\\d{7,8}\"],[,,\"44\\\\d{6}\",\"\\\\d{7,8}\",,,\"44123456\"],[,,\"[3567]\\\\d{7}\",\"\\\\d{7,8}\",,,\"33123456\"],[,,\"800\\\\d{4}\",\"\\\\d{7,8}\",,,\"8001234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"QA\",974,\"00\",,,,,,,,[[,\"([28]\\\\d{2})(\\\\d{4})\",\"$1 $2\",[\"[28]\"],\"\",\"\",0],[,\"([3-7]\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[3-7]\"],\"\",\"\",0]],,[,,\"2(?:[12]\\\\d|61)\\\\d{4}\",\n\"\\\\d{7}\",,,\"2123456\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"999\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],RE:[,[,,\"[268]\\\\d{8}\",\"\\\\d{9}\"],[,,\"262\\\\d{6}\",\"\\\\d{9}\",,,\"262161234\"],[,,\"6(?:9[23]|47)\\\\d{6}\",\"\\\\d{9}\",,,\"692123456\"],[,,\"80\\\\d{7}\",\"\\\\d{9}\",,,\"801234567\"],[,,\"89[1-37-9]\\\\d{6}\",\"\\\\d{9}\",,,\"891123456\"],[,,\"8(?:1[019]|2[0156]|84|90)\\\\d{6}\",\"\\\\d{9}\",,,\"810123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"RE\",262,\"00\",\"0\",,,\"0\",,,,[[,\"([268]\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",,\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],\n1,\"262|6[49]|8\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:12|[578])\",\"\\\\d{2,3}\",,,\"15\"],[,,\"NA\",\"NA\"]],RO:[,[,,\"[237-9]\\\\d{8}\",\"\\\\d{9}\"],[,,\"[23][13-6]\\\\d{7}\",\"\\\\d{9}\",,,\"211234567\"],[,,\"7[1-8]\\\\d{7}\",\"\\\\d{9}\",,,\"712345678\"],[,,\"800\\\\d{6}\",\"\\\\d{9}\",,,\"800123456\"],[,,\"90[036]\\\\d{6}\",\"\\\\d{9}\",,,\"900123456\"],[,,\"801\\\\d{6}\",\"\\\\d{9}\",,,\"801123456\"],[,,\"802\\\\d{6}\",\"\\\\d{9}\",,,\"802123456\"],[,,\"NA\",\"NA\"],\"RO\",40,\"00\",\"0\",\" int \",,\"0\",,,,[[,\"([237]\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[23]1|7\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\n\"$1 $2 $3\",[\"[23][02-9]|[89]\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"37\\\\d{7}\",\"\\\\d{9}\",,,\"372123456\"],,[,,\"112\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],RS:[,[,,\"[1-36-9]\\\\d{4,11}\",\"\\\\d{5,12}\"],[,,\"[1-3]\\\\d{6,11}\",\"\\\\d{5,12}\",,,\"101234567\"],[,,\"6(?:[0-689]|7\\\\d)\\\\d{6,7}\",\"\\\\d{8,10}\",,,\"601234567\"],[,,\"800\\\\d{3,9}\",\"\\\\d{6,12}\",,,\"80012345\"],[,,\"(?:90[0169]|78\\\\d)\\\\d{3,7}\",\"\\\\d{6,12}\",,,\"90012345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"RS\",381,\"00\",\"0\",,,\"0\",,,,[[,\"([23]\\\\d{2})(\\\\d{4,9})\",\"$1 $2\",\n[\"(?:2[389]|39)0\"],\"0$1\",\"\",0],[,\"([1-3]\\\\d)(\\\\d{5,10})\",\"$1 $2\",[\"1|2(?:[0-24-7]|[389][1-9])|3(?:[0-8]|9[1-9])\"],\"0$1\",\"\",0],[,\"(6\\\\d)(\\\\d{6,8})\",\"$1 $2\",[\"6\"],\"0$1\",\"\",0],[,\"([89]\\\\d{2})(\\\\d{3,9})\",\"$1 $2\",[\"[89]\"],\"0$1\",\"\",0],[,\"(7[26])(\\\\d{4,9})\",\"$1 $2\",[\"7[26]\"],\"0$1\",\"\",0],[,\"(7[08]\\\\d)(\\\\d{4,9})\",\"$1 $2\",[\"7[08]\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"7[06]\\\\d{4,10}\",\"\\\\d{6,12}\",,,\"700123456\"],,[,,\"112|9[234]\",\"\\\\d{2,3}\",,,\"112\"],[,,\"NA\",\"NA\"]],RU:[,[,,\"[3489]\\\\d{9}\",\"\\\\d{10}\"],\n[,,\"(?:3(?:0[12]|4[1-35-79]|5[1-3]|8[1-58]|9[0145])|4(?:01|1[1356]|2[13467]|7[1-5]|8[1-7]|9[1-689])|8(?:1[1-8]|2[01]|3[13-6]|4[0-8]|5[15]|6[1-35-7]|7[1-37-9]))\\\\d{7}\",\"\\\\d{10}\",,,\"3011234567\"],[,,\"9\\\\d{9}\",\"\\\\d{10}\",,,\"9123456789\"],[,,\"80[04]\\\\d{7}\",\"\\\\d{10}\",,,\"8001234567\"],[,,\"80[39]\\\\d{7}\",\"\\\\d{10}\",,,\"8091234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"RU\",7,\"810\",\"8\",,,\"8\",,\"8~10\",,[[,\"([3489]\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2-$3-$4\",[\"[34689]\"],\"8 ($1)\",\"\",1],[,\"(7\\\\d{2})(\\\\d{3})(\\\\d{4})\",\n\"$1 $2 $3\",[\"7\"],\"8 ($1)\",\"\",1]],,[,,\"NA\",\"NA\"],1,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"0[123]|112\",\"\\\\d{2,3}\",,,\"112\"],[,,\"NA\",\"NA\"]],RW:[,[,,\"[027-9]\\\\d{7,8}\",\"\\\\d{8,9}\"],[,,\"2[258]\\\\d{7}|06\\\\d{6}\",\"\\\\d{8,9}\",,,\"250123456\"],[,,\"7[258]\\\\d{7}\",\"\\\\d{9}\",,,\"720123456\"],[,,\"800\\\\d{6}\",\"\\\\d{9}\",,,\"800123456\"],[,,\"900\\\\d{6}\",\"\\\\d{9}\",,,\"900123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"RW\",250,\"00\",\"0\",,,\"0\",,,,[[,\"(2\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"2\"],\"$1\",\"\",0],[,\"([7-9]\\\\d{2})(\\\\d{3})(\\\\d{3})\",\n\"$1 $2 $3\",[\"[7-9]\"],\"0$1\",\"\",0],[,\"(0\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"0\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],1,[,,\"112\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],SA:[,[,,\"[1-467]\\\\d{7}|5\\\\d{8}|(?:8|92)\\\\d{9}\",\"\\\\d{7,11}\"],[,,\"(?:[12][24-8]|3[35-8]|4[34-68]|6[2-5]|7[235-7])\\\\d{6}\",\"\\\\d{7,8}\",,,\"12345678\"],[,,\"(?:5[013-689]\\\\d|8111)\\\\d{6}\",\"\\\\d{9,10}\",,,\"512345678\"],[,,\"800\\\\d{7}\",\"\\\\d{10}\",,,\"8001234567\"],[,,\"9200\\\\d{7}\",\"\\\\d{11}\",,,\"92001234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\n[,,\"NA\",\"NA\"],\"SA\",966,\"00\",\"0\",,,\"0\",,,,[[,\"([1-467])(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[1-467]\"],\"0$1\",\"\",0],[,\"(9200)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"9\"],\"0$1\",\"\",0],[,\"(5\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"5\"],\"0$1\",\"\",0],[,\"(800)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"80\"],\"0$1\",\"\",0],[,\"(8111)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"81\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"99[7-9]\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],SB:[,[,,\"[1-8]\\\\d{4,6}\",\"\\\\d{5,7}\"],[,,\"(?:1[4-79]|[23]\\\\d|4[01]|5[03]|6[0-37])\\\\d{3}\",\n\"\\\\d{5}\",,,\"40123\"],[,,\"7(?:4\\\\d|5[025-8]|6[01])\\\\d{4}|8[4-8]\\\\d{5}\",\"\\\\d{7}\",,,\"7421234\"],[,,\"1[38]\\\\d{3}\",\"\\\\d{5}\",,,\"18123\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"5[12]\\\\d{3}\",\"\\\\d{5}\",,,\"51123\"],\"SB\",677,\"0[01]\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[78]\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"999\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],SC:[,[,,\"[24689]\\\\d{5,6}\",\"\\\\d{6,7}\"],[,,\"(?:2(?:55[0-5]|78[013])|4(?:2(?:0[589]|1[03-9]|[2-9]\\\\d)|[346]\\\\d{2}))\\\\d{3}\",\"\\\\d{7}\",,,\"4217123\"],\n[,,\"2(?:5(?:[0-46-9]\\\\d|5[6-9])|7(?:[0-79]\\\\d|8[24-9]))\\\\d{3}\",\"\\\\d{7}\",,,\"2510123\"],[,,\"8000\\\\d{2}\",\"\\\\d{6}\",,,\"800000\"],[,,\"98\\\\d{4}\",\"\\\\d{6}\",,,\"981234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"64\\\\d{5}\",\"\\\\d{7}\",,,\"6412345\"],\"SC\",248,\"0[0-2]\",,,,,,\"00\",,[[,\"(\\\\d{3})(\\\\d{3})\",\"$1 $2\",[\"[89]\"],\"\",\"\",0],[,\"(\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[246]\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"999\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],SD:[,[,,\"[19]\\\\d{8}\",\"\\\\d{9}\"],[,,\"1(?:[25]\\\\d|8[3567])\\\\d{6}\",\n\"\\\\d{9}\",,,\"121231234\"],[,,\"9[012569]\\\\d{7}\",\"\\\\d{9}\",,,\"911231234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"SD\",249,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",,\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"999\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],SE:[,[,,\"[1-9]\\\\d{6,9}\",\"\\\\d{5,10}\"],[,,\"1(?:0[1-8]\\\\d{6}|[136]\\\\d{5,7}|(?:2[0-35]|4[0-4]|5[0-25-9]|7[13-6]|[89]\\\\d)\\\\d{5,6})|2(?:[136]\\\\d{5,7}|(?:2[0-7]|4[0136-8]|5[0-38]|7[018]|8[01]|9[0-57])\\\\d{5,6})|3(?:[356]\\\\d{5,7}|(?:0[0-4]|1\\\\d|2[0-25]|4[056]|7[0-2]|8[0-3]|9[023])\\\\d{5,6})|4(?:[0246]\\\\d{5,7}|(?:1[01-8]|3[0135]|5[14-79]|7[0-246-9]|8[0156]|9[0-689])\\\\d{5,6})|5(?:0[0-6]|1[0-5]|2[0-68]|3[0-4]|4\\\\d|5[0-5]|6[03-5]|7[013]|8[0-79]|9[01])\\\\d{5,6}|6(?:[03]\\\\d{5,7}|(?:1[1-3]|2[0-4]|4[02-57]|5[0-37]|6[0-3]|7[0-2]|8[0247]|9[0-356])\\\\d{5,6})|8\\\\d{6,8}|9(?:0\\\\d{5,7}|(?:1[0-68]|2\\\\d|3[02-59]|4[0-4]|5[0-4]|6[01]|7[0135-8]|8[01])\\\\d{5,6})\",\n\"\\\\d{5,9}\",,,\"8123456\"],[,,\"7[02-46]\\\\d{7}\",\"\\\\d{9}\",,,\"701234567\"],[,,\"20\\\\d{4,7}\",\"\\\\d{6,9}\",,,\"201234567\"],[,,\"9(?:00|39|44)\\\\d{7}\",\"\\\\d{10}\",,,\"9001234567\"],[,,\"77\\\\d{7}\",\"\\\\d{9}\",,,\"771234567\"],[,,\"75\\\\d{7}\",\"\\\\d{9}\",,,\"751234567\"],[,,\"NA\",\"NA\"],\"SE\",46,\"00\",\"0\",,,\"0\",,,,[[,\"(8)(\\\\d{2,3})(\\\\d{2,3})(\\\\d{2})\",\"$1-$2 $3 $4\",[\"8\"],\"0$1\",\"\",0],[,\"([1-69]\\\\d)(\\\\d{2,3})(\\\\d{2})(\\\\d{2})\",\"$1-$2 $3 $4\",[\"1[013689]|2[0136]|3[1356]|4[0246]|54|6[03]|90\"],\"0$1\",\"\",0],[,\"([1-69]\\\\d)(\\\\d{3})(\\\\d{2})\",\"$1-$2 $3\",\n[\"1[13689]|2[136]|3[1356]|4[0246]|54|6[03]|90\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1-$2 $3 $4\",[\"1[2457]|2[2457-9]|3[0247-9]|4[1357-9]|5[0-35-9]|6[124-9]|9(?:[125-8]|3[0-5]|4[0-3])\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{2,3})(\\\\d{2})\",\"$1-$2 $3\",[\"1[2457]|2[2457-9]|3[0247-9]|4[1357-9]|5[0-35-9]|6[124-9]|9(?:[125-8]|3[0-5]|4[0-3])\"],\"0$1\",\"\",0],[,\"(7\\\\d)(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1-$2 $3 $4\",[\"7\"],\"0$1\",\"\",0],[,\"(20)(\\\\d{2,3})(\\\\d{2})\",\"$1-$2 $3\",[\"20\"],\"0$1\",\"\",0],[,\"(9[034]\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{3})\",\n\"$1-$2 $3 $4\",[\"9[034]\"],\"0$1\",\"\",0]],[[,\"(8)(\\\\d{2,3})(\\\\d{2,3})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"8\"]],[,\"([1-69]\\\\d)(\\\\d{2,3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"1[013689]|2[0136]|3[1356]|4[0246]|54|6[03]|90\"]],[,\"([1-69]\\\\d)(\\\\d{3})(\\\\d{2})\",\"$1 $2 $3\",[\"1[13689]|2[136]|3[1356]|4[0246]|54|6[03]|90\"]],[,\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"1[2457]|2[2457-9]|3[0247-9]|4[1357-9]|5[0-35-9]|6[124-9]|9(?:[125-8]|3[0-5]|4[0-3])\"]],[,\"(\\\\d{3})(\\\\d{2,3})(\\\\d{2})\",\"$1 $2 $3\",[\"1[2457]|2[2457-9]|3[0247-9]|4[1357-9]|5[0-35-9]|6[124-9]|9(?:[125-8]|3[0-5]|4[0-3])\"]],\n[,\"(7\\\\d)(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"7\"]],[,\"(20)(\\\\d{2,3})(\\\\d{2})\",\"$1 $2 $3\",[\"20\"]],[,\"(9[034]\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"9[034]\"]]],[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112|90000\",\"\\\\d{3,5}\",,,\"112\"],[,,\"NA\",\"NA\"]],SG:[,[,,\"[36]\\\\d{7}|[17-9]\\\\d{7,10}\",\"\\\\d{8,11}\"],[,,\"6[1-8]\\\\d{6}\",\"\\\\d{8}\",,,\"61234567\"],[,,\"(?:8[1-6]|9[0-8])\\\\d{6}\",\"\\\\d{8}\",,,\"81234567\"],[,,\"1?800\\\\d{7}\",\"\\\\d{10,11}\",,,\"18001234567\"],[,,\"1900\\\\d{7}\",\"\\\\d{11}\",,,\"19001234567\"],[,,\"NA\",\n\"NA\"],[,,\"NA\",\"NA\"],[,,\"3[0-2]\\\\d{6}\",\"\\\\d{8}\",,,\"31234567\"],\"SG\",65,\"0[0-3][0-9]\",,,,,,,,[[,\"([3689]\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[369]|8[1-9]\"],\"\",\"\",0],[,\"(1[89]00)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1[89]\"],\"\",\"\",0],[,\"(7000)(\\\\d{4})(\\\\d{3})\",\"$1 $2 $3\",[\"70\"],\"\",\"\",0],[,\"(800)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"80\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"7000\\\\d{7}\",\"\\\\d{11}\",,,\"70001234567\"],,[,,\"99[59]\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],SH:[,[,,\"[2-9]\\\\d{3}\",\"\\\\d{4}\"],[,,\"(?:[2-468]\\\\d|7[01])\\\\d{2}\",\n\"\\\\d{4}\",,,\"2158\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"(?:[59]\\\\d|7[2-9])\\\\d{2}\",\"\\\\d{4}\",,,\"5012\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"SH\",290,\"00\",,,,,,,,,,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"9(?:11|99)\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],SI:[,[,,\"[1-7]\\\\d{6,7}|[89]\\\\d{4,7}\",\"\\\\d{5,8}\"],[,,\"(?:1\\\\d|2[2-8]|3[4-8]|4[24-8]|[57][3-8])\\\\d{6}\",\"\\\\d{7,8}\",,,\"11234567\"],[,,\"(?:[37][01]|4[019]|51|64)\\\\d{6}\",\"\\\\d{8}\",,,\"31234567\"],[,,\"80\\\\d{4,6}\",\"\\\\d{6,8}\",,,\"80123456\"],[,,\"90\\\\d{4,6}|89[1-3]\\\\d{2,5}\",\n\"\\\\d{5,8}\",,,\"90123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"(?:59|8[1-3])\\\\d{6}\",\"\\\\d{8}\",,,\"59012345\"],\"SI\",386,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d)(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[12]|3[4-8]|4[24-8]|5[3-8]|7[3-8]\"],\"(0$1)\",\"\",0],[,\"([3-7]\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[37][01]|4[019]|51|64\"],\"0$1\",\"\",0],[,\"([89][09])(\\\\d{3,6})\",\"$1 $2\",[\"[89][09]\"],\"0$1\",\"\",0],[,\"([58]\\\\d{2})(\\\\d{5})\",\"$1 $2\",[\"59|8[1-3]\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[23]\",\"\\\\d{3}\",,,\"112\"],\n[,,\"NA\",\"NA\"]],SJ:[,[,,\"0\\\\d{4}|[4789]\\\\d{7}\",\"\\\\d{5}(?:\\\\d{3})?\"],[,,\"79\\\\d{6}\",\"\\\\d{8}\",,,\"79123456\"],[,,\"(?:4[015-8]|9\\\\d)\\\\d{6}\",\"\\\\d{8}\",,,\"41234567\"],[,,\"80[01]\\\\d{5}\",\"\\\\d{8}\",,,\"80012345\"],[,,\"82[09]\\\\d{5}\",\"\\\\d{8}\",,,\"82012345\"],[,,\"810(?:0[0-6]|[2-8]\\\\d)\\\\d{3}\",\"\\\\d{8}\",,,\"81021234\"],[,,\"880\\\\d{5}\",\"\\\\d{8}\",,,\"88012345\"],[,,\"NA\",\"NA\"],\"SJ\",47,\"00\",,,,,,,,,,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"0\\\\d{4}|81(?:0(?:0[7-9]|1\\\\d)|5\\\\d{2})\\\\d{3}\",\"\\\\d{5}(?:\\\\d{3})?\",,,\"01234\"],1,[,,\"11[023]\",\"\\\\d{3}\",\n,,\"112\"],[,,\"NA\",\"NA\"]],SK:[,[,,\"[2-689]\\\\d{8}\",\"\\\\d{9}\"],[,,\"[2-5]\\\\d{8}\",\"\\\\d{9}\",,,\"212345678\"],[,,\"9(?:0[1-8]|1[0-24-9]|4[0489])\\\\d{6}\",\"\\\\d{9}\",,,\"912123456\"],[,,\"800\\\\d{6}\",\"\\\\d{9}\",,,\"800123456\"],[,,\"9(?:[78]\\\\d{7}|00\\\\d{6})\",\"\\\\d{9}\",,,\"900123456\"],[,,\"8[5-9]\\\\d{7}\",\"\\\\d{9}\",,,\"850123456\"],[,,\"NA\",\"NA\"],[,,\"6(?:5[0-4]|9[0-6])\\\\d{6}\",\"\\\\d{9}\",,,\"690123456\"],\"SK\",421,\"00\",\"0\",,,\"0\",,,,[[,\"(2)(\\\\d{3})(\\\\d{3})(\\\\d{2})\",\"$1/$2 $3 $4\",[\"2\"],\"0$1\",\"\",0],[,\"([3-5]\\\\d)(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1/$2 $3 $4\",\n[\"[3-5]\"],\"0$1\",\"\",0],[,\"([689]\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[689]\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:12|5[058])\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],SL:[,[,,\"[2-578]\\\\d{7}\",\"\\\\d{6,8}\"],[,,\"[235]2[2-4][2-9]\\\\d{4}\",\"\\\\d{6,8}\",,,\"22221234\"],[,,\"(?:25|3[03]|44|5[056]|7[6-8]|88)[1-9]\\\\d{5}\",\"\\\\d{6,8}\",,,\"25123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"SL\",232,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d{2})(\\\\d{6})\",\"$1 $2\",,\"(0$1)\",\"\",0]],,[,,\"NA\",\n\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"(?:01|99)9\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],SM:[,[,,\"[05-7]\\\\d{7,9}\",\"\\\\d{6,10}\"],[,,\"0549(?:8[0157-9]|9\\\\d)\\\\d{4}\",\"\\\\d{6,10}\",,,\"0549886377\"],[,,\"6[16]\\\\d{6}\",\"\\\\d{8}\",,,\"66661212\"],[,,\"NA\",\"NA\"],[,,\"7[178]\\\\d{6}\",\"\\\\d{8}\",,,\"71123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"5[158]\\\\d{6}\",\"\\\\d{8}\",,,\"58001110\"],\"SM\",378,\"00\",,,,\"(?:0549)?([89]\\\\d{5})\",\"0549$1\",,,[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[5-7]\"],\"\",\"\",0],[,\"(0549)(\\\\d{6})\",\"$1 $2\",[\"0\"],\n\"\",\"\",0],[,\"(\\\\d{6})\",\"0549 $1\",[\"[89]\"],\"\",\"\",0]],[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[5-7]\"]],[,\"(0549)(\\\\d{6})\",\"($1) $2\",[\"0\"]],[,\"(\\\\d{6})\",\"(0549) $1\",[\"[89]\"]]],[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],1,[,,\"11[358]\",\"\\\\d{3}\",,,\"113\"],[,,\"NA\",\"NA\"]],SN:[,[,,\"[37]\\\\d{8}\",\"\\\\d{9}\"],[,,\"3(?:010|3(?:8[1-9]|9[2-9]))\\\\d{5}\",\"\\\\d{9}\",,,\"301012345\"],[,,\"7(?:0[1256]0|6(?:1[23]|2[89]|3[3489]|4[6-9]|5[1-9]|6[3-9]|7[45]|8[3-8])|7(?:01|[12-79]\\\\d|8[0139]))\\\\d{5}\",\"\\\\d{9}\",,,\"701012345\"],\n[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"33301\\\\d{4}\",\"\\\\d{9}\",,,\"333011234\"],\"SN\",221,\"00\",,,,,,,,[[,\"(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"]],SO:[,[,,\"[1-79]\\\\d{6,8}\",\"\\\\d{7,9}\"],[,,\"(?:5[57-9]|[1-4]\\\\d)\\\\d{5}\",\"\\\\d{7}\",,,\"5522010\"],[,,\"(?:15|24|6[179]?\\\\d|7\\\\d|9[01])\\\\d{6}\",\"\\\\d{8,9}\",,,\"90792024\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"SO\",252,\"00\",\"0\",\n,,\"0\",,,,[[,\"(\\\\d)(\\\\d{6})\",\"$1 $2\",[\"[1-5]\"],\"\",\"\",0],[,\"(\\\\d)(\\\\d{7})\",\"$1 $2\",[\"[267]\"],\"\",\"\",0],[,\"([19]\\\\d)(\\\\d{6})\",\"$1 $2\",[\"15|9\"],\"\",\"\",0],[,\"(6\\\\d)(\\\\d{7})\",\"$1 $2\",[\"6[17]\"],\"\",\"\",0],[,\"(69\\\\d)(\\\\d{6})\",\"$1 $2\",[\"69\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"]],SR:[,[,,\"[2-8]\\\\d{5,6}\",\"\\\\d{6,7}\"],[,,\"(?:2[1-3]|3[0-7]|4\\\\d|5[2-58]|68\\\\d)\\\\d{4}\",\"\\\\d{6,7}\",,,\"211234\"],[,,\"(?:7[1-5]|8[1-9])\\\\d{5}\",\"\\\\d{7}\",,,\"7412345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,\n,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"56\\\\d{4}\",\"\\\\d{6}\",,,\"561234\"],\"SR\",597,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{3})\",\"$1-$2\",[\"[2-4]|5[2-58]\"],\"\",\"\",0],[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1-$2-$3\",[\"56\"],\"\",\"\",0],[,\"(\\\\d{3})(\\\\d{4})\",\"$1-$2\",[\"[6-8]\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"115\",\"\\\\d{3}\",,,\"115\"],[,,\"NA\",\"NA\"]],ST:[,[,,\"[29]\\\\d{6}\",\"\\\\d{7}\"],[,,\"22\\\\d{5}\",\"\\\\d{7}\",,,\"2221234\"],[,,\"9[89]\\\\d{5}\",\"\\\\d{7}\",,,\"9812345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\n\"NA\"],\"ST\",239,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],SV:[,[,,\"[267]\\\\d{7}|[89]\\\\d{6}(?:\\\\d{4})?\",\"\\\\d{7,8}|\\\\d{11}\"],[,,\"2[1-6]\\\\d{6}\",\"\\\\d{8}\",,,\"21234567\"],[,,\"[67]\\\\d{7}\",\"\\\\d{8}\",,,\"70123456\"],[,,\"800\\\\d{4}(?:\\\\d{4})?\",\"\\\\d{7}(?:\\\\d{4})?\",,,\"8001234\"],[,,\"900\\\\d{4}(?:\\\\d{4})?\",\"\\\\d{7}(?:\\\\d{4})?\",,,\"9001234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"SV\",503,\"00\",,,,,,,,[[,\"(\\\\d{4})(\\\\d{4})\",\n\"$1 $2\",[\"[267]\"],\"\",\"\",0],[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[89]\"],\"\",\"\",0],[,\"(\\\\d{3})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"[89]\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],SX:[,[,,\"[5789]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"7215(?:4[2-8]|8[239])\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"7215425678\"],[,,\"7215(?:1[02]|2\\\\d|5[03469]|8[01678])\\\\d{4}\",\"\\\\d{10}\",,,\"7215205678\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002123456\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,\n,\"9002123456\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"SX\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,\"721\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"919\",\"\\\\d{3}\",,,\"919\"],[,,\"NA\",\"NA\"]],SY:[,[,,\"[1-59]\\\\d{7,8}\",\"\\\\d{6,9}\"],[,,\"(?:1(?:1\\\\d?|4\\\\d|[2356])|2[1-35]|3(?:[13]\\\\d|4)|4[13]|5[1-3])\\\\d{6}\",\"\\\\d{6,9}\",,,\"112345678\"],[,,\"9(?:3[23]|4[457]|55|6[67]|88|9[1-49])\\\\d{6}\",\"\\\\d{9}\",,,\"944567890\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"SY\",\n963,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[1-5]\"],\"0$1\",\"\",1],[,\"(9[3-689])(\\\\d{4})(\\\\d{3})\",\"$1 $2 $3\",[\"9\"],\"0$1\",\"\",1]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[023]\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],SZ:[,[,,\"[027]\\\\d{7}\",\"\\\\d{8}\"],[,,\"2(?:2(?:0[07]|[13]7|2[57])|3(?:0[34]|[1278]3|3[23]|[46][34])|(?:40[4-69]|67)|5(?:0[5-7]|1[6-9]|[23][78]|48|5[01]))\\\\d{4}\",\"\\\\d{8}\",,,\"22171234\"],[,,\"7[6-8]\\\\d{6}\",\"\\\\d{8}\",,,\"76123456\"],[,,\"0800\\\\d{4}\",\"\\\\d{8}\",,,\"08001234\"],\n[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"SZ\",268,\"00\",,,,,,,,[[,\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[027]\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"0800\\\\d{4}\",\"\\\\d{8}\",,,\"08001234\"],[,,\"NA\",\"NA\"],1,[,,\"999\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],TC:[,[,,\"[5689]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"649(?:712|9(?:4\\\\d|50))\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"6497121234\"],[,,\"649(?:2(?:3[12]|4[1-5])|3(?:3[1-39]|4[1-57])|4[34][12])\\\\d{4}\",\"\\\\d{10}\",,,\"6492311234\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002345678\"],\n[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002345678\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"64971[01]\\\\d{4}\",\"\\\\d{10}\",,,\"6497101234\"],\"TC\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,\"649\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"9(?:11|99)\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],TD:[,[,,\"[2679]\\\\d{7}\",\"\\\\d{8}\"],[,,\"22(?:[3789]0|5[0-5]|6[89])\\\\d{4}\",\"\\\\d{8}\",,,\"22501234\"],[,,\"(?:6[36]\\\\d|77\\\\d|9(?:5[0-4]|9\\\\d))\\\\d{5}\",\"\\\\d{8}\",,,\"63012345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\n\"NA\"],[,,\"NA\",\"NA\"],\"TD\",235,\"00|16\",,,,,,\"00\",,[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1[78]\",\"\\\\d{2}\",,,\"17\"],[,,\"NA\",\"NA\"]],TG:[,[,,\"[29]\\\\d{7}\",\"\\\\d{8}\"],[,,\"2(?:2[2-7]|3[23]|44|55|66|77)\\\\d{5}\",\"\\\\d{8}\",,,\"22212345\"],[,,\"9[0-289]\\\\d{6}\",\"\\\\d{8}\",,,\"90112345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"TG\",228,\"00\",,,,,,,,[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",,\"\",\"\",0]],,[,,\"NA\",\n\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:01|1[78]|7[17])\",\"\\\\d{3}\",,,\"117\"],[,,\"NA\",\"NA\"]],TH:[,[,,\"[2-9]\\\\d{7,8}|1\\\\d{3}(?:\\\\d{6})?\",\"\\\\d{4}|\\\\d{8,10}\"],[,,\"(?:2[1-9]|3[2-9]|4[2-5]|5[2-6]|7[3-7])\\\\d{6}\",\"\\\\d{8}\",,,\"21234567\"],[,,\"[89]\\\\d{8}\",\"\\\\d{9}\",,,\"812345678\"],[,,\"1800\\\\d{6}\",\"\\\\d{10}\",,,\"1800123456\"],[,,\"1900\\\\d{6}\",\"\\\\d{10}\",,,\"1900123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"60\\\\d{7}\",\"\\\\d{9}\",,,\"601234567\"],\"TH\",66,\"00\",\"0\",,,\"0\",,,,[[,\"(2)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"2\"],\"0$1\",\"\",0],\n[,\"([3-7]\\\\d)(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[3-7]\"],\"0$1\",\"\",0],[,\"([89])(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"[89]\"],\"0$1\",\"\",0],[,\"(1[89]00)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"1\"],\"$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"1\\\\d{3}\",\"\\\\d{4}\",,,\"1100\"],[,,\"1\\\\d{3}\",\"\\\\d{4}\",,,\"1100\"],,[,,\"1(?:669|9[19])\",\"\\\\d{3,4}\",,,\"191\"],[,,\"NA\",\"NA\"]],TJ:[,[,,\"[3-59]\\\\d{8}\",\"\\\\d{3,9}\"],[,,\"(?:3(?:1[3-5]|2[245]|3[12]|4[24-7]|5[25]|72)|4(?:46|74|87))\\\\d{6}\",\"\\\\d{3,9}\",,,\"372123456\"],[,,\"(?:505|9[0-35-9]\\\\d)\\\\d{6}\",\"\\\\d{9}\",,,\"917123456\"],\n[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"TJ\",992,\"810\",\"8\",,,\"8\",,\"8~10\",,[[,\"([349]\\\\d{2})(\\\\d{2})(\\\\d{4})\",\"$1 $2 $3\",[\"[34]7|91[78]\"],\"(8) $1\",\"\",1],[,\"([459]\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"4[48]|5|9(?:1[59]|[0235-9])\"],\"(8) $1\",\"\",1],[,\"(331700)(\\\\d)(\\\\d{2})\",\"$1 $2 $3\",[\"331\",\"3317\",\"33170\",\"331700\"],\"(8) $1\",\"\",1],[,\"(\\\\d{4})(\\\\d)(\\\\d{4})\",\"$1 $2 $3\",[\"3[1-5]\",\"3(?:[1245]|3(?:[02-9]|1[0-589]))\"],\"(8) $1\",\"\",1]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,\n,\"1(?:0[1-3]|12)\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],TK:[,[,,\"[2-5]\\\\d{3}\",\"\\\\d{4}\"],[,,\"[2-4]\\\\d{3}\",\"\\\\d{4}\",,,\"3010\"],[,,\"5\\\\d{3}\",\"\\\\d{4}\",,,\"5190\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"TK\",690,\"00\",,,,,,,,,,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"]],TL:[,[,,\"[2-47-9]\\\\d{6}\",\"\\\\d{7}\"],[,,\"(?:2[1-5]|3[1-9]|4[1-4])\\\\d{5}\",\"\\\\d{7}\",,,\"2112345\"],[,,\"7[2-4]\\\\d{5}\",\"\\\\d{7}\",,,\"7212345\"],[,,\"80\\\\d{5}\",\"\\\\d{7}\",,,\"8012345\"],[,,\"90\\\\d{5}\",\n\"\\\\d{7}\",,,\"9012345\"],[,,\"NA\",\"NA\"],[,,\"70\\\\d{5}\",\"\\\\d{7}\",,,\"7012345\"],[,,\"NA\",\"NA\"],\"TL\",670,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],TM:[,[,,\"[1-6]\\\\d{7}\",\"\\\\d{8}\"],[,,\"(?:1(?:2\\\\d|3[1-9])|2(?:22|4[0-35-8])|3(?:22|4[03-9])|4(?:22|3[128]|4\\\\d|6[15])|5(?:22|5[7-9]|6[014-689]))\\\\d{5}\",\"\\\\d{8}\",,,\"12345678\"],[,,\"6[3-8]\\\\d{6}\",\"\\\\d{8}\",,,\"66123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\n[,,\"NA\",\"NA\"],\"TM\",993,\"810\",\"8\",,,\"8\",,\"8~10\",,[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2-$3-$4\",[\"12\"],\"(8 $1)\",\"\",0],[,\"(\\\\d{2})(\\\\d{6})\",\"$1 $2\",[\"6\"],\"8 $1\",\"\",0],[,\"(\\\\d{3})(\\\\d)(\\\\d{2})(\\\\d{2})\",\"$1 $2-$3-$4\",[\"13|[2-5]\"],\"(8 $1)\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"0[1-3]\",\"\\\\d{2}\",,,\"03\"],[,,\"NA\",\"NA\"]],TN:[,[,,\"[2457-9]\\\\d{7}\",\"\\\\d{8}\"],[,,\"7\\\\d{7}\",\"\\\\d{8}\",,,\"71234567\"],[,,\"(?:[29]\\\\d|4[01]|5[01258]|)\\\\d{6}\",\"\\\\d{8}\",,,\"20123456\"],[,,\"NA\",\"NA\"],[,,\"8[028]\\\\d{6}\",\n\"\\\\d{8}\",,,\"80123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"TN\",216,\"00\",,,,,,,,[[,\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"19[078]\",\"\\\\d{3}\",,,\"197\"],[,,\"NA\",\"NA\"]],TO:[,[,,\"[02-8]\\\\d{4,6}\",\"\\\\d{5,7}\"],[,,\"(?:2\\\\d|3[1-8]|4[1-4]|[56]0|7[0149]|8[05])\\\\d{3}\",\"\\\\d{5}\",,,\"20123\"],[,,\"(?:7[578]|8[7-9])\\\\d{5}\",\"\\\\d{7}\",,,\"7715123\"],[,,\"0800\\\\d{3}\",\"\\\\d{7}\",,,\"0800222\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"TO\",676,\"00\",,\n,,,,,,[[,\"(\\\\d{2})(\\\\d{3})\",\"$1-$2\",[\"[1-6]|7[0-4]|8[05]\"],\"\",\"\",0],[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"7[5-9]|8[7-9]\"],\"\",\"\",0],[,\"(\\\\d{4})(\\\\d{3})\",\"$1 $2\",[\"0\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],1,[,,\"9(?:11|22|33|99)\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],TR:[,[,,\"[2-589]\\\\d{9}|444\\\\d{4}\",\"\\\\d{7,10}\"],[,,\"(?:2(?:[13][26]|[28][2468]|[45][268]|[67][246])|3(?:[13][28]|[24-6][2468]|[78][02468]|92)|4(?:[16][246]|[23578][2468]|4[26]))\\\\d{7}\",\"\\\\d{10}\",,,\"2123456789\"],[,,\"5(?:0[1-35-7]|22|3\\\\d|4[1-79]|5[1-5]|9[246])\\\\d{7}\",\n\"\\\\d{10}\",,,\"5012345678\"],[,,\"800\\\\d{7}\",\"\\\\d{10}\",,,\"8001234567\"],[,,\"900\\\\d{7}\",\"\\\\d{10}\",,,\"9001234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"TR\",90,\"00\",\"0\",,,\"0\",,,,[[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[23]|4(?:[0-35-9]|4[0-35-9])\"],\"(0$1)\",\"\",1],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[589]\"],\"0$1\",\"\",1],[,\"(444)(\\\\d{1})(\\\\d{3})\",\"$1 $2 $3\",[\"444\"],\"\",\"\",0]],,[,,\"512\\\\d{7}\",\"\\\\d{10}\",,,\"5123456789\"],,,[,,\"444\\\\d{4}\",\"\\\\d{7}\",,,\"4441444\"],[,,\"444\\\\d{4}|850\\\\d{7}\",\"\\\\d{7,10}\",,,\n\"4441444\"],,[,,\"1(?:1[02]|55)\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],TT:[,[,,\"[589]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"868(?:2(?:01|2[1-5])|6(?:07|1[4-6]|2[1-9]|[3-6]\\\\d|7[0-79]|9[0-8])|82[12])\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"8682211234\"],[,,\"868(?:29\\\\d|3(?:0[1-9]|1[02-9]|[2-9]\\\\d)|4(?:[679]\\\\d|8[0-4])|6(?:20|78|8\\\\d)|7(?:03|1[02-9]|[2-9]\\\\d))\\\\d{4}\",\"\\\\d{10}\",,,\"8682911234\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002345678\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002345678\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\n\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"TT\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,\"868\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"99[09]\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],TV:[,[,,\"[29]\\\\d{4,5}\",\"\\\\d{5,6}\"],[,,\"2[02-9]\\\\d{3}\",\"\\\\d{5}\",,,\"20123\"],[,,\"90\\\\d{4}\",\"\\\\d{6}\",,,\"901234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"TV\",688,\"00\",,,,,,,,,,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],TW:[,[,,\"[2-9]\\\\d{7,8}\",\"\\\\d{8,9}\"],[,,\"[2-8]\\\\d{7,8}\",\n\"\\\\d{8,9}\",,,\"21234567\"],[,,\"9\\\\d{8}\",\"\\\\d{9}\",,,\"912345678\"],[,,\"800\\\\d{6}\",\"\\\\d{9}\",,,\"800123456\"],[,,\"900\\\\d{6}\",\"\\\\d{9}\",,,\"900123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"TW\",886,\"0(?:0[25679]|19)\",\"0\",\"#\",,\"0\",,,,[[,\"([2-8])(\\\\d{3,4})(\\\\d{4})\",\"$1 $2 $3\",[\"[2-7]|8[1-9]\"],\"0$1\",\"\",0],[,\"([89]\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"80|9\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[029]\",\"\\\\d{3}\",,,\"110\"],[,,\"NA\",\"NA\"]],TZ:[,[,,\"\\\\d{9}\",\"\\\\d{7,9}\"],[,,\"2[2-8]\\\\d{7}\",\n\"\\\\d{7,9}\",,,\"222345678\"],[,,\"(?:6[158]|7[1-9])\\\\d{7}\",\"\\\\d{9}\",,,\"612345678\"],[,,\"80[08]\\\\d{6}\",\"\\\\d{9}\",,,\"800123456\"],[,,\"90\\\\d{7}\",\"\\\\d{9}\",,,\"900123456\"],[,,\"8(?:40|6[01])\\\\d{6}\",\"\\\\d{9}\",,,\"840123456\"],[,,\"NA\",\"NA\"],[,,\"41\\\\d{7}\",\"\\\\d{9}\",,,\"412345678\"],\"TZ\",255,\"00[056]\",\"0\",,,\"0\",,,,[[,\"([24]\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[24]\"],\"0$1\",\"\",0],[,\"([67]\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[67]\"],\"0$1\",\"\",0],[,\"([89]\\\\d{2})(\\\\d{2})(\\\\d{4})\",\"$1 $2 $3\",[\"[89]\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],\n,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[12]|999\",\"\\\\d{3}\",,,\"111\"],[,,\"NA\",\"NA\"]],UA:[,[,,\"[3-689]\\\\d{8}\",\"\\\\d{5,9}\"],[,,\"(?:3[1-8]|4[13-8]|5[1-7]|6[12459])\\\\d{7}\",\"\\\\d{5,9}\",,,\"311234567\"],[,,\"(?:39|50|6[36-8]|9[1-9])\\\\d{7}\",\"\\\\d{9}\",,,\"391234567\"],[,,\"800\\\\d{6}\",\"\\\\d{9}\",,,\"800123456\"],[,,\"900\\\\d{6}\",\"\\\\d{9}\",,,\"900123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"UA\",380,\"00\",\"0\",,,\"0\",,\"0~0\",,[[,\"([3-69]\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"39|4(?:[45][0-5]|87)|5(?:0|6[37]|7[37])|6[36-8]|9[1-9]\",\n\"39|4(?:[45][0-5]|87)|5(?:0|6(?:3[14-7]|7)|7[37])|6[36-8]|9[1-9]\"],\"0$1\",\"\",0],[,\"([3-689]\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"3[1-8]2|4[1378]2|5(?:[12457]2|6[24])|6(?:[49]2|[12][29]|5[24])|8|90\",\"3(?:[1-46-8]2[013-9]|52)|4[1378]2|5(?:[12457]2|6[24])|6(?:[49]2|[12][29]|5[24])|8|90\"],\"0$1\",\"\",0],[,\"([3-6]\\\\d{3})(\\\\d{5})\",\"$1 $2\",[\"3(?:5[013-9]|[1-46-8])|4(?:[137][013-9]|6|[45][6-9]|8[4-6])|5(?:[1245][013-9]|6[0135-9]|3|7[4-6])|6(?:[49][013-9]|5[0135-9]|[12][13-8])\",\"3(?:5[013-9]|[1-46-8](?:22|[013-9]))|4(?:[137][013-9]|6|[45][6-9]|8[4-6])|5(?:[1245][013-9]|6(?:3[02389]|[015689])|3|7[4-6])|6(?:[49][013-9]|5[0135-9]|[12][13-8])\"],\n\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:0[123]|12)\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],UG:[,[,,\"\\\\d{9}\",\"\\\\d{5,9}\"],[,,\"20(?:[014]\\\\d{2}|2(?:40|[5-9]\\\\d)|3[23]\\\\d|5[0-4]\\\\d)\\\\d{4}|[34]\\\\d{8}\",\"\\\\d{5,9}\",,,\"312345678\"],[,,\"7(?:0[0-7]|[15789]\\\\d|20|[46][0-4])\\\\d{6}\",\"\\\\d{9}\",,,\"712345678\"],[,,\"800[123]\\\\d{5}\",\"\\\\d{9}\",,,\"800123456\"],[,,\"90[123]\\\\d{6}\",\"\\\\d{9}\",,,\"901123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"UG\",256,\"00[057]\",\"0\",,,\"0\",,,,[[,\"(\\\\d{3})(\\\\d{6})\",\"$1 $2\",\n[\"[7-9]|20(?:[013-5]|2[5-9])|4(?:6[45]|[7-9])\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{7})\",\"$1 $2\",[\"3|4(?:[1-5]|6[0-36-9])\"],\"0$1\",\"\",0],[,\"(2024)(\\\\d{5})\",\"$1 $2\",[\"2024\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"999\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],US:[,[,,\"[2-9]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"(?:2(?:0[1-35-9]|1[02-9]|2[4589]|3[149]|4[08]|5[1-46]|6[0279]|7[06]|8[13])|3(?:0[1-57-9]|1[02-9]|2[0135]|3[014679]|47|5[12]|6[01]|8[056])|4(?:0[124-9]|1[02-579]|2[3-5]|3[0245]|4[0235]|58|69|7[0589]|8[04])|5(?:0[1-57-9]|1[0235-8]|20|3[0149]|4[01]|5[19]|6[1-37]|7[013-5]|8[056])|6(?:0[1-35-9]|1[024-9]|2[036]|3[016]|4[16]|5[017]|6[0-279]|78|8[12])|7(?:0[1-46-8]|1[02-9]|2[047]|3[124]|4[07]|5[47]|6[02359]|7[02-59]|8[156])|8(?:0[1-68]|1[02-8]|28|3[0-25]|4[3578]|5[06-9]|6[02-5]|7[028])|9(?:0[1346-9]|1[02-9]|2[0589]|3[1678]|4[0179]|5[1246]|7[0-3589]|8[0459]))[2-9]\\\\d{6}\",\n\"\\\\d{7}(?:\\\\d{3})?\",,,\"2012345678\"],[,,\"(?:2(?:0[1-35-9]|1[02-9]|2[4589]|3[149]|4[08]|5[1-46]|6[0279]|7[06]|8[13])|3(?:0[1-57-9]|1[02-9]|2[0135]|3[014679]|47|5[12]|6[01]|8[056])|4(?:0[124-9]|1[02-579]|2[3-5]|3[0245]|4[0235]|58|69|7[0589]|8[04])|5(?:0[1-57-9]|1[0235-8]|20|3[0149]|4[01]|5[19]|6[1-37]|7[013-5]|8[056])|6(?:0[1-35-9]|1[024-9]|2[036]|3[016]|4[16]|5[017]|6[0-279]|78|8[12])|7(?:0[1-46-8]|1[02-9]|2[047]|3[124]|4[07]|5[47]|6[02359]|7[02-59]|8[156])|8(?:0[1-68]|1[02-8]|28|3[0-25]|4[3578]|5[06-9]|6[02-5]|7[028])|9(?:0[1346-9]|1[02-9]|2[0589]|3[1678]|4[0179]|5[1246]|7[0-3589]|8[0459]))[2-9]\\\\d{6}\",\n\"\\\\d{7}(?:\\\\d{3})?\",,,\"2012345678\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002345678\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002345678\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"US\",1,\"011\",\"1\",,,\"1\",,,1,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1-$2\",,\"\",\"\",0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"($1) $2-$3\",,\"\",\"\",0]],[[,\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\"]],[,,\"NA\",\"NA\"],1,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"112|911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],UY:[,[,,\"[2489]\\\\d{6,7}\",\n\"\\\\d{7,8}\"],[,,\"2\\\\d{7}|4[2-7]\\\\d{6}\",\"\\\\d{7,8}\",,,\"21231234\"],[,,\"9[13-9]\\\\d{6}\",\"\\\\d{8}\",,,\"94231234\"],[,,\"80[05]\\\\d{4}\",\"\\\\d{7}\",,,\"8001234\"],[,,\"90[0-8]\\\\d{4}\",\"\\\\d{7}\",,,\"9001234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"UY\",598,\"0(?:1[3-9]\\\\d|0)\",\"0\",\" int. \",,\"0\",,\"00\",,[[,\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[24]\"],\"\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"9[1-9]\"],\"0$1\",\"\",0],[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[89]0\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"128|911\",\n\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],UZ:[,[,,\"[679]\\\\d{8}\",\"\\\\d{7,9}\"],[,,\"(?:6(?:1(?:22|3[124]|4[1-4]|5[123578]|64)|2(?:22|3[0-57-9]|41)|5(?:22|3[3-7]|5[024-8])|6\\\\d{2}|7(?:[23]\\\\d|7[69]|)|9(?:4[1-8]|6[135]))|7(?:0(?:5[4-9]|6[0146]|7[12456]|9[135-8])|1[12]\\\\d|2(?:22|3[1345789]|4[123579]|5[14])|3(?:2\\\\d|3[1578]|4[1-35-7]|5[1-57]|61)|4(?:2\\\\d|3[1-4579]|7[1-79])|5(?:22|5[1-9]|6[1457])|6(?:22|3[12457]|4[13-8])|9(?:22|5[1-9])))\\\\d{5}\",\"\\\\d{7,9}\",,,\"662345678\"],[,,\"6(?:1(?:2(?:98|2[01])|35[0-4]|50\\\\d|61[23]|7(?:[01][017]|4\\\\d|55|9[5-9]))|2(?:11\\\\d|2(?:[12]1|9[01379])|5(?:[126]\\\\d|3[0-4])|7\\\\d{2})|5(?:19[01]|2(?:27|9[26])|30\\\\d|59\\\\d|7\\\\d{2})|6(?:2(?:1[5-9]|2[0367]|38|41|52|60)|3[79]\\\\d|4(?:56|83)|7(?:[07]\\\\d|1[017]|3[07]|4[047]|5[057]|67|8[0178]|9[79])|9[0-3]\\\\d)|7(?:2(?:24|3[237]|4[5-9]|7[15-8])|5(?:7[12]|8[0589])|7(?:0\\\\d|[39][07])|9(?:0\\\\d|7[079]))|9(2(?:1[1267]|5\\\\d|3[01]|7[0-4])|5[67]\\\\d|6(?:2[0-26]|8\\\\d)|7\\\\d{2}))\\\\d{4}|7(?:0\\\\d{3}|1(?:13[01]|6(?:0[47]|1[67]|66)|71[3-69]|98\\\\d)|2(?:2(?:2[79]|95)|3(?:2[5-9]|6[0-6])|57\\\\d|7(?:0\\\\d|1[17]|2[27]|3[37]|44|5[057]|66|88))|3(?:2(?:1[0-6]|21|3[469]|7[159])|33\\\\d|5(?:0[0-4]|5[579]|9\\\\d)|7(?:[0-3579]\\\\d|4[0467]|6[67]|8[078])|9[4-6]\\\\d)|4(?:2(?:29|5[0257]|6[0-7]|7[1-57])|5(?:1[0-4]|8\\\\d|9[5-9])|7(?:0\\\\d|1[024589]|2[0127]|3[0137]|[46][07]|5[01]|7[5-9]|9[079])|9(?:7[015-9]|[89]\\\\d))|5(?:112|2(?:0\\\\d|2[29]|[49]4)|3[1568]\\\\d|52[6-9]|7(?:0[01578]|1[017]|[23]7|4[047]|[5-7]\\\\d|8[78]|9[079]))|6(?:2(?:2[1245]|4[2-4])|39\\\\d|41[179]|5(?:[349]\\\\d|5[0-2])|7(?:0[017]|[13]\\\\d|22|44|55|67|88))|9(?:22[128]|3(?:2[0-4]|7\\\\d)|57[05629]|7(?:2[05-9]|3[37]|4\\\\d|60|7[2579]|87|9[07])))\\\\d{4}|9[0-57-9]\\\\d{7}\",\n\"\\\\d{7,9}\",,,\"912345678\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"UZ\",998,\"810\",\"8\",,,\"8\",,\"8~10\",,[[,\"([679]\\\\d)(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",,\"8$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"0(?:0[123]|[123]|50)\",\"\\\\d{2,3}\",,,\"01\"],[,,\"NA\",\"NA\"]],VA:[,[,,\"06\\\\d{8}\",\"\\\\d{10}\"],[,,\"06698\\\\d{5}\",\"\\\\d{10}\",,,\"0669812345\"],[,,\"N/A\",\"N/A\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"VA\",379,\"00\",,,,,,,,[[,\"(06)(\\\\d{4})(\\\\d{4})\",\n\"$1 $2 $3\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],1,[,,\"11[2358]\",\"\\\\d{3}\",,,\"113\"],[,,\"NA\",\"NA\"]],VC:[,[,,\"[5789]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"784(?:266|3(?:6[6-9]|7\\\\d|8[0-24-6])|4(?:38|5[0-36-8]|8\\\\d|9[01])|555|638|784)\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"7842661234\"],[,,\"784(?:4(?:3[0-4]|5[45]|9[2-5])|5(?:2[6-9]|3[0-4]|93))\\\\d{4}\",\"\\\\d{10}\",,,\"7844301234\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002345678\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002345678\"],[,,\"NA\",\"NA\"],[,\n,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"VC\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,\"784\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"9(?:11|99)\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],VE:[,[,,\"[24589]\\\\d{9}\",\"\\\\d{7,10}\"],[,,\"(?:2(?:12|3[457-9]|[58][1-9]|[467]\\\\d|9[1-6])|50[01])\\\\d{7}\",\"\\\\d{7,10}\",,,\"2121234567\"],[,,\"4(?:1[24-8]|2[46])\\\\d{7}\",\"\\\\d{10}\",,,\"4121234567\"],[,,\"800\\\\d{7}\",\"\\\\d{10}\",,,\"8001234567\"],[,,\"900\\\\d{7}\",\"\\\\d{10}\",,,\"9001234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\n\"VE\",58,\"00\",\"0\",,,\"(1\\\\d{2})|0\",,,,[[,\"(\\\\d{3})(\\\\d{7})\",\"$1-$2\",,\"0$1\",\"$CC $1\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"171\",\"\\\\d{3}\",,,\"171\"],[,,\"NA\",\"NA\"]],VG:[,[,,\"[2589]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"284(?:(?:229|4(?:22|9[45])|774|8(?:52|6[459]))\\\\d{4}|496[0-5]\\\\d{3})\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"2842291234\"],[,,\"284(?:(?:3(?:0[0-3]|4[0-367])|4(?:4[0-6]|68|99)|54[0-57])\\\\d{4}|496[6-9]\\\\d{3})\",\"\\\\d{10}\",,,\"2843001234\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002345678\"],\n[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002345678\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"VG\",1,\"011\",\"1\",,,\"1\",,,,,,[,,\"NA\",\"NA\"],,\"284\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"9(?:11|99)\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],VI:[,[,,\"[3589]\\\\d{9}\",\"\\\\d{7}(?:\\\\d{3})?\"],[,,\"340(?:2(?:01|2[067]|36|44|77)|3(?:32|44)|4(?:4[38]|7[34])|5(?:1[34]|55)|6(?:26|4[23]|9[023])|7(?:[17]\\\\d|27)|884|998)\\\\d{4}\",\"\\\\d{7}(?:\\\\d{3})?\",,,\"3406421234\"],[,,\"340(?:2(?:01|2[067]|36|44|77)|3(?:32|44)|4(?:4[38]|7[34])|5(?:1[34]|55)|6(?:26|4[23]|9[023])|7(?:[17]\\\\d|27)|884|998)\\\\d{4}\",\n\"\\\\d{7}(?:\\\\d{3})?\",,,\"3406421234\"],[,,\"8(?:00|55|66|77|88)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"8002345678\"],[,,\"900[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"9002345678\"],[,,\"NA\",\"NA\"],[,,\"5(?:00|33|44)[2-9]\\\\d{6}\",\"\\\\d{10}\",,,\"5002345678\"],[,,\"NA\",\"NA\"],\"VI\",1,\"011\",\"1\",,,\"1\",,,1,,,[,,\"NA\",\"NA\"],,\"340\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"911\",\"\\\\d{3}\",,,\"911\"],[,,\"NA\",\"NA\"]],VN:[,[,,\"8\\\\d{5,8}|[1-79]\\\\d{7,9}\",\"\\\\d{7,10}\"],[,,\"(?:2(?:[025-79]|1[0189]|[348][01])|3(?:[0136-9]|[25][01])|[48]\\\\d|5(?:[01][01]|[2-9])|6(?:[0-46-8]|5[01])|7(?:[02-79]|[18][01]))\\\\d{7}|69\\\\d{5,6}|80\\\\d{5}\",\n\"\\\\d{7,10}\",,,\"2101234567\"],[,,\"(?:9\\\\d|1(?:2\\\\d|6[3-9]|88|99))\\\\d{7}\",\"\\\\d{9,10}\",,,\"912345678\"],[,,\"1800\\\\d{4,6}\",\"\\\\d{8,10}\",,,\"1800123456\"],[,,\"1900\\\\d{4,6}\",\"\\\\d{8,10}\",,,\"1900123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"VN\",84,\"00\",\"0\",,,\"0\",,,,[[,\"([48])(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"[48]\"],\"0$1\",\"\",1],[,\"([235-7]\\\\d)(\\\\d{4})(\\\\d{3})\",\"$1 $2 $3\",[\"2[025-79]|3[0136-9]|5[2-9]|6[0-46-9]|7[02-79]\"],\"0$1\",\"\",1],[,\"(80)(\\\\d{5})\",\"$1 $2\",[\"80\"],\"0$1\",\"\",1],[,\"(69\\\\d)(\\\\d{4,5})\",\"$1 $2\",[\"69\"],\n\"0$1\",\"\",1],[,\"([235-7]\\\\d{2})(\\\\d{4})(\\\\d{3})\",\"$1 $2 $3\",[\"2[1348]|3[25]|5[01]|65|7[18]\"],\"0$1\",\"\",1],[,\"(9\\\\d)(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"9\"],\"0$1\",\"\",1],[,\"(1[2689]\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1(?:[26]|88|99)\"],\"0$1\",\"\",1],[,\"(1[89]00)(\\\\d{4,6})\",\"$1 $2\",[\"1[89]0\"],\"$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"11[345]\",\"\\\\d{3}\",,,\"113\"],[,,\"NA\",\"NA\"]],VU:[,[,,\"[2-57-9]\\\\d{4,6}\",\"\\\\d{5,7}\"],[,,\"(?:2[2-9]\\\\d|3(?:[67]\\\\d|8[0-8])|48[4-9]|88\\\\d)\\\\d{2}\",\"\\\\d{5}\",\n,,\"22123\"],[,,\"(?:5(?:7[2-5]|[3-69]\\\\d)|7[013-7]\\\\d)\\\\d{4}\",\"\\\\d{7}\",,,\"5912345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"VU\",678,\"00\",,,,,,,,[[,\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[579]\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"30\\\\d{3}|900\\\\d{4}\",\"\\\\d{5,7}\",,,\"30123\"],,[,,\"112\",\"\\\\d{3}\",,,\"112\"],[,,\"NA\",\"NA\"]],WF:[,[,,\"[5-7]\\\\d{5}\",\"\\\\d{6}\"],[,,\"(?:50|68|72)\\\\d{4}\",\"\\\\d{6}\",,,\"501234\"],[,,\"(?:50|68|72)\\\\d{4}\",\"\\\\d{6}\",,,\"501234\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\n\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"WF\",681,\"00\",,,,,,,1,[[,\"(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1[578]\",\"\\\\d{2}\",,,\"15\"],[,,\"NA\",\"NA\"]],WS:[,[,,\"[2-8]\\\\d{4,6}\",\"\\\\d{5,7}\"],[,,\"(?:[2-5]\\\\d|6[1-9]|84\\\\d{2})\\\\d{3}\",\"\\\\d{5,7}\",,,\"22123\"],[,,\"(?:60|7[25-7]\\\\d)\\\\d{4}\",\"\\\\d{6,7}\",,,\"601234\"],[,,\"800\\\\d{3}\",\"\\\\d{6}\",,,\"800123\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"WS\",685,\"0\",,,,,,,,[[,\"(8\\\\d{2})(\\\\d{3,4})\",\"$1 $2\",[\"8\"],\"\",\n\"\",0],[,\"(7\\\\d)(\\\\d{5})\",\"$1 $2\",[\"7\"],\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"99[4-6]\",\"\\\\d{3}\",,,\"994\"],[,,\"NA\",\"NA\"]],YE:[,[,,\"[1-7]\\\\d{6,8}\",\"\\\\d{6,9}\"],[,,\"(?:1(?:7\\\\d|[2-68])|2[2-68]|3[2358]|4[2-58]|5[2-6]|6[3-58]|7[24-68])\\\\d{5}\",\"\\\\d{6,8}\",,,\"1234567\"],[,,\"7[0137]\\\\d{7}\",\"\\\\d{9}\",,,\"712345678\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"YE\",967,\"00\",\"0\",,,\"0\",,,,[[,\"([1-7])(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[1-6]|7[24-68]\"],\"0$1\",\"\",0],[,\"(7\\\\d{2})(\\\\d{3})(\\\\d{3})\",\n\"$1 $2 $3\",[\"7[0137]\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"19[1459]\",\"\\\\d{3}\",,,\"191\"],[,,\"NA\",\"NA\"]],YT:[,[,,\"[268]\\\\d{8}\",\"\\\\d{9}\"],[,,\"2696[0-4]\\\\d{4}\",\"\\\\d{9}\",,,\"269601234\"],[,,\"639\\\\d{6}\",\"\\\\d{9}\",,,\"639123456\"],[,,\"80\\\\d{7}\",\"\\\\d{9}\",,,\"801234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"YT\",262,\"00\",\"0\",,,\"0\",,,,,,[,,\"NA\",\"NA\"],,\"269|63\",[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:12|5)\",\"\\\\d{2,3}\",,,\"15\"],[,,\"NA\",\"NA\"]],ZA:[,[,,\"[1-5]\\\\d{8}|(?:7\\\\d{4,8}|8[1-5789]\\\\d{3,7})|8[06]\\\\d{7}\",\n\"\\\\d{5,9}\"],[,,\"(?:1[0-8]|2[1-478]|3[1-69]|4\\\\d|5[1346-8])\\\\d{7}\",\"\\\\d{8,9}\",,,\"101234567\"],[,,\"(?:7[1-4689]|8[1-5789])\\\\d{3,7}\",\"\\\\d{5,9}\",,,\"711234567\"],[,,\"80\\\\d{7}\",\"\\\\d{9}\",,,\"801234567\"],[,,\"86[1-9]\\\\d{6}\",\"\\\\d{9}\",,,\"861234567\"],[,,\"860\\\\d{6}\",\"\\\\d{9}\",,,\"860123456\"],[,,\"NA\",\"NA\"],[,,\"87\\\\d{7}\",\"\\\\d{9}\",,,\"871234567\"],\"ZA\",27,\"00\",\"0\",,,\"0\",,,,[[,\"(860)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"860\"],\"0$1\",\"\",0],[,\"([1-578]\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[1-57]|8(?:[0-57-9]|6[1-9])\"],\"0$1\",\"\",0],[,\n\"(\\\\d{2})(\\\\d{3,4})\",\"$1 $2\",[\"7|8[1-5789]\"],\"0$1\",\"\",0],[,\"(\\\\d{2})(\\\\d{3})(\\\\d{2,3})\",\"$1 $2 $3\",[\"7|8[1-5789]\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"1(?:01(?:11|77)|12)\",\"\\\\d{3,5}\",,,\"10111\"],[,,\"NA\",\"NA\"]],ZM:[,[,,\"[289]\\\\d{8}\",\"\\\\d{9}\"],[,,\"21[1-8]\\\\d{6}\",\"\\\\d{9}\",,,\"211234567\"],[,,\"9(?:5[05]|6[1-9]|7[13-9])\\\\d{6}\",\"\\\\d{9}\",,,\"955123456\"],[,,\"800\\\\d{6}\",\"\\\\d{9}\",,,\"800123456\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"ZM\",260,\"00\",\"0\",,,\"0\",,,,[[,\"([29]\\\\d)(\\\\d{7})\",\n\"$1 $2\",[\"[29]\"],\"0$1\",\"\",0],[,\"(800)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"8\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"(?:112|99[139])\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],ZW:[,[,,\"2(?:[012457-9]\\\\d{3,8}|6\\\\d{3,6})|[13-79]\\\\d{4,8}|86\\\\d{8}\",\"\\\\d{3,10}\"],[,,\"(?:1[3-9]|2(?:0[45]|[16]|2[28]|[49]8?|58[23]|7[246]|8[1346-9])|3(?:08?|17?|3[78]|[2456]|7[1569]|8[379])|5(?:[07-9]|1[78]|483|5(?:7?|8))|6(?:0|28|37?|[45][68][78]|98?)|848)\\\\d{3,6}|(?:2(?:27|5|7[135789]|8[25])|3[39]|5[1-46]|6[126-8])\\\\d{4,6}|2(?:0|70)\\\\d{5,6}|(?:4\\\\d|9[2-8])\\\\d{4,7}\",\n\"\\\\d{3,10}\",,,\"1312345\"],[,,\"7[137]\\\\d{7}\",\"\\\\d{9}\",,,\"711234567\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"86(?:1[12]|22|30|44|8[367]|99)\\\\d{6}\",\"\\\\d{10}\",,,\"8686123456\"],\"ZW\",263,\"00\",\"0\",,,\"0\",,,,[[,\"([49])(\\\\d{3})(\\\\d{2,5})\",\"$1 $2 $3\",[\"4|9[2-9]\"],\"0$1\",\"\",0],[,\"([179]\\\\d)(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[19]1|7\"],\"0$1\",\"\",0],[,\"([1-356]\\\\d)(\\\\d{3,5})\",\"$1 $2\",[\"1[3-9]|2(?:[1-469]|0[0-35-9]|[45][0-79])|3(?:0[0-79]|1[0-689]|[24-69]|3[0-69])|5(?:[02-46-9]|[15][0-69])|6(?:[0145]|[29][0-79]|3[0-689]|[68][0-69])\"],\n\"0$1\",\"\",0],[,\"([1-356]\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"1[3-9]|2(?:[1-469]|0[0-35-9]|[45][0-79])|3(?:0[0-79]|1[0-689]|[24-69]|3[0-69])|5(?:[02-46-9]|[15][0-69])|6(?:[0145]|[29][0-79]|3[0-689]|[68][0-69])\"],\"0$1\",\"\",0],[,\"([2356]\\\\d{2})(\\\\d{3,5})\",\"$1 $2\",[\"2(?:[278]|0[45]|48)|3(?:08|17|3[78]|[78])|5[15][78]|6(?:[29]8|37|[68][78])\"],\"0$1\",\"\",0],[,\"([2356]\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"2(?:[278]|0[45]|48)|3(?:08|17|3[78]|[78])|5[15][78]|6(?:[29]8|37|[68][78])\"],\"0$1\",\"\",0],[,\"([25]\\\\d{3})(\\\\d{3,5})\",\n\"$1 $2\",[\"(?:25|54)8\",\"258[23]|5483\"],\"0$1\",\"\",0],[,\"([25]\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"(?:25|54)8\",\"258[23]|5483\"],\"0$1\",\"\",0],[,\"(8\\\\d{3})(\\\\d{6})\",\"$1 $2\",[\"8\"],\"0$1\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"(?:112|99[3459])\",\"\\\\d{3}\",,,\"999\"],[,,\"NA\",\"NA\"]],\"001\":[,[,,\"\\\\d{8}\",\"\\\\d{8}\",,,\"12345678\"],[,,\"NA\",\"NA\",,,\"12345678\"],[,,\"NA\",\"NA\",,,\"12345678\"],[,,\"\\\\d{8}\",\"\\\\d{8}\",,,\"12345678\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"001\",800,\"\",,,,,,,1,[[,\"(\\\\d{4})(\\\\d{4})\",\n\"$1 $2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"]],\"001\":[,[,,\"\\\\d{8}\",\"\\\\d{8}\",,,\"12345678\"],[,,\"NA\",\"NA\",,,\"12345678\"],[,,\"NA\",\"NA\",,,\"12345678\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"\\\\d{8}\",\"\\\\d{8}\",,,\"12345678\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"001\",808,\"\",,,,,,,1,[[,\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"]],\"001\":[,[,,\"51\\\\d{7}(?:\\\\d{3})?\",\"\\\\d{9}(?:\\\\d{3})?\",,,\"510012345\"],[,,\"NA\",\"NA\",,\n,\"510012345\"],[,,\"NA\",\"NA\",,,\"510012345\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"51(?:00\\\\d{5}(?:\\\\d{3})?|10\\\\d{8})\",\"\\\\d{9}(?:\\\\d{3})?\",,,\"510012345\"],\"001\",883,\"\",,,,,,,1,[[,\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",,\"\",\"\",0],[,\"(\\\\d{3})(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3 $4\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"]],\"001\":[,[,,\"\\\\d{11}\",\"\\\\d{11}\",,,\"12345678901\"],[,,\"NA\",\"NA\",,,\"12345678901\"],[,,\"NA\",\"NA\",,,\"12345678901\"],[,,\"NA\",\"NA\"],\n[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"001\",888,\"\",,,,,,,1,[[,\"(\\\\d{3})(\\\\d{3})(\\\\d{5})\",\"$1 $2 $3\",,\"\",\"\",0]],,[,,\"NA\",\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"\\\\d{11}\",\"\\\\d{11}\",,,\"12345678901\"],,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"]],\"001\":[,[,,\"\\\\d{9}\",\"\\\\d{9}\",,,\"123456789\"],[,,\"NA\",\"NA\",,,\"123456789\"],[,,\"NA\",\"NA\",,,\"123456789\"],[,,\"NA\",\"NA\"],[,,\"\\\\d{9}\",\"\\\\d{9}\",,,\"123456789\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],\"001\",979,\"\",,,,,,,1,[[,\"(\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",,\"\",\"\",0]],,[,,\"NA\",\n\"NA\"],,,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"],,[,,\"NA\",\"NA\"],[,,\"NA\",\"NA\"]]};/*\n\n Protocol Buffer 2 Copyright 2008 Google Inc.\n All other code copyright its respective owners.\n Copyright (C) 2010 The Libphonenumber Authors\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\ni18n.phonenumbers.PhoneNumber=function(){goog.proto2.Message.apply(this)};goog.inherits(i18n.phonenumbers.PhoneNumber,goog.proto2.Message);i18n.phonenumbers.PhoneNumber.prototype.getCountryCode=function(){return this.get$Value(1)};i18n.phonenumbers.PhoneNumber.prototype.getCountryCodeOrDefault=function(){return this.get$ValueOrDefault(1)};i18n.phonenumbers.PhoneNumber.prototype.setCountryCode=function(a){this.set$Value(1,a)};i18n.phonenumbers.PhoneNumber.prototype.hasCountryCode=function(){return this.has$Value(1)};\ni18n.phonenumbers.PhoneNumber.prototype.countryCodeCount=function(){return this.count$Values(1)};i18n.phonenumbers.PhoneNumber.prototype.clearCountryCode=function(){this.clear$Field(1)};i18n.phonenumbers.PhoneNumber.prototype.getNationalNumber=function(){return this.get$Value(2)};i18n.phonenumbers.PhoneNumber.prototype.getNationalNumberOrDefault=function(){return this.get$ValueOrDefault(2)};i18n.phonenumbers.PhoneNumber.prototype.setNationalNumber=function(a){this.set$Value(2,a)};\ni18n.phonenumbers.PhoneNumber.prototype.hasNationalNumber=function(){return this.has$Value(2)};i18n.phonenumbers.PhoneNumber.prototype.nationalNumberCount=function(){return this.count$Values(2)};i18n.phonenumbers.PhoneNumber.prototype.clearNationalNumber=function(){this.clear$Field(2)};i18n.phonenumbers.PhoneNumber.prototype.getExtension=function(){return this.get$Value(3)};i18n.phonenumbers.PhoneNumber.prototype.getExtensionOrDefault=function(){return this.get$ValueOrDefault(3)};\ni18n.phonenumbers.PhoneNumber.prototype.setExtension=function(a){this.set$Value(3,a)};i18n.phonenumbers.PhoneNumber.prototype.hasExtension=function(){return this.has$Value(3)};i18n.phonenumbers.PhoneNumber.prototype.extensionCount=function(){return this.count$Values(3)};i18n.phonenumbers.PhoneNumber.prototype.clearExtension=function(){this.clear$Field(3)};i18n.phonenumbers.PhoneNumber.prototype.getItalianLeadingZero=function(){return this.get$Value(4)};\ni18n.phonenumbers.PhoneNumber.prototype.getItalianLeadingZeroOrDefault=function(){return this.get$ValueOrDefault(4)};i18n.phonenumbers.PhoneNumber.prototype.setItalianLeadingZero=function(a){this.set$Value(4,a)};i18n.phonenumbers.PhoneNumber.prototype.hasItalianLeadingZero=function(){return this.has$Value(4)};i18n.phonenumbers.PhoneNumber.prototype.italianLeadingZeroCount=function(){return this.count$Values(4)};i18n.phonenumbers.PhoneNumber.prototype.clearItalianLeadingZero=function(){this.clear$Field(4)};\ni18n.phonenumbers.PhoneNumber.prototype.getRawInput=function(){return this.get$Value(5)};i18n.phonenumbers.PhoneNumber.prototype.getRawInputOrDefault=function(){return this.get$ValueOrDefault(5)};i18n.phonenumbers.PhoneNumber.prototype.setRawInput=function(a){this.set$Value(5,a)};i18n.phonenumbers.PhoneNumber.prototype.hasRawInput=function(){return this.has$Value(5)};i18n.phonenumbers.PhoneNumber.prototype.rawInputCount=function(){return this.count$Values(5)};\ni18n.phonenumbers.PhoneNumber.prototype.clearRawInput=function(){this.clear$Field(5)};i18n.phonenumbers.PhoneNumber.prototype.getCountryCodeSource=function(){return this.get$Value(6)};i18n.phonenumbers.PhoneNumber.prototype.getCountryCodeSourceOrDefault=function(){return this.get$ValueOrDefault(6)};i18n.phonenumbers.PhoneNumber.prototype.setCountryCodeSource=function(a){this.set$Value(6,a)};i18n.phonenumbers.PhoneNumber.prototype.hasCountryCodeSource=function(){return this.has$Value(6)};\ni18n.phonenumbers.PhoneNumber.prototype.countryCodeSourceCount=function(){return this.count$Values(6)};i18n.phonenumbers.PhoneNumber.prototype.clearCountryCodeSource=function(){this.clear$Field(6)};i18n.phonenumbers.PhoneNumber.prototype.getPreferredDomesticCarrierCode=function(){return this.get$Value(7)};i18n.phonenumbers.PhoneNumber.prototype.getPreferredDomesticCarrierCodeOrDefault=function(){return this.get$ValueOrDefault(7)};\ni18n.phonenumbers.PhoneNumber.prototype.setPreferredDomesticCarrierCode=function(a){this.set$Value(7,a)};i18n.phonenumbers.PhoneNumber.prototype.hasPreferredDomesticCarrierCode=function(){return this.has$Value(7)};i18n.phonenumbers.PhoneNumber.prototype.preferredDomesticCarrierCodeCount=function(){return this.count$Values(7)};i18n.phonenumbers.PhoneNumber.prototype.clearPreferredDomesticCarrierCode=function(){this.clear$Field(7)};\ni18n.phonenumbers.PhoneNumber.CountryCodeSource={FROM_NUMBER_WITH_PLUS_SIGN:1,FROM_NUMBER_WITH_IDD:5,FROM_NUMBER_WITHOUT_PLUS_SIGN:10,FROM_DEFAULT_COUNTRY:20};\ngoog.proto2.Message.set$Metadata(i18n.phonenumbers.PhoneNumber,{\"0\":{name:\"PhoneNumber\",fullName:\"i18n.phonenumbers.PhoneNumber\"},1:{name:\"country_code\",required:!0,fieldType:goog.proto2.Message.FieldType.INT32,type:Number},2:{name:\"national_number\",required:!0,fieldType:goog.proto2.Message.FieldType.UINT64,type:Number},3:{name:\"extension\",fieldType:goog.proto2.Message.FieldType.STRING,type:String},4:{name:\"italian_leading_zero\",fieldType:goog.proto2.Message.FieldType.BOOL,type:Boolean},5:{name:\"raw_input\",\nfieldType:goog.proto2.Message.FieldType.STRING,type:String},6:{name:\"country_code_source\",fieldType:goog.proto2.Message.FieldType.ENUM,defaultValue:i18n.phonenumbers.PhoneNumber.CountryCodeSource.FROM_NUMBER_WITH_PLUS_SIGN,type:i18n.phonenumbers.PhoneNumber.CountryCodeSource},7:{name:\"preferred_domestic_carrier_code\",fieldType:goog.proto2.Message.FieldType.STRING,type:String}});goog.proto2.Serializer=function(){};goog.proto2.Serializer.prototype.getSerializedValue=function(a,b){return a.isCompositeType()?this.serialize(b):b};goog.proto2.Serializer.prototype.deserialize=function(a,b){var c=a.createMessageInstance();this.deserializeTo(c,b);goog.proto2.Util.assert(c instanceof goog.proto2.Message);return c};\ngoog.proto2.Serializer.prototype.getDeserializedValue=function(a,b){if(a.isCompositeType())return this.deserialize(a.getFieldMessageType(),b);if(!a.deserializationConversionPermitted())return b;var c=a.getNativeType();if(c===String){if(\"number\"===typeof b)return\"\"+b}else if(c===Number&&\"string\"===typeof b&&/^-?[0-9]+$/.test(b))return Number(b);return b};goog.proto2.LazyDeserializer=function(){};goog.inherits(goog.proto2.LazyDeserializer,goog.proto2.Serializer);goog.proto2.LazyDeserializer.prototype.deserialize=function(a,b){var c=a.createMessageInstance();c.initializeForLazyDeserializer(this,b);goog.proto2.Util.assert(c instanceof goog.proto2.Message);return c};goog.proto2.LazyDeserializer.prototype.deserializeTo=function(){throw Error(\"Unimplemented\");};goog.proto2.PbLiteSerializer=function(){};goog.inherits(goog.proto2.PbLiteSerializer,goog.proto2.LazyDeserializer);goog.proto2.PbLiteSerializer.prototype.zeroIndexing_=!1;goog.proto2.PbLiteSerializer.prototype.setZeroIndexed=function(a){this.zeroIndexing_=a};\ngoog.proto2.PbLiteSerializer.prototype.serialize=function(a){for(var b=a.getDescriptor().getFields(),c=[],d=this.zeroIndexing_,e=0;e<b.length;e++){var f=b[e];if(a.has(f)){var g=f.getTag(),g=d?g-1:g;if(f.isRepeated()){c[g]=[];for(var h=0;h<a.countOf(f);h++)c[g][h]=this.getSerializedValue(f,a.get(f,h))}else c[g]=this.getSerializedValue(f,a.get(f))}}a.forEachUnknown(function(a,b){c[d?a-1:a]=b});return c};\ngoog.proto2.PbLiteSerializer.prototype.deserializeField=function(a,b,c){if(null==c)return c;if(b.isRepeated()){a=[];goog.proto2.Util.assert(goog.isArray(c));for(var d=0;d<c.length;d++)a[d]=this.getDeserializedValue(b,c[d]);return a}return this.getDeserializedValue(b,c)};goog.proto2.PbLiteSerializer.prototype.getSerializedValue=function(a,b){return a.getFieldType()==goog.proto2.FieldDescriptor.FieldType.BOOL?b?1:0:goog.proto2.Serializer.prototype.getSerializedValue.apply(this,arguments)};\ngoog.proto2.PbLiteSerializer.prototype.getDeserializedValue=function(a,b){return a.getFieldType()==goog.proto2.FieldDescriptor.FieldType.BOOL?1===b:goog.proto2.Serializer.prototype.getDeserializedValue.apply(this,arguments)};goog.proto2.PbLiteSerializer.prototype.deserialize=function(a,b){var c=b;if(this.zeroIndexing_){var c=[],d;for(d in b)c[parseInt(d,10)+1]=b[d]}return goog.proto2.PbLiteSerializer.superClass_.deserialize.call(this,a,c)};/*\n\n Copyright (C) 2010 The Libphonenumber Authors\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\ni18n.phonenumbers.PhoneNumberUtil=function(){this.regionToMetadataMap={}};goog.addSingletonGetter(i18n.phonenumbers.PhoneNumberUtil);i18n.phonenumbers.Error={INVALID_COUNTRY_CODE:\"Invalid country calling code\",NOT_A_NUMBER:\"The string supplied did not seem to be a phone number\",TOO_SHORT_AFTER_IDD:\"Phone number too short after IDD\",TOO_SHORT_NSN:\"The string supplied is too short to be a phone number\",TOO_LONG:\"The string supplied is too long to be a phone number\"};\ni18n.phonenumbers.PhoneNumberUtil.NANPA_COUNTRY_CODE_=1;i18n.phonenumbers.PhoneNumberUtil.MIN_LENGTH_FOR_NSN_=3;i18n.phonenumbers.PhoneNumberUtil.MAX_LENGTH_FOR_NSN_=16;i18n.phonenumbers.PhoneNumberUtil.MAX_LENGTH_COUNTRY_CODE_=3;i18n.phonenumbers.PhoneNumberUtil.UNKNOWN_REGION_=\"ZZ\";i18n.phonenumbers.PhoneNumberUtil.COLOMBIA_MOBILE_TO_FIXED_LINE_PREFIX_=\"3\";i18n.phonenumbers.PhoneNumberUtil.PLUS_SIGN=\"+\";i18n.phonenumbers.PhoneNumberUtil.RFC3966_EXTN_PREFIX_=\";ext=\";\ni18n.phonenumbers.PhoneNumberUtil.DIGIT_MAPPINGS={\"0\":\"0\",1:\"1\",2:\"2\",3:\"3\",4:\"4\",5:\"5\",6:\"6\",7:\"7\",8:\"8\",9:\"9\",\"\\uff10\":\"0\",\"\\uff11\":\"1\",\"\\uff12\":\"2\",\"\\uff13\":\"3\",\"\\uff14\":\"4\",\"\\uff15\":\"5\",\"\\uff16\":\"6\",\"\\uff17\":\"7\",\"\\uff18\":\"8\",\"\\uff19\":\"9\",\"\\u0660\":\"0\",\"\\u0661\":\"1\",\"\\u0662\":\"2\",\"\\u0663\":\"3\",\"\\u0664\":\"4\",\"\\u0665\":\"5\",\"\\u0666\":\"6\",\"\\u0667\":\"7\",\"\\u0668\":\"8\",\"\\u0669\":\"9\",\"\\u06f0\":\"0\",\"\\u06f1\":\"1\",\"\\u06f2\":\"2\",\"\\u06f3\":\"3\",\"\\u06f4\":\"4\",\"\\u06f5\":\"5\",\"\\u06f6\":\"6\",\"\\u06f7\":\"7\",\"\\u06f8\":\"8\",\"\\u06f9\":\"9\"};\ni18n.phonenumbers.PhoneNumberUtil.DIALLABLE_CHAR_MAPPINGS_={\"0\":\"0\",1:\"1\",2:\"2\",3:\"3\",4:\"4\",5:\"5\",6:\"6\",7:\"7\",8:\"8\",9:\"9\",\"+\":\"+\",\"*\":\"*\"};i18n.phonenumbers.PhoneNumberUtil.ALPHA_MAPPINGS_={A:\"2\",B:\"2\",C:\"2\",D:\"3\",E:\"3\",F:\"3\",G:\"4\",H:\"4\",I:\"4\",J:\"5\",K:\"5\",L:\"5\",M:\"6\",N:\"6\",O:\"6\",P:\"7\",Q:\"7\",R:\"7\",S:\"7\",T:\"8\",U:\"8\",V:\"8\",W:\"9\",X:\"9\",Y:\"9\",Z:\"9\"};\ni18n.phonenumbers.PhoneNumberUtil.ALL_NORMALIZATION_MAPPINGS_={\"0\":\"0\",1:\"1\",2:\"2\",3:\"3\",4:\"4\",5:\"5\",6:\"6\",7:\"7\",8:\"8\",9:\"9\",\"\\uff10\":\"0\",\"\\uff11\":\"1\",\"\\uff12\":\"2\",\"\\uff13\":\"3\",\"\\uff14\":\"4\",\"\\uff15\":\"5\",\"\\uff16\":\"6\",\"\\uff17\":\"7\",\"\\uff18\":\"8\",\"\\uff19\":\"9\",\"\\u0660\":\"0\",\"\\u0661\":\"1\",\"\\u0662\":\"2\",\"\\u0663\":\"3\",\"\\u0664\":\"4\",\"\\u0665\":\"5\",\"\\u0666\":\"6\",\"\\u0667\":\"7\",\"\\u0668\":\"8\",\"\\u0669\":\"9\",\"\\u06f0\":\"0\",\"\\u06f1\":\"1\",\"\\u06f2\":\"2\",\"\\u06f3\":\"3\",\"\\u06f4\":\"4\",\"\\u06f5\":\"5\",\"\\u06f6\":\"6\",\"\\u06f7\":\"7\",\"\\u06f8\":\"8\",\n\"\\u06f9\":\"9\",A:\"2\",B:\"2\",C:\"2\",D:\"3\",E:\"3\",F:\"3\",G:\"4\",H:\"4\",I:\"4\",J:\"5\",K:\"5\",L:\"5\",M:\"6\",N:\"6\",O:\"6\",P:\"7\",Q:\"7\",R:\"7\",S:\"7\",T:\"8\",U:\"8\",V:\"8\",W:\"9\",X:\"9\",Y:\"9\",Z:\"9\"};\ni18n.phonenumbers.PhoneNumberUtil.ALL_PLUS_NUMBER_GROUPING_SYMBOLS_={\"0\":\"0\",1:\"1\",2:\"2\",3:\"3\",4:\"4\",5:\"5\",6:\"6\",7:\"7\",8:\"8\",9:\"9\",A:\"A\",B:\"B\",C:\"C\",D:\"D\",E:\"E\",F:\"F\",G:\"G\",H:\"H\",I:\"I\",J:\"J\",K:\"K\",L:\"L\",M:\"M\",N:\"N\",O:\"O\",P:\"P\",Q:\"Q\",R:\"R\",S:\"S\",T:\"T\",U:\"U\",V:\"V\",W:\"W\",X:\"X\",Y:\"Y\",Z:\"Z\",a:\"A\",b:\"B\",c:\"C\",d:\"D\",e:\"E\",f:\"F\",g:\"G\",h:\"H\",i:\"I\",j:\"J\",k:\"K\",l:\"L\",m:\"M\",n:\"N\",o:\"O\",p:\"P\",q:\"Q\",r:\"R\",s:\"S\",t:\"T\",u:\"U\",v:\"V\",w:\"W\",x:\"X\",y:\"Y\",z:\"Z\",\"-\":\"-\",\"\\uff0d\":\"-\",\"\\u2010\":\"-\",\"\\u2011\":\"-\",\"\\u2012\":\"-\",\n\"\\u2013\":\"-\",\"\\u2014\":\"-\",\"\\u2015\":\"-\",\"\\u2212\":\"-\",\"/\":\"/\",\"\\uff0f\":\"/\",\" \":\" \",\"\\u3000\":\" \",\"\\u2060\":\" \",\".\":\".\",\"\\uff0e\":\".\"};i18n.phonenumbers.PhoneNumberUtil.UNIQUE_INTERNATIONAL_PREFIX_=/[\\d]+(?:[~\\u2053\\u223C\\uFF5E][\\d]+)?/;i18n.phonenumbers.PhoneNumberUtil.VALID_PUNCTUATION=\"-x\\u2010-\\u2015\\u2212\\u30fc\\uff0d-\\uff0f \\u00a0\\u200b\\u2060\\u3000()\\uff08\\uff09\\uff3b\\uff3d.\\\\[\\\\]/~\\u2053\\u223c\\uff5e\";i18n.phonenumbers.PhoneNumberUtil.VALID_DIGITS_=\"0-9\\uff10-\\uff19\\u0660-\\u0669\\u06f0-\\u06f9\";\ni18n.phonenumbers.PhoneNumberUtil.VALID_ALPHA_=\"A-Za-z\";i18n.phonenumbers.PhoneNumberUtil.PLUS_CHARS_=\"+\\uff0b\";i18n.phonenumbers.PhoneNumberUtil.PLUS_CHARS_PATTERN=RegExp(\"[\"+i18n.phonenumbers.PhoneNumberUtil.PLUS_CHARS_+\"]+\");i18n.phonenumbers.PhoneNumberUtil.LEADING_PLUS_CHARS_PATTERN_=RegExp(\"^[\"+i18n.phonenumbers.PhoneNumberUtil.PLUS_CHARS_+\"]+\");i18n.phonenumbers.PhoneNumberUtil.SEPARATOR_PATTERN_=RegExp(\"[\"+i18n.phonenumbers.PhoneNumberUtil.VALID_PUNCTUATION+\"]+\",\"g\");\ni18n.phonenumbers.PhoneNumberUtil.CAPTURING_DIGIT_PATTERN=RegExp(\"([\"+i18n.phonenumbers.PhoneNumberUtil.VALID_DIGITS_+\"])\");i18n.phonenumbers.PhoneNumberUtil.VALID_START_CHAR_PATTERN_=RegExp(\"[\"+i18n.phonenumbers.PhoneNumberUtil.PLUS_CHARS_+i18n.phonenumbers.PhoneNumberUtil.VALID_DIGITS_+\"]\");i18n.phonenumbers.PhoneNumberUtil.SECOND_NUMBER_START_PATTERN_=/[\\\\\\/] *x/;\ni18n.phonenumbers.PhoneNumberUtil.UNWANTED_END_CHAR_PATTERN_=RegExp(\"[^\"+i18n.phonenumbers.PhoneNumberUtil.VALID_DIGITS_+i18n.phonenumbers.PhoneNumberUtil.VALID_ALPHA_+\"#]+$\");i18n.phonenumbers.PhoneNumberUtil.VALID_ALPHA_PHONE_PATTERN_=/(?:.*?[A-Za-z]){3}.*/;\ni18n.phonenumbers.PhoneNumberUtil.VALID_PHONE_NUMBER_=\"[\"+i18n.phonenumbers.PhoneNumberUtil.PLUS_CHARS_+\"]*(?:[\"+i18n.phonenumbers.PhoneNumberUtil.VALID_PUNCTUATION+\"]*[\"+i18n.phonenumbers.PhoneNumberUtil.VALID_DIGITS_+\"]){3,}[\"+i18n.phonenumbers.PhoneNumberUtil.VALID_PUNCTUATION+i18n.phonenumbers.PhoneNumberUtil.VALID_ALPHA_+i18n.phonenumbers.PhoneNumberUtil.VALID_DIGITS_+\"]*\";i18n.phonenumbers.PhoneNumberUtil.DEFAULT_EXTN_PREFIX_=\" ext. \";\ni18n.phonenumbers.PhoneNumberUtil.CAPTURING_EXTN_DIGITS_=\"([\"+i18n.phonenumbers.PhoneNumberUtil.VALID_DIGITS_+\"]{1,7})\";\ni18n.phonenumbers.PhoneNumberUtil.EXTN_PATTERNS_FOR_PARSING_=i18n.phonenumbers.PhoneNumberUtil.RFC3966_EXTN_PREFIX_+i18n.phonenumbers.PhoneNumberUtil.CAPTURING_EXTN_DIGITS_+\"|[ \\u00a0\\\\t,]*(?:e?xt(?:ensi(?:o\\u0301?|\\u00f3))?n?|\\uff45?\\uff58\\uff54\\uff4e?|[,x\\uff58#\\uff03~\\uff5e]|int|anexo|\\uff49\\uff4e\\uff54)[:\\\\.\\uff0e]?[ \\u00a0\\\\t,-]*\"+i18n.phonenumbers.PhoneNumberUtil.CAPTURING_EXTN_DIGITS_+\"#?|[- ]+([\"+i18n.phonenumbers.PhoneNumberUtil.VALID_DIGITS_+\"]{1,5})#\";\ni18n.phonenumbers.PhoneNumberUtil.EXTN_PATTERN_=RegExp(\"(?:\"+i18n.phonenumbers.PhoneNumberUtil.EXTN_PATTERNS_FOR_PARSING_+\")$\",\"i\");i18n.phonenumbers.PhoneNumberUtil.VALID_PHONE_NUMBER_PATTERN_=RegExp(\"^\"+i18n.phonenumbers.PhoneNumberUtil.VALID_PHONE_NUMBER_+\"(?:\"+i18n.phonenumbers.PhoneNumberUtil.EXTN_PATTERNS_FOR_PARSING_+\")?$\",\"i\");i18n.phonenumbers.PhoneNumberUtil.NON_DIGITS_PATTERN_=/\\D+/;i18n.phonenumbers.PhoneNumberUtil.FIRST_GROUP_PATTERN_=/(\\$\\d)/;\ni18n.phonenumbers.PhoneNumberUtil.NP_PATTERN_=/\\$NP/;i18n.phonenumbers.PhoneNumberUtil.FG_PATTERN_=/\\$FG/;i18n.phonenumbers.PhoneNumberUtil.CC_PATTERN_=/\\$CC/;i18n.phonenumbers.PhoneNumberUtil.REGION_CODE_FOR_NON_GEO_ENTITY=\"001\";i18n.phonenumbers.PhoneNumberFormat={E164:0,INTERNATIONAL:1,NATIONAL:2,RFC3966:3};i18n.phonenumbers.PhoneNumberType={FIXED_LINE:0,MOBILE:1,FIXED_LINE_OR_MOBILE:2,TOLL_FREE:3,PREMIUM_RATE:4,SHARED_COST:5,VOIP:6,PERSONAL_NUMBER:7,PAGER:8,UAN:9,VOICEMAIL:10,UNKNOWN:-1};\ni18n.phonenumbers.PhoneNumberUtil.MatchType={NOT_A_NUMBER:0,NO_MATCH:1,SHORT_NSN_MATCH:2,NSN_MATCH:3,EXACT_MATCH:4};i18n.phonenumbers.PhoneNumberUtil.ValidationResult={IS_POSSIBLE:0,INVALID_COUNTRY_CODE:1,TOO_SHORT:2,TOO_LONG:3};\ni18n.phonenumbers.PhoneNumberUtil.extractPossibleNumber=function(a){var b=a.search(i18n.phonenumbers.PhoneNumberUtil.VALID_START_CHAR_PATTERN_);0<=b?(a=a.substring(b),a=a.replace(i18n.phonenumbers.PhoneNumberUtil.UNWANTED_END_CHAR_PATTERN_,\"\"),b=a.search(i18n.phonenumbers.PhoneNumberUtil.SECOND_NUMBER_START_PATTERN_),0<=b&&(a=a.substring(0,b))):a=\"\";return a};\ni18n.phonenumbers.PhoneNumberUtil.isViablePhoneNumber=function(a){return a.length<i18n.phonenumbers.PhoneNumberUtil.MIN_LENGTH_FOR_NSN_?!1:i18n.phonenumbers.PhoneNumberUtil.matchesEntirely_(i18n.phonenumbers.PhoneNumberUtil.VALID_PHONE_NUMBER_PATTERN_,a)};\ni18n.phonenumbers.PhoneNumberUtil.normalize=function(a){return i18n.phonenumbers.PhoneNumberUtil.matchesEntirely_(i18n.phonenumbers.PhoneNumberUtil.VALID_ALPHA_PHONE_PATTERN_,a)?i18n.phonenumbers.PhoneNumberUtil.normalizeHelper_(a,i18n.phonenumbers.PhoneNumberUtil.ALL_NORMALIZATION_MAPPINGS_,!0):i18n.phonenumbers.PhoneNumberUtil.normalizeDigitsOnly(a)};i18n.phonenumbers.PhoneNumberUtil.normalizeSB_=function(a){var b=i18n.phonenumbers.PhoneNumberUtil.normalize(a.toString());a.clear();a.append(b)};\ni18n.phonenumbers.PhoneNumberUtil.normalizeDigitsOnly=function(a){return i18n.phonenumbers.PhoneNumberUtil.normalizeHelper_(a,i18n.phonenumbers.PhoneNumberUtil.DIGIT_MAPPINGS,!0)};i18n.phonenumbers.PhoneNumberUtil.convertAlphaCharactersInNumber=function(a){return i18n.phonenumbers.PhoneNumberUtil.normalizeHelper_(a,i18n.phonenumbers.PhoneNumberUtil.ALL_NORMALIZATION_MAPPINGS_,!1)};\ni18n.phonenumbers.PhoneNumberUtil.prototype.getLengthOfGeographicalAreaCode=function(a){if(null==a)return 0;var b=this.getRegionCodeForNumber(a);if(!this.isValidRegionCode_(b))return 0;b=this.getMetadataForRegion(b);if(!b.hasNationalPrefix())return 0;b=this.getNumberTypeHelper_(this.getNationalSignificantNumber(a),b);return b!=i18n.phonenumbers.PhoneNumberType.FIXED_LINE&&b!=i18n.phonenumbers.PhoneNumberType.FIXED_LINE_OR_MOBILE?0:this.getLengthOfNationalDestinationCode(a)};\ni18n.phonenumbers.PhoneNumberUtil.prototype.getLengthOfNationalDestinationCode=function(a){var b;a.hasExtension()?(b=a.clone(),b.clearExtension()):b=a;b=this.format(b,i18n.phonenumbers.PhoneNumberFormat.INTERNATIONAL).split(i18n.phonenumbers.PhoneNumberUtil.NON_DIGITS_PATTERN_);0==b[0].length&&b.shift();return 2>=b.length?0:\"AR\"==this.getRegionCodeForCountryCode(a.getCountryCodeOrDefault())&&this.getNumberType(a)==i18n.phonenumbers.PhoneNumberType.MOBILE?b[2].length+1:b[1].length};\ni18n.phonenumbers.PhoneNumberUtil.normalizeHelper_=function(a,b,c){for(var d=new goog.string.StringBuffer,e,f,g=a.length,h=0;h<g;++h)e=a.charAt(h),f=b[e.toUpperCase()],null!=f?d.append(f):c||d.append(e);return d.toString()};i18n.phonenumbers.PhoneNumberUtil.prototype.isValidRegionCode_=function(a){return null!=a&&a!=i18n.phonenumbers.PhoneNumberUtil.REGION_CODE_FOR_NON_GEO_ENTITY&&a.toUpperCase()in i18n.phonenumbers.metadata.countryToMetadata};\ni18n.phonenumbers.PhoneNumberUtil.prototype.hasValidCountryCallingCode_=function(a){return a in i18n.phonenumbers.metadata.countryCodeToRegionCodeMap};\ni18n.phonenumbers.PhoneNumberUtil.prototype.format=function(a,b){if(0==a.getNationalNumber()&&a.hasRawInput()){var c=a.getRawInputOrDefault();if(0<c.length)return c}var c=a.getCountryCodeOrDefault(),d=this.getNationalSignificantNumber(a);if(b==i18n.phonenumbers.PhoneNumberFormat.E164)return this.formatNumberByFormat_(c,i18n.phonenumbers.PhoneNumberFormat.E164,d,\"\");var e=this.getRegionCodeForCountryCode(c);if(!this.hasValidCountryCallingCode_(c))return d;var f=this.getMetadataForRegionOrCallingCode_(c,\ne),e=this.maybeGetFormattedExtension_(a,f,b),d=this.formatNationalNumber_(d,f,b);return this.formatNumberByFormat_(c,b,d,e)};\ni18n.phonenumbers.PhoneNumberUtil.prototype.formatByPattern=function(a,b,c){var d=a.getCountryCodeOrDefault(),e=this.getNationalSignificantNumber(a),f=this.getRegionCodeForCountryCode(d);if(!this.hasValidCountryCallingCode_(d))return e;for(var g=[],f=this.getMetadataForRegionOrCallingCode_(d,f),h=c.length,i=0;i<h;++i){var j=c[i],l=j.getNationalPrefixFormattingRuleOrDefault();if(0<l.length){var j=j.clone(),k=f.getNationalPrefixOrDefault();0<k.length?(l=l.replace(i18n.phonenumbers.PhoneNumberUtil.NP_PATTERN_,\nk).replace(i18n.phonenumbers.PhoneNumberUtil.FG_PATTERN_,\"$1\"),j.setNationalPrefixFormattingRule(l)):j.clearNationalPrefixFormattingRule()}g.push(j)}a=this.maybeGetFormattedExtension_(a,f,b);e=this.formatAccordingToFormats_(e,g,b);return this.formatNumberByFormat_(d,b,e,a)};\ni18n.phonenumbers.PhoneNumberUtil.prototype.formatNationalNumberWithCarrierCode=function(a,b){var c=a.getCountryCodeOrDefault(),d=this.getNationalSignificantNumber(a),e=this.getRegionCodeForCountryCode(c);if(!this.hasValidCountryCallingCode_(c))return d;var f=this.getMetadataForRegionOrCallingCode_(c,e),e=this.maybeGetFormattedExtension_(a,f,i18n.phonenumbers.PhoneNumberFormat.NATIONAL),d=this.formatNationalNumber_(d,f,i18n.phonenumbers.PhoneNumberFormat.NATIONAL,b);return this.formatNumberByFormat_(c,\ni18n.phonenumbers.PhoneNumberFormat.NATIONAL,d,e)};i18n.phonenumbers.PhoneNumberUtil.prototype.getMetadataForRegionOrCallingCode_=function(a,b){return i18n.phonenumbers.PhoneNumberUtil.REGION_CODE_FOR_NON_GEO_ENTITY==b?this.getMetadataForNonGeographicalRegion(a):this.getMetadataForRegion(b)};\ni18n.phonenumbers.PhoneNumberUtil.prototype.formatNationalNumberWithPreferredCarrierCode=function(a,b){return this.formatNationalNumberWithCarrierCode(a,a.hasPreferredDomesticCarrierCode()?a.getPreferredDomesticCarrierCodeOrDefault():b)};\ni18n.phonenumbers.PhoneNumberUtil.prototype.formatNumberForMobileDialing=function(a,b,c){var d=a.getCountryCodeOrDefault();if(!this.hasValidCountryCallingCode_(d))return a.hasRawInput()?a.getRawInputOrDefault():\"\";a=a.clone();a.clearExtension();var e=this.getNumberType(a),d=this.getRegionCodeForCountryCode(d);if(\"CO\"==d&&\"CO\"==b)b=e==i18n.phonenumbers.PhoneNumberType.FIXED_LINE?this.formatNationalNumberWithCarrierCode(a,i18n.phonenumbers.PhoneNumberUtil.COLOMBIA_MOBILE_TO_FIXED_LINE_PREFIX_):this.format(a,\ni18n.phonenumbers.PhoneNumberFormat.NATIONAL);else if(\"PE\"==d&&\"PE\"==b)b=this.format(a,i18n.phonenumbers.PhoneNumberFormat.NATIONAL);else if(\"BR\"==d&&\"BR\"==b&&(e==i18n.phonenumbers.PhoneNumberType.FIXED_LINE||e==i18n.phonenumbers.PhoneNumberType.MOBILE||e==i18n.phonenumbers.PhoneNumberType.FIXED_LINE_OR_MOBILE))b=a.hasPreferredDomesticCarrierCode()?this.formatNationalNumberWithPreferredCarrierCode(a,\"\"):\"\";else{if(this.canBeInternationallyDialled(a))return c?this.format(a,i18n.phonenumbers.PhoneNumberFormat.INTERNATIONAL):\nthis.format(a,i18n.phonenumbers.PhoneNumberFormat.E164);b=b==d?this.format(a,i18n.phonenumbers.PhoneNumberFormat.NATIONAL):\"\"}return c?b:i18n.phonenumbers.PhoneNumberUtil.normalizeHelper_(b,i18n.phonenumbers.PhoneNumberUtil.DIALLABLE_CHAR_MAPPINGS_,!0)};\ni18n.phonenumbers.PhoneNumberUtil.prototype.formatOutOfCountryCallingNumber=function(a,b){if(!this.isValidRegionCode_(b))return this.format(a,i18n.phonenumbers.PhoneNumberFormat.INTERNATIONAL);var c=a.getCountryCodeOrDefault(),d=this.getNationalSignificantNumber(a);if(!this.hasValidCountryCallingCode_(c))return d;if(c==i18n.phonenumbers.PhoneNumberUtil.NANPA_COUNTRY_CODE_){if(this.isNANPACountry(b))return c+\" \"+this.format(a,i18n.phonenumbers.PhoneNumberFormat.NATIONAL)}else if(c==this.getCountryCodeForRegion(b))return this.format(a,\ni18n.phonenumbers.PhoneNumberFormat.NATIONAL);var e=this.getMetadataForRegion(b),f=e.getInternationalPrefixOrDefault(),g=\"\";i18n.phonenumbers.PhoneNumberUtil.matchesEntirely_(i18n.phonenumbers.PhoneNumberUtil.UNIQUE_INTERNATIONAL_PREFIX_,f)?g=f:e.hasPreferredInternationalPrefix()&&(g=e.getPreferredInternationalPrefixOrDefault());e=this.getRegionCodeForCountryCode(c);e=this.getMetadataForRegionOrCallingCode_(c,e);d=this.formatNationalNumber_(d,e,i18n.phonenumbers.PhoneNumberFormat.INTERNATIONAL);e=\nthis.maybeGetFormattedExtension_(a,e,i18n.phonenumbers.PhoneNumberFormat.INTERNATIONAL);return 0<g.length?g+\" \"+c+\" \"+d+e:this.formatNumberByFormat_(c,i18n.phonenumbers.PhoneNumberFormat.INTERNATIONAL,d,e)};\ni18n.phonenumbers.PhoneNumberUtil.prototype.formatInOriginalFormat=function(a,b){if(a.hasRawInput()&&(this.hasUnexpectedItalianLeadingZero_(a)||!this.hasFormattingPatternForNumber_(a)))return a.getRawInputOrDefault();if(!a.hasCountryCodeSource())return this.format(a,i18n.phonenumbers.PhoneNumberFormat.NATIONAL);var c;switch(a.getCountryCodeSource()){case i18n.phonenumbers.PhoneNumber.CountryCodeSource.FROM_NUMBER_WITH_PLUS_SIGN:c=this.format(a,i18n.phonenumbers.PhoneNumberFormat.INTERNATIONAL);break;\ncase i18n.phonenumbers.PhoneNumber.CountryCodeSource.FROM_NUMBER_WITH_IDD:c=this.formatOutOfCountryCallingNumber(a,b);break;case i18n.phonenumbers.PhoneNumber.CountryCodeSource.FROM_NUMBER_WITHOUT_PLUS_SIGN:c=this.format(a,i18n.phonenumbers.PhoneNumberFormat.INTERNATIONAL).substring(1);break;default:var d=this.getRegionCodeForCountryCode(a.getCountryCodeOrDefault()),e=this.getNddPrefixForRegion(d,!0);c=this.format(a,i18n.phonenumbers.PhoneNumberFormat.NATIONAL);if(null==e||0==e.length)break;if(this.rawInputContainsNationalPrefix_(a.getRawInputOrDefault(),\ne,d))break;var d=this.getMetadataForRegion(d),e=this.getNationalSignificantNumber(a),d=this.chooseFormattingPatternForNumber_(d.numberFormatArray(),e),e=d.getNationalPrefixFormattingRuleOrDefault(),f=e.indexOf(\"$1\");if(0>=f)break;e=e.substring(0,f);e=i18n.phonenumbers.PhoneNumberUtil.normalizeDigitsOnly(e);if(0==e.length)break;c=d.clone();c.clearNationalPrefixFormattingRule();c=this.formatByPattern(a,i18n.phonenumbers.PhoneNumberFormat.NATIONAL,[c])}d=a.getRawInputOrDefault();return null!=c&&i18n.phonenumbers.PhoneNumberUtil.normalizeDigitsOnly(c)==\ni18n.phonenumbers.PhoneNumberUtil.normalizeDigitsOnly(d)?c:d};i18n.phonenumbers.PhoneNumberUtil.prototype.rawInputContainsNationalPrefix_=function(a,b,c){a=i18n.phonenumbers.PhoneNumberUtil.normalizeDigitsOnly(a);if(goog.string.startsWith(a,b))try{return this.isValidNumber(this.parse(a.substring(b.length),c))}catch(d){}return!1};i18n.phonenumbers.PhoneNumberUtil.prototype.hasUnexpectedItalianLeadingZero_=function(a){return a.hasItalianLeadingZero()&&!this.isLeadingZeroPossible(a.getCountryCodeOrDefault())};\ni18n.phonenumbers.PhoneNumberUtil.prototype.hasFormattingPatternForNumber_=function(a){var b=a.getCountryCodeOrDefault(),c=this.getRegionCodeForCountryCode(b),b=this.getMetadataForRegionOrCallingCode_(b,c);if(null==b)return!1;a=this.getNationalSignificantNumber(a);return null!=this.chooseFormattingPatternForNumber_(b.numberFormatArray(),a)};\ni18n.phonenumbers.PhoneNumberUtil.prototype.formatOutOfCountryKeepingAlphaChars=function(a,b){var c=a.getRawInputOrDefault();if(0==c.length)return this.formatOutOfCountryCallingNumber(a,b);var d=a.getCountryCodeOrDefault();if(!this.hasValidCountryCallingCode_(d))return c;var c=i18n.phonenumbers.PhoneNumberUtil.normalizeHelper_(c,i18n.phonenumbers.PhoneNumberUtil.ALL_PLUS_NUMBER_GROUPING_SYMBOLS_,!0),e=this.getNationalSignificantNumber(a);3<e.length&&(e=c.indexOf(e.substring(0,3)),-1!=e&&(c=c.substring(e)));\ne=this.getMetadataForRegion(b);if(d==i18n.phonenumbers.PhoneNumberUtil.NANPA_COUNTRY_CODE_){if(this.isNANPACountry(b))return d+\" \"+c}else if(d==this.getCountryCodeForRegion(b)){for(var d=[],f=0;f<e.numberFormatArray().length;++f){var g=e.numberFormatArray()[f].clone();g.setPattern(\"(\\\\d+)(.*)\");g.setFormat(\"$1$2\");d.push(g)}return this.formatAccordingToFormats_(c,d,i18n.phonenumbers.PhoneNumberFormat.NATIONAL)}f=\"\";null!=e&&(f=e.getInternationalPrefixOrDefault(),f=i18n.phonenumbers.PhoneNumberUtil.matchesEntirely_(i18n.phonenumbers.PhoneNumberUtil.UNIQUE_INTERNATIONAL_PREFIX_,\nf)?f:e.getPreferredInternationalPrefixOrDefault());e=this.getRegionCodeForCountryCode(d);e=this.getMetadataForRegionOrCallingCode_(d,e);e=this.maybeGetFormattedExtension_(a,e,i18n.phonenumbers.PhoneNumberFormat.INTERNATIONAL);return 0<f.length?f+\" \"+d+\" \"+c+e:this.formatNumberByFormat_(d,i18n.phonenumbers.PhoneNumberFormat.INTERNATIONAL,c,e)};\ni18n.phonenumbers.PhoneNumberUtil.prototype.getNationalSignificantNumber=function(a){var b=\"\"+a.getNationalNumber();return a.hasItalianLeadingZero()&&a.getItalianLeadingZero()?\"0\"+b:b};\ni18n.phonenumbers.PhoneNumberUtil.prototype.formatNumberByFormat_=function(a,b,c,d){switch(b){case i18n.phonenumbers.PhoneNumberFormat.E164:return i18n.phonenumbers.PhoneNumberUtil.PLUS_SIGN+a+c+d;case i18n.phonenumbers.PhoneNumberFormat.INTERNATIONAL:return i18n.phonenumbers.PhoneNumberUtil.PLUS_SIGN+a+\" \"+c+d;case i18n.phonenumbers.PhoneNumberFormat.RFC3966:return i18n.phonenumbers.PhoneNumberUtil.PLUS_SIGN+a+\"-\"+c+d;default:return c+d}};\ni18n.phonenumbers.PhoneNumberUtil.prototype.formatNationalNumber_=function(a,b,c,d){b=0==b.intlNumberFormatArray().length||c==i18n.phonenumbers.PhoneNumberFormat.NATIONAL?b.numberFormatArray():b.intlNumberFormatArray();a=this.formatAccordingToFormats_(a,b,c,d);c==i18n.phonenumbers.PhoneNumberFormat.RFC3966&&(a=a.replace(i18n.phonenumbers.PhoneNumberUtil.SEPARATOR_PATTERN_,\"-\"));return a};\ni18n.phonenumbers.PhoneNumberUtil.prototype.chooseFormattingPatternForNumber_=function(a,b){for(var c,d=a.length,e=0;e<d;++e){c=a[e];var f=c.leadingDigitsPatternCount();if(0==f||0==b.search(c.getLeadingDigitsPattern(f-1)))if(f=RegExp(c.getPattern()),i18n.phonenumbers.PhoneNumberUtil.matchesEntirely_(f,b))return c}return null};\ni18n.phonenumbers.PhoneNumberUtil.prototype.formatAccordingToFormats_=function(a,b,c,d){var e=this.chooseFormattingPatternForNumber_(b,a);if(null==e)return a;var b=e.getFormatOrDefault(),f=RegExp(e.getPattern()),g=e.getDomesticCarrierCodeFormattingRuleOrDefault();if(c==i18n.phonenumbers.PhoneNumberFormat.NATIONAL&&null!=d&&0<d.length&&0<g.length)return c=g.replace(i18n.phonenumbers.PhoneNumberUtil.CC_PATTERN_,d),b=b.replace(i18n.phonenumbers.PhoneNumberUtil.FIRST_GROUP_PATTERN_,c),a.replace(f,b);\nd=e.getNationalPrefixFormattingRuleOrDefault();return c==i18n.phonenumbers.PhoneNumberFormat.NATIONAL&&null!=d&&0<d.length?a.replace(f,b.replace(i18n.phonenumbers.PhoneNumberUtil.FIRST_GROUP_PATTERN_,d)):a.replace(f,b)};i18n.phonenumbers.PhoneNumberUtil.prototype.getExampleNumber=function(a){return this.getExampleNumberForType(a,i18n.phonenumbers.PhoneNumberType.FIXED_LINE)};\ni18n.phonenumbers.PhoneNumberUtil.prototype.getExampleNumberForType=function(a,b){if(!this.isValidRegionCode_(a))return null;var c=this.getNumberDescByType_(this.getMetadataForRegion(a),b);try{if(c.hasExampleNumber())return this.parse(c.getExampleNumberOrDefault(),a)}catch(d){}return null};\ni18n.phonenumbers.PhoneNumberUtil.prototype.getExampleNumberForNonGeoEntity=function(a){var b=this.getMetadataForNonGeographicalRegion(a);if(null!=b){b=b.getGeneralDesc();try{if(b.hasExampleNumber())return this.parse(\"+\"+a+b.getExampleNumber(),\"ZZ\")}catch(c){}}return null};\ni18n.phonenumbers.PhoneNumberUtil.prototype.maybeGetFormattedExtension_=function(a,b,c){return!a.hasExtension()||0==a.getExtension().length?\"\":c==i18n.phonenumbers.PhoneNumberFormat.RFC3966?i18n.phonenumbers.PhoneNumberUtil.RFC3966_EXTN_PREFIX_+a.getExtension():this.formatExtension_(a.getExtensionOrDefault(),b)};\ni18n.phonenumbers.PhoneNumberUtil.prototype.formatExtension_=function(a,b){return b.hasPreferredExtnPrefix()?b.getPreferredExtnPrefix()+a:i18n.phonenumbers.PhoneNumberUtil.DEFAULT_EXTN_PREFIX_+a};\ni18n.phonenumbers.PhoneNumberUtil.prototype.getNumberDescByType_=function(a,b){switch(b){case i18n.phonenumbers.PhoneNumberType.PREMIUM_RATE:return a.getPremiumRate();case i18n.phonenumbers.PhoneNumberType.TOLL_FREE:return a.getTollFree();case i18n.phonenumbers.PhoneNumberType.MOBILE:return a.getMobile();case i18n.phonenumbers.PhoneNumberType.FIXED_LINE:case i18n.phonenumbers.PhoneNumberType.FIXED_LINE_OR_MOBILE:return a.getFixedLine();case i18n.phonenumbers.PhoneNumberType.SHARED_COST:return a.getSharedCost();\ncase i18n.phonenumbers.PhoneNumberType.VOIP:return a.getVoip();case i18n.phonenumbers.PhoneNumberType.PERSONAL_NUMBER:return a.getPersonalNumber();case i18n.phonenumbers.PhoneNumberType.PAGER:return a.getPager();case i18n.phonenumbers.PhoneNumberType.UAN:return a.getUan();case i18n.phonenumbers.PhoneNumberType.VOICEMAIL:return a.getVoicemail();default:return a.getGeneralDesc()}};\ni18n.phonenumbers.PhoneNumberUtil.prototype.getNumberType=function(a){var b=this.getRegionCodeForNumber(a);if(!this.isValidRegionCode_(b)&&i18n.phonenumbers.PhoneNumberUtil.REGION_CODE_FOR_NON_GEO_ENTITY!=b)return i18n.phonenumbers.PhoneNumberType.UNKNOWN;var c=this.getNationalSignificantNumber(a),a=this.getMetadataForRegionOrCallingCode_(a.getCountryCodeOrDefault(),b);return this.getNumberTypeHelper_(c,a)};\ni18n.phonenumbers.PhoneNumberUtil.prototype.getNumberTypeHelper_=function(a,b){var c=b.getGeneralDesc();return!c.hasNationalNumberPattern()||!this.isNumberMatchingDesc_(a,c)?i18n.phonenumbers.PhoneNumberType.UNKNOWN:this.isNumberMatchingDesc_(a,b.getPremiumRate())?i18n.phonenumbers.PhoneNumberType.PREMIUM_RATE:this.isNumberMatchingDesc_(a,b.getTollFree())?i18n.phonenumbers.PhoneNumberType.TOLL_FREE:this.isNumberMatchingDesc_(a,b.getSharedCost())?i18n.phonenumbers.PhoneNumberType.SHARED_COST:this.isNumberMatchingDesc_(a,\nb.getVoip())?i18n.phonenumbers.PhoneNumberType.VOIP:this.isNumberMatchingDesc_(a,b.getPersonalNumber())?i18n.phonenumbers.PhoneNumberType.PERSONAL_NUMBER:this.isNumberMatchingDesc_(a,b.getPager())?i18n.phonenumbers.PhoneNumberType.PAGER:this.isNumberMatchingDesc_(a,b.getUan())?i18n.phonenumbers.PhoneNumberType.UAN:this.isNumberMatchingDesc_(a,b.getVoicemail())?i18n.phonenumbers.PhoneNumberType.VOICEMAIL:this.isNumberMatchingDesc_(a,b.getFixedLine())?b.getSameMobileAndFixedLinePattern()||this.isNumberMatchingDesc_(a,\nb.getMobile())?i18n.phonenumbers.PhoneNumberType.FIXED_LINE_OR_MOBILE:i18n.phonenumbers.PhoneNumberType.FIXED_LINE:!b.getSameMobileAndFixedLinePattern()&&this.isNumberMatchingDesc_(a,b.getMobile())?i18n.phonenumbers.PhoneNumberType.MOBILE:i18n.phonenumbers.PhoneNumberType.UNKNOWN};\ni18n.phonenumbers.PhoneNumberUtil.prototype.getMetadataForRegion=function(a){if(null==a)return null;var a=a.toUpperCase(),b=this.regionToMetadataMap[a];if(null==b){var b=new goog.proto2.PbLiteSerializer,c=i18n.phonenumbers.metadata.countryToMetadata[a];if(null==c)return null;b=b.deserialize(i18n.phonenumbers.PhoneMetadata.getDescriptor(),c);this.regionToMetadataMap[a]=b}return b};i18n.phonenumbers.PhoneNumberUtil.prototype.getMetadataForNonGeographicalRegion=function(a){return this.getMetadataForRegion(this.getRegionCodeForCountryCode(a))};\ni18n.phonenumbers.PhoneNumberUtil.prototype.isNumberMatchingDesc_=function(a,b){return i18n.phonenumbers.PhoneNumberUtil.matchesEntirely_(b.getPossibleNumberPatternOrDefault(),a)&&i18n.phonenumbers.PhoneNumberUtil.matchesEntirely_(b.getNationalNumberPatternOrDefault(),a)};i18n.phonenumbers.PhoneNumberUtil.prototype.isValidNumber=function(a){var b=this.getRegionCodeForNumber(a);return this.isValidNumberForRegion(a,b)};\ni18n.phonenumbers.PhoneNumberUtil.prototype.isValidNumberForRegion=function(a,b){var c=a.getCountryCodeOrDefault();if(0==c||i18n.phonenumbers.PhoneNumberUtil.REGION_CODE_FOR_NON_GEO_ENTITY!=b&&c!=this.getCountryCodeForRegion(b))return!1;var c=this.getMetadataForRegionOrCallingCode_(c,b),d=c.getGeneralDesc(),e=this.getNationalSignificantNumber(a);return!d.hasNationalNumberPattern()?(c=e.length,c>i18n.phonenumbers.PhoneNumberUtil.MIN_LENGTH_FOR_NSN_&&c<=i18n.phonenumbers.PhoneNumberUtil.MAX_LENGTH_FOR_NSN_):\nthis.getNumberTypeHelper_(e,c)!=i18n.phonenumbers.PhoneNumberType.UNKNOWN};i18n.phonenumbers.PhoneNumberUtil.prototype.getRegionCodeForNumber=function(a){if(null==a)return null;var b=a.getCountryCodeOrDefault(),b=i18n.phonenumbers.metadata.countryCodeToRegionCodeMap[b];return null==b?null:1==b.length?b[0]:this.getRegionCodeForNumberFromRegionList_(a,b)};\ni18n.phonenumbers.PhoneNumberUtil.prototype.getRegionCodeForNumberFromRegionList_=function(a,b){for(var c=this.getNationalSignificantNumber(a),d,e=b.length,f=0;f<e;f++){d=b[f];var g=this.getMetadataForRegion(d);if(g.hasLeadingDigits()){if(0==c.search(g.getLeadingDigits()))return d}else if(this.getNumberTypeHelper_(c,g)!=i18n.phonenumbers.PhoneNumberType.UNKNOWN)return d}return null};\ni18n.phonenumbers.PhoneNumberUtil.prototype.getRegionCodeForCountryCode=function(a){a=i18n.phonenumbers.metadata.countryCodeToRegionCodeMap[a];return null==a?i18n.phonenumbers.PhoneNumberUtil.UNKNOWN_REGION_:a[0]};i18n.phonenumbers.PhoneNumberUtil.prototype.getCountryCodeForRegion=function(a){return!this.isValidRegionCode_(a)?0:this.getMetadataForRegion(a).getCountryCodeOrDefault()};\ni18n.phonenumbers.PhoneNumberUtil.prototype.getNddPrefixForRegion=function(a,b){if(!this.isValidRegionCode_(a))return null;var c=this.getMetadataForRegion(a).getNationalPrefixOrDefault();if(0==c.length)return null;b&&(c=c.replace(\"~\",\"\"));return c};i18n.phonenumbers.PhoneNumberUtil.prototype.isNANPACountry=function(a){return null!=a&&goog.array.contains(i18n.phonenumbers.metadata.countryCodeToRegionCodeMap[i18n.phonenumbers.PhoneNumberUtil.NANPA_COUNTRY_CODE_],a.toUpperCase())};\ni18n.phonenumbers.PhoneNumberUtil.prototype.isLeadingZeroPossible=function(a){a=this.getMetadataForRegion(this.getRegionCodeForCountryCode(a));return null!=a&&a.getLeadingZeroPossibleOrDefault()};\ni18n.phonenumbers.PhoneNumberUtil.prototype.isAlphaNumber=function(a){if(!i18n.phonenumbers.PhoneNumberUtil.isViablePhoneNumber(a))return!1;a=new goog.string.StringBuffer(a);this.maybeStripExtension(a);return i18n.phonenumbers.PhoneNumberUtil.matchesEntirely_(i18n.phonenumbers.PhoneNumberUtil.VALID_ALPHA_PHONE_PATTERN_,a.toString())};i18n.phonenumbers.PhoneNumberUtil.prototype.isPossibleNumber=function(a){return this.isPossibleNumberWithReason(a)==i18n.phonenumbers.PhoneNumberUtil.ValidationResult.IS_POSSIBLE};\ni18n.phonenumbers.PhoneNumberUtil.prototype.testNumberLengthAgainstPattern_=function(a,b){return i18n.phonenumbers.PhoneNumberUtil.matchesEntirely_(a,b)?i18n.phonenumbers.PhoneNumberUtil.ValidationResult.IS_POSSIBLE:0==b.search(a)?i18n.phonenumbers.PhoneNumberUtil.ValidationResult.TOO_LONG:i18n.phonenumbers.PhoneNumberUtil.ValidationResult.TOO_SHORT};\ni18n.phonenumbers.PhoneNumberUtil.prototype.isPossibleNumberWithReason=function(a){var b=this.getNationalSignificantNumber(a),a=a.getCountryCodeOrDefault();if(!this.hasValidCountryCallingCode_(a))return i18n.phonenumbers.PhoneNumberUtil.ValidationResult.INVALID_COUNTRY_CODE;var c=this.getRegionCodeForCountryCode(a),a=this.getMetadataForRegionOrCallingCode_(a,c).getGeneralDesc();return!a.hasNationalNumberPattern()?(b=b.length,b<i18n.phonenumbers.PhoneNumberUtil.MIN_LENGTH_FOR_NSN_?i18n.phonenumbers.PhoneNumberUtil.ValidationResult.TOO_SHORT:\nb>i18n.phonenumbers.PhoneNumberUtil.MAX_LENGTH_FOR_NSN_?i18n.phonenumbers.PhoneNumberUtil.ValidationResult.TOO_LONG:i18n.phonenumbers.PhoneNumberUtil.ValidationResult.IS_POSSIBLE):this.testNumberLengthAgainstPattern_(a.getPossibleNumberPatternOrDefault(),b)};i18n.phonenumbers.PhoneNumberUtil.prototype.isPossibleNumberString=function(a,b){try{return this.isPossibleNumber(this.parse(a,b))}catch(c){return!1}};\ni18n.phonenumbers.PhoneNumberUtil.prototype.truncateTooLongNumber=function(a){if(this.isValidNumber(a))return!0;var b=a.clone(),c=a.getNationalNumberOrDefault();do if(c=Math.floor(c/10),b.setNationalNumber(c),0==c||this.isPossibleNumberWithReason(b)==i18n.phonenumbers.PhoneNumberUtil.ValidationResult.TOO_SHORT)return!1;while(!this.isValidNumber(b));a.setNationalNumber(c);return!0};\ni18n.phonenumbers.PhoneNumberUtil.prototype.extractCountryCode=function(a,b){var c=a.toString();if(0==c.length||\"0\"==c.charAt(0))return 0;for(var d,e=c.length,f=1;f<=i18n.phonenumbers.PhoneNumberUtil.MAX_LENGTH_COUNTRY_CODE_&&f<=e;++f)if(d=parseInt(c.substring(0,f),10),d in i18n.phonenumbers.metadata.countryCodeToRegionCodeMap)return b.append(c.substring(f)),d;return 0};\ni18n.phonenumbers.PhoneNumberUtil.prototype.maybeExtractCountryCode=function(a,b,c,d,e){if(0==a.length)return 0;var a=new goog.string.StringBuffer(a),f;null!=b&&(f=b.getInternationalPrefix());null==f&&(f=\"NonMatch\");f=this.maybeStripInternationalPrefixAndNormalize(a,f);d&&e.setCountryCodeSource(f);if(f!=i18n.phonenumbers.PhoneNumber.CountryCodeSource.FROM_DEFAULT_COUNTRY){if(a.getLength()<i18n.phonenumbers.PhoneNumberUtil.MIN_LENGTH_FOR_NSN_)throw i18n.phonenumbers.Error.TOO_SHORT_AFTER_IDD;c=this.extractCountryCode(a,\nc);if(0!=c)return e.setCountryCode(c),c;throw i18n.phonenumbers.Error.INVALID_COUNTRY_CODE;}if(null!=b){f=b.getCountryCodeOrDefault();var g=\"\"+f,h=a.toString();if(goog.string.startsWith(h,g)){var i=new goog.string.StringBuffer(h.substring(g.length)),h=b.getGeneralDesc(),g=RegExp(h.getNationalNumberPatternOrDefault());this.maybeStripNationalPrefixAndCarrierCode(i,b,null);b=i.toString();h=h.getPossibleNumberPatternOrDefault();if(!i18n.phonenumbers.PhoneNumberUtil.matchesEntirely_(g,a.toString())&&i18n.phonenumbers.PhoneNumberUtil.matchesEntirely_(g,\nb)||this.testNumberLengthAgainstPattern_(h,a.toString())==i18n.phonenumbers.PhoneNumberUtil.ValidationResult.TOO_LONG)return c.append(b),d&&e.setCountryCodeSource(i18n.phonenumbers.PhoneNumber.CountryCodeSource.FROM_NUMBER_WITHOUT_PLUS_SIGN),e.setCountryCode(f),f}}e.setCountryCode(0);return 0};\ni18n.phonenumbers.PhoneNumberUtil.prototype.parsePrefixAsIdd_=function(a,b){var c=b.toString();if(0==c.search(a)){var d=c.match(a)[0].length,e=c.substring(d).match(i18n.phonenumbers.PhoneNumberUtil.CAPTURING_DIGIT_PATTERN);if(e&&null!=e[1]&&0<e[1].length&&\"0\"==i18n.phonenumbers.PhoneNumberUtil.normalizeDigitsOnly(e[1]))return!1;b.clear();b.append(c.substring(d));return!0}return!1};\ni18n.phonenumbers.PhoneNumberUtil.prototype.maybeStripInternationalPrefixAndNormalize=function(a,b){var c=a.toString();if(0==c.length)return i18n.phonenumbers.PhoneNumber.CountryCodeSource.FROM_DEFAULT_COUNTRY;if(i18n.phonenumbers.PhoneNumberUtil.LEADING_PLUS_CHARS_PATTERN_.test(c))return c=c.replace(i18n.phonenumbers.PhoneNumberUtil.LEADING_PLUS_CHARS_PATTERN_,\"\"),a.clear(),a.append(i18n.phonenumbers.PhoneNumberUtil.normalize(c)),i18n.phonenumbers.PhoneNumber.CountryCodeSource.FROM_NUMBER_WITH_PLUS_SIGN;\nc=RegExp(b);i18n.phonenumbers.PhoneNumberUtil.normalizeSB_(a);return this.parsePrefixAsIdd_(c,a)?i18n.phonenumbers.PhoneNumber.CountryCodeSource.FROM_NUMBER_WITH_IDD:i18n.phonenumbers.PhoneNumber.CountryCodeSource.FROM_DEFAULT_COUNTRY};\ni18n.phonenumbers.PhoneNumberUtil.prototype.maybeStripNationalPrefixAndCarrierCode=function(a,b,c){var d=a.toString(),e=d.length,f=b.getNationalPrefixForParsing();if(0==e||null==f||0==f.length)return!1;var g=RegExp(\"^(?:\"+f+\")\");if(e=g.exec(d)){var f=RegExp(b.getGeneralDesc().getNationalNumberPatternOrDefault()),h=e.length-1,i=b.getNationalPrefixTransformRule(),g=(b=null==i||0==i.length||null==e[h]||0==e[h].length)?d.substring(e[0].length):d.replace(g,i);if(i18n.phonenumbers.PhoneNumberUtil.matchesEntirely_(f,\nd)&&!i18n.phonenumbers.PhoneNumberUtil.matchesEntirely_(f,g))return!1;(b&&0<h&&null!=e[1]||!b&&1<h)&&null!=c&&c.append(e[1]);a.clear();a.append(g);return!0}return!1};\ni18n.phonenumbers.PhoneNumberUtil.prototype.maybeStripExtension=function(a){var b=a.toString(),c=b.search(i18n.phonenumbers.PhoneNumberUtil.EXTN_PATTERN_);if(0<=c&&i18n.phonenumbers.PhoneNumberUtil.isViablePhoneNumber(b.substring(0,c)))for(var d=b.match(i18n.phonenumbers.PhoneNumberUtil.EXTN_PATTERN_),e=d.length,f=1;f<e;++f)if(null!=d[f]&&0<d[f].length)return a.clear(),a.append(b.substring(0,c)),d[f];return\"\"};\ni18n.phonenumbers.PhoneNumberUtil.prototype.checkRegionForParsing_=function(a,b){return this.isValidRegionCode_(b)||null!=a&&0<a.length&&i18n.phonenumbers.PhoneNumberUtil.LEADING_PLUS_CHARS_PATTERN_.test(a)};i18n.phonenumbers.PhoneNumberUtil.prototype.parse=function(a,b){return this.parseHelper_(a,b,!1,!0)};\ni18n.phonenumbers.PhoneNumberUtil.prototype.parseAndKeepRawInput=function(a,b){if(!this.isValidRegionCode_(b)&&0<a.length&&a.charAt(0)!=i18n.phonenumbers.PhoneNumberUtil.PLUS_SIGN)throw i18n.phonenumbers.Error.INVALID_COUNTRY_CODE;return this.parseHelper_(a,b,!0,!0)};\ni18n.phonenumbers.PhoneNumberUtil.prototype.parseHelper_=function(a,b,c,d){if(null==a)throw i18n.phonenumbers.Error.NOT_A_NUMBER;var e=i18n.phonenumbers.PhoneNumberUtil.extractPossibleNumber(a);if(!i18n.phonenumbers.PhoneNumberUtil.isViablePhoneNumber(e))throw i18n.phonenumbers.Error.NOT_A_NUMBER;if(d&&!this.checkRegionForParsing_(e,b))throw i18n.phonenumbers.Error.INVALID_COUNTRY_CODE;d=new i18n.phonenumbers.PhoneNumber;c&&d.setRawInput(a);var f=new goog.string.StringBuffer(e),a=this.maybeStripExtension(f);\n0<a.length&&d.setExtension(a);var a=this.getMetadataForRegion(b),e=new goog.string.StringBuffer,g=0,h=f.toString();try{g=this.maybeExtractCountryCode(h,a,e,c,d)}catch(i){if(i==i18n.phonenumbers.Error.INVALID_COUNTRY_CODE&&i18n.phonenumbers.PhoneNumberUtil.LEADING_PLUS_CHARS_PATTERN_.test(h)){if(h=h.replace(i18n.phonenumbers.PhoneNumberUtil.LEADING_PLUS_CHARS_PATTERN_,\"\"),g=this.maybeExtractCountryCode(h,a,e,c,d),0==g)throw i;}else throw i;}0!=g?(f=this.getRegionCodeForCountryCode(g),f!=b&&(a=this.getMetadataForRegionOrCallingCode_(g,\nf))):(i18n.phonenumbers.PhoneNumberUtil.normalizeSB_(f),e.append(f.toString()),null!=b?(g=a.getCountryCodeOrDefault(),d.setCountryCode(g)):c&&d.clearCountryCodeSource());if(e.getLength()<i18n.phonenumbers.PhoneNumberUtil.MIN_LENGTH_FOR_NSN_)throw i18n.phonenumbers.Error.TOO_SHORT_NSN;null!=a&&(b=new goog.string.StringBuffer,this.maybeStripNationalPrefixAndCarrierCode(e,a,b),c&&d.setPreferredDomesticCarrierCode(b.toString()));c=e.toString();b=c.length;if(b<i18n.phonenumbers.PhoneNumberUtil.MIN_LENGTH_FOR_NSN_)throw i18n.phonenumbers.Error.TOO_SHORT_NSN;\nif(b>i18n.phonenumbers.PhoneNumberUtil.MAX_LENGTH_FOR_NSN_)throw i18n.phonenumbers.Error.TOO_LONG;\"0\"==c.charAt(0)&&d.setItalianLeadingZero(!0);d.setNationalNumber(parseInt(c,10));return d};\ni18n.phonenumbers.PhoneNumberUtil.prototype.isNumberMatch=function(a,b){var c,d;if(\"string\"==typeof a)try{c=this.parse(a,i18n.phonenumbers.PhoneNumberUtil.UNKNOWN_REGION_)}catch(e){if(e!=i18n.phonenumbers.Error.INVALID_COUNTRY_CODE)return i18n.phonenumbers.PhoneNumberUtil.MatchType.NOT_A_NUMBER;if(\"string\"!=typeof b){var f=this.getRegionCodeForCountryCode(b.getCountryCodeOrDefault());if(f!=i18n.phonenumbers.PhoneNumberUtil.UNKNOWN_REGION_){try{c=this.parse(a,f)}catch(g){return i18n.phonenumbers.PhoneNumberUtil.MatchType.NOT_A_NUMBER}c=\nthis.isNumberMatch(c,b);return c==i18n.phonenumbers.PhoneNumberUtil.MatchType.EXACT_MATCH?i18n.phonenumbers.PhoneNumberUtil.MatchType.NSN_MATCH:c}}try{c=this.parseHelper_(a,null,!1,!1)}catch(h){return i18n.phonenumbers.PhoneNumberUtil.MatchType.NOT_A_NUMBER}}else c=a.clone();if(\"string\"==typeof b)try{return d=this.parse(b,i18n.phonenumbers.PhoneNumberUtil.UNKNOWN_REGION_),this.isNumberMatch(a,d)}catch(i){return i!=i18n.phonenumbers.Error.INVALID_COUNTRY_CODE?i18n.phonenumbers.PhoneNumberUtil.MatchType.NOT_A_NUMBER:\nthis.isNumberMatch(b,c)}else d=b.clone();c.clearRawInput();c.clearCountryCodeSource();c.clearPreferredDomesticCarrierCode();d.clearRawInput();d.clearCountryCodeSource();d.clearPreferredDomesticCarrierCode();c.hasExtension()&&0==c.getExtension().length&&c.clearExtension();d.hasExtension()&&0==d.getExtension().length&&d.clearExtension();if(c.hasExtension()&&d.hasExtension()&&c.getExtension()!=d.getExtension())return i18n.phonenumbers.PhoneNumberUtil.MatchType.NO_MATCH;var f=c.getCountryCodeOrDefault(),\nj=d.getCountryCodeOrDefault();if(0!=f&&0!=j)return c.equals(d)?i18n.phonenumbers.PhoneNumberUtil.MatchType.EXACT_MATCH:f==j&&this.isNationalNumberSuffixOfTheOther_(c,d)?i18n.phonenumbers.PhoneNumberUtil.MatchType.SHORT_NSN_MATCH:i18n.phonenumbers.PhoneNumberUtil.MatchType.NO_MATCH;c.setCountryCode(0);d.setCountryCode(0);return c.equals(d)?i18n.phonenumbers.PhoneNumberUtil.MatchType.NSN_MATCH:this.isNationalNumberSuffixOfTheOther_(c,d)?i18n.phonenumbers.PhoneNumberUtil.MatchType.SHORT_NSN_MATCH:i18n.phonenumbers.PhoneNumberUtil.MatchType.NO_MATCH};\ni18n.phonenumbers.PhoneNumberUtil.prototype.isNationalNumberSuffixOfTheOther_=function(a,b){var c=\"\"+a.getNationalNumber(),d=\"\"+b.getNationalNumber();return goog.string.endsWith(c,d)||goog.string.endsWith(d,c)};i18n.phonenumbers.PhoneNumberUtil.prototype.canBeInternationallyDialled=function(a){var b=this.getRegionCodeForNumber(a);if(!this.isValidRegionCode_(b))return!0;b=this.getMetadataForRegion(b);return!this.isNumberMatchingDesc_(this.getNationalSignificantNumber(a),b.getNoInternationalDialling())};\ni18n.phonenumbers.PhoneNumberUtil.matchesEntirely_=function(a,b){var c=\"string\"==typeof a?b.match(\"^(?:\"+a+\")$\"):b.match(a);return c&&c[0].length==b.length?!0:!1};/*\n\n Copyright (C) 2010 The Libphonenumber Authors\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\ni18n.phonenumbers.AsYouTypeFormatter=function(a){this.digitPlaceholder_=\"\\u2008\";this.digitPattern_=RegExp(this.digitPlaceholder_);this.currentOutput_=\"\";this.formattingTemplate_=new goog.string.StringBuffer;this.currentFormattingPattern_=\"\";this.accruedInput_=new goog.string.StringBuffer;this.accruedInputWithoutFormatting_=new goog.string.StringBuffer;this.ableToFormat_=!0;this.isExpectingCountryCallingCode_=this.isInternationalFormatting_=this.inputHasFormatting_=!1;this.phoneUtil_=i18n.phonenumbers.PhoneNumberUtil.getInstance();\nthis.positionToRemember_=this.originalPosition_=this.lastMatchPosition_=0;this.prefixBeforeNationalNumber_=new goog.string.StringBuffer;this.nationalPrefixExtracted_=\"\";this.nationalNumber_=new goog.string.StringBuffer;this.possibleFormats_=[];this.defaultCountry_=a;this.defaultMetaData_=this.currentMetaData_=this.getMetadataForRegion_(this.defaultCountry_)};i18n.phonenumbers.AsYouTypeFormatter.EMPTY_METADATA_=new i18n.phonenumbers.PhoneMetadata;i18n.phonenumbers.AsYouTypeFormatter.EMPTY_METADATA_.setInternationalPrefix(\"NA\");\ni18n.phonenumbers.AsYouTypeFormatter.CHARACTER_CLASS_PATTERN_=/\\[([^\\[\\]])*\\]/g;i18n.phonenumbers.AsYouTypeFormatter.STANDALONE_DIGIT_PATTERN_=/\\d(?=[^,}][^,}])/g;i18n.phonenumbers.AsYouTypeFormatter.ELIGIBLE_FORMAT_PATTERN_=RegExp(\"^[\"+i18n.phonenumbers.PhoneNumberUtil.VALID_PUNCTUATION+\"]*(\\\\$\\\\d[\"+i18n.phonenumbers.PhoneNumberUtil.VALID_PUNCTUATION+\"]*)+$\");i18n.phonenumbers.AsYouTypeFormatter.MIN_LEADING_DIGITS_LENGTH_=3;\ni18n.phonenumbers.AsYouTypeFormatter.prototype.getMetadataForRegion_=function(a){a=this.phoneUtil_.getMetadataForRegion(this.phoneUtil_.getRegionCodeForCountryCode(this.phoneUtil_.getCountryCodeForRegion(a)));return null!=a?a:i18n.phonenumbers.AsYouTypeFormatter.EMPTY_METADATA_};\ni18n.phonenumbers.AsYouTypeFormatter.prototype.maybeCreateNewTemplate_=function(){for(var a=this.possibleFormats_.length,b=0;b<a;++b){var c=this.possibleFormats_[b],d=c.getPatternOrDefault();if(this.currentFormattingPattern_==d)return!1;if(this.createFormattingTemplate_(c))return this.currentFormattingPattern_=d,this.lastMatchPosition_=0,!0}return this.ableToFormat_=!1};\ni18n.phonenumbers.AsYouTypeFormatter.prototype.getAvailableFormats_=function(a){for(var b=this.isInternationalFormatting_&&0<this.currentMetaData_.intlNumberFormatCount()?this.currentMetaData_.intlNumberFormatArray():this.currentMetaData_.numberFormatArray(),c=b.length,d=0;d<c;++d){var e=b[d];this.isFormatEligible_(e.getFormatOrDefault())&&this.possibleFormats_.push(e)}this.narrowDownPossibleFormats_(a)};i18n.phonenumbers.AsYouTypeFormatter.prototype.isFormatEligible_=function(a){return i18n.phonenumbers.AsYouTypeFormatter.ELIGIBLE_FORMAT_PATTERN_.test(a)};\ni18n.phonenumbers.AsYouTypeFormatter.prototype.narrowDownPossibleFormats_=function(a){for(var b=[],c=a.length-i18n.phonenumbers.AsYouTypeFormatter.MIN_LEADING_DIGITS_LENGTH_,d=this.possibleFormats_.length,e=0;e<d;++e){var f=this.possibleFormats_[e];f.leadingDigitsPatternCount()>c?(f=f.getLeadingDigitsPatternOrDefault(c),0==a.search(f)&&b.push(this.possibleFormats_[e])):b.push(this.possibleFormats_[e])}this.possibleFormats_=b};\ni18n.phonenumbers.AsYouTypeFormatter.prototype.createFormattingTemplate_=function(a){var b=a.getPatternOrDefault();if(-1!=b.indexOf(\"|\"))return!1;b=b.replace(i18n.phonenumbers.AsYouTypeFormatter.CHARACTER_CLASS_PATTERN_,\"\\\\d\");b=b.replace(i18n.phonenumbers.AsYouTypeFormatter.STANDALONE_DIGIT_PATTERN_,\"\\\\d\");this.formattingTemplate_.clear();a=this.getFormattingTemplate_(b,a.getFormatOrDefault());return 0<a.length?(this.formattingTemplate_.append(a),!0):!1};\ni18n.phonenumbers.AsYouTypeFormatter.prototype.getFormattingTemplate_=function(a,b){var c=\"999999999999999\".match(a)[0];if(c.length<this.nationalNumber_.getLength())return\"\";c=c.replace(RegExp(a,\"g\"),b);return c=c.replace(RegExp(\"9\",\"g\"),this.digitPlaceholder_)};\ni18n.phonenumbers.AsYouTypeFormatter.prototype.clear=function(){this.currentOutput_=\"\";this.accruedInput_.clear();this.accruedInputWithoutFormatting_.clear();this.formattingTemplate_.clear();this.lastMatchPosition_=0;this.currentFormattingPattern_=\"\";this.prefixBeforeNationalNumber_.clear();this.nationalPrefixExtracted_=\"\";this.nationalNumber_.clear();this.ableToFormat_=!0;this.inputHasFormatting_=!1;this.originalPosition_=this.positionToRemember_=0;this.isExpectingCountryCallingCode_=this.isInternationalFormatting_=\n!1;this.possibleFormats_=[];this.currentMetaData_!=this.defaultMetaData_&&(this.currentMetaData_=this.getMetadataForRegion_(this.defaultCountry_))};i18n.phonenumbers.AsYouTypeFormatter.prototype.inputDigit=function(a){return this.currentOutput_=this.inputDigitWithOptionToRememberPosition_(a,!1)};i18n.phonenumbers.AsYouTypeFormatter.prototype.inputDigitAndRememberPosition=function(a){return this.currentOutput_=this.inputDigitWithOptionToRememberPosition_(a,!0)};\ni18n.phonenumbers.AsYouTypeFormatter.prototype.inputDigitWithOptionToRememberPosition_=function(a,b){this.accruedInput_.append(a);b&&(this.originalPosition_=this.accruedInput_.getLength());this.isDigitOrLeadingPlusSign_(a)?a=this.normalizeAndAccrueDigitsAndPlusSign_(a,b):(this.ableToFormat_=!1,this.inputHasFormatting_=!0);if(!this.ableToFormat_){if(!this.inputHasFormatting_)if(this.attemptToExtractIdd_()){if(this.attemptToExtractCountryCallingCode_())return this.attemptToChoosePatternWithPrefixExtracted_()}else if(this.ableToExtractLongerNdd_())return this.prefixBeforeNationalNumber_.append(\" \"),\nthis.attemptToChoosePatternWithPrefixExtracted_();return this.accruedInput_.toString()}switch(this.accruedInputWithoutFormatting_.getLength()){case 0:case 1:case 2:return this.accruedInput_.toString();case 3:if(this.attemptToExtractIdd_())this.isExpectingCountryCallingCode_=!0;else return this.nationalPrefixExtracted_=this.removeNationalPrefixFromNationalNumber_(),this.attemptToChooseFormattingPattern_();default:if(this.isExpectingCountryCallingCode_)return this.attemptToExtractCountryCallingCode_()&&\n(this.isExpectingCountryCallingCode_=!1),this.prefixBeforeNationalNumber_.toString()+this.nationalNumber_.toString();if(0<this.possibleFormats_.length){var c=this.inputDigitHelper_(a),d=this.attemptToFormatAccruedDigits_();if(0<d.length)return d;this.narrowDownPossibleFormats_(this.nationalNumber_.toString());return this.maybeCreateNewTemplate_()?this.inputAccruedNationalNumber_():this.ableToFormat_?this.prefixBeforeNationalNumber_.toString()+c:this.accruedInput_.toString()}return this.attemptToChooseFormattingPattern_()}};\ni18n.phonenumbers.AsYouTypeFormatter.prototype.attemptToChoosePatternWithPrefixExtracted_=function(){this.ableToFormat_=!0;this.isExpectingCountryCallingCode_=!1;this.possibleFormats_=[];return this.attemptToChooseFormattingPattern_()};\ni18n.phonenumbers.AsYouTypeFormatter.prototype.ableToExtractLongerNdd_=function(){if(0<this.nationalPrefixExtracted_.length){var a=this.nationalNumber_.toString();this.nationalNumber_.clear();this.nationalNumber_.append(this.nationalPrefixExtracted_);this.nationalNumber_.append(a);var a=this.prefixBeforeNationalNumber_.toString(),b=a.lastIndexOf(this.nationalPrefixExtracted_);this.prefixBeforeNationalNumber_.clear();this.prefixBeforeNationalNumber_.append(a.substring(0,b))}return this.nationalPrefixExtracted_!=\nthis.removeNationalPrefixFromNationalNumber_()};i18n.phonenumbers.AsYouTypeFormatter.prototype.isDigitOrLeadingPlusSign_=function(a){return i18n.phonenumbers.PhoneNumberUtil.CAPTURING_DIGIT_PATTERN.test(a)||1==this.accruedInput_.getLength()&&i18n.phonenumbers.PhoneNumberUtil.PLUS_CHARS_PATTERN.test(a)};\ni18n.phonenumbers.AsYouTypeFormatter.prototype.attemptToFormatAccruedDigits_=function(){for(var a=this.nationalNumber_.toString(),b=this.possibleFormats_.length,c=0;c<b;++c){var d=this.possibleFormats_[c],e=d.getPatternOrDefault();if(RegExp(\"^(?:\"+e+\")$\").test(a))return this.prefixBeforeNationalNumber_.toString()+a.replace(RegExp(e,\"g\"),d.getFormat())}return\"\"};\ni18n.phonenumbers.AsYouTypeFormatter.prototype.getRememberedPosition=function(){if(!this.ableToFormat_)return this.originalPosition_;for(var a=0,b=0,c=this.accruedInputWithoutFormatting_.toString(),d=this.currentOutput_.toString();a<this.positionToRemember_&&b<d.length;)c.charAt(a)==d.charAt(b)&&a++,b++;return b};\ni18n.phonenumbers.AsYouTypeFormatter.prototype.attemptToChooseFormattingPattern_=function(){var a=this.nationalNumber_.toString();return a.length>=i18n.phonenumbers.AsYouTypeFormatter.MIN_LEADING_DIGITS_LENGTH_?(this.getAvailableFormats_(a.substring(0,i18n.phonenumbers.AsYouTypeFormatter.MIN_LEADING_DIGITS_LENGTH_)),this.maybeCreateNewTemplate_()?this.inputAccruedNationalNumber_():this.accruedInput_.toString()):this.prefixBeforeNationalNumber_.toString()+a};\ni18n.phonenumbers.AsYouTypeFormatter.prototype.inputAccruedNationalNumber_=function(){var a=this.nationalNumber_.toString(),b=a.length;if(0<b){for(var c=\"\",d=0;d<b;d++)c=this.inputDigitHelper_(a.charAt(d));return this.ableToFormat_?this.prefixBeforeNationalNumber_.toString()+c:this.accruedInput_.toString()}return this.prefixBeforeNationalNumber_.toString()};\ni18n.phonenumbers.AsYouTypeFormatter.prototype.removeNationalPrefixFromNationalNumber_=function(){var a=this.nationalNumber_.toString(),b=0;if(1==this.currentMetaData_.getCountryCode()&&\"1\"==a.charAt(0))b=1,this.prefixBeforeNationalNumber_.append(\"1 \"),this.isInternationalFormatting_=!0;else if(this.currentMetaData_.hasNationalPrefixForParsing()){var c=RegExp(\"^(?:\"+this.currentMetaData_.getNationalPrefixForParsing()+\")\"),c=a.match(c);null!=c&&null!=c[0]&&0<c[0].length&&(this.isInternationalFormatting_=\n!0,b=c[0].length,this.prefixBeforeNationalNumber_.append(a.substring(0,b)))}this.nationalNumber_.clear();this.nationalNumber_.append(a.substring(b));return a.substring(0,b)};\ni18n.phonenumbers.AsYouTypeFormatter.prototype.attemptToExtractIdd_=function(){var a=this.accruedInputWithoutFormatting_.toString(),b=RegExp(\"^(?:\\\\\"+i18n.phonenumbers.PhoneNumberUtil.PLUS_SIGN+\"|\"+this.currentMetaData_.getInternationalPrefix()+\")\"),b=a.match(b);return null!=b&&null!=b[0]&&0<b[0].length?(this.isInternationalFormatting_=!0,b=b[0].length,this.nationalNumber_.clear(),this.nationalNumber_.append(a.substring(b)),this.prefixBeforeNationalNumber_.clear(),this.prefixBeforeNationalNumber_.append(a.substring(0,\nb)),a.charAt(0)!=i18n.phonenumbers.PhoneNumberUtil.PLUS_SIGN&&this.prefixBeforeNationalNumber_.append(\" \"),!0):!1};\ni18n.phonenumbers.AsYouTypeFormatter.prototype.attemptToExtractCountryCallingCode_=function(){if(0==this.nationalNumber_.getLength())return!1;var a=new goog.string.StringBuffer,b=this.phoneUtil_.extractCountryCode(this.nationalNumber_,a);if(0==b)return!1;this.nationalNumber_.clear();this.nationalNumber_.append(a.toString());a=this.phoneUtil_.getRegionCodeForCountryCode(b);i18n.phonenumbers.PhoneNumberUtil.REGION_CODE_FOR_NON_GEO_ENTITY==a?this.currentMetaData_=this.phoneUtil_.getMetadataForNonGeographicalRegion(b):\na!=this.defaultCountry_&&(this.currentMetaData_=this.getMetadataForRegion_(a));this.prefixBeforeNationalNumber_.append(\"\"+b).append(\" \");return!0};\ni18n.phonenumbers.AsYouTypeFormatter.prototype.normalizeAndAccrueDigitsAndPlusSign_=function(a,b){var c;a==i18n.phonenumbers.PhoneNumberUtil.PLUS_SIGN?(c=a,this.accruedInputWithoutFormatting_.append(a)):(c=i18n.phonenumbers.PhoneNumberUtil.DIGIT_MAPPINGS[a],this.accruedInputWithoutFormatting_.append(c),this.nationalNumber_.append(c));b&&(this.positionToRemember_=this.accruedInputWithoutFormatting_.getLength());return c};\ni18n.phonenumbers.AsYouTypeFormatter.prototype.inputDigitHelper_=function(a){var b=this.formattingTemplate_.toString();if(0<=b.substring(this.lastMatchPosition_).search(this.digitPattern_)){var c=b.search(this.digitPattern_),a=b.replace(this.digitPattern_,a);this.formattingTemplate_.clear();this.formattingTemplate_.append(a);this.lastMatchPosition_=c;return a.substring(0,this.lastMatchPosition_+1)}1==this.possibleFormats_.length&&(this.ableToFormat_=!1);this.currentFormattingPattern_=\"\";return this.accruedInput_.toString()};\n\n//@ sourceURL=../../third-party/libphonenumber/compiled_formatter.js\n");

if (__PERF__) { modulr.perf.defineEnd = modulr.perf.requireMainStart = Date.now(); }

require("index");

if (__PERF__) { modulr.perf.requireMainEnd = modulr.perf.end = Date.now(); }